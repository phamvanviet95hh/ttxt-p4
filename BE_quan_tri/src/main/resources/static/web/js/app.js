/*! jQuery v3.2.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function(a,b){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){"use strict";var c=[],d=a.document,e=Object.getPrototypeOf,f=c.slice,g=c.concat,h=c.push,i=c.indexOf,j={},k=j.toString,l=j.hasOwnProperty,m=l.toString,n=m.call(Object),o={};function p(a,b){b=b||d;var c=b.createElement("script");c.text=a,b.head.appendChild(c).parentNode.removeChild(c)}var q="3.2.1",r=function(a,b){return new r.fn.init(a,b)},s=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,t=/^-ms-/,u=/-([a-z])/g,v=function(a,b){return b.toUpperCase()};r.fn=r.prototype={jquery:q,constructor:r,length:0,toArray:function(){return f.call(this)},get:function(a){return null==a?f.call(this):a<0?this[a+this.length]:this[a]},pushStack:function(a){var b=r.merge(this.constructor(),a);return b.prevObject=this,b},each:function(a){return r.each(this,a)},map:function(a){return this.pushStack(r.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(f.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(a<0?b:0);return this.pushStack(c>=0&&c<b?[this[c]]:[])},end:function(){return this.prevObject||this.constructor()},push:h,sort:c.sort,splice:c.splice},r.extend=r.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||r.isFunction(g)||(g={}),h===i&&(g=this,h--);h<i;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(r.isPlainObject(d)||(e=Array.isArray(d)))?(e?(e=!1,f=c&&Array.isArray(c)?c:[]):f=c&&r.isPlainObject(c)?c:{},g[b]=r.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},r.extend({expando:"jQuery"+(q+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===r.type(a)},isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){var b=r.type(a);return("number"===b||"string"===b)&&!isNaN(a-parseFloat(a))},isPlainObject:function(a){var b,c;return!(!a||"[object Object]"!==k.call(a))&&(!(b=e(a))||(c=l.call(b,"constructor")&&b.constructor,"function"==typeof c&&m.call(c)===n))},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?j[k.call(a)]||"object":typeof a},globalEval:function(a){p(a)},camelCase:function(a){return a.replace(t,"ms-").replace(u,v)},each:function(a,b){var c,d=0;if(w(a)){for(c=a.length;d<c;d++)if(b.call(a[d],d,a[d])===!1)break}else for(d in a)if(b.call(a[d],d,a[d])===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(s,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(w(Object(a))?r.merge(c,"string"==typeof a?[a]:a):h.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:i.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;d<c;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;f<g;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,e,f=0,h=[];if(w(a))for(d=a.length;f<d;f++)e=b(a[f],f,c),null!=e&&h.push(e);else for(f in a)e=b(a[f],f,c),null!=e&&h.push(e);return g.apply([],h)},guid:1,proxy:function(a,b){var c,d,e;if("string"==typeof b&&(c=a[b],b=a,a=c),r.isFunction(a))return d=f.call(arguments,2),e=function(){return a.apply(b||this,d.concat(f.call(arguments)))},e.guid=a.guid=a.guid||r.guid++,e},now:Date.now,support:o}),"function"==typeof Symbol&&(r.fn[Symbol.iterator]=c[Symbol.iterator]),r.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(a,b){j["[object "+b+"]"]=b.toLowerCase()});function w(a){var b=!!a&&"length"in a&&a.length,c=r.type(a);return"function"!==c&&!r.isWindow(a)&&("array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a)}var x=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C={}.hasOwnProperty,D=[],E=D.pop,F=D.push,G=D.push,H=D.slice,I=function(a,b){for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return-1},J="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",K="[\\x20\\t\\r\\n\\f]",L="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",M="\\["+K+"*("+L+")(?:"+K+"*([*^$|!~]?=)"+K+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+L+"))|)"+K+"*\\]",N=":("+L+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+M+")*)|.*)\\)|)",O=new RegExp(K+"+","g"),P=new RegExp("^"+K+"+|((?:^|[^\\\\])(?:\\\\.)*)"+K+"+$","g"),Q=new RegExp("^"+K+"*,"+K+"*"),R=new RegExp("^"+K+"*([>+~]|"+K+")"+K+"*"),S=new RegExp("="+K+"*([^\\]'\"]*?)"+K+"*\\]","g"),T=new RegExp(N),U=new RegExp("^"+L+"$"),V={ID:new RegExp("^#("+L+")"),CLASS:new RegExp("^\\.("+L+")"),TAG:new RegExp("^("+L+"|[*])"),ATTR:new RegExp("^"+M),PSEUDO:new RegExp("^"+N),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+K+"*(even|odd|(([+-]|)(\\d*)n|)"+K+"*(?:([+-]|)"+K+"*(\\d+)|))"+K+"*\\)|)","i"),bool:new RegExp("^(?:"+J+")$","i"),needsContext:new RegExp("^"+K+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+K+"*((?:-\\d)?\\d*)"+K+"*\\)|)(?=[^-]|$)","i")},W=/^(?:input|select|textarea|button)$/i,X=/^h\d$/i,Y=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,$=/[+~]/,_=new RegExp("\\\\([\\da-f]{1,6}"+K+"?|("+K+")|.)","ig"),aa=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:d<0?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ba=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ca=function(a,b){return b?"\0"===a?"\ufffd":a.slice(0,-1)+"\\"+a.charCodeAt(a.length-1).toString(16)+" ":"\\"+a},da=function(){m()},ea=ta(function(a){return a.disabled===!0&&("form"in a||"label"in a)},{dir:"parentNode",next:"legend"});try{G.apply(D=H.call(v.childNodes),v.childNodes),D[v.childNodes.length].nodeType}catch(fa){G={apply:D.length?function(a,b){F.apply(a,H.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s=b&&b.ownerDocument,w=b?b.nodeType:9;if(d=d||[],"string"!=typeof a||!a||1!==w&&9!==w&&11!==w)return d;if(!e&&((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,p)){if(11!==w&&(l=Z.exec(a)))if(f=l[1]){if(9===w){if(!(j=b.getElementById(f)))return d;if(j.id===f)return d.push(j),d}else if(s&&(j=s.getElementById(f))&&t(b,j)&&j.id===f)return d.push(j),d}else{if(l[2])return G.apply(d,b.getElementsByTagName(a)),d;if((f=l[3])&&c.getElementsByClassName&&b.getElementsByClassName)return G.apply(d,b.getElementsByClassName(f)),d}if(c.qsa&&!A[a+" "]&&(!q||!q.test(a))){if(1!==w)s=b,r=a;else if("object"!==b.nodeName.toLowerCase()){(k=b.getAttribute("id"))?k=k.replace(ba,ca):b.setAttribute("id",k=u),o=g(a),h=o.length;while(h--)o[h]="#"+k+" "+sa(o[h]);r=o.join(","),s=$.test(a)&&qa(b.parentNode)||b}if(r)try{return G.apply(d,s.querySelectorAll(r)),d}catch(x){}finally{k===u&&b.removeAttribute("id")}}}return i(a.replace(P,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("fieldset");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=c.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&a.sourceIndex-b.sourceIndex;if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return function(b){return"form"in b?b.parentNode&&b.disabled===!1?"label"in b?"label"in b.parentNode?b.parentNode.disabled===a:b.disabled===a:b.isDisabled===a||b.isDisabled!==!a&&ea(b)===a:b.disabled===a:"label"in b&&b.disabled===a}}function pa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function qa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return!!b&&"HTML"!==b.nodeName},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=n.documentElement,p=!f(n),v!==n&&(e=n.defaultView)&&e.top!==e&&(e.addEventListener?e.addEventListener("unload",da,!1):e.attachEvent&&e.attachEvent("onunload",da)),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(n.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=Y.test(n.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!n.getElementsByName||!n.getElementsByName(u).length}),c.getById?(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){return a.getAttribute("id")===b}},d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c?[c]:[]}}):(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}},d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c,d,e,f=b.getElementById(a);if(f){if(c=f.getAttributeNode("id"),c&&c.value===a)return[f];e=b.getElementsByName(a),d=0;while(f=e[d++])if(c=f.getAttributeNode("id"),c&&c.value===a)return[f]}return[]}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){if("undefined"!=typeof b.getElementsByClassName&&p)return b.getElementsByClassName(a)},r=[],q=[],(c.qsa=Y.test(n.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\r\\' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+K+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+K+"*(?:value|"+J+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){a.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var b=n.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+K+"*[*^$|!~]?="),2!==a.querySelectorAll(":enabled").length&&q.push(":enabled",":disabled"),o.appendChild(a).disabled=!0,2!==a.querySelectorAll(":disabled").length&&q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=Y.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"*"),s.call(a,"[s!='']:x"),r.push("!=",N)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=Y.test(o.compareDocumentPosition),t=b||Y.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===n||a.ownerDocument===v&&t(v,a)?-1:b===n||b.ownerDocument===v&&t(v,b)?1:k?I(k,a)-I(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,g=[a],h=[b];if(!e||!f)return a===n?-1:b===n?1:e?-1:f?1:k?I(k,a)-I(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)g.unshift(c);c=b;while(c=c.parentNode)h.unshift(c);while(g[d]===h[d])d++;return d?la(g[d],h[d]):g[d]===v?-1:h[d]===v?1:0},n):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(S,"='$1']"),c.matchesSelector&&p&&!A[b+" "]&&(!r||!r.test(b))&&(!q||!q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&C.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.escape=function(a){return(a+"").replace(ba,ca)},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:V,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(_,aa),a[3]=(a[3]||a[4]||a[5]||"").replace(_,aa),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return V.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&T.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(_,aa).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+K+")"+a+"("+K+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:!b||(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(O," ")+" ").indexOf(c)>-1:"|="===b&&(e===c||e.slice(0,c.length+1)===c+"-"))}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h,t=!1;if(q){if(f){while(p){m=b;while(m=m[p])if(h?m.nodeName.toLowerCase()===r:1===m.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){m=q,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n&&j[2],m=n&&q.childNodes[n];while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if(1===m.nodeType&&++t&&m===b){k[a]=[w,n,t];break}}else if(s&&(m=b,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n),t===!1)while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if((h?m.nodeName.toLowerCase()===r:1===m.nodeType)&&++t&&(s&&(l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),k[a]=[w,t]),m===b))break;return t-=e,t===d||t%d===0&&t/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=I(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(P,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(_,aa),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return U.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(_,aa).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:oa(!1),disabled:oa(!0),checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return X.test(a.nodeName)},input:function(a){return W.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:pa(function(){return[0]}),last:pa(function(a,b){return[b-1]}),eq:pa(function(a,b,c){return[c<0?c+b:c]}),even:pa(function(a,b){for(var c=0;c<b;c+=2)a.push(c);return a}),odd:pa(function(a,b){for(var c=1;c<b;c+=2)a.push(c);return a}),lt:pa(function(a,b,c){for(var d=c<0?c+b:c;--d>=0;)a.push(d);return a}),gt:pa(function(a,b,c){for(var d=c<0?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function ra(){}ra.prototype=d.filters=d.pseudos,d.setFilters=new ra,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){c&&!(e=Q.exec(h))||(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=R.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(P," ")}),h=h.slice(c.length));for(g in d.filter)!(e=V[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function sa(a){for(var b=0,c=a.length,d="";b<c;b++)d+=a[b].value;return d}function ta(a,b,c){var d=b.dir,e=b.next,f=e||d,g=c&&"parentNode"===f,h=x++;return b.first?function(b,c,e){while(b=b[d])if(1===b.nodeType||g)return a(b,c,e);return!1}:function(b,c,i){var j,k,l,m=[w,h];if(i){while(b=b[d])if((1===b.nodeType||g)&&a(b,c,i))return!0}else while(b=b[d])if(1===b.nodeType||g)if(l=b[u]||(b[u]={}),k=l[b.uniqueID]||(l[b.uniqueID]={}),e&&e===b.nodeName.toLowerCase())b=b[d]||b;else{if((j=k[f])&&j[0]===w&&j[1]===h)return m[2]=j[2];if(k[f]=m,m[2]=a(b,c,i))return!0}return!1}}function ua(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function va(a,b,c){for(var d=0,e=b.length;d<e;d++)ga(a,b[d],c);return c}function wa(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;h<i;h++)(f=a[h])&&(c&&!c(f,d,e)||(g.push(f),j&&b.push(h)));return g}function xa(a,b,c,d,e,f){return d&&!d[u]&&(d=xa(d)),e&&!e[u]&&(e=xa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||va(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:wa(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=wa(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?I(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=wa(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):G.apply(g,r)})}function ya(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=ta(function(a){return a===b},h,!0),l=ta(function(a){return I(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];i<f;i++)if(c=d.relative[a[i].type])m=[ta(ua(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;e<f;e++)if(d.relative[a[e].type])break;return xa(i>1&&ua(m),i>1&&sa(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(P,"$1"),c,i<e&&ya(a.slice(i,e)),e<f&&ya(a=a.slice(e)),e<f&&sa(a))}m.push(c)}return ua(m)}function za(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,o,q,r=0,s="0",t=f&&[],u=[],v=j,x=f||e&&d.find.TAG("*",k),y=w+=null==v?1:Math.random()||.1,z=x.length;for(k&&(j=g===n||g||k);s!==z&&null!=(l=x[s]);s++){if(e&&l){o=0,g||l.ownerDocument===n||(m(l),h=!p);while(q=a[o++])if(q(l,g||n,h)){i.push(l);break}k&&(w=y)}c&&((l=!q&&l)&&r--,f&&t.push(l))}if(r+=s,c&&s!==r){o=0;while(q=b[o++])q(t,u,g,h);if(f){if(r>0)while(s--)t[s]||u[s]||(u[s]=E.call(i));u=wa(u)}G.apply(i,u),k&&!f&&u.length>0&&r+b.length>1&&ga.uniqueSort(i)}return k&&(w=y,j=v),t};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=ya(b[c]),f[u]?d.push(f):e.push(f);f=A(a,za(e,d)),f.selector=a}return f},i=ga.select=function(a,b,c,e){var f,i,j,k,l,m="function"==typeof a&&a,n=!e&&g(a=m.selector||a);if(c=c||[],1===n.length){if(i=n[0]=n[0].slice(0),i.length>2&&"ID"===(j=i[0]).type&&9===b.nodeType&&p&&d.relative[i[1].type]){if(b=(d.find.ID(j.matches[0].replace(_,aa),b)||[])[0],!b)return c;m&&(b=b.parentNode),a=a.slice(i.shift().value.length)}f=V.needsContext.test(a)?0:i.length;while(f--){if(j=i[f],d.relative[k=j.type])break;if((l=d.find[k])&&(e=l(j.matches[0].replace(_,aa),$.test(i[0].type)&&qa(b.parentNode)||b))){if(i.splice(f,1),a=e.length&&sa(i),!a)return G.apply(c,e),c;break}}}return(m||h(a,n))(e,b,!p,c,!b||$.test(a)&&qa(b.parentNode)||b),c},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("fieldset"))}),ja(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){if(!c)return a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){if(!c&&"input"===a.nodeName.toLowerCase())return a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(J,function(a,b,c){var d;if(!c)return a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);r.find=x,r.expr=x.selectors,r.expr[":"]=r.expr.pseudos,r.uniqueSort=r.unique=x.uniqueSort,r.text=x.getText,r.isXMLDoc=x.isXML,r.contains=x.contains,r.escapeSelector=x.escape;var y=function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&r(a).is(c))break;d.push(a)}return d},z=function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c},A=r.expr.match.needsContext;function B(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()}var C=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i,D=/^.[^:#\[\.,]*$/;function E(a,b,c){return r.isFunction(b)?r.grep(a,function(a,d){return!!b.call(a,d,a)!==c}):b.nodeType?r.grep(a,function(a){return a===b!==c}):"string"!=typeof b?r.grep(a,function(a){return i.call(b,a)>-1!==c}):D.test(b)?r.filter(b,a,c):(b=r.filter(b,a),r.grep(a,function(a){return i.call(b,a)>-1!==c&&1===a.nodeType}))}r.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?r.find.matchesSelector(d,a)?[d]:[]:r.find.matches(a,r.grep(b,function(a){return 1===a.nodeType}))},r.fn.extend({find:function(a){var b,c,d=this.length,e=this;if("string"!=typeof a)return this.pushStack(r(a).filter(function(){for(b=0;b<d;b++)if(r.contains(e[b],this))return!0}));for(c=this.pushStack([]),b=0;b<d;b++)r.find(a,e[b],c);return d>1?r.uniqueSort(c):c},filter:function(a){return this.pushStack(E(this,a||[],!1))},not:function(a){return this.pushStack(E(this,a||[],!0))},is:function(a){return!!E(this,"string"==typeof a&&A.test(a)?r(a):a||[],!1).length}});var F,G=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,H=r.fn.init=function(a,b,c){var e,f;if(!a)return this;if(c=c||F,"string"==typeof a){if(e="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:G.exec(a),!e||!e[1]&&b)return!b||b.jquery?(b||c).find(a):this.constructor(b).find(a);if(e[1]){if(b=b instanceof r?b[0]:b,r.merge(this,r.parseHTML(e[1],b&&b.nodeType?b.ownerDocument||b:d,!0)),C.test(e[1])&&r.isPlainObject(b))for(e in b)r.isFunction(this[e])?this[e](b[e]):this.attr(e,b[e]);return this}return f=d.getElementById(e[2]),f&&(this[0]=f,this.length=1),this}return a.nodeType?(this[0]=a,this.length=1,this):r.isFunction(a)?void 0!==c.ready?c.ready(a):a(r):r.makeArray(a,this)};H.prototype=r.fn,F=r(d);var I=/^(?:parents|prev(?:Until|All))/,J={children:!0,contents:!0,next:!0,prev:!0};r.fn.extend({has:function(a){var b=r(a,this),c=b.length;return this.filter(function(){for(var a=0;a<c;a++)if(r.contains(this,b[a]))return!0})},closest:function(a,b){var c,d=0,e=this.length,f=[],g="string"!=typeof a&&r(a);if(!A.test(a))for(;d<e;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&r.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?r.uniqueSort(f):f)},index:function(a){return a?"string"==typeof a?i.call(r(a),this[0]):i.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(r.uniqueSort(r.merge(this.get(),r(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function K(a,b){while((a=a[b])&&1!==a.nodeType);return a}r.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return y(a,"parentNode")},parentsUntil:function(a,b,c){return y(a,"parentNode",c)},next:function(a){return K(a,"nextSibling")},prev:function(a){return K(a,"previousSibling")},nextAll:function(a){return y(a,"nextSibling")},prevAll:function(a){return y(a,"previousSibling")},nextUntil:function(a,b,c){return y(a,"nextSibling",c)},prevUntil:function(a,b,c){return y(a,"previousSibling",c)},siblings:function(a){return z((a.parentNode||{}).firstChild,a)},children:function(a){return z(a.firstChild)},contents:function(a){return B(a,"iframe")?a.contentDocument:(B(a,"template")&&(a=a.content||a),r.merge([],a.childNodes))}},function(a,b){r.fn[a]=function(c,d){var e=r.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=r.filter(d,e)),this.length>1&&(J[a]||r.uniqueSort(e),I.test(a)&&e.reverse()),this.pushStack(e)}});var L=/[^\x20\t\r\n\f]+/g;function M(a){var b={};return r.each(a.match(L)||[],function(a,c){b[c]=!0}),b}r.Callbacks=function(a){a="string"==typeof a?M(a):r.extend({},a);var b,c,d,e,f=[],g=[],h=-1,i=function(){for(e=e||a.once,d=b=!0;g.length;h=-1){c=g.shift();while(++h<f.length)f[h].apply(c[0],c[1])===!1&&a.stopOnFalse&&(h=f.length,c=!1)}a.memory||(c=!1),b=!1,e&&(f=c?[]:"")},j={add:function(){return f&&(c&&!b&&(h=f.length-1,g.push(c)),function d(b){r.each(b,function(b,c){r.isFunction(c)?a.unique&&j.has(c)||f.push(c):c&&c.length&&"string"!==r.type(c)&&d(c)})}(arguments),c&&!b&&i()),this},remove:function(){return r.each(arguments,function(a,b){var c;while((c=r.inArray(b,f,c))>-1)f.splice(c,1),c<=h&&h--}),this},has:function(a){return a?r.inArray(a,f)>-1:f.length>0},empty:function(){return f&&(f=[]),this},disable:function(){return e=g=[],f=c="",this},disabled:function(){return!f},lock:function(){return e=g=[],c||b||(f=c=""),this},locked:function(){return!!e},fireWith:function(a,c){return e||(c=c||[],c=[a,c.slice?c.slice():c],g.push(c),b||i()),this},fire:function(){return j.fireWith(this,arguments),this},fired:function(){return!!d}};return j};function N(a){return a}function O(a){throw a}function P(a,b,c,d){var e;try{a&&r.isFunction(e=a.promise)?e.call(a).done(b).fail(c):a&&r.isFunction(e=a.then)?e.call(a,b,c):b.apply(void 0,[a].slice(d))}catch(a){c.apply(void 0,[a])}}r.extend({Deferred:function(b){var c=[["notify","progress",r.Callbacks("memory"),r.Callbacks("memory"),2],["resolve","done",r.Callbacks("once memory"),r.Callbacks("once memory"),0,"resolved"],["reject","fail",r.Callbacks("once memory"),r.Callbacks("once memory"),1,"rejected"]],d="pending",e={state:function(){return d},always:function(){return f.done(arguments).fail(arguments),this},"catch":function(a){return e.then(null,a)},pipe:function(){var a=arguments;return r.Deferred(function(b){r.each(c,function(c,d){var e=r.isFunction(a[d[4]])&&a[d[4]];f[d[1]](function(){var a=e&&e.apply(this,arguments);a&&r.isFunction(a.promise)?a.promise().progress(b.notify).done(b.resolve).fail(b.reject):b[d[0]+"With"](this,e?[a]:arguments)})}),a=null}).promise()},then:function(b,d,e){var f=0;function g(b,c,d,e){return function(){var h=this,i=arguments,j=function(){var a,j;if(!(b<f)){if(a=d.apply(h,i),a===c.promise())throw new TypeError("Thenable self-resolution");j=a&&("object"==typeof a||"function"==typeof a)&&a.then,r.isFunction(j)?e?j.call(a,g(f,c,N,e),g(f,c,O,e)):(f++,j.call(a,g(f,c,N,e),g(f,c,O,e),g(f,c,N,c.notifyWith))):(d!==N&&(h=void 0,i=[a]),(e||c.resolveWith)(h,i))}},k=e?j:function(){try{j()}catch(a){r.Deferred.exceptionHook&&r.Deferred.exceptionHook(a,k.stackTrace),b+1>=f&&(d!==O&&(h=void 0,i=[a]),c.rejectWith(h,i))}};b?k():(r.Deferred.getStackHook&&(k.stackTrace=r.Deferred.getStackHook()),a.setTimeout(k))}}return r.Deferred(function(a){c[0][3].add(g(0,a,r.isFunction(e)?e:N,a.notifyWith)),c[1][3].add(g(0,a,r.isFunction(b)?b:N)),c[2][3].add(g(0,a,r.isFunction(d)?d:O))}).promise()},promise:function(a){return null!=a?r.extend(a,e):e}},f={};return r.each(c,function(a,b){var g=b[2],h=b[5];e[b[1]]=g.add,h&&g.add(function(){d=h},c[3-a][2].disable,c[0][2].lock),g.add(b[3].fire),f[b[0]]=function(){return f[b[0]+"With"](this===f?void 0:this,arguments),this},f[b[0]+"With"]=g.fireWith}),e.promise(f),b&&b.call(f,f),f},when:function(a){var b=arguments.length,c=b,d=Array(c),e=f.call(arguments),g=r.Deferred(),h=function(a){return function(c){d[a]=this,e[a]=arguments.length>1?f.call(arguments):c,--b||g.resolveWith(d,e)}};if(b<=1&&(P(a,g.done(h(c)).resolve,g.reject,!b),"pending"===g.state()||r.isFunction(e[c]&&e[c].then)))return g.then();while(c--)P(e[c],h(c),g.reject);return g.promise()}});var Q=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;r.Deferred.exceptionHook=function(b,c){a.console&&a.console.warn&&b&&Q.test(b.name)&&a.console.warn("jQuery.Deferred exception: "+b.message,b.stack,c)},r.readyException=function(b){a.setTimeout(function(){throw b})};var R=r.Deferred();r.fn.ready=function(a){return R.then(a)["catch"](function(a){r.readyException(a)}),this},r.extend({isReady:!1,readyWait:1,ready:function(a){(a===!0?--r.readyWait:r.isReady)||(r.isReady=!0,a!==!0&&--r.readyWait>0||R.resolveWith(d,[r]))}}),r.ready.then=R.then;function S(){d.removeEventListener("DOMContentLoaded",S),
    a.removeEventListener("load",S),r.ready()}"complete"===d.readyState||"loading"!==d.readyState&&!d.documentElement.doScroll?a.setTimeout(r.ready):(d.addEventListener("DOMContentLoaded",S),a.addEventListener("load",S));var T=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===r.type(c)){e=!0;for(h in c)T(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,r.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(r(a),c)})),b))for(;h<i;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},U=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function V(){this.expando=r.expando+V.uid++}V.uid=1,V.prototype={cache:function(a){var b=a[this.expando];return b||(b={},U(a)&&(a.nodeType?a[this.expando]=b:Object.defineProperty(a,this.expando,{value:b,configurable:!0}))),b},set:function(a,b,c){var d,e=this.cache(a);if("string"==typeof b)e[r.camelCase(b)]=c;else for(d in b)e[r.camelCase(d)]=b[d];return e},get:function(a,b){return void 0===b?this.cache(a):a[this.expando]&&a[this.expando][r.camelCase(b)]},access:function(a,b,c){return void 0===b||b&&"string"==typeof b&&void 0===c?this.get(a,b):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d=a[this.expando];if(void 0!==d){if(void 0!==b){Array.isArray(b)?b=b.map(r.camelCase):(b=r.camelCase(b),b=b in d?[b]:b.match(L)||[]),c=b.length;while(c--)delete d[b[c]]}(void 0===b||r.isEmptyObject(d))&&(a.nodeType?a[this.expando]=void 0:delete a[this.expando])}},hasData:function(a){var b=a[this.expando];return void 0!==b&&!r.isEmptyObject(b)}};var W=new V,X=new V,Y=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Z=/[A-Z]/g;function $(a){return"true"===a||"false"!==a&&("null"===a?null:a===+a+""?+a:Y.test(a)?JSON.parse(a):a)}function _(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(Z,"-$&").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c=$(c)}catch(e){}X.set(a,b,c)}else c=void 0;return c}r.extend({hasData:function(a){return X.hasData(a)||W.hasData(a)},data:function(a,b,c){return X.access(a,b,c)},removeData:function(a,b){X.remove(a,b)},_data:function(a,b,c){return W.access(a,b,c)},_removeData:function(a,b){W.remove(a,b)}}),r.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=X.get(f),1===f.nodeType&&!W.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=r.camelCase(d.slice(5)),_(f,d,e[d])));W.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){X.set(this,a)}):T(this,function(b){var c;if(f&&void 0===b){if(c=X.get(f,a),void 0!==c)return c;if(c=_(f,a),void 0!==c)return c}else this.each(function(){X.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){X.remove(this,a)})}}),r.extend({queue:function(a,b,c){var d;if(a)return b=(b||"fx")+"queue",d=W.get(a,b),c&&(!d||Array.isArray(c)?d=W.access(a,b,r.makeArray(c)):d.push(c)),d||[]},dequeue:function(a,b){b=b||"fx";var c=r.queue(a,b),d=c.length,e=c.shift(),f=r._queueHooks(a,b),g=function(){r.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return W.get(a,c)||W.access(a,c,{empty:r.Callbacks("once memory").add(function(){W.remove(a,[b+"queue",c])})})}}),r.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?r.queue(this[0],a):void 0===b?this:this.each(function(){var c=r.queue(this,a,b);r._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&r.dequeue(this,a)})},dequeue:function(a){return this.each(function(){r.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=r.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=W.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var aa=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,ba=new RegExp("^(?:([+-])=|)("+aa+")([a-z%]*)$","i"),ca=["Top","Right","Bottom","Left"],da=function(a,b){return a=b||a,"none"===a.style.display||""===a.style.display&&r.contains(a.ownerDocument,a)&&"none"===r.css(a,"display")},ea=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};function fa(a,b,c,d){var e,f=1,g=20,h=d?function(){return d.cur()}:function(){return r.css(a,b,"")},i=h(),j=c&&c[3]||(r.cssNumber[b]?"":"px"),k=(r.cssNumber[b]||"px"!==j&&+i)&&ba.exec(r.css(a,b));if(k&&k[3]!==j){j=j||k[3],c=c||[],k=+i||1;do f=f||".5",k/=f,r.style(a,b,k+j);while(f!==(f=h()/i)&&1!==f&&--g)}return c&&(k=+k||+i||0,e=c[1]?k+(c[1]+1)*c[2]:+c[2],d&&(d.unit=j,d.start=k,d.end=e)),e}var ga={};function ha(a){var b,c=a.ownerDocument,d=a.nodeName,e=ga[d];return e?e:(b=c.body.appendChild(c.createElement(d)),e=r.css(b,"display"),b.parentNode.removeChild(b),"none"===e&&(e="block"),ga[d]=e,e)}function ia(a,b){for(var c,d,e=[],f=0,g=a.length;f<g;f++)d=a[f],d.style&&(c=d.style.display,b?("none"===c&&(e[f]=W.get(d,"display")||null,e[f]||(d.style.display="")),""===d.style.display&&da(d)&&(e[f]=ha(d))):"none"!==c&&(e[f]="none",W.set(d,"display",c)));for(f=0;f<g;f++)null!=e[f]&&(a[f].style.display=e[f]);return a}r.fn.extend({show:function(){return ia(this,!0)},hide:function(){return ia(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){da(this)?r(this).show():r(this).hide()})}});var ja=/^(?:checkbox|radio)$/i,ka=/<([a-z][^\/\0>\x20\t\r\n\f]+)/i,la=/^$|\/(?:java|ecma)script/i,ma={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ma.optgroup=ma.option,ma.tbody=ma.tfoot=ma.colgroup=ma.caption=ma.thead,ma.th=ma.td;function na(a,b){var c;return c="undefined"!=typeof a.getElementsByTagName?a.getElementsByTagName(b||"*"):"undefined"!=typeof a.querySelectorAll?a.querySelectorAll(b||"*"):[],void 0===b||b&&B(a,b)?r.merge([a],c):c}function oa(a,b){for(var c=0,d=a.length;c<d;c++)W.set(a[c],"globalEval",!b||W.get(b[c],"globalEval"))}var pa=/<|&#?\w+;/;function qa(a,b,c,d,e){for(var f,g,h,i,j,k,l=b.createDocumentFragment(),m=[],n=0,o=a.length;n<o;n++)if(f=a[n],f||0===f)if("object"===r.type(f))r.merge(m,f.nodeType?[f]:f);else if(pa.test(f)){g=g||l.appendChild(b.createElement("div")),h=(ka.exec(f)||["",""])[1].toLowerCase(),i=ma[h]||ma._default,g.innerHTML=i[1]+r.htmlPrefilter(f)+i[2],k=i[0];while(k--)g=g.lastChild;r.merge(m,g.childNodes),g=l.firstChild,g.textContent=""}else m.push(b.createTextNode(f));l.textContent="",n=0;while(f=m[n++])if(d&&r.inArray(f,d)>-1)e&&e.push(f);else if(j=r.contains(f.ownerDocument,f),g=na(l.appendChild(f),"script"),j&&oa(g),c){k=0;while(f=g[k++])la.test(f.type||"")&&c.push(f)}return l}!function(){var a=d.createDocumentFragment(),b=a.appendChild(d.createElement("div")),c=d.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),o.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",o.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var ra=d.documentElement,sa=/^key/,ta=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,ua=/^([^.]*)(?:\.(.+)|)/;function va(){return!0}function wa(){return!1}function xa(){try{return d.activeElement}catch(a){}}function ya(a,b,c,d,e,f){var g,h;if("object"==typeof b){"string"!=typeof c&&(d=d||c,c=void 0);for(h in b)ya(a,h,c,d,b[h],f);return a}if(null==d&&null==e?(e=c,d=c=void 0):null==e&&("string"==typeof c?(e=d,d=void 0):(e=d,d=c,c=void 0)),e===!1)e=wa;else if(!e)return a;return 1===f&&(g=e,e=function(a){return r().off(a),g.apply(this,arguments)},e.guid=g.guid||(g.guid=r.guid++)),a.each(function(){r.event.add(this,b,e,d,c)})}r.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=W.get(a);if(q){c.handler&&(f=c,c=f.handler,e=f.selector),e&&r.find.matchesSelector(ra,e),c.guid||(c.guid=r.guid++),(i=q.events)||(i=q.events={}),(g=q.handle)||(g=q.handle=function(b){return"undefined"!=typeof r&&r.event.triggered!==b.type?r.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(L)||[""],j=b.length;while(j--)h=ua.exec(b[j])||[],n=p=h[1],o=(h[2]||"").split(".").sort(),n&&(l=r.event.special[n]||{},n=(e?l.delegateType:l.bindType)||n,l=r.event.special[n]||{},k=r.extend({type:n,origType:p,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&r.expr.match.needsContext.test(e),namespace:o.join(".")},f),(m=i[n])||(m=i[n]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,o,g)!==!1||a.addEventListener&&a.addEventListener(n,g)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),r.event.global[n]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=W.hasData(a)&&W.get(a);if(q&&(i=q.events)){b=(b||"").match(L)||[""],j=b.length;while(j--)if(h=ua.exec(b[j])||[],n=p=h[1],o=(h[2]||"").split(".").sort(),n){l=r.event.special[n]||{},n=(d?l.delegateType:l.bindType)||n,m=i[n]||[],h=h[2]&&new RegExp("(^|\\.)"+o.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&p!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,o,q.handle)!==!1||r.removeEvent(a,n,q.handle),delete i[n])}else for(n in i)r.event.remove(a,n+b[j],c,d,!0);r.isEmptyObject(i)&&W.remove(a,"handle events")}},dispatch:function(a){var b=r.event.fix(a),c,d,e,f,g,h,i=new Array(arguments.length),j=(W.get(this,"events")||{})[b.type]||[],k=r.event.special[b.type]||{};for(i[0]=b,c=1;c<arguments.length;c++)i[c]=arguments[c];if(b.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,b)!==!1){h=r.event.handlers.call(this,b,j),c=0;while((f=h[c++])&&!b.isPropagationStopped()){b.currentTarget=f.elem,d=0;while((g=f.handlers[d++])&&!b.isImmediatePropagationStopped())b.rnamespace&&!b.rnamespace.test(g.namespace)||(b.handleObj=g,b.data=g.data,e=((r.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(b.result=e)===!1&&(b.preventDefault(),b.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,b),b.result}},handlers:function(a,b){var c,d,e,f,g,h=[],i=b.delegateCount,j=a.target;if(i&&j.nodeType&&!("click"===a.type&&a.button>=1))for(;j!==this;j=j.parentNode||this)if(1===j.nodeType&&("click"!==a.type||j.disabled!==!0)){for(f=[],g={},c=0;c<i;c++)d=b[c],e=d.selector+" ",void 0===g[e]&&(g[e]=d.needsContext?r(e,this).index(j)>-1:r.find(e,this,null,[j]).length),g[e]&&f.push(d);f.length&&h.push({elem:j,handlers:f})}return j=this,i<b.length&&h.push({elem:j,handlers:b.slice(i)}),h},addProp:function(a,b){Object.defineProperty(r.Event.prototype,a,{enumerable:!0,configurable:!0,get:r.isFunction(b)?function(){if(this.originalEvent)return b(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[a]},set:function(b){Object.defineProperty(this,a,{enumerable:!0,configurable:!0,writable:!0,value:b})}})},fix:function(a){return a[r.expando]?a:new r.Event(a)},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==xa()&&this.focus)return this.focus(),!1},delegateType:"focusin"},blur:{trigger:function(){if(this===xa()&&this.blur)return this.blur(),!1},delegateType:"focusout"},click:{trigger:function(){if("checkbox"===this.type&&this.click&&B(this,"input"))return this.click(),!1},_default:function(a){return B(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}}},r.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c)},r.Event=function(a,b){return this instanceof r.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?va:wa,this.target=a.target&&3===a.target.nodeType?a.target.parentNode:a.target,this.currentTarget=a.currentTarget,this.relatedTarget=a.relatedTarget):this.type=a,b&&r.extend(this,b),this.timeStamp=a&&a.timeStamp||r.now(),void(this[r.expando]=!0)):new r.Event(a,b)},r.Event.prototype={constructor:r.Event,isDefaultPrevented:wa,isPropagationStopped:wa,isImmediatePropagationStopped:wa,isSimulated:!1,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=va,a&&!this.isSimulated&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=va,a&&!this.isSimulated&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=va,a&&!this.isSimulated&&a.stopImmediatePropagation(),this.stopPropagation()}},r.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(a){var b=a.button;return null==a.which&&sa.test(a.type)?null!=a.charCode?a.charCode:a.keyCode:!a.which&&void 0!==b&&ta.test(a.type)?1&b?1:2&b?3:4&b?2:0:a.which}},r.event.addProp),r.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){r.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return e&&(e===d||r.contains(d,e))||(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),r.fn.extend({on:function(a,b,c,d){return ya(this,a,b,c,d)},one:function(a,b,c,d){return ya(this,a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,r(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return b!==!1&&"function"!=typeof b||(c=b,b=void 0),c===!1&&(c=wa),this.each(function(){r.event.remove(this,a,c,b)})}});var za=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,Aa=/<script|<style|<link/i,Ba=/checked\s*(?:[^=]|=\s*.checked.)/i,Ca=/^true\/(.*)/,Da=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function Ea(a,b){return B(a,"table")&&B(11!==b.nodeType?b:b.firstChild,"tr")?r(">tbody",a)[0]||a:a}function Fa(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function Ga(a){var b=Ca.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function Ha(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(W.hasData(a)&&(f=W.access(a),g=W.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;c<d;c++)r.event.add(b,e,j[e][c])}X.hasData(a)&&(h=X.access(a),i=r.extend({},h),X.set(b,i))}}function Ia(a,b){var c=b.nodeName.toLowerCase();"input"===c&&ja.test(a.type)?b.checked=a.checked:"input"!==c&&"textarea"!==c||(b.defaultValue=a.defaultValue)}function Ja(a,b,c,d){b=g.apply([],b);var e,f,h,i,j,k,l=0,m=a.length,n=m-1,q=b[0],s=r.isFunction(q);if(s||m>1&&"string"==typeof q&&!o.checkClone&&Ba.test(q))return a.each(function(e){var f=a.eq(e);s&&(b[0]=q.call(this,e,f.html())),Ja(f,b,c,d)});if(m&&(e=qa(b,a[0].ownerDocument,!1,a,d),f=e.firstChild,1===e.childNodes.length&&(e=f),f||d)){for(h=r.map(na(e,"script"),Fa),i=h.length;l<m;l++)j=e,l!==n&&(j=r.clone(j,!0,!0),i&&r.merge(h,na(j,"script"))),c.call(a[l],j,l);if(i)for(k=h[h.length-1].ownerDocument,r.map(h,Ga),l=0;l<i;l++)j=h[l],la.test(j.type||"")&&!W.access(j,"globalEval")&&r.contains(k,j)&&(j.src?r._evalUrl&&r._evalUrl(j.src):p(j.textContent.replace(Da,""),k))}return a}function Ka(a,b,c){for(var d,e=b?r.filter(b,a):a,f=0;null!=(d=e[f]);f++)c||1!==d.nodeType||r.cleanData(na(d)),d.parentNode&&(c&&r.contains(d.ownerDocument,d)&&oa(na(d,"script")),d.parentNode.removeChild(d));return a}r.extend({htmlPrefilter:function(a){return a.replace(za,"<$1></$2>")},clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=r.contains(a.ownerDocument,a);if(!(o.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||r.isXMLDoc(a)))for(g=na(h),f=na(a),d=0,e=f.length;d<e;d++)Ia(f[d],g[d]);if(b)if(c)for(f=f||na(a),g=g||na(h),d=0,e=f.length;d<e;d++)Ha(f[d],g[d]);else Ha(a,h);return g=na(h,"script"),g.length>0&&oa(g,!i&&na(a,"script")),h},cleanData:function(a){for(var b,c,d,e=r.event.special,f=0;void 0!==(c=a[f]);f++)if(U(c)){if(b=c[W.expando]){if(b.events)for(d in b.events)e[d]?r.event.remove(c,d):r.removeEvent(c,d,b.handle);c[W.expando]=void 0}c[X.expando]&&(c[X.expando]=void 0)}}}),r.fn.extend({detach:function(a){return Ka(this,a,!0)},remove:function(a){return Ka(this,a)},text:function(a){return T(this,function(a){return void 0===a?r.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=a)})},null,a,arguments.length)},append:function(){return Ja(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ea(this,a);b.appendChild(a)}})},prepend:function(){return Ja(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ea(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return Ja(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return Ja(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(r.cleanData(na(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null!=a&&a,b=null==b?a:b,this.map(function(){return r.clone(this,a,b)})},html:function(a){return T(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!Aa.test(a)&&!ma[(ka.exec(a)||["",""])[1].toLowerCase()]){a=r.htmlPrefilter(a);try{for(;c<d;c++)b=this[c]||{},1===b.nodeType&&(r.cleanData(na(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=[];return Ja(this,arguments,function(b){var c=this.parentNode;r.inArray(this,a)<0&&(r.cleanData(na(this)),c&&c.replaceChild(b,this))},a)}}),r.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){r.fn[a]=function(a){for(var c,d=[],e=r(a),f=e.length-1,g=0;g<=f;g++)c=g===f?this:this.clone(!0),r(e[g])[b](c),h.apply(d,c.get());return this.pushStack(d)}});var La=/^margin/,Ma=new RegExp("^("+aa+")(?!px)[a-z%]+$","i"),Na=function(b){var c=b.ownerDocument.defaultView;return c&&c.opener||(c=a),c.getComputedStyle(b)};!function(){function b(){if(i){i.style.cssText="box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%",i.innerHTML="",ra.appendChild(h);var b=a.getComputedStyle(i);c="1%"!==b.top,g="2px"===b.marginLeft,e="4px"===b.width,i.style.marginRight="50%",f="4px"===b.marginRight,ra.removeChild(h),i=null}}var c,e,f,g,h=d.createElement("div"),i=d.createElement("div");i.style&&(i.style.backgroundClip="content-box",i.cloneNode(!0).style.backgroundClip="",o.clearCloneStyle="content-box"===i.style.backgroundClip,h.style.cssText="border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute",h.appendChild(i),r.extend(o,{pixelPosition:function(){return b(),c},boxSizingReliable:function(){return b(),e},pixelMarginRight:function(){return b(),f},reliableMarginLeft:function(){return b(),g}}))}();function Oa(a,b,c){var d,e,f,g,h=a.style;return c=c||Na(a),c&&(g=c.getPropertyValue(b)||c[b],""!==g||r.contains(a.ownerDocument,a)||(g=r.style(a,b)),!o.pixelMarginRight()&&Ma.test(g)&&La.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+"":g}function Pa(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}var Qa=/^(none|table(?!-c[ea]).+)/,Ra=/^--/,Sa={position:"absolute",visibility:"hidden",display:"block"},Ta={letterSpacing:"0",fontWeight:"400"},Ua=["Webkit","Moz","ms"],Va=d.createElement("div").style;function Wa(a){if(a in Va)return a;var b=a[0].toUpperCase()+a.slice(1),c=Ua.length;while(c--)if(a=Ua[c]+b,a in Va)return a}function Xa(a){var b=r.cssProps[a];return b||(b=r.cssProps[a]=Wa(a)||a),b}function Ya(a,b,c){var d=ba.exec(b);return d?Math.max(0,d[2]-(c||0))+(d[3]||"px"):b}function Za(a,b,c,d,e){var f,g=0;for(f=c===(d?"border":"content")?4:"width"===b?1:0;f<4;f+=2)"margin"===c&&(g+=r.css(a,c+ca[f],!0,e)),d?("content"===c&&(g-=r.css(a,"padding"+ca[f],!0,e)),"margin"!==c&&(g-=r.css(a,"border"+ca[f]+"Width",!0,e))):(g+=r.css(a,"padding"+ca[f],!0,e),"padding"!==c&&(g+=r.css(a,"border"+ca[f]+"Width",!0,e)));return g}function $a(a,b,c){var d,e=Na(a),f=Oa(a,b,e),g="border-box"===r.css(a,"boxSizing",!1,e);return Ma.test(f)?f:(d=g&&(o.boxSizingReliable()||f===a.style[b]),"auto"===f&&(f=a["offset"+b[0].toUpperCase()+b.slice(1)]),f=parseFloat(f)||0,f+Za(a,b,c||(g?"border":"content"),d,e)+"px")}r.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Oa(a,"opacity");return""===c?"1":c}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=r.camelCase(b),i=Ra.test(b),j=a.style;return i||(b=Xa(h)),g=r.cssHooks[b]||r.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:j[b]:(f=typeof c,"string"===f&&(e=ba.exec(c))&&e[1]&&(c=fa(a,b,e),f="number"),null!=c&&c===c&&("number"===f&&(c+=e&&e[3]||(r.cssNumber[h]?"":"px")),o.clearCloneStyle||""!==c||0!==b.indexOf("background")||(j[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i?j.setProperty(b,c):j[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=r.camelCase(b),i=Ra.test(b);return i||(b=Xa(h)),g=r.cssHooks[b]||r.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=Oa(a,b,d)),"normal"===e&&b in Ta&&(e=Ta[b]),""===c||c?(f=parseFloat(e),c===!0||isFinite(f)?f||0:e):e}}),r.each(["height","width"],function(a,b){r.cssHooks[b]={get:function(a,c,d){if(c)return!Qa.test(r.css(a,"display"))||a.getClientRects().length&&a.getBoundingClientRect().width?$a(a,b,d):ea(a,Sa,function(){return $a(a,b,d)})},set:function(a,c,d){var e,f=d&&Na(a),g=d&&Za(a,b,d,"border-box"===r.css(a,"boxSizing",!1,f),f);return g&&(e=ba.exec(c))&&"px"!==(e[3]||"px")&&(a.style[b]=c,c=r.css(a,b)),Ya(a,c,g)}}}),r.cssHooks.marginLeft=Pa(o.reliableMarginLeft,function(a,b){if(b)return(parseFloat(Oa(a,"marginLeft"))||a.getBoundingClientRect().left-ea(a,{marginLeft:0},function(){return a.getBoundingClientRect().left}))+"px"}),r.each({margin:"",padding:"",border:"Width"},function(a,b){r.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];d<4;d++)e[a+ca[d]+b]=f[d]||f[d-2]||f[0];return e}},La.test(a)||(r.cssHooks[a+b].set=Ya)}),r.fn.extend({css:function(a,b){return T(this,function(a,b,c){var d,e,f={},g=0;if(Array.isArray(b)){for(d=Na(a),e=b.length;g<e;g++)f[b[g]]=r.css(a,b[g],!1,d);return f}return void 0!==c?r.style(a,b,c):r.css(a,b)},a,b,arguments.length>1)}});function _a(a,b,c,d,e){return new _a.prototype.init(a,b,c,d,e)}r.Tween=_a,_a.prototype={constructor:_a,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||r.easing._default,this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(r.cssNumber[c]?"":"px")},cur:function(){var a=_a.propHooks[this.prop];return a&&a.get?a.get(this):_a.propHooks._default.get(this)},run:function(a){var b,c=_a.propHooks[this.prop];return this.options.duration?this.pos=b=r.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):_a.propHooks._default.set(this),this}},_a.prototype.init.prototype=_a.prototype,_a.propHooks={_default:{get:function(a){var b;return 1!==a.elem.nodeType||null!=a.elem[a.prop]&&null==a.elem.style[a.prop]?a.elem[a.prop]:(b=r.css(a.elem,a.prop,""),b&&"auto"!==b?b:0)},set:function(a){r.fx.step[a.prop]?r.fx.step[a.prop](a):1!==a.elem.nodeType||null==a.elem.style[r.cssProps[a.prop]]&&!r.cssHooks[a.prop]?a.elem[a.prop]=a.now:r.style(a.elem,a.prop,a.now+a.unit)}}},_a.propHooks.scrollTop=_a.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},r.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2},_default:"swing"},r.fx=_a.prototype.init,r.fx.step={};var ab,bb,cb=/^(?:toggle|show|hide)$/,db=/queueHooks$/;function eb(){bb&&(d.hidden===!1&&a.requestAnimationFrame?a.requestAnimationFrame(eb):a.setTimeout(eb,r.fx.interval),r.fx.tick())}function fb(){return a.setTimeout(function(){ab=void 0}),ab=r.now()}function gb(a,b){var c,d=0,e={height:a};for(b=b?1:0;d<4;d+=2-b)c=ca[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function hb(a,b,c){for(var d,e=(kb.tweeners[b]||[]).concat(kb.tweeners["*"]),f=0,g=e.length;f<g;f++)if(d=e[f].call(c,b,a))return d}function ib(a,b,c){var d,e,f,g,h,i,j,k,l="width"in b||"height"in b,m=this,n={},o=a.style,p=a.nodeType&&da(a),q=W.get(a,"fxshow");c.queue||(g=r._queueHooks(a,"fx"),null==g.unqueued&&(g.unqueued=0,h=g.empty.fire,g.empty.fire=function(){g.unqueued||h()}),g.unqueued++,m.always(function(){m.always(function(){g.unqueued--,r.queue(a,"fx").length||g.empty.fire()})}));for(d in b)if(e=b[d],cb.test(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}n[d]=q&&q[d]||r.style(a,d)}if(i=!r.isEmptyObject(b),i||!r.isEmptyObject(n)){l&&1===a.nodeType&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=q&&q.display,null==j&&(j=W.get(a,"display")),k=r.css(a,"display"),"none"===k&&(j?k=j:(ia([a],!0),j=a.style.display||j,k=r.css(a,"display"),ia([a]))),("inline"===k||"inline-block"===k&&null!=j)&&"none"===r.css(a,"float")&&(i||(m.done(function(){o.display=j}),null==j&&(k=o.display,j="none"===k?"":k)),o.display="inline-block")),c.overflow&&(o.overflow="hidden",m.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]})),i=!1;for(d in n)i||(q?"hidden"in q&&(p=q.hidden):q=W.access(a,"fxshow",{display:j}),f&&(q.hidden=!p),p&&ia([a],!0),m.done(function(){p||ia([a]),W.remove(a,"fxshow");for(d in n)r.style(a,d,n[d])})),i=hb(p?q[d]:0,d,m),d in q||(q[d]=i.start,p&&(i.end=i.start,i.start=0))}}function jb(a,b){var c,d,e,f,g;for(c in a)if(d=r.camelCase(c),e=b[d],f=a[c],Array.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=r.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function kb(a,b,c){var d,e,f=0,g=kb.prefilters.length,h=r.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=ab||fb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;g<i;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),f<1&&i?c:(i||h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:r.extend({},b),opts:r.extend(!0,{specialEasing:{},easing:r.easing._default},c),originalProperties:b,originalOptions:c,startTime:ab||fb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=r.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;c<d;c++)j.tweens[c].run(1);return b?(h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j,b])):h.rejectWith(a,[j,b]),this}}),k=j.props;for(jb(k,j.opts.specialEasing);f<g;f++)if(d=kb.prefilters[f].call(j,a,k,j.opts))return r.isFunction(d.stop)&&(r._queueHooks(j.elem,j.opts.queue).stop=r.proxy(d.stop,d)),d;return r.map(k,hb,j),r.isFunction(j.opts.start)&&j.opts.start.call(a,j),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always),r.fx.timer(r.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j}r.Animation=r.extend(kb,{tweeners:{"*":[function(a,b){var c=this.createTween(a,b);return fa(c.elem,a,ba.exec(b),c),c}]},tweener:function(a,b){r.isFunction(a)?(b=a,a=["*"]):a=a.match(L);for(var c,d=0,e=a.length;d<e;d++)c=a[d],kb.tweeners[c]=kb.tweeners[c]||[],kb.tweeners[c].unshift(b)},prefilters:[ib],prefilter:function(a,b){b?kb.prefilters.unshift(a):kb.prefilters.push(a)}}),r.speed=function(a,b,c){var d=a&&"object"==typeof a?r.extend({},a):{complete:c||!c&&b||r.isFunction(a)&&a,duration:a,easing:c&&b||b&&!r.isFunction(b)&&b};return r.fx.off?d.duration=0:"number"!=typeof d.duration&&(d.duration in r.fx.speeds?d.duration=r.fx.speeds[d.duration]:d.duration=r.fx.speeds._default),null!=d.queue&&d.queue!==!0||(d.queue="fx"),d.old=d.complete,d.complete=function(){r.isFunction(d.old)&&d.old.call(this),d.queue&&r.dequeue(this,d.queue)},d},r.fn.extend({fadeTo:function(a,b,c,d){return this.filter(da).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=r.isEmptyObject(a),f=r.speed(b,c,d),g=function(){var b=kb(this,r.extend({},a),f);(e||W.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=r.timers,g=W.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&db.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));!b&&c||r.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=W.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=r.timers,g=d?d.length:0;for(c.finish=!0,r.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;b<g;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),r.each(["toggle","show","hide"],function(a,b){var c=r.fn[b];r.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(gb(b,!0),a,d,e)}}),r.each({slideDown:gb("show"),slideUp:gb("hide"),slideToggle:gb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){r.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),r.timers=[],r.fx.tick=function(){var a,b=0,c=r.timers;for(ab=r.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||r.fx.stop(),ab=void 0},r.fx.timer=function(a){r.timers.push(a),r.fx.start()},r.fx.interval=13,r.fx.start=function(){bb||(bb=!0,eb())},r.fx.stop=function(){bb=null},r.fx.speeds={slow:600,fast:200,_default:400},r.fn.delay=function(b,c){return b=r.fx?r.fx.speeds[b]||b:b,c=c||"fx",this.queue(c,function(c,d){var e=a.setTimeout(c,b);d.stop=function(){a.clearTimeout(e)}})},function(){var a=d.createElement("input"),b=d.createElement("select"),c=b.appendChild(d.createElement("option"));a.type="checkbox",o.checkOn=""!==a.value,o.optSelected=c.selected,a=d.createElement("input"),a.value="t",a.type="radio",o.radioValue="t"===a.value}();var lb,mb=r.expr.attrHandle;r.fn.extend({attr:function(a,b){return T(this,r.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){r.removeAttr(this,a)})}}),r.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return"undefined"==typeof a.getAttribute?r.prop(a,b,c):(1===f&&r.isXMLDoc(a)||(e=r.attrHooks[b.toLowerCase()]||(r.expr.match.bool.test(b)?lb:void 0)),void 0!==c?null===c?void r.removeAttr(a,b):e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:(a.setAttribute(b,c+""),c):e&&"get"in e&&null!==(d=e.get(a,b))?d:(d=r.find.attr(a,b),
    null==d?void 0:d))},attrHooks:{type:{set:function(a,b){if(!o.radioValue&&"radio"===b&&B(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}},removeAttr:function(a,b){var c,d=0,e=b&&b.match(L);if(e&&1===a.nodeType)while(c=e[d++])a.removeAttribute(c)}}),lb={set:function(a,b,c){return b===!1?r.removeAttr(a,c):a.setAttribute(c,c),c}},r.each(r.expr.match.bool.source.match(/\w+/g),function(a,b){var c=mb[b]||r.find.attr;mb[b]=function(a,b,d){var e,f,g=b.toLowerCase();return d||(f=mb[g],mb[g]=e,e=null!=c(a,b,d)?g:null,mb[g]=f),e}});var nb=/^(?:input|select|textarea|button)$/i,ob=/^(?:a|area)$/i;r.fn.extend({prop:function(a,b){return T(this,r.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[r.propFix[a]||a]})}}),r.extend({prop:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return 1===f&&r.isXMLDoc(a)||(b=r.propFix[b]||b,e=r.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=r.find.attr(a,"tabindex");return b?parseInt(b,10):nb.test(a.nodeName)||ob.test(a.nodeName)&&a.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),o.optSelected||(r.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null},set:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex)}}),r.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){r.propFix[this.toLowerCase()]=this});function pb(a){var b=a.match(L)||[];return b.join(" ")}function qb(a){return a.getAttribute&&a.getAttribute("class")||""}r.fn.extend({addClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).addClass(a.call(this,b,qb(this)))});if("string"==typeof a&&a){b=a.match(L)||[];while(c=this[i++])if(e=qb(c),d=1===c.nodeType&&" "+pb(e)+" "){g=0;while(f=b[g++])d.indexOf(" "+f+" ")<0&&(d+=f+" ");h=pb(d),e!==h&&c.setAttribute("class",h)}}return this},removeClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).removeClass(a.call(this,b,qb(this)))});if(!arguments.length)return this.attr("class","");if("string"==typeof a&&a){b=a.match(L)||[];while(c=this[i++])if(e=qb(c),d=1===c.nodeType&&" "+pb(e)+" "){g=0;while(f=b[g++])while(d.indexOf(" "+f+" ")>-1)d=d.replace(" "+f+" "," ");h=pb(d),e!==h&&c.setAttribute("class",h)}}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):r.isFunction(a)?this.each(function(c){r(this).toggleClass(a.call(this,c,qb(this),b),b)}):this.each(function(){var b,d,e,f;if("string"===c){d=0,e=r(this),f=a.match(L)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else void 0!==a&&"boolean"!==c||(b=qb(this),b&&W.set(this,"__className__",b),this.setAttribute&&this.setAttribute("class",b||a===!1?"":W.get(this,"__className__")||""))})},hasClass:function(a){var b,c,d=0;b=" "+a+" ";while(c=this[d++])if(1===c.nodeType&&(" "+pb(qb(c))+" ").indexOf(b)>-1)return!0;return!1}});var rb=/\r/g;r.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=r.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,r(this).val()):a,null==e?e="":"number"==typeof e?e+="":Array.isArray(e)&&(e=r.map(e,function(a){return null==a?"":a+""})),b=r.valHooks[this.type]||r.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=r.valHooks[e.type]||r.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(rb,""):null==c?"":c)}}}),r.extend({valHooks:{option:{get:function(a){var b=r.find.attr(a,"value");return null!=b?b:pb(r.text(a))}},select:{get:function(a){var b,c,d,e=a.options,f=a.selectedIndex,g="select-one"===a.type,h=g?null:[],i=g?f+1:e.length;for(d=f<0?i:g?f:0;d<i;d++)if(c=e[d],(c.selected||d===f)&&!c.disabled&&(!c.parentNode.disabled||!B(c.parentNode,"optgroup"))){if(b=r(c).val(),g)return b;h.push(b)}return h},set:function(a,b){var c,d,e=a.options,f=r.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=r.inArray(r.valHooks.option.get(d),f)>-1)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),r.each(["radio","checkbox"],function(){r.valHooks[this]={set:function(a,b){if(Array.isArray(b))return a.checked=r.inArray(r(a).val(),b)>-1}},o.checkOn||(r.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var sb=/^(?:focusinfocus|focusoutblur)$/;r.extend(r.event,{trigger:function(b,c,e,f){var g,h,i,j,k,m,n,o=[e||d],p=l.call(b,"type")?b.type:b,q=l.call(b,"namespace")?b.namespace.split("."):[];if(h=i=e=e||d,3!==e.nodeType&&8!==e.nodeType&&!sb.test(p+r.event.triggered)&&(p.indexOf(".")>-1&&(q=p.split("."),p=q.shift(),q.sort()),k=p.indexOf(":")<0&&"on"+p,b=b[r.expando]?b:new r.Event(p,"object"==typeof b&&b),b.isTrigger=f?2:3,b.namespace=q.join("."),b.rnamespace=b.namespace?new RegExp("(^|\\.)"+q.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=e),c=null==c?[b]:r.makeArray(c,[b]),n=r.event.special[p]||{},f||!n.trigger||n.trigger.apply(e,c)!==!1)){if(!f&&!n.noBubble&&!r.isWindow(e)){for(j=n.delegateType||p,sb.test(j+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),i=h;i===(e.ownerDocument||d)&&o.push(i.defaultView||i.parentWindow||a)}g=0;while((h=o[g++])&&!b.isPropagationStopped())b.type=g>1?j:n.bindType||p,m=(W.get(h,"events")||{})[b.type]&&W.get(h,"handle"),m&&m.apply(h,c),m=k&&h[k],m&&m.apply&&U(h)&&(b.result=m.apply(h,c),b.result===!1&&b.preventDefault());return b.type=p,f||b.isDefaultPrevented()||n._default&&n._default.apply(o.pop(),c)!==!1||!U(e)||k&&r.isFunction(e[p])&&!r.isWindow(e)&&(i=e[k],i&&(e[k]=null),r.event.triggered=p,e[p](),r.event.triggered=void 0,i&&(e[k]=i)),b.result}},simulate:function(a,b,c){var d=r.extend(new r.Event,c,{type:a,isSimulated:!0});r.event.trigger(d,null,b)}}),r.fn.extend({trigger:function(a,b){return this.each(function(){r.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];if(c)return r.event.trigger(a,b,c,!0)}}),r.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(a,b){r.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),r.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),o.focusin="onfocusin"in a,o.focusin||r.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){r.event.simulate(b,a.target,r.event.fix(a))};r.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=W.access(d,b);e||d.addEventListener(a,c,!0),W.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=W.access(d,b)-1;e?W.access(d,b,e):(d.removeEventListener(a,c,!0),W.remove(d,b))}}});var tb=a.location,ub=r.now(),vb=/\?/;r.parseXML=function(b){var c;if(!b||"string"!=typeof b)return null;try{c=(new a.DOMParser).parseFromString(b,"text/xml")}catch(d){c=void 0}return c&&!c.getElementsByTagName("parsererror").length||r.error("Invalid XML: "+b),c};var wb=/\[\]$/,xb=/\r?\n/g,yb=/^(?:submit|button|image|reset|file)$/i,zb=/^(?:input|select|textarea|keygen)/i;function Ab(a,b,c,d){var e;if(Array.isArray(b))r.each(b,function(b,e){c||wb.test(a)?d(a,e):Ab(a+"["+("object"==typeof e&&null!=e?b:"")+"]",e,c,d)});else if(c||"object"!==r.type(b))d(a,b);else for(e in b)Ab(a+"["+e+"]",b[e],c,d)}r.param=function(a,b){var c,d=[],e=function(a,b){var c=r.isFunction(b)?b():b;d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(null==c?"":c)};if(Array.isArray(a)||a.jquery&&!r.isPlainObject(a))r.each(a,function(){e(this.name,this.value)});else for(c in a)Ab(c,a[c],b,e);return d.join("&")},r.fn.extend({serialize:function(){return r.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=r.prop(this,"elements");return a?r.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!r(this).is(":disabled")&&zb.test(this.nodeName)&&!yb.test(a)&&(this.checked||!ja.test(a))}).map(function(a,b){var c=r(this).val();return null==c?null:Array.isArray(c)?r.map(c,function(a){return{name:b.name,value:a.replace(xb,"\r\n")}}):{name:b.name,value:c.replace(xb,"\r\n")}}).get()}});var Bb=/%20/g,Cb=/#.*$/,Db=/([?&])_=[^&]*/,Eb=/^(.*?):[ \t]*([^\r\n]*)$/gm,Fb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Gb=/^(?:GET|HEAD)$/,Hb=/^\/\//,Ib={},Jb={},Kb="*/".concat("*"),Lb=d.createElement("a");Lb.href=tb.href;function Mb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(L)||[];if(r.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Nb(a,b,c,d){var e={},f=a===Jb;function g(h){var i;return e[h]=!0,r.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Ob(a,b){var c,d,e=r.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&r.extend(!0,a,d),a}function Pb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}if(f)return f!==i[0]&&i.unshift(f),c[f]}function Qb(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}r.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:tb.href,type:"GET",isLocal:Fb.test(tb.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Kb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":r.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Ob(Ob(a,r.ajaxSettings),b):Ob(r.ajaxSettings,a)},ajaxPrefilter:Mb(Ib),ajaxTransport:Mb(Jb),ajax:function(b,c){"object"==typeof b&&(c=b,b=void 0),c=c||{};var e,f,g,h,i,j,k,l,m,n,o=r.ajaxSetup({},c),p=o.context||o,q=o.context&&(p.nodeType||p.jquery)?r(p):r.event,s=r.Deferred(),t=r.Callbacks("once memory"),u=o.statusCode||{},v={},w={},x="canceled",y={readyState:0,getResponseHeader:function(a){var b;if(k){if(!h){h={};while(b=Eb.exec(g))h[b[1].toLowerCase()]=b[2]}b=h[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return k?g:null},setRequestHeader:function(a,b){return null==k&&(a=w[a.toLowerCase()]=w[a.toLowerCase()]||a,v[a]=b),this},overrideMimeType:function(a){return null==k&&(o.mimeType=a),this},statusCode:function(a){var b;if(a)if(k)y.always(a[y.status]);else for(b in a)u[b]=[u[b],a[b]];return this},abort:function(a){var b=a||x;return e&&e.abort(b),A(0,b),this}};if(s.promise(y),o.url=((b||o.url||tb.href)+"").replace(Hb,tb.protocol+"//"),o.type=c.method||c.type||o.method||o.type,o.dataTypes=(o.dataType||"*").toLowerCase().match(L)||[""],null==o.crossDomain){j=d.createElement("a");try{j.href=o.url,j.href=j.href,o.crossDomain=Lb.protocol+"//"+Lb.host!=j.protocol+"//"+j.host}catch(z){o.crossDomain=!0}}if(o.data&&o.processData&&"string"!=typeof o.data&&(o.data=r.param(o.data,o.traditional)),Nb(Ib,o,c,y),k)return y;l=r.event&&o.global,l&&0===r.active++&&r.event.trigger("ajaxStart"),o.type=o.type.toUpperCase(),o.hasContent=!Gb.test(o.type),f=o.url.replace(Cb,""),o.hasContent?o.data&&o.processData&&0===(o.contentType||"").indexOf("application/x-www-form-urlencoded")&&(o.data=o.data.replace(Bb,"+")):(n=o.url.slice(f.length),o.data&&(f+=(vb.test(f)?"&":"?")+o.data,delete o.data),o.cache===!1&&(f=f.replace(Db,"$1"),n=(vb.test(f)?"&":"?")+"_="+ub++ +n),o.url=f+n),o.ifModified&&(r.lastModified[f]&&y.setRequestHeader("If-Modified-Since",r.lastModified[f]),r.etag[f]&&y.setRequestHeader("If-None-Match",r.etag[f])),(o.data&&o.hasContent&&o.contentType!==!1||c.contentType)&&y.setRequestHeader("Content-Type",o.contentType),y.setRequestHeader("Accept",o.dataTypes[0]&&o.accepts[o.dataTypes[0]]?o.accepts[o.dataTypes[0]]+("*"!==o.dataTypes[0]?", "+Kb+"; q=0.01":""):o.accepts["*"]);for(m in o.headers)y.setRequestHeader(m,o.headers[m]);if(o.beforeSend&&(o.beforeSend.call(p,y,o)===!1||k))return y.abort();if(x="abort",t.add(o.complete),y.done(o.success),y.fail(o.error),e=Nb(Jb,o,c,y)){if(y.readyState=1,l&&q.trigger("ajaxSend",[y,o]),k)return y;o.async&&o.timeout>0&&(i=a.setTimeout(function(){y.abort("timeout")},o.timeout));try{k=!1,e.send(v,A)}catch(z){if(k)throw z;A(-1,z)}}else A(-1,"No Transport");function A(b,c,d,h){var j,m,n,v,w,x=c;k||(k=!0,i&&a.clearTimeout(i),e=void 0,g=h||"",y.readyState=b>0?4:0,j=b>=200&&b<300||304===b,d&&(v=Pb(o,y,d)),v=Qb(o,v,y,j),j?(o.ifModified&&(w=y.getResponseHeader("Last-Modified"),w&&(r.lastModified[f]=w),w=y.getResponseHeader("etag"),w&&(r.etag[f]=w)),204===b||"HEAD"===o.type?x="nocontent":304===b?x="notmodified":(x=v.state,m=v.data,n=v.error,j=!n)):(n=x,!b&&x||(x="error",b<0&&(b=0))),y.status=b,y.statusText=(c||x)+"",j?s.resolveWith(p,[m,x,y]):s.rejectWith(p,[y,x,n]),y.statusCode(u),u=void 0,l&&q.trigger(j?"ajaxSuccess":"ajaxError",[y,o,j?m:n]),t.fireWith(p,[y,x]),l&&(q.trigger("ajaxComplete",[y,o]),--r.active||r.event.trigger("ajaxStop")))}return y},getJSON:function(a,b,c){return r.get(a,b,c,"json")},getScript:function(a,b){return r.get(a,void 0,b,"script")}}),r.each(["get","post"],function(a,b){r[b]=function(a,c,d,e){return r.isFunction(c)&&(e=e||d,d=c,c=void 0),r.ajax(r.extend({url:a,type:b,dataType:e,data:c,success:d},r.isPlainObject(a)&&a))}}),r._evalUrl=function(a){return r.ajax({url:a,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,"throws":!0})},r.fn.extend({wrapAll:function(a){var b;return this[0]&&(r.isFunction(a)&&(a=a.call(this[0])),b=r(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this},wrapInner:function(a){return r.isFunction(a)?this.each(function(b){r(this).wrapInner(a.call(this,b))}):this.each(function(){var b=r(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=r.isFunction(a);return this.each(function(c){r(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(a){return this.parent(a).not("body").each(function(){r(this).replaceWith(this.childNodes)}),this}}),r.expr.pseudos.hidden=function(a){return!r.expr.pseudos.visible(a)},r.expr.pseudos.visible=function(a){return!!(a.offsetWidth||a.offsetHeight||a.getClientRects().length)},r.ajaxSettings.xhr=function(){try{return new a.XMLHttpRequest}catch(b){}};var Rb={0:200,1223:204},Sb=r.ajaxSettings.xhr();o.cors=!!Sb&&"withCredentials"in Sb,o.ajax=Sb=!!Sb,r.ajaxTransport(function(b){var c,d;if(o.cors||Sb&&!b.crossDomain)return{send:function(e,f){var g,h=b.xhr();if(h.open(b.type,b.url,b.async,b.username,b.password),b.xhrFields)for(g in b.xhrFields)h[g]=b.xhrFields[g];b.mimeType&&h.overrideMimeType&&h.overrideMimeType(b.mimeType),b.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest");for(g in e)h.setRequestHeader(g,e[g]);c=function(a){return function(){c&&(c=d=h.onload=h.onerror=h.onabort=h.onreadystatechange=null,"abort"===a?h.abort():"error"===a?"number"!=typeof h.status?f(0,"error"):f(h.status,h.statusText):f(Rb[h.status]||h.status,h.statusText,"text"!==(h.responseType||"text")||"string"!=typeof h.responseText?{binary:h.response}:{text:h.responseText},h.getAllResponseHeaders()))}},h.onload=c(),d=h.onerror=c("error"),void 0!==h.onabort?h.onabort=d:h.onreadystatechange=function(){4===h.readyState&&a.setTimeout(function(){c&&d()})},c=c("abort");try{h.send(b.hasContent&&b.data||null)}catch(i){if(c)throw i}},abort:function(){c&&c()}}}),r.ajaxPrefilter(function(a){a.crossDomain&&(a.contents.script=!1)}),r.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(a){return r.globalEval(a),a}}}),r.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),r.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(e,f){b=r("<script>").prop({charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&f("error"===a.type?404:200,a.type)}),d.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Tb=[],Ub=/(=)\?(?=&|$)|\?\?/;r.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Tb.pop()||r.expando+"_"+ub++;return this[a]=!0,a}}),r.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Ub.test(b.url)?"url":"string"==typeof b.data&&0===(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Ub.test(b.data)&&"data");if(h||"jsonp"===b.dataTypes[0])return e=b.jsonpCallback=r.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Ub,"$1"+e):b.jsonp!==!1&&(b.url+=(vb.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||r.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){void 0===f?r(a).removeProp(e):a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Tb.push(e)),g&&r.isFunction(f)&&f(g[0]),g=f=void 0}),"script"}),o.createHTMLDocument=function(){var a=d.implementation.createHTMLDocument("").body;return a.innerHTML="<form></form><form></form>",2===a.childNodes.length}(),r.parseHTML=function(a,b,c){if("string"!=typeof a)return[];"boolean"==typeof b&&(c=b,b=!1);var e,f,g;return b||(o.createHTMLDocument?(b=d.implementation.createHTMLDocument(""),e=b.createElement("base"),e.href=d.location.href,b.head.appendChild(e)):b=d),f=C.exec(a),g=!c&&[],f?[b.createElement(f[1])]:(f=qa([a],b,g),g&&g.length&&r(g).remove(),r.merge([],f.childNodes))},r.fn.load=function(a,b,c){var d,e,f,g=this,h=a.indexOf(" ");return h>-1&&(d=pb(a.slice(h)),a=a.slice(0,h)),r.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&r.ajax({url:a,type:e||"GET",dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?r("<div>").append(r.parseHTML(a)).find(d):a)}).always(c&&function(a,b){g.each(function(){c.apply(this,f||[a.responseText,b,a])})}),this},r.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){r.fn[b]=function(a){return this.on(b,a)}}),r.expr.pseudos.animated=function(a){return r.grep(r.timers,function(b){return a===b.elem}).length},r.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=r.css(a,"position"),l=r(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=r.css(a,"top"),i=r.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),r.isFunction(b)&&(b=b.call(a,c,r.extend({},h))),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},r.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){r.offset.setOffset(this,a,b)});var b,c,d,e,f=this[0];if(f)return f.getClientRects().length?(d=f.getBoundingClientRect(),b=f.ownerDocument,c=b.documentElement,e=b.defaultView,{top:d.top+e.pageYOffset-c.clientTop,left:d.left+e.pageXOffset-c.clientLeft}):{top:0,left:0}},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===r.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),B(a[0],"html")||(d=a.offset()),d={top:d.top+r.css(a[0],"borderTopWidth",!0),left:d.left+r.css(a[0],"borderLeftWidth",!0)}),{top:b.top-d.top-r.css(c,"marginTop",!0),left:b.left-d.left-r.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent;while(a&&"static"===r.css(a,"position"))a=a.offsetParent;return a||ra})}}),r.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c="pageYOffset"===b;r.fn[a]=function(d){return T(this,function(a,d,e){var f;return r.isWindow(a)?f=a:9===a.nodeType&&(f=a.defaultView),void 0===e?f?f[b]:a[d]:void(f?f.scrollTo(c?f.pageXOffset:e,c?e:f.pageYOffset):a[d]=e)},a,d,arguments.length)}}),r.each(["top","left"],function(a,b){r.cssHooks[b]=Pa(o.pixelPosition,function(a,c){if(c)return c=Oa(a,b),Ma.test(c)?r(a).position()[b]+"px":c})}),r.each({Height:"height",Width:"width"},function(a,b){r.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){r.fn[d]=function(e,f){var g=arguments.length&&(c||"boolean"!=typeof e),h=c||(e===!0||f===!0?"margin":"border");return T(this,function(b,c,e){var f;return r.isWindow(b)?0===d.indexOf("outer")?b["inner"+a]:b.document.documentElement["client"+a]:9===b.nodeType?(f=b.documentElement,Math.max(b.body["scroll"+a],f["scroll"+a],b.body["offset"+a],f["offset"+a],f["client"+a])):void 0===e?r.css(b,c,h):r.style(b,c,e,h)},b,g?e:void 0,g)}})}),r.fn.extend({bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}}),r.holdReady=function(a){a?r.readyWait++:r.ready(!0)},r.isArray=Array.isArray,r.parseJSON=JSON.parse,r.nodeName=B,"function"==typeof define&&define.amd&&define("jquery",[],function(){return r});var Vb=a.jQuery,Wb=a.$;return r.noConflict=function(b){return a.$===r&&(a.$=Wb),b&&a.jQuery===r&&(a.jQuery=Vb),r},b||(a.jQuery=a.$=r),r});
    
    /*! jQuery UI - v1.12.1 - 2016-09-14
    * http://jqueryui.com
    * Includes: widget.js, position.js, data.js, disable-selection.js, effect.js, effects/effect-blind.js, effects/effect-bounce.js, effects/effect-clip.js, effects/effect-drop.js, effects/effect-explode.js, effects/effect-fade.js, effects/effect-fold.js, effects/effect-highlight.js, effects/effect-puff.js, effects/effect-pulsate.js, effects/effect-scale.js, effects/effect-shake.js, effects/effect-size.js, effects/effect-slide.js, effects/effect-transfer.js, focusable.js, form-reset-mixin.js, jquery-1-7.js, keycode.js, labels.js, scroll-parent.js, tabbable.js, unique-id.js, widgets/accordion.js, widgets/autocomplete.js, widgets/button.js, widgets/checkboxradio.js, widgets/controlgroup.js, widgets/datepicker.js, widgets/dialog.js, widgets/draggable.js, widgets/droppable.js, widgets/menu.js, widgets/mouse.js, widgets/progressbar.js, widgets/resizable.js, widgets/selectable.js, widgets/selectmenu.js, widgets/slider.js, widgets/sortable.js, widgets/spinner.js, widgets/tabs.js, widgets/tooltip.js
    * Copyright jQuery Foundation and other contributors; Licensed MIT */
    
    (function( factory ) {
        if ( typeof define === "function" && define.amd ) {
    
            // AMD. Register as an anonymous module.
            define([ "jquery" ], factory );
        } else {
    
            // Browser globals
            factory( jQuery );
        }
    }(function( $ ) {
    
    $.ui = $.ui || {};
    
    var version = $.ui.version = "1.12.1";
    
    
    /*!
     * jQuery UI Widget 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Widget
    //>>group: Core
    //>>description: Provides a factory for creating stateful widgets with a common API.
    //>>docs: http://api.jqueryui.com/jQuery.widget/
    //>>demos: http://jqueryui.com/widget/
    
    
    
    var widgetUuid = 0;
    var widgetSlice = Array.prototype.slice;
    
    $.cleanData = ( function( orig ) {
        return function( elems ) {
            var events, elem, i;
            for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {
                try {
    
                    // Only trigger remove when necessary to save time
                    events = $._data( elem, "events" );
                    if ( events && events.remove ) {
                        $( elem ).triggerHandler( "remove" );
                    }
    
                // Http://bugs.jquery.com/ticket/8235
                } catch ( e ) {}
            }
            orig( elems );
        };
    } )( $.cleanData );
    
    $.widget = function( name, base, prototype ) {
        var existingConstructor, constructor, basePrototype;
    
        // ProxiedPrototype allows the provided prototype to remain unmodified
        // so that it can be used as a mixin for multiple widgets (#8876)
        var proxiedPrototype = {};
    
        var namespace = name.split( "." )[ 0 ];
        name = name.split( "." )[ 1 ];
        var fullName = namespace + "-" + name;
    
        if ( !prototype ) {
            prototype = base;
            base = $.Widget;
        }
    
        if ( $.isArray( prototype ) ) {
            prototype = $.extend.apply( null, [ {} ].concat( prototype ) );
        }
    
        // Create selector for plugin
        $.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
            return !!$.data( elem, fullName );
        };
    
        $[ namespace ] = $[ namespace ] || {};
        existingConstructor = $[ namespace ][ name ];
        constructor = $[ namespace ][ name ] = function( options, element ) {
    
            // Allow instantiation without "new" keyword
            if ( !this._createWidget ) {
                return new constructor( options, element );
            }
    
            // Allow instantiation without initializing for simple inheritance
            // must use "new" keyword (the code above always passes args)
            if ( arguments.length ) {
                this._createWidget( options, element );
            }
        };
    
        // Extend with the existing constructor to carry over any static properties
        $.extend( constructor, existingConstructor, {
            version: prototype.version,
    
            // Copy the object used to create the prototype in case we need to
            // redefine the widget later
            _proto: $.extend( {}, prototype ),
    
            // Track widgets that inherit from this widget in case this widget is
            // redefined after a widget inherits from it
            _childConstructors: []
        } );
    
        basePrototype = new base();
    
        // We need to make the options hash a property directly on the new instance
        // otherwise we'll modify the options hash on the prototype that we're
        // inheriting from
        basePrototype.options = $.widget.extend( {}, basePrototype.options );
        $.each( prototype, function( prop, value ) {
            if ( !$.isFunction( value ) ) {
                proxiedPrototype[ prop ] = value;
                return;
            }
            proxiedPrototype[ prop ] = ( function() {
                function _super() {
                    return base.prototype[ prop ].apply( this, arguments );
                }
    
                function _superApply( args ) {
                    return base.prototype[ prop ].apply( this, args );
                }
    
                return function() {
                    var __super = this._super;
                    var __superApply = this._superApply;
                    var returnValue;
    
                    this._super = _super;
                    this._superApply = _superApply;
    
                    returnValue = value.apply( this, arguments );
    
                    this._super = __super;
                    this._superApply = __superApply;
    
                    return returnValue;
                };
            } )();
        } );
        constructor.prototype = $.widget.extend( basePrototype, {
    
            // TODO: remove support for widgetEventPrefix
            // always use the name + a colon as the prefix, e.g., draggable:start
            // don't prefix for widgets that aren't DOM-based
            widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name
        }, proxiedPrototype, {
            constructor: constructor,
            namespace: namespace,
            widgetName: name,
            widgetFullName: fullName
        } );
    
        // If this widget is being redefined then we need to find all widgets that
        // are inheriting from it and redefine all of them so that they inherit from
        // the new version of this widget. We're essentially trying to replace one
        // level in the prototype chain.
        if ( existingConstructor ) {
            $.each( existingConstructor._childConstructors, function( i, child ) {
                var childPrototype = child.prototype;
    
                // Redefine the child widget using the same prototype that was
                // originally used, but inherit from the new version of the base
                $.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,
                    child._proto );
            } );
    
            // Remove the list of existing child constructors from the old constructor
            // so the old child constructors can be garbage collected
            delete existingConstructor._childConstructors;
        } else {
            base._childConstructors.push( constructor );
        }
    
        $.widget.bridge( name, constructor );
    
        return constructor;
    };
    
    $.widget.extend = function( target ) {
        var input = widgetSlice.call( arguments, 1 );
        var inputIndex = 0;
        var inputLength = input.length;
        var key;
        var value;
    
        for ( ; inputIndex < inputLength; inputIndex++ ) {
            for ( key in input[ inputIndex ] ) {
                value = input[ inputIndex ][ key ];
                if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
    
                    // Clone objects
                    if ( $.isPlainObject( value ) ) {
                        target[ key ] = $.isPlainObject( target[ key ] ) ?
                            $.widget.extend( {}, target[ key ], value ) :
    
                            // Don't extend strings, arrays, etc. with objects
                            $.widget.extend( {}, value );
    
                    // Copy everything else by reference
                    } else {
                        target[ key ] = value;
                    }
                }
            }
        }
        return target;
    };
    
    $.widget.bridge = function( name, object ) {
        var fullName = object.prototype.widgetFullName || name;
        $.fn[ name ] = function( options ) {
            var isMethodCall = typeof options === "string";
            var args = widgetSlice.call( arguments, 1 );
            var returnValue = this;
    
            if ( isMethodCall ) {
    
                // If this is an empty collection, we need to have the instance method
                // return undefined instead of the jQuery instance
                if ( !this.length && options === "instance" ) {
                    returnValue = undefined;
                } else {
                    this.each( function() {
                        var methodValue;
                        var instance = $.data( this, fullName );
    
                        if ( options === "instance" ) {
                            returnValue = instance;
                            return false;
                        }
    
                        if ( !instance ) {
                            return $.error( "cannot call methods on " + name +
                                " prior to initialization; " +
                                "attempted to call method '" + options + "'" );
                        }
    
                        if ( !$.isFunction( instance[ options ] ) || options.charAt( 0 ) === "_" ) {
                            return $.error( "no such method '" + options + "' for " + name +
                                " widget instance" );
                        }
    
                        methodValue = instance[ options ].apply( instance, args );
    
                        if ( methodValue !== instance && methodValue !== undefined ) {
                            returnValue = methodValue && methodValue.jquery ?
                                returnValue.pushStack( methodValue.get() ) :
                                methodValue;
                            return false;
                        }
                    } );
                }
            } else {
    
                // Allow multiple hashes to be passed on init
                if ( args.length ) {
                    options = $.widget.extend.apply( null, [ options ].concat( args ) );
                }
    
                this.each( function() {
                    var instance = $.data( this, fullName );
                    if ( instance ) {
                        instance.option( options || {} );
                        if ( instance._init ) {
                            instance._init();
                        }
                    } else {
                        $.data( this, fullName, new object( options, this ) );
                    }
                } );
            }
    
            return returnValue;
        };
    };
    
    $.Widget = function( /* options, element */ ) {};
    $.Widget._childConstructors = [];
    
    $.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
    
        options: {
            classes: {},
            disabled: false,
    
            // Callbacks
            create: null
        },
    
        _createWidget: function( options, element ) {
            element = $( element || this.defaultElement || this )[ 0 ];
            this.element = $( element );
            this.uuid = widgetUuid++;
            this.eventNamespace = "." + this.widgetName + this.uuid;
    
            this.bindings = $();
            this.hoverable = $();
            this.focusable = $();
            this.classesElementLookup = {};
    
            if ( element !== this ) {
                $.data( element, this.widgetFullName, this );
                this._on( true, this.element, {
                    remove: function( event ) {
                        if ( event.target === element ) {
                            this.destroy();
                        }
                    }
                } );
                this.document = $( element.style ?
    
                    // Element within the document
                    element.ownerDocument :
    
                    // Element is window or document
                    element.document || element );
                this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );
            }
    
            this.options = $.widget.extend( {},
                this.options,
                this._getCreateOptions(),
                options );
    
            this._create();
    
            if ( this.options.disabled ) {
                this._setOptionDisabled( this.options.disabled );
            }
    
            this._trigger( "create", null, this._getCreateEventData() );
            this._init();
        },
    
        _getCreateOptions: function() {
            return {};
        },
    
        _getCreateEventData: $.noop,
    
        _create: $.noop,
    
        _init: $.noop,
    
        destroy: function() {
            var that = this;
    
            this._destroy();
            $.each( this.classesElementLookup, function( key, value ) {
                that._removeClass( value, key );
            } );
    
            // We can probably remove the unbind calls in 2.0
            // all event bindings should go through this._on()
            this.element
                .off( this.eventNamespace )
                .removeData( this.widgetFullName );
            this.widget()
                .off( this.eventNamespace )
                .removeAttr( "aria-disabled" );
    
            // Clean up events and states
            this.bindings.off( this.eventNamespace );
        },
    
        _destroy: $.noop,
    
        widget: function() {
            return this.element;
        },
    
        option: function( key, value ) {
            var options = key;
            var parts;
            var curOption;
            var i;
    
            if ( arguments.length === 0 ) {
    
                // Don't return a reference to the internal hash
                return $.widget.extend( {}, this.options );
            }
    
            if ( typeof key === "string" ) {
    
                // Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
                options = {};
                parts = key.split( "." );
                key = parts.shift();
                if ( parts.length ) {
                    curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
                    for ( i = 0; i < parts.length - 1; i++ ) {
                        curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
                        curOption = curOption[ parts[ i ] ];
                    }
                    key = parts.pop();
                    if ( arguments.length === 1 ) {
                        return curOption[ key ] === undefined ? null : curOption[ key ];
                    }
                    curOption[ key ] = value;
                } else {
                    if ( arguments.length === 1 ) {
                        return this.options[ key ] === undefined ? null : this.options[ key ];
                    }
                    options[ key ] = value;
                }
            }
    
            this._setOptions( options );
    
            return this;
        },
    
        _setOptions: function( options ) {
            var key;
    
            for ( key in options ) {
                this._setOption( key, options[ key ] );
            }
    
            return this;
        },
    
        _setOption: function( key, value ) {
            if ( key === "classes" ) {
                this._setOptionClasses( value );
            }
    
            this.options[ key ] = value;
    
            if ( key === "disabled" ) {
                this._setOptionDisabled( value );
            }
    
            return this;
        },
    
        _setOptionClasses: function( value ) {
            var classKey, elements, currentElements;
    
            for ( classKey in value ) {
                currentElements = this.classesElementLookup[ classKey ];
                if ( value[ classKey ] === this.options.classes[ classKey ] ||
                        !currentElements ||
                        !currentElements.length ) {
                    continue;
                }
    
                // We are doing this to create a new jQuery object because the _removeClass() call
                // on the next line is going to destroy the reference to the current elements being
                // tracked. We need to save a copy of this collection so that we can add the new classes
                // below.
                elements = $( currentElements.get() );
                this._removeClass( currentElements, classKey );
    
                // We don't use _addClass() here, because that uses this.options.classes
                // for generating the string of classes. We want to use the value passed in from
                // _setOption(), this is the new value of the classes option which was passed to
                // _setOption(). We pass this value directly to _classes().
                elements.addClass( this._classes( {
                    element: elements,
                    keys: classKey,
                    classes: value,
                    add: true
                } ) );
            }
        },
    
        _setOptionDisabled: function( value ) {
            this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );
    
            // If the widget is becoming disabled, then nothing is interactive
            if ( value ) {
                this._removeClass( this.hoverable, null, "ui-state-hover" );
                this._removeClass( this.focusable, null, "ui-state-focus" );
            }
        },
    
        enable: function() {
            return this._setOptions( { disabled: false } );
        },
    
        disable: function() {
            return this._setOptions( { disabled: true } );
        },
    
        _classes: function( options ) {
            var full = [];
            var that = this;
    
            options = $.extend( {
                element: this.element,
                classes: this.options.classes || {}
            }, options );
    
            function processClassString( classes, checkOption ) {
                var current, i;
                for ( i = 0; i < classes.length; i++ ) {
                    current = that.classesElementLookup[ classes[ i ] ] || $();
                    if ( options.add ) {
                        current = $( $.unique( current.get().concat( options.element.get() ) ) );
                    } else {
                        current = $( current.not( options.element ).get() );
                    }
                    that.classesElementLookup[ classes[ i ] ] = current;
                    full.push( classes[ i ] );
                    if ( checkOption && options.classes[ classes[ i ] ] ) {
                        full.push( options.classes[ classes[ i ] ] );
                    }
                }
            }
    
            this._on( options.element, {
                "remove": "_untrackClassesElement"
            } );
    
            if ( options.keys ) {
                processClassString( options.keys.match( /\S+/g ) || [], true );
            }
            if ( options.extra ) {
                processClassString( options.extra.match( /\S+/g ) || [] );
            }
    
            return full.join( " " );
        },
    
        _untrackClassesElement: function( event ) {
            var that = this;
            $.each( that.classesElementLookup, function( key, value ) {
                if ( $.inArray( event.target, value ) !== -1 ) {
                    that.classesElementLookup[ key ] = $( value.not( event.target ).get() );
                }
            } );
        },
    
        _removeClass: function( element, keys, extra ) {
            return this._toggleClass( element, keys, extra, false );
        },
    
        _addClass: function( element, keys, extra ) {
            return this._toggleClass( element, keys, extra, true );
        },
    
        _toggleClass: function( element, keys, extra, add ) {
            add = ( typeof add === "boolean" ) ? add : extra;
            var shift = ( typeof element === "string" || element === null ),
                options = {
                    extra: shift ? keys : extra,
                    keys: shift ? element : keys,
                    element: shift ? this.element : element,
                    add: add
                };
            options.element.toggleClass( this._classes( options ), add );
            return this;
        },
    
        _on: function( suppressDisabledCheck, element, handlers ) {
            var delegateElement;
            var instance = this;
    
            // No suppressDisabledCheck flag, shuffle arguments
            if ( typeof suppressDisabledCheck !== "boolean" ) {
                handlers = element;
                element = suppressDisabledCheck;
                suppressDisabledCheck = false;
            }
    
            // No element argument, shuffle and use this.element
            if ( !handlers ) {
                handlers = element;
                element = this.element;
                delegateElement = this.widget();
            } else {
                element = delegateElement = $( element );
                this.bindings = this.bindings.add( element );
            }
    
            $.each( handlers, function( event, handler ) {
                function handlerProxy() {
    
                    // Allow widgets to customize the disabled handling
                    // - disabled as an array instead of boolean
                    // - disabled class as method for disabling individual parts
                    if ( !suppressDisabledCheck &&
                            ( instance.options.disabled === true ||
                            $( this ).hasClass( "ui-state-disabled" ) ) ) {
                        return;
                    }
                    return ( typeof handler === "string" ? instance[ handler ] : handler )
                        .apply( instance, arguments );
                }
    
                // Copy the guid so direct unbinding works
                if ( typeof handler !== "string" ) {
                    handlerProxy.guid = handler.guid =
                        handler.guid || handlerProxy.guid || $.guid++;
                }
    
                var match = event.match( /^([\w:-]*)\s*(.*)$/ );
                var eventName = match[ 1 ] + instance.eventNamespace;
                var selector = match[ 2 ];
    
                if ( selector ) {
                    delegateElement.on( eventName, selector, handlerProxy );
                } else {
                    element.on( eventName, handlerProxy );
                }
            } );
        },
    
        _off: function( element, eventName ) {
            eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +
                this.eventNamespace;
            element.off( eventName ).off( eventName );
    
            // Clear the stack to avoid memory leaks (#10056)
            this.bindings = $( this.bindings.not( element ).get() );
            this.focusable = $( this.focusable.not( element ).get() );
            this.hoverable = $( this.hoverable.not( element ).get() );
        },
    
        _delay: function( handler, delay ) {
            function handlerProxy() {
                return ( typeof handler === "string" ? instance[ handler ] : handler )
                    .apply( instance, arguments );
            }
            var instance = this;
            return setTimeout( handlerProxy, delay || 0 );
        },
    
        _hoverable: function( element ) {
            this.hoverable = this.hoverable.add( element );
            this._on( element, {
                mouseenter: function( event ) {
                    this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
                },
                mouseleave: function( event ) {
                    this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
                }
            } );
        },
    
        _focusable: function( element ) {
            this.focusable = this.focusable.add( element );
            this._on( element, {
                focusin: function( event ) {
                    this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
                },
                focusout: function( event ) {
                    this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
                }
            } );
        },
    
        _trigger: function( type, event, data ) {
            var prop, orig;
            var callback = this.options[ type ];
    
            data = data || {};
            event = $.Event( event );
            event.type = ( type === this.widgetEventPrefix ?
                type :
                this.widgetEventPrefix + type ).toLowerCase();
    
            // The original event may come from any element
            // so we need to reset the target on the new event
            event.target = this.element[ 0 ];
    
            // Copy original event properties over to the new event
            orig = event.originalEvent;
            if ( orig ) {
                for ( prop in orig ) {
                    if ( !( prop in event ) ) {
                        event[ prop ] = orig[ prop ];
                    }
                }
            }
    
            this.element.trigger( event, data );
            return !( $.isFunction( callback ) &&
                callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||
                event.isDefaultPrevented() );
        }
    };
    
    $.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
        $.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
            if ( typeof options === "string" ) {
                options = { effect: options };
            }
    
            var hasOptions;
            var effectName = !options ?
                method :
                options === true || typeof options === "number" ?
                    defaultEffect :
                    options.effect || defaultEffect;
    
            options = options || {};
            if ( typeof options === "number" ) {
                options = { duration: options };
            }
    
            hasOptions = !$.isEmptyObject( options );
            options.complete = callback;
    
            if ( options.delay ) {
                element.delay( options.delay );
            }
    
            if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
                element[ method ]( options );
            } else if ( effectName !== method && element[ effectName ] ) {
                element[ effectName ]( options.duration, options.easing, callback );
            } else {
                element.queue( function( next ) {
                    $( this )[ method ]();
                    if ( callback ) {
                        callback.call( element[ 0 ] );
                    }
                    next();
                } );
            }
        };
    } );
    
    var widget = $.widget;
    
    
    /*!
     * jQuery UI Position 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/position/
     */
    
    //>>label: Position
    //>>group: Core
    //>>description: Positions elements relative to other elements.
    //>>docs: http://api.jqueryui.com/position/
    //>>demos: http://jqueryui.com/position/
    
    
    ( function() {
    var cachedScrollbarWidth,
        max = Math.max,
        abs = Math.abs,
        rhorizontal = /left|center|right/,
        rvertical = /top|center|bottom/,
        roffset = /[\+\-]\d+(\.[\d]+)?%?/,
        rposition = /^\w+/,
        rpercent = /%$/,
        _position = $.fn.position;
    
    function getOffsets( offsets, width, height ) {
        return [
            parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
            parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
        ];
    }
    
    function parseCss( element, property ) {
        return parseInt( $.css( element, property ), 10 ) || 0;
    }
    
    function getDimensions( elem ) {
        var raw = elem[ 0 ];
        if ( raw.nodeType === 9 ) {
            return {
                width: elem.width(),
                height: elem.height(),
                offset: { top: 0, left: 0 }
            };
        }
        if ( $.isWindow( raw ) ) {
            return {
                width: elem.width(),
                height: elem.height(),
                offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
            };
        }
        if ( raw.preventDefault ) {
            return {
                width: 0,
                height: 0,
                offset: { top: raw.pageY, left: raw.pageX }
            };
        }
        return {
            width: elem.outerWidth(),
            height: elem.outerHeight(),
            offset: elem.offset()
        };
    }
    
    $.position = {
        scrollbarWidth: function() {
            if ( cachedScrollbarWidth !== undefined ) {
                return cachedScrollbarWidth;
            }
            var w1, w2,
                div = $( "<div " +
                    "style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'>" +
                    "<div style='height:100px;width:auto;'></div></div>" ),
                innerDiv = div.children()[ 0 ];
    
            $( "body" ).append( div );
            w1 = innerDiv.offsetWidth;
            div.css( "overflow", "scroll" );
    
            w2 = innerDiv.offsetWidth;
    
            if ( w1 === w2 ) {
                w2 = div[ 0 ].clientWidth;
            }
    
            div.remove();
    
            return ( cachedScrollbarWidth = w1 - w2 );
        },
        getScrollInfo: function( within ) {
            var overflowX = within.isWindow || within.isDocument ? "" :
                    within.element.css( "overflow-x" ),
                overflowY = within.isWindow || within.isDocument ? "" :
                    within.element.css( "overflow-y" ),
                hasOverflowX = overflowX === "scroll" ||
                    ( overflowX === "auto" && within.width < within.element[ 0 ].scrollWidth ),
                hasOverflowY = overflowY === "scroll" ||
                    ( overflowY === "auto" && within.height < within.element[ 0 ].scrollHeight );
            return {
                width: hasOverflowY ? $.position.scrollbarWidth() : 0,
                height: hasOverflowX ? $.position.scrollbarWidth() : 0
            };
        },
        getWithinInfo: function( element ) {
            var withinElement = $( element || window ),
                isWindow = $.isWindow( withinElement[ 0 ] ),
                isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9,
                hasOffset = !isWindow && !isDocument;
            return {
                element: withinElement,
                isWindow: isWindow,
                isDocument: isDocument,
                offset: hasOffset ? $( element ).offset() : { left: 0, top: 0 },
                scrollLeft: withinElement.scrollLeft(),
                scrollTop: withinElement.scrollTop(),
                width: withinElement.outerWidth(),
                height: withinElement.outerHeight()
            };
        }
    };
    
    $.fn.position = function( options ) {
        if ( !options || !options.of ) {
            return _position.apply( this, arguments );
        }
    
        // Make a copy, we don't want to modify arguments
        options = $.extend( {}, options );
    
        var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
            target = $( options.of ),
            within = $.position.getWithinInfo( options.within ),
            scrollInfo = $.position.getScrollInfo( within ),
            collision = ( options.collision || "flip" ).split( " " ),
            offsets = {};
    
        dimensions = getDimensions( target );
        if ( target[ 0 ].preventDefault ) {
    
            // Force left top to allow flipping
            options.at = "left top";
        }
        targetWidth = dimensions.width;
        targetHeight = dimensions.height;
        targetOffset = dimensions.offset;
    
        // Clone to reuse original targetOffset later
        basePosition = $.extend( {}, targetOffset );
    
        // Force my and at to have valid horizontal and vertical positions
        // if a value is missing or invalid, it will be converted to center
        $.each( [ "my", "at" ], function() {
            var pos = ( options[ this ] || "" ).split( " " ),
                horizontalOffset,
                verticalOffset;
    
            if ( pos.length === 1 ) {
                pos = rhorizontal.test( pos[ 0 ] ) ?
                    pos.concat( [ "center" ] ) :
                    rvertical.test( pos[ 0 ] ) ?
                        [ "center" ].concat( pos ) :
                        [ "center", "center" ];
            }
            pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
            pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";
    
            // Calculate offsets
            horizontalOffset = roffset.exec( pos[ 0 ] );
            verticalOffset = roffset.exec( pos[ 1 ] );
            offsets[ this ] = [
                horizontalOffset ? horizontalOffset[ 0 ] : 0,
                verticalOffset ? verticalOffset[ 0 ] : 0
            ];
    
            // Reduce to just the positions without the offsets
            options[ this ] = [
                rposition.exec( pos[ 0 ] )[ 0 ],
                rposition.exec( pos[ 1 ] )[ 0 ]
            ];
        } );
    
        // Normalize collision option
        if ( collision.length === 1 ) {
            collision[ 1 ] = collision[ 0 ];
        }
    
        if ( options.at[ 0 ] === "right" ) {
            basePosition.left += targetWidth;
        } else if ( options.at[ 0 ] === "center" ) {
            basePosition.left += targetWidth / 2;
        }
    
        if ( options.at[ 1 ] === "bottom" ) {
            basePosition.top += targetHeight;
        } else if ( options.at[ 1 ] === "center" ) {
            basePosition.top += targetHeight / 2;
        }
    
        atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
        basePosition.left += atOffset[ 0 ];
        basePosition.top += atOffset[ 1 ];
    
        return this.each( function() {
            var collisionPosition, using,
                elem = $( this ),
                elemWidth = elem.outerWidth(),
                elemHeight = elem.outerHeight(),
                marginLeft = parseCss( this, "marginLeft" ),
                marginTop = parseCss( this, "marginTop" ),
                collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) +
                    scrollInfo.width,
                collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) +
                    scrollInfo.height,
                position = $.extend( {}, basePosition ),
                myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );
    
            if ( options.my[ 0 ] === "right" ) {
                position.left -= elemWidth;
            } else if ( options.my[ 0 ] === "center" ) {
                position.left -= elemWidth / 2;
            }
    
            if ( options.my[ 1 ] === "bottom" ) {
                position.top -= elemHeight;
            } else if ( options.my[ 1 ] === "center" ) {
                position.top -= elemHeight / 2;
            }
    
            position.left += myOffset[ 0 ];
            position.top += myOffset[ 1 ];
    
            collisionPosition = {
                marginLeft: marginLeft,
                marginTop: marginTop
            };
    
            $.each( [ "left", "top" ], function( i, dir ) {
                if ( $.ui.position[ collision[ i ] ] ) {
                    $.ui.position[ collision[ i ] ][ dir ]( position, {
                        targetWidth: targetWidth,
                        targetHeight: targetHeight,
                        elemWidth: elemWidth,
                        elemHeight: elemHeight,
                        collisionPosition: collisionPosition,
                        collisionWidth: collisionWidth,
                        collisionHeight: collisionHeight,
                        offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
                        my: options.my,
                        at: options.at,
                        within: within,
                        elem: elem
                    } );
                }
            } );
    
            if ( options.using ) {
    
                // Adds feedback as second argument to using callback, if present
                using = function( props ) {
                    var left = targetOffset.left - position.left,
                        right = left + targetWidth - elemWidth,
                        top = targetOffset.top - position.top,
                        bottom = top + targetHeight - elemHeight,
                        feedback = {
                            target: {
                                element: target,
                                left: targetOffset.left,
                                top: targetOffset.top,
                                width: targetWidth,
                                height: targetHeight
                            },
                            element: {
                                element: elem,
                                left: position.left,
                                top: position.top,
                                width: elemWidth,
                                height: elemHeight
                            },
                            horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                            vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                        };
                    if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
                        feedback.horizontal = "center";
                    }
                    if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
                        feedback.vertical = "middle";
                    }
                    if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
                        feedback.important = "horizontal";
                    } else {
                        feedback.important = "vertical";
                    }
                    options.using.call( this, props, feedback );
                };
            }
    
            elem.offset( $.extend( position, { using: using } ) );
        } );
    };
    
    $.ui.position = {
        fit: {
            left: function( position, data ) {
                var within = data.within,
                    withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
                    outerWidth = within.width,
                    collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                    overLeft = withinOffset - collisionPosLeft,
                    overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
                    newOverRight;
    
                // Element is wider than within
                if ( data.collisionWidth > outerWidth ) {
    
                    // Element is initially over the left side of within
                    if ( overLeft > 0 && overRight <= 0 ) {
                        newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -
                            withinOffset;
                        position.left += overLeft - newOverRight;
    
                    // Element is initially over right side of within
                    } else if ( overRight > 0 && overLeft <= 0 ) {
                        position.left = withinOffset;
    
                    // Element is initially over both left and right sides of within
                    } else {
                        if ( overLeft > overRight ) {
                            position.left = withinOffset + outerWidth - data.collisionWidth;
                        } else {
                            position.left = withinOffset;
                        }
                    }
    
                // Too far left -> align with left edge
                } else if ( overLeft > 0 ) {
                    position.left += overLeft;
    
                // Too far right -> align with right edge
                } else if ( overRight > 0 ) {
                    position.left -= overRight;
    
                // Adjust based on position and margin
                } else {
                    position.left = max( position.left - collisionPosLeft, position.left );
                }
            },
            top: function( position, data ) {
                var within = data.within,
                    withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
                    outerHeight = data.within.height,
                    collisionPosTop = position.top - data.collisionPosition.marginTop,
                    overTop = withinOffset - collisionPosTop,
                    overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
                    newOverBottom;
    
                // Element is taller than within
                if ( data.collisionHeight > outerHeight ) {
    
                    // Element is initially over the top of within
                    if ( overTop > 0 && overBottom <= 0 ) {
                        newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -
                            withinOffset;
                        position.top += overTop - newOverBottom;
    
                    // Element is initially over bottom of within
                    } else if ( overBottom > 0 && overTop <= 0 ) {
                        position.top = withinOffset;
    
                    // Element is initially over both top and bottom of within
                    } else {
                        if ( overTop > overBottom ) {
                            position.top = withinOffset + outerHeight - data.collisionHeight;
                        } else {
                            position.top = withinOffset;
                        }
                    }
    
                // Too far up -> align with top
                } else if ( overTop > 0 ) {
                    position.top += overTop;
    
                // Too far down -> align with bottom edge
                } else if ( overBottom > 0 ) {
                    position.top -= overBottom;
    
                // Adjust based on position and margin
                } else {
                    position.top = max( position.top - collisionPosTop, position.top );
                }
            }
        },
        flip: {
            left: function( position, data ) {
                var within = data.within,
                    withinOffset = within.offset.left + within.scrollLeft,
                    outerWidth = within.width,
                    offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
                    collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                    overLeft = collisionPosLeft - offsetLeft,
                    overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
                    myOffset = data.my[ 0 ] === "left" ?
                        -data.elemWidth :
                        data.my[ 0 ] === "right" ?
                            data.elemWidth :
                            0,
                    atOffset = data.at[ 0 ] === "left" ?
                        data.targetWidth :
                        data.at[ 0 ] === "right" ?
                            -data.targetWidth :
                            0,
                    offset = -2 * data.offset[ 0 ],
                    newOverRight,
                    newOverLeft;
    
                if ( overLeft < 0 ) {
                    newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -
                        outerWidth - withinOffset;
                    if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
                        position.left += myOffset + atOffset + offset;
                    }
                } else if ( overRight > 0 ) {
                    newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +
                        atOffset + offset - offsetLeft;
                    if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
                        position.left += myOffset + atOffset + offset;
                    }
                }
            },
            top: function( position, data ) {
                var within = data.within,
                    withinOffset = within.offset.top + within.scrollTop,
                    outerHeight = within.height,
                    offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
                    collisionPosTop = position.top - data.collisionPosition.marginTop,
                    overTop = collisionPosTop - offsetTop,
                    overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
                    top = data.my[ 1 ] === "top",
                    myOffset = top ?
                        -data.elemHeight :
                        data.my[ 1 ] === "bottom" ?
                            data.elemHeight :
                            0,
                    atOffset = data.at[ 1 ] === "top" ?
                        data.targetHeight :
                        data.at[ 1 ] === "bottom" ?
                            -data.targetHeight :
                            0,
                    offset = -2 * data.offset[ 1 ],
                    newOverTop,
                    newOverBottom;
                if ( overTop < 0 ) {
                    newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -
                        outerHeight - withinOffset;
                    if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
                        position.top += myOffset + atOffset + offset;
                    }
                } else if ( overBottom > 0 ) {
                    newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +
                        offset - offsetTop;
                    if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
                        position.top += myOffset + atOffset + offset;
                    }
                }
            }
        },
        flipfit: {
            left: function() {
                $.ui.position.flip.left.apply( this, arguments );
                $.ui.position.fit.left.apply( this, arguments );
            },
            top: function() {
                $.ui.position.flip.top.apply( this, arguments );
                $.ui.position.fit.top.apply( this, arguments );
            }
        }
    };
    
    } )();
    
    var position = $.ui.position;
    
    
    /*!
     * jQuery UI :data 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: :data Selector
    //>>group: Core
    //>>description: Selects elements which have data stored under the specified key.
    //>>docs: http://api.jqueryui.com/data-selector/
    
    
    var data = $.extend( $.expr[ ":" ], {
        data: $.expr.createPseudo ?
            $.expr.createPseudo( function( dataName ) {
                return function( elem ) {
                    return !!$.data( elem, dataName );
                };
            } ) :
    
            // Support: jQuery <1.8
            function( elem, i, match ) {
                return !!$.data( elem, match[ 3 ] );
            }
    } );
    
    /*!
     * jQuery UI Disable Selection 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: disableSelection
    //>>group: Core
    //>>description: Disable selection of text content within the set of matched elements.
    //>>docs: http://api.jqueryui.com/disableSelection/
    
    // This file is deprecated
    
    
    var disableSelection = $.fn.extend( {
        disableSelection: ( function() {
            var eventType = "onselectstart" in document.createElement( "div" ) ?
                "selectstart" :
                "mousedown";
    
            return function() {
                return this.on( eventType + ".ui-disableSelection", function( event ) {
                    event.preventDefault();
                } );
            };
        } )(),
    
        enableSelection: function() {
            return this.off( ".ui-disableSelection" );
        }
    } );
    
    
    /*!
     * jQuery UI Effects 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Effects Core
    //>>group: Effects
    // jscs:disable maximumLineLength
    //>>description: Extends the internal jQuery effects. Includes morphing and easing. Required by all other effects.
    // jscs:enable maximumLineLength
    //>>docs: http://api.jqueryui.com/category/effects-core/
    //>>demos: http://jqueryui.com/effect/
    
    
    
    var dataSpace = "ui-effects-",
        dataSpaceStyle = "ui-effects-style",
        dataSpaceAnimated = "ui-effects-animated",
    
        // Create a local jQuery because jQuery Color relies on it and the
        // global may not exist with AMD and a custom build (#10199)
        jQuery = $;
    
    $.effects = {
        effect: {}
    };
    
    /*!
     * jQuery Color Animations v2.1.2
     * https://github.com/jquery/jquery-color
     *
     * Copyright 2014 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * Date: Wed Jan 16 08:47:09 2013 -0600
     */
    ( function( jQuery, undefined ) {
    
        var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor " +
            "borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",
    
        // Plusequals test for += 100 -= 100
        rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
    
        // A set of RE's that can match strings and generate color tuples.
        stringParsers = [ {
                re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                parse: function( execResult ) {
                    return [
                        execResult[ 1 ],
                        execResult[ 2 ],
                        execResult[ 3 ],
                        execResult[ 4 ]
                    ];
                }
            }, {
                re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                parse: function( execResult ) {
                    return [
                        execResult[ 1 ] * 2.55,
                        execResult[ 2 ] * 2.55,
                        execResult[ 3 ] * 2.55,
                        execResult[ 4 ]
                    ];
                }
            }, {
    
                // This regex ignores A-F because it's compared against an already lowercased string
                re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
                parse: function( execResult ) {
                    return [
                        parseInt( execResult[ 1 ], 16 ),
                        parseInt( execResult[ 2 ], 16 ),
                        parseInt( execResult[ 3 ], 16 )
                    ];
                }
            }, {
    
                // This regex ignores A-F because it's compared against an already lowercased string
                re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
                parse: function( execResult ) {
                    return [
                        parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
                        parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
                        parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
                    ];
                }
            }, {
                re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                space: "hsla",
                parse: function( execResult ) {
                    return [
                        execResult[ 1 ],
                        execResult[ 2 ] / 100,
                        execResult[ 3 ] / 100,
                        execResult[ 4 ]
                    ];
                }
            } ],
    
        // JQuery.Color( )
        color = jQuery.Color = function( color, green, blue, alpha ) {
            return new jQuery.Color.fn.parse( color, green, blue, alpha );
        },
        spaces = {
            rgba: {
                props: {
                    red: {
                        idx: 0,
                        type: "byte"
                    },
                    green: {
                        idx: 1,
                        type: "byte"
                    },
                    blue: {
                        idx: 2,
                        type: "byte"
                    }
                }
            },
    
            hsla: {
                props: {
                    hue: {
                        idx: 0,
                        type: "degrees"
                    },
                    saturation: {
                        idx: 1,
                        type: "percent"
                    },
                    lightness: {
                        idx: 2,
                        type: "percent"
                    }
                }
            }
        },
        propTypes = {
            "byte": {
                floor: true,
                max: 255
            },
            "percent": {
                max: 1
            },
            "degrees": {
                mod: 360,
                floor: true
            }
        },
        support = color.support = {},
    
        // Element for support tests
        supportElem = jQuery( "<p>" )[ 0 ],
    
        // Colors = jQuery.Color.names
        colors,
    
        // Local aliases of functions called often
        each = jQuery.each;
    
    // Determine rgba support immediately
    supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
    support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;
    
    // Define cache name and alpha properties
    // for rgba and hsla spaces
    each( spaces, function( spaceName, space ) {
        space.cache = "_" + spaceName;
        space.props.alpha = {
            idx: 3,
            type: "percent",
            def: 1
        };
    } );
    
    function clamp( value, prop, allowEmpty ) {
        var type = propTypes[ prop.type ] || {};
    
        if ( value == null ) {
            return ( allowEmpty || !prop.def ) ? null : prop.def;
        }
    
        // ~~ is an short way of doing floor for positive numbers
        value = type.floor ? ~~value : parseFloat( value );
    
        // IE will pass in empty strings as value for alpha,
        // which will hit this case
        if ( isNaN( value ) ) {
            return prop.def;
        }
    
        if ( type.mod ) {
    
            // We add mod before modding to make sure that negatives values
            // get converted properly: -10 -> 350
            return ( value + type.mod ) % type.mod;
        }
    
        // For now all property types without mod have min and max
        return 0 > value ? 0 : type.max < value ? type.max : value;
    }
    
    function stringParse( string ) {
        var inst = color(),
            rgba = inst._rgba = [];
    
        string = string.toLowerCase();
    
        each( stringParsers, function( i, parser ) {
            var parsed,
                match = parser.re.exec( string ),
                values = match && parser.parse( match ),
                spaceName = parser.space || "rgba";
    
            if ( values ) {
                parsed = inst[ spaceName ]( values );
    
                // If this was an rgba parse the assignment might happen twice
                // oh well....
                inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
                rgba = inst._rgba = parsed._rgba;
    
                // Exit each( stringParsers ) here because we matched
                return false;
            }
        } );
    
        // Found a stringParser that handled it
        if ( rgba.length ) {
    
            // If this came from a parsed string, force "transparent" when alpha is 0
            // chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
            if ( rgba.join() === "0,0,0,0" ) {
                jQuery.extend( rgba, colors.transparent );
            }
            return inst;
        }
    
        // Named colors
        return colors[ string ];
    }
    
    color.fn = jQuery.extend( color.prototype, {
        parse: function( red, green, blue, alpha ) {
            if ( red === undefined ) {
                this._rgba = [ null, null, null, null ];
                return this;
            }
            if ( red.jquery || red.nodeType ) {
                red = jQuery( red ).css( green );
                green = undefined;
            }
    
            var inst = this,
                type = jQuery.type( red ),
                rgba = this._rgba = [];
    
            // More than 1 argument specified - assume ( red, green, blue, alpha )
            if ( green !== undefined ) {
                red = [ red, green, blue, alpha ];
                type = "array";
            }
    
            if ( type === "string" ) {
                return this.parse( stringParse( red ) || colors._default );
            }
    
            if ( type === "array" ) {
                each( spaces.rgba.props, function( key, prop ) {
                    rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
                } );
                return this;
            }
    
            if ( type === "object" ) {
                if ( red instanceof color ) {
                    each( spaces, function( spaceName, space ) {
                        if ( red[ space.cache ] ) {
                            inst[ space.cache ] = red[ space.cache ].slice();
                        }
                    } );
                } else {
                    each( spaces, function( spaceName, space ) {
                        var cache = space.cache;
                        each( space.props, function( key, prop ) {
    
                            // If the cache doesn't exist, and we know how to convert
                            if ( !inst[ cache ] && space.to ) {
    
                                // If the value was null, we don't need to copy it
                                // if the key was alpha, we don't need to copy it either
                                if ( key === "alpha" || red[ key ] == null ) {
                                    return;
                                }
                                inst[ cache ] = space.to( inst._rgba );
                            }
    
                            // This is the only case where we allow nulls for ALL properties.
                            // call clamp with alwaysAllowEmpty
                            inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
                        } );
    
                        // Everything defined but alpha?
                        if ( inst[ cache ] &&
                                jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {
    
                            // Use the default of 1
                            inst[ cache ][ 3 ] = 1;
                            if ( space.from ) {
                                inst._rgba = space.from( inst[ cache ] );
                            }
                        }
                    } );
                }
                return this;
            }
        },
        is: function( compare ) {
            var is = color( compare ),
                same = true,
                inst = this;
    
            each( spaces, function( _, space ) {
                var localCache,
                    isCache = is[ space.cache ];
                if ( isCache ) {
                    localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
                    each( space.props, function( _, prop ) {
                        if ( isCache[ prop.idx ] != null ) {
                            same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
                            return same;
                        }
                    } );
                }
                return same;
            } );
            return same;
        },
        _space: function() {
            var used = [],
                inst = this;
            each( spaces, function( spaceName, space ) {
                if ( inst[ space.cache ] ) {
                    used.push( spaceName );
                }
            } );
            return used.pop();
        },
        transition: function( other, distance ) {
            var end = color( other ),
                spaceName = end._space(),
                space = spaces[ spaceName ],
                startColor = this.alpha() === 0 ? color( "transparent" ) : this,
                start = startColor[ space.cache ] || space.to( startColor._rgba ),
                result = start.slice();
    
            end = end[ space.cache ];
            each( space.props, function( key, prop ) {
                var index = prop.idx,
                    startValue = start[ index ],
                    endValue = end[ index ],
                    type = propTypes[ prop.type ] || {};
    
                // If null, don't override start value
                if ( endValue === null ) {
                    return;
                }
    
                // If null - use end
                if ( startValue === null ) {
                    result[ index ] = endValue;
                } else {
                    if ( type.mod ) {
                        if ( endValue - startValue > type.mod / 2 ) {
                            startValue += type.mod;
                        } else if ( startValue - endValue > type.mod / 2 ) {
                            startValue -= type.mod;
                        }
                    }
                    result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
                }
            } );
            return this[ spaceName ]( result );
        },
        blend: function( opaque ) {
    
            // If we are already opaque - return ourself
            if ( this._rgba[ 3 ] === 1 ) {
                return this;
            }
    
            var rgb = this._rgba.slice(),
                a = rgb.pop(),
                blend = color( opaque )._rgba;
    
            return color( jQuery.map( rgb, function( v, i ) {
                return ( 1 - a ) * blend[ i ] + a * v;
            } ) );
        },
        toRgbaString: function() {
            var prefix = "rgba(",
                rgba = jQuery.map( this._rgba, function( v, i ) {
                    return v == null ? ( i > 2 ? 1 : 0 ) : v;
                } );
    
            if ( rgba[ 3 ] === 1 ) {
                rgba.pop();
                prefix = "rgb(";
            }
    
            return prefix + rgba.join() + ")";
        },
        toHslaString: function() {
            var prefix = "hsla(",
                hsla = jQuery.map( this.hsla(), function( v, i ) {
                    if ( v == null ) {
                        v = i > 2 ? 1 : 0;
                    }
    
                    // Catch 1 and 2
                    if ( i && i < 3 ) {
                        v = Math.round( v * 100 ) + "%";
                    }
                    return v;
                } );
    
            if ( hsla[ 3 ] === 1 ) {
                hsla.pop();
                prefix = "hsl(";
            }
            return prefix + hsla.join() + ")";
        },
        toHexString: function( includeAlpha ) {
            var rgba = this._rgba.slice(),
                alpha = rgba.pop();
    
            if ( includeAlpha ) {
                rgba.push( ~~( alpha * 255 ) );
            }
    
            return "#" + jQuery.map( rgba, function( v ) {
    
                // Default to 0 when nulls exist
                v = ( v || 0 ).toString( 16 );
                return v.length === 1 ? "0" + v : v;
            } ).join( "" );
        },
        toString: function() {
            return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
        }
    } );
    color.fn.parse.prototype = color.fn;
    
    // Hsla conversions adapted from:
    // https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021
    
    function hue2rgb( p, q, h ) {
        h = ( h + 1 ) % 1;
        if ( h * 6 < 1 ) {
            return p + ( q - p ) * h * 6;
        }
        if ( h * 2 < 1 ) {
            return q;
        }
        if ( h * 3 < 2 ) {
            return p + ( q - p ) * ( ( 2 / 3 ) - h ) * 6;
        }
        return p;
    }
    
    spaces.hsla.to = function( rgba ) {
        if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
            return [ null, null, null, rgba[ 3 ] ];
        }
        var r = rgba[ 0 ] / 255,
            g = rgba[ 1 ] / 255,
            b = rgba[ 2 ] / 255,
            a = rgba[ 3 ],
            max = Math.max( r, g, b ),
            min = Math.min( r, g, b ),
            diff = max - min,
            add = max + min,
            l = add * 0.5,
            h, s;
    
        if ( min === max ) {
            h = 0;
        } else if ( r === max ) {
            h = ( 60 * ( g - b ) / diff ) + 360;
        } else if ( g === max ) {
            h = ( 60 * ( b - r ) / diff ) + 120;
        } else {
            h = ( 60 * ( r - g ) / diff ) + 240;
        }
    
        // Chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
        // otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
        if ( diff === 0 ) {
            s = 0;
        } else if ( l <= 0.5 ) {
            s = diff / add;
        } else {
            s = diff / ( 2 - add );
        }
        return [ Math.round( h ) % 360, s, l, a == null ? 1 : a ];
    };
    
    spaces.hsla.from = function( hsla ) {
        if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
            return [ null, null, null, hsla[ 3 ] ];
        }
        var h = hsla[ 0 ] / 360,
            s = hsla[ 1 ],
            l = hsla[ 2 ],
            a = hsla[ 3 ],
            q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
            p = 2 * l - q;
    
        return [
            Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
            Math.round( hue2rgb( p, q, h ) * 255 ),
            Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
            a
        ];
    };
    
    each( spaces, function( spaceName, space ) {
        var props = space.props,
            cache = space.cache,
            to = space.to,
            from = space.from;
    
        // Makes rgba() and hsla()
        color.fn[ spaceName ] = function( value ) {
    
            // Generate a cache for this space if it doesn't exist
            if ( to && !this[ cache ] ) {
                this[ cache ] = to( this._rgba );
            }
            if ( value === undefined ) {
                return this[ cache ].slice();
            }
    
            var ret,
                type = jQuery.type( value ),
                arr = ( type === "array" || type === "object" ) ? value : arguments,
                local = this[ cache ].slice();
    
            each( props, function( key, prop ) {
                var val = arr[ type === "object" ? key : prop.idx ];
                if ( val == null ) {
                    val = local[ prop.idx ];
                }
                local[ prop.idx ] = clamp( val, prop );
            } );
    
            if ( from ) {
                ret = color( from( local ) );
                ret[ cache ] = local;
                return ret;
            } else {
                return color( local );
            }
        };
    
        // Makes red() green() blue() alpha() hue() saturation() lightness()
        each( props, function( key, prop ) {
    
            // Alpha is included in more than one space
            if ( color.fn[ key ] ) {
                return;
            }
            color.fn[ key ] = function( value ) {
                var vtype = jQuery.type( value ),
                    fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
                    local = this[ fn ](),
                    cur = local[ prop.idx ],
                    match;
    
                if ( vtype === "undefined" ) {
                    return cur;
                }
    
                if ( vtype === "function" ) {
                    value = value.call( this, cur );
                    vtype = jQuery.type( value );
                }
                if ( value == null && prop.empty ) {
                    return this;
                }
                if ( vtype === "string" ) {
                    match = rplusequals.exec( value );
                    if ( match ) {
                        value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
                    }
                }
                local[ prop.idx ] = value;
                return this[ fn ]( local );
            };
        } );
    } );
    
    // Add cssHook and .fx.step function for each named hook.
    // accept a space separated string of properties
    color.hook = function( hook ) {
        var hooks = hook.split( " " );
        each( hooks, function( i, hook ) {
            jQuery.cssHooks[ hook ] = {
                set: function( elem, value ) {
                    var parsed, curElem,
                        backgroundColor = "";
    
                    if ( value !== "transparent" && ( jQuery.type( value ) !== "string" ||
                            ( parsed = stringParse( value ) ) ) ) {
                        value = color( parsed || value );
                        if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
                            curElem = hook === "backgroundColor" ? elem.parentNode : elem;
                            while (
                                ( backgroundColor === "" || backgroundColor === "transparent" ) &&
                                curElem && curElem.style
                            ) {
                                try {
                                    backgroundColor = jQuery.css( curElem, "backgroundColor" );
                                    curElem = curElem.parentNode;
                                } catch ( e ) {
                                }
                            }
    
                            value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
                                backgroundColor :
                                "_default" );
                        }
    
                        value = value.toRgbaString();
                    }
                    try {
                        elem.style[ hook ] = value;
                    } catch ( e ) {
    
                        // Wrapped to prevent IE from throwing errors on "invalid" values like
                        // 'auto' or 'inherit'
                    }
                }
            };
            jQuery.fx.step[ hook ] = function( fx ) {
                if ( !fx.colorInit ) {
                    fx.start = color( fx.elem, hook );
                    fx.end = color( fx.end );
                    fx.colorInit = true;
                }
                jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
            };
        } );
    
    };
    
    color.hook( stepHooks );
    
    jQuery.cssHooks.borderColor = {
        expand: function( value ) {
            var expanded = {};
    
            each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
                expanded[ "border" + part + "Color" ] = value;
            } );
            return expanded;
        }
    };
    
    // Basic color names only.
    // Usage of any of the other color names requires adding yourself or including
    // jquery.color.svg-names.js.
    colors = jQuery.Color.names = {
    
        // 4.1. Basic color keywords
        aqua: "#00ffff",
        black: "#000000",
        blue: "#0000ff",
        fuchsia: "#ff00ff",
        gray: "#808080",
        green: "#008000",
        lime: "#00ff00",
        maroon: "#800000",
        navy: "#000080",
        olive: "#808000",
        purple: "#800080",
        red: "#ff0000",
        silver: "#c0c0c0",
        teal: "#008080",
        white: "#ffffff",
        yellow: "#ffff00",
    
        // 4.2.3. "transparent" color keyword
        transparent: [ null, null, null, 0 ],
    
        _default: "#ffffff"
    };
    
    } )( jQuery );
    
    /******************************************************************************/
    /****************************** CLASS ANIMATIONS ******************************/
    /******************************************************************************/
    ( function() {
    
    var classAnimationActions = [ "add", "remove", "toggle" ],
        shorthandStyles = {
            border: 1,
            borderBottom: 1,
            borderColor: 1,
            borderLeft: 1,
            borderRight: 1,
            borderTop: 1,
            borderWidth: 1,
            margin: 1,
            padding: 1
        };
    
    $.each(
        [ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ],
        function( _, prop ) {
            $.fx.step[ prop ] = function( fx ) {
                if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
                    jQuery.style( fx.elem, prop, fx.end );
                    fx.setAttr = true;
                }
            };
        }
    );
    
    function getElementStyles( elem ) {
        var key, len,
            style = elem.ownerDocument.defaultView ?
                elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :
                elem.currentStyle,
            styles = {};
    
        if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
            len = style.length;
            while ( len-- ) {
                key = style[ len ];
                if ( typeof style[ key ] === "string" ) {
                    styles[ $.camelCase( key ) ] = style[ key ];
                }
            }
    
        // Support: Opera, IE <9
        } else {
            for ( key in style ) {
                if ( typeof style[ key ] === "string" ) {
                    styles[ key ] = style[ key ];
                }
            }
        }
    
        return styles;
    }
    
    function styleDifference( oldStyle, newStyle ) {
        var diff = {},
            name, value;
    
        for ( name in newStyle ) {
            value = newStyle[ name ];
            if ( oldStyle[ name ] !== value ) {
                if ( !shorthandStyles[ name ] ) {
                    if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
                        diff[ name ] = value;
                    }
                }
            }
        }
    
        return diff;
    }
    
    // Support: jQuery <1.8
    if ( !$.fn.addBack ) {
        $.fn.addBack = function( selector ) {
            return this.add( selector == null ?
                this.prevObject : this.prevObject.filter( selector )
            );
        };
    }
    
    $.effects.animateClass = function( value, duration, easing, callback ) {
        var o = $.speed( duration, easing, callback );
    
        return this.queue( function() {
            var animated = $( this ),
                baseClass = animated.attr( "class" ) || "",
                applyClassChange,
                allAnimations = o.children ? animated.find( "*" ).addBack() : animated;
    
            // Map the animated objects to store the original styles.
            allAnimations = allAnimations.map( function() {
                var el = $( this );
                return {
                    el: el,
                    start: getElementStyles( this )
                };
            } );
    
            // Apply class change
            applyClassChange = function() {
                $.each( classAnimationActions, function( i, action ) {
                    if ( value[ action ] ) {
                        animated[ action + "Class" ]( value[ action ] );
                    }
                } );
            };
            applyClassChange();
    
            // Map all animated objects again - calculate new styles and diff
            allAnimations = allAnimations.map( function() {
                this.end = getElementStyles( this.el[ 0 ] );
                this.diff = styleDifference( this.start, this.end );
                return this;
            } );
    
            // Apply original class
            animated.attr( "class", baseClass );
    
            // Map all animated objects again - this time collecting a promise
            allAnimations = allAnimations.map( function() {
                var styleInfo = this,
                    dfd = $.Deferred(),
                    opts = $.extend( {}, o, {
                        queue: false,
                        complete: function() {
                            dfd.resolve( styleInfo );
                        }
                    } );
    
                this.el.animate( this.diff, opts );
                return dfd.promise();
            } );
    
            // Once all animations have completed:
            $.when.apply( $, allAnimations.get() ).done( function() {
    
                // Set the final class
                applyClassChange();
    
                // For each animated element,
                // clear all css properties that were animated
                $.each( arguments, function() {
                    var el = this.el;
                    $.each( this.diff, function( key ) {
                        el.css( key, "" );
                    } );
                } );
    
                // This is guarnteed to be there if you use jQuery.speed()
                // it also handles dequeuing the next anim...
                o.complete.call( animated[ 0 ] );
            } );
        } );
    };
    
    $.fn.extend( {
        addClass: ( function( orig ) {
            return function( classNames, speed, easing, callback ) {
                return speed ?
                    $.effects.animateClass.call( this,
                        { add: classNames }, speed, easing, callback ) :
                    orig.apply( this, arguments );
            };
        } )( $.fn.addClass ),
    
        removeClass: ( function( orig ) {
            return function( classNames, speed, easing, callback ) {
                return arguments.length > 1 ?
                    $.effects.animateClass.call( this,
                        { remove: classNames }, speed, easing, callback ) :
                    orig.apply( this, arguments );
            };
        } )( $.fn.removeClass ),
    
        toggleClass: ( function( orig ) {
            return function( classNames, force, speed, easing, callback ) {
                if ( typeof force === "boolean" || force === undefined ) {
                    if ( !speed ) {
    
                        // Without speed parameter
                        return orig.apply( this, arguments );
                    } else {
                        return $.effects.animateClass.call( this,
                            ( force ? { add: classNames } : { remove: classNames } ),
                            speed, easing, callback );
                    }
                } else {
    
                    // Without force parameter
                    return $.effects.animateClass.call( this,
                        { toggle: classNames }, force, speed, easing );
                }
            };
        } )( $.fn.toggleClass ),
    
        switchClass: function( remove, add, speed, easing, callback ) {
            return $.effects.animateClass.call( this, {
                add: add,
                remove: remove
            }, speed, easing, callback );
        }
    } );
    
    } )();
    
    /******************************************************************************/
    /*********************************** EFFECTS **********************************/
    /******************************************************************************/
    
    ( function() {
    
    if ( $.expr && $.expr.filters && $.expr.filters.animated ) {
        $.expr.filters.animated = ( function( orig ) {
            return function( elem ) {
                return !!$( elem ).data( dataSpaceAnimated ) || orig( elem );
            };
        } )( $.expr.filters.animated );
    }
    
    if ( $.uiBackCompat !== false ) {
        $.extend( $.effects, {
    
            // Saves a set of properties in a data storage
            save: function( element, set ) {
                var i = 0, length = set.length;
                for ( ; i < length; i++ ) {
                    if ( set[ i ] !== null ) {
                        element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
                    }
                }
            },
    
            // Restores a set of previously saved properties from a data storage
            restore: function( element, set ) {
                var val, i = 0, length = set.length;
                for ( ; i < length; i++ ) {
                    if ( set[ i ] !== null ) {
                        val = element.data( dataSpace + set[ i ] );
                        element.css( set[ i ], val );
                    }
                }
            },
    
            setMode: function( el, mode ) {
                if ( mode === "toggle" ) {
                    mode = el.is( ":hidden" ) ? "show" : "hide";
                }
                return mode;
            },
    
            // Wraps the element around a wrapper that copies position properties
            createWrapper: function( element ) {
    
                // If the element is already wrapped, return it
                if ( element.parent().is( ".ui-effects-wrapper" ) ) {
                    return element.parent();
                }
    
                // Wrap the element
                var props = {
                        width: element.outerWidth( true ),
                        height: element.outerHeight( true ),
                        "float": element.css( "float" )
                    },
                    wrapper = $( "<div></div>" )
                        .addClass( "ui-effects-wrapper" )
                        .css( {
                            fontSize: "100%",
                            background: "transparent",
                            border: "none",
                            margin: 0,
                            padding: 0
                        } ),
    
                    // Store the size in case width/height are defined in % - Fixes #5245
                    size = {
                        width: element.width(),
                        height: element.height()
                    },
                    active = document.activeElement;
    
                // Support: Firefox
                // Firefox incorrectly exposes anonymous content
                // https://bugzilla.mozilla.org/show_bug.cgi?id=561664
                try {
                    active.id;
                } catch ( e ) {
                    active = document.body;
                }
    
                element.wrap( wrapper );
    
                // Fixes #7595 - Elements lose focus when wrapped.
                if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
                    $( active ).trigger( "focus" );
                }
    
                // Hotfix for jQuery 1.4 since some change in wrap() seems to actually
                // lose the reference to the wrapped element
                wrapper = element.parent();
    
                // Transfer positioning properties to the wrapper
                if ( element.css( "position" ) === "static" ) {
                    wrapper.css( { position: "relative" } );
                    element.css( { position: "relative" } );
                } else {
                    $.extend( props, {
                        position: element.css( "position" ),
                        zIndex: element.css( "z-index" )
                    } );
                    $.each( [ "top", "left", "bottom", "right" ], function( i, pos ) {
                        props[ pos ] = element.css( pos );
                        if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
                            props[ pos ] = "auto";
                        }
                    } );
                    element.css( {
                        position: "relative",
                        top: 0,
                        left: 0,
                        right: "auto",
                        bottom: "auto"
                    } );
                }
                element.css( size );
    
                return wrapper.css( props ).show();
            },
    
            removeWrapper: function( element ) {
                var active = document.activeElement;
    
                if ( element.parent().is( ".ui-effects-wrapper" ) ) {
                    element.parent().replaceWith( element );
    
                    // Fixes #7595 - Elements lose focus when wrapped.
                    if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
                        $( active ).trigger( "focus" );
                    }
                }
    
                return element;
            }
        } );
    }
    
    $.extend( $.effects, {
        version: "1.12.1",
    
        define: function( name, mode, effect ) {
            if ( !effect ) {
                effect = mode;
                mode = "effect";
            }
    
            $.effects.effect[ name ] = effect;
            $.effects.effect[ name ].mode = mode;
    
            return effect;
        },
    
        scaledDimensions: function( element, percent, direction ) {
            if ( percent === 0 ) {
                return {
                    height: 0,
                    width: 0,
                    outerHeight: 0,
                    outerWidth: 0
                };
            }
    
            var x = direction !== "horizontal" ? ( ( percent || 100 ) / 100 ) : 1,
                y = direction !== "vertical" ? ( ( percent || 100 ) / 100 ) : 1;
    
            return {
                height: element.height() * y,
                width: element.width() * x,
                outerHeight: element.outerHeight() * y,
                outerWidth: element.outerWidth() * x
            };
    
        },
    
        clipToBox: function( animation ) {
            return {
                width: animation.clip.right - animation.clip.left,
                height: animation.clip.bottom - animation.clip.top,
                left: animation.clip.left,
                top: animation.clip.top
            };
        },
    
        // Injects recently queued functions to be first in line (after "inprogress")
        unshift: function( element, queueLength, count ) {
            var queue = element.queue();
    
            if ( queueLength > 1 ) {
                queue.splice.apply( queue,
                    [ 1, 0 ].concat( queue.splice( queueLength, count ) ) );
            }
            element.dequeue();
        },
    
        saveStyle: function( element ) {
            element.data( dataSpaceStyle, element[ 0 ].style.cssText );
        },
    
        restoreStyle: function( element ) {
            element[ 0 ].style.cssText = element.data( dataSpaceStyle ) || "";
            element.removeData( dataSpaceStyle );
        },
    
        mode: function( element, mode ) {
            var hidden = element.is( ":hidden" );
    
            if ( mode === "toggle" ) {
                mode = hidden ? "show" : "hide";
            }
            if ( hidden ? mode === "hide" : mode === "show" ) {
                mode = "none";
            }
            return mode;
        },
    
        // Translates a [top,left] array into a baseline value
        getBaseline: function( origin, original ) {
            var y, x;
    
            switch ( origin[ 0 ] ) {
            case "top":
                y = 0;
                break;
            case "middle":
                y = 0.5;
                break;
            case "bottom":
                y = 1;
                break;
            default:
                y = origin[ 0 ] / original.height;
            }
    
            switch ( origin[ 1 ] ) {
            case "left":
                x = 0;
                break;
            case "center":
                x = 0.5;
                break;
            case "right":
                x = 1;
                break;
            default:
                x = origin[ 1 ] / original.width;
            }
    
            return {
                x: x,
                y: y
            };
        },
    
        // Creates a placeholder element so that the original element can be made absolute
        createPlaceholder: function( element ) {
            var placeholder,
                cssPosition = element.css( "position" ),
                position = element.position();
    
            // Lock in margins first to account for form elements, which
            // will change margin if you explicitly set height
            // see: http://jsfiddle.net/JZSMt/3/ https://bugs.webkit.org/show_bug.cgi?id=107380
            // Support: Safari
            element.css( {
                marginTop: element.css( "marginTop" ),
                marginBottom: element.css( "marginBottom" ),
                marginLeft: element.css( "marginLeft" ),
                marginRight: element.css( "marginRight" )
            } )
            .outerWidth( element.outerWidth() )
            .outerHeight( element.outerHeight() );
    
            if ( /^(static|relative)/.test( cssPosition ) ) {
                cssPosition = "absolute";
    
                placeholder = $( "<" + element[ 0 ].nodeName + ">" ).insertAfter( element ).css( {
    
                    // Convert inline to inline block to account for inline elements
                    // that turn to inline block based on content (like img)
                    display: /^(inline|ruby)/.test( element.css( "display" ) ) ?
                        "inline-block" :
                        "block",
                    visibility: "hidden",
    
                    // Margins need to be set to account for margin collapse
                    marginTop: element.css( "marginTop" ),
                    marginBottom: element.css( "marginBottom" ),
                    marginLeft: element.css( "marginLeft" ),
                    marginRight: element.css( "marginRight" ),
                    "float": element.css( "float" )
                } )
                .outerWidth( element.outerWidth() )
                .outerHeight( element.outerHeight() )
                .addClass( "ui-effects-placeholder" );
    
                element.data( dataSpace + "placeholder", placeholder );
            }
    
            element.css( {
                position: cssPosition,
                left: position.left,
                top: position.top
            } );
    
            return placeholder;
        },
    
        removePlaceholder: function( element ) {
            var dataKey = dataSpace + "placeholder",
                    placeholder = element.data( dataKey );
    
            if ( placeholder ) {
                placeholder.remove();
                element.removeData( dataKey );
            }
        },
    
        // Removes a placeholder if it exists and restores
        // properties that were modified during placeholder creation
        cleanUp: function( element ) {
            $.effects.restoreStyle( element );
            $.effects.removePlaceholder( element );
        },
    
        setTransition: function( element, list, factor, value ) {
            value = value || {};
            $.each( list, function( i, x ) {
                var unit = element.cssUnit( x );
                if ( unit[ 0 ] > 0 ) {
                    value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
                }
            } );
            return value;
        }
    } );
    
    // Return an effect options object for the given parameters:
    function _normalizeArguments( effect, options, speed, callback ) {
    
        // Allow passing all options as the first parameter
        if ( $.isPlainObject( effect ) ) {
            options = effect;
            effect = effect.effect;
        }
    
        // Convert to an object
        effect = { effect: effect };
    
        // Catch (effect, null, ...)
        if ( options == null ) {
            options = {};
        }
    
        // Catch (effect, callback)
        if ( $.isFunction( options ) ) {
            callback = options;
            speed = null;
            options = {};
        }
    
        // Catch (effect, speed, ?)
        if ( typeof options === "number" || $.fx.speeds[ options ] ) {
            callback = speed;
            speed = options;
            options = {};
        }
    
        // Catch (effect, options, callback)
        if ( $.isFunction( speed ) ) {
            callback = speed;
            speed = null;
        }
    
        // Add options to effect
        if ( options ) {
            $.extend( effect, options );
        }
    
        speed = speed || options.duration;
        effect.duration = $.fx.off ? 0 :
            typeof speed === "number" ? speed :
            speed in $.fx.speeds ? $.fx.speeds[ speed ] :
            $.fx.speeds._default;
    
        effect.complete = callback || options.complete;
    
        return effect;
    }
    
    function standardAnimationOption( option ) {
    
        // Valid standard speeds (nothing, number, named speed)
        if ( !option || typeof option === "number" || $.fx.speeds[ option ] ) {
            return true;
        }
    
        // Invalid strings - treat as "normal" speed
        if ( typeof option === "string" && !$.effects.effect[ option ] ) {
            return true;
        }
    
        // Complete callback
        if ( $.isFunction( option ) ) {
            return true;
        }
    
        // Options hash (but not naming an effect)
        if ( typeof option === "object" && !option.effect ) {
            return true;
        }
    
        // Didn't match any standard API
        return false;
    }
    
    $.fn.extend( {
        effect: function( /* effect, options, speed, callback */ ) {
            var args = _normalizeArguments.apply( this, arguments ),
                effectMethod = $.effects.effect[ args.effect ],
                defaultMode = effectMethod.mode,
                queue = args.queue,
                queueName = queue || "fx",
                complete = args.complete,
                mode = args.mode,
                modes = [],
                prefilter = function( next ) {
                    var el = $( this ),
                        normalizedMode = $.effects.mode( el, mode ) || defaultMode;
    
                    // Sentinel for duck-punching the :animated psuedo-selector
                    el.data( dataSpaceAnimated, true );
    
                    // Save effect mode for later use,
                    // we can't just call $.effects.mode again later,
                    // as the .show() below destroys the initial state
                    modes.push( normalizedMode );
    
                    // See $.uiBackCompat inside of run() for removal of defaultMode in 1.13
                    if ( defaultMode && ( normalizedMode === "show" ||
                            ( normalizedMode === defaultMode && normalizedMode === "hide" ) ) ) {
                        el.show();
                    }
    
                    if ( !defaultMode || normalizedMode !== "none" ) {
                        $.effects.saveStyle( el );
                    }
    
                    if ( $.isFunction( next ) ) {
                        next();
                    }
                };
    
            if ( $.fx.off || !effectMethod ) {
    
                // Delegate to the original method (e.g., .show()) if possible
                if ( mode ) {
                    return this[ mode ]( args.duration, complete );
                } else {
                    return this.each( function() {
                        if ( complete ) {
                            complete.call( this );
                        }
                    } );
                }
            }
    
            function run( next ) {
                var elem = $( this );
    
                function cleanup() {
                    elem.removeData( dataSpaceAnimated );
    
                    $.effects.cleanUp( elem );
    
                    if ( args.mode === "hide" ) {
                        elem.hide();
                    }
    
                    done();
                }
    
                function done() {
                    if ( $.isFunction( complete ) ) {
                        complete.call( elem[ 0 ] );
                    }
    
                    if ( $.isFunction( next ) ) {
                        next();
                    }
                }
    
                // Override mode option on a per element basis,
                // as toggle can be either show or hide depending on element state
                args.mode = modes.shift();
    
                if ( $.uiBackCompat !== false && !defaultMode ) {
                    if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {
    
                        // Call the core method to track "olddisplay" properly
                        elem[ mode ]();
                        done();
                    } else {
                        effectMethod.call( elem[ 0 ], args, done );
                    }
                } else {
                    if ( args.mode === "none" ) {
    
                        // Call the core method to track "olddisplay" properly
                        elem[ mode ]();
                        done();
                    } else {
                        effectMethod.call( elem[ 0 ], args, cleanup );
                    }
                }
            }
    
            // Run prefilter on all elements first to ensure that
            // any showing or hiding happens before placeholder creation,
            // which ensures that any layout changes are correctly captured.
            return queue === false ?
                this.each( prefilter ).each( run ) :
                this.queue( queueName, prefilter ).queue( queueName, run );
        },
    
        show: ( function( orig ) {
            return function( option ) {
                if ( standardAnimationOption( option ) ) {
                    return orig.apply( this, arguments );
                } else {
                    var args = _normalizeArguments.apply( this, arguments );
                    args.mode = "show";
                    return this.effect.call( this, args );
                }
            };
        } )( $.fn.show ),
    
        hide: ( function( orig ) {
            return function( option ) {
                if ( standardAnimationOption( option ) ) {
                    return orig.apply( this, arguments );
                } else {
                    var args = _normalizeArguments.apply( this, arguments );
                    args.mode = "hide";
                    return this.effect.call( this, args );
                }
            };
        } )( $.fn.hide ),
    
        toggle: ( function( orig ) {
            return function( option ) {
                if ( standardAnimationOption( option ) || typeof option === "boolean" ) {
                    return orig.apply( this, arguments );
                } else {
                    var args = _normalizeArguments.apply( this, arguments );
                    args.mode = "toggle";
                    return this.effect.call( this, args );
                }
            };
        } )( $.fn.toggle ),
    
        cssUnit: function( key ) {
            var style = this.css( key ),
                val = [];
    
            $.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
                if ( style.indexOf( unit ) > 0 ) {
                    val = [ parseFloat( style ), unit ];
                }
            } );
            return val;
        },
    
        cssClip: function( clipObj ) {
            if ( clipObj ) {
                return this.css( "clip", "rect(" + clipObj.top + "px " + clipObj.right + "px " +
                    clipObj.bottom + "px " + clipObj.left + "px)" );
            }
            return parseClip( this.css( "clip" ), this );
        },
    
        transfer: function( options, done ) {
            var element = $( this ),
                target = $( options.to ),
                targetFixed = target.css( "position" ) === "fixed",
                body = $( "body" ),
                fixTop = targetFixed ? body.scrollTop() : 0,
                fixLeft = targetFixed ? body.scrollLeft() : 0,
                endPosition = target.offset(),
                animation = {
                    top: endPosition.top - fixTop,
                    left: endPosition.left - fixLeft,
                    height: target.innerHeight(),
                    width: target.innerWidth()
                },
                startPosition = element.offset(),
                transfer = $( "<div class='ui-effects-transfer'></div>" )
                    .appendTo( "body" )
                    .addClass( options.className )
                    .css( {
                        top: startPosition.top - fixTop,
                        left: startPosition.left - fixLeft,
                        height: element.innerHeight(),
                        width: element.innerWidth(),
                        position: targetFixed ? "fixed" : "absolute"
                    } )
                    .animate( animation, options.duration, options.easing, function() {
                        transfer.remove();
                        if ( $.isFunction( done ) ) {
                            done();
                        }
                    } );
        }
    } );
    
    function parseClip( str, element ) {
            var outerWidth = element.outerWidth(),
                outerHeight = element.outerHeight(),
                clipRegex = /^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/,
                values = clipRegex.exec( str ) || [ "", 0, outerWidth, outerHeight, 0 ];
    
            return {
                top: parseFloat( values[ 1 ] ) || 0,
                right: values[ 2 ] === "auto" ? outerWidth : parseFloat( values[ 2 ] ),
                bottom: values[ 3 ] === "auto" ? outerHeight : parseFloat( values[ 3 ] ),
                left: parseFloat( values[ 4 ] ) || 0
            };
    }
    
    $.fx.step.clip = function( fx ) {
        if ( !fx.clipInit ) {
            fx.start = $( fx.elem ).cssClip();
            if ( typeof fx.end === "string" ) {
                fx.end = parseClip( fx.end, fx.elem );
            }
            fx.clipInit = true;
        }
    
        $( fx.elem ).cssClip( {
            top: fx.pos * ( fx.end.top - fx.start.top ) + fx.start.top,
            right: fx.pos * ( fx.end.right - fx.start.right ) + fx.start.right,
            bottom: fx.pos * ( fx.end.bottom - fx.start.bottom ) + fx.start.bottom,
            left: fx.pos * ( fx.end.left - fx.start.left ) + fx.start.left
        } );
    };
    
    } )();
    
    /******************************************************************************/
    /*********************************** EASING ***********************************/
    /******************************************************************************/
    
    ( function() {
    
    // Based on easing equations from Robert Penner (http://www.robertpenner.com/easing)
    
    var baseEasings = {};
    
    $.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
        baseEasings[ name ] = function( p ) {
            return Math.pow( p, i + 2 );
        };
    } );
    
    $.extend( baseEasings, {
        Sine: function( p ) {
            return 1 - Math.cos( p * Math.PI / 2 );
        },
        Circ: function( p ) {
            return 1 - Math.sqrt( 1 - p * p );
        },
        Elastic: function( p ) {
            return p === 0 || p === 1 ? p :
                -Math.pow( 2, 8 * ( p - 1 ) ) * Math.sin( ( ( p - 1 ) * 80 - 7.5 ) * Math.PI / 15 );
        },
        Back: function( p ) {
            return p * p * ( 3 * p - 2 );
        },
        Bounce: function( p ) {
            var pow2,
                bounce = 4;
    
            while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
            return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
        }
    } );
    
    $.each( baseEasings, function( name, easeIn ) {
        $.easing[ "easeIn" + name ] = easeIn;
        $.easing[ "easeOut" + name ] = function( p ) {
            return 1 - easeIn( 1 - p );
        };
        $.easing[ "easeInOut" + name ] = function( p ) {
            return p < 0.5 ?
                easeIn( p * 2 ) / 2 :
                1 - easeIn( p * -2 + 2 ) / 2;
        };
    } );
    
    } )();
    
    var effect = $.effects;
    
    
    /*!
     * jQuery UI Effects Blind 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Blind Effect
    //>>group: Effects
    //>>description: Blinds the element.
    //>>docs: http://api.jqueryui.com/blind-effect/
    //>>demos: http://jqueryui.com/effect/
    
    
    
    var effectsEffectBlind = $.effects.define( "blind", "hide", function( options, done ) {
        var map = {
                up: [ "bottom", "top" ],
                vertical: [ "bottom", "top" ],
                down: [ "top", "bottom" ],
                left: [ "right", "left" ],
                horizontal: [ "right", "left" ],
                right: [ "left", "right" ]
            },
            element = $( this ),
            direction = options.direction || "up",
            start = element.cssClip(),
            animate = { clip: $.extend( {}, start ) },
            placeholder = $.effects.createPlaceholder( element );
    
        animate.clip[ map[ direction ][ 0 ] ] = animate.clip[ map[ direction ][ 1 ] ];
    
        if ( options.mode === "show" ) {
            element.cssClip( animate.clip );
            if ( placeholder ) {
                placeholder.css( $.effects.clipToBox( animate ) );
            }
    
            animate.clip = start;
        }
    
        if ( placeholder ) {
            placeholder.animate( $.effects.clipToBox( animate ), options.duration, options.easing );
        }
    
        element.animate( animate, {
            queue: false,
            duration: options.duration,
            easing: options.easing,
            complete: done
        } );
    } );
    
    
    /*!
     * jQuery UI Effects Bounce 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Bounce Effect
    //>>group: Effects
    //>>description: Bounces an element horizontally or vertically n times.
    //>>docs: http://api.jqueryui.com/bounce-effect/
    //>>demos: http://jqueryui.com/effect/
    
    
    
    var effectsEffectBounce = $.effects.define( "bounce", function( options, done ) {
        var upAnim, downAnim, refValue,
            element = $( this ),
    
            // Defaults:
            mode = options.mode,
            hide = mode === "hide",
            show = mode === "show",
            direction = options.direction || "up",
            distance = options.distance,
            times = options.times || 5,
    
            // Number of internal animations
            anims = times * 2 + ( show || hide ? 1 : 0 ),
            speed = options.duration / anims,
            easing = options.easing,
    
            // Utility:
            ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
            motion = ( direction === "up" || direction === "left" ),
            i = 0,
    
            queuelen = element.queue().length;
    
        $.effects.createPlaceholder( element );
    
        refValue = element.css( ref );
    
        // Default distance for the BIGGEST bounce is the outer Distance / 3
        if ( !distance ) {
            distance = element[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;
        }
    
        if ( show ) {
            downAnim = { opacity: 1 };
            downAnim[ ref ] = refValue;
    
            // If we are showing, force opacity 0 and set the initial position
            // then do the "first" animation
            element
                .css( "opacity", 0 )
                .css( ref, motion ? -distance * 2 : distance * 2 )
                .animate( downAnim, speed, easing );
        }
    
        // Start at the smallest distance if we are hiding
        if ( hide ) {
            distance = distance / Math.pow( 2, times - 1 );
        }
    
        downAnim = {};
        downAnim[ ref ] = refValue;
    
        // Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
        for ( ; i < times; i++ ) {
            upAnim = {};
            upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;
    
            element
                .animate( upAnim, speed, easing )
                .animate( downAnim, speed, easing );
    
            distance = hide ? distance * 2 : distance / 2;
        }
    
        // Last Bounce when Hiding
        if ( hide ) {
            upAnim = { opacity: 0 };
            upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;
    
            element.animate( upAnim, speed, easing );
        }
    
        element.queue( done );
    
        $.effects.unshift( element, queuelen, anims + 1 );
    } );
    
    
    /*!
     * jQuery UI Effects Clip 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Clip Effect
    //>>group: Effects
    //>>description: Clips the element on and off like an old TV.
    //>>docs: http://api.jqueryui.com/clip-effect/
    //>>demos: http://jqueryui.com/effect/
    
    
    
    var effectsEffectClip = $.effects.define( "clip", "hide", function( options, done ) {
        var start,
            animate = {},
            element = $( this ),
            direction = options.direction || "vertical",
            both = direction === "both",
            horizontal = both || direction === "horizontal",
            vertical = both || direction === "vertical";
    
        start = element.cssClip();
        animate.clip = {
            top: vertical ? ( start.bottom - start.top ) / 2 : start.top,
            right: horizontal ? ( start.right - start.left ) / 2 : start.right,
            bottom: vertical ? ( start.bottom - start.top ) / 2 : start.bottom,
            left: horizontal ? ( start.right - start.left ) / 2 : start.left
        };
    
        $.effects.createPlaceholder( element );
    
        if ( options.mode === "show" ) {
            element.cssClip( animate.clip );
            animate.clip = start;
        }
    
        element.animate( animate, {
            queue: false,
            duration: options.duration,
            easing: options.easing,
            complete: done
        } );
    
    } );
    
    
    /*!
     * jQuery UI Effects Drop 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Drop Effect
    //>>group: Effects
    //>>description: Moves an element in one direction and hides it at the same time.
    //>>docs: http://api.jqueryui.com/drop-effect/
    //>>demos: http://jqueryui.com/effect/
    
    
    
    var effectsEffectDrop = $.effects.define( "drop", "hide", function( options, done ) {
    
        var distance,
            element = $( this ),
            mode = options.mode,
            show = mode === "show",
            direction = options.direction || "left",
            ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
            motion = ( direction === "up" || direction === "left" ) ? "-=" : "+=",
            oppositeMotion = ( motion === "+=" ) ? "-=" : "+=",
            animation = {
                opacity: 0
            };
    
        $.effects.createPlaceholder( element );
    
        distance = options.distance ||
            element[ ref === "top" ? "outerHeight" : "outerWidth" ]( true ) / 2;
    
        animation[ ref ] = motion + distance;
    
        if ( show ) {
            element.css( animation );
    
            animation[ ref ] = oppositeMotion + distance;
            animation.opacity = 1;
        }
    
        // Animate
        element.animate( animation, {
            queue: false,
            duration: options.duration,
            easing: options.easing,
            complete: done
        } );
    } );
    
    
    /*!
     * jQuery UI Effects Explode 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Explode Effect
    //>>group: Effects
    // jscs:disable maximumLineLength
    //>>description: Explodes an element in all directions into n pieces. Implodes an element to its original wholeness.
    // jscs:enable maximumLineLength
    //>>docs: http://api.jqueryui.com/explode-effect/
    //>>demos: http://jqueryui.com/effect/
    
    
    
    var effectsEffectExplode = $.effects.define( "explode", "hide", function( options, done ) {
    
        var i, j, left, top, mx, my,
            rows = options.pieces ? Math.round( Math.sqrt( options.pieces ) ) : 3,
            cells = rows,
            element = $( this ),
            mode = options.mode,
            show = mode === "show",
    
            // Show and then visibility:hidden the element before calculating offset
            offset = element.show().css( "visibility", "hidden" ).offset(),
    
            // Width and height of a piece
            width = Math.ceil( element.outerWidth() / cells ),
            height = Math.ceil( element.outerHeight() / rows ),
            pieces = [];
    
        // Children animate complete:
        function childComplete() {
            pieces.push( this );
            if ( pieces.length === rows * cells ) {
                animComplete();
            }
        }
    
        // Clone the element for each row and cell.
        for ( i = 0; i < rows; i++ ) { // ===>
            top = offset.top + i * height;
            my = i - ( rows - 1 ) / 2;
    
            for ( j = 0; j < cells; j++ ) { // |||
                left = offset.left + j * width;
                mx = j - ( cells - 1 ) / 2;
    
                // Create a clone of the now hidden main element that will be absolute positioned
                // within a wrapper div off the -left and -top equal to size of our pieces
                element
                    .clone()
                    .appendTo( "body" )
                    .wrap( "<div></div>" )
                    .css( {
                        position: "absolute",
                        visibility: "visible",
                        left: -j * width,
                        top: -i * height
                    } )
    
                    // Select the wrapper - make it overflow: hidden and absolute positioned based on
                    // where the original was located +left and +top equal to the size of pieces
                    .parent()
                        .addClass( "ui-effects-explode" )
                        .css( {
                            position: "absolute",
                            overflow: "hidden",
                            width: width,
                            height: height,
                            left: left + ( show ? mx * width : 0 ),
                            top: top + ( show ? my * height : 0 ),
                            opacity: show ? 0 : 1
                        } )
                        .animate( {
                            left: left + ( show ? 0 : mx * width ),
                            top: top + ( show ? 0 : my * height ),
                            opacity: show ? 1 : 0
                        }, options.duration || 500, options.easing, childComplete );
            }
        }
    
        function animComplete() {
            element.css( {
                visibility: "visible"
            } );
            $( pieces ).remove();
            done();
        }
    } );
    
    
    /*!
     * jQuery UI Effects Fade 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Fade Effect
    //>>group: Effects
    //>>description: Fades the element.
    //>>docs: http://api.jqueryui.com/fade-effect/
    //>>demos: http://jqueryui.com/effect/
    
    
    
    var effectsEffectFade = $.effects.define( "fade", "toggle", function( options, done ) {
        var show = options.mode === "show";
    
        $( this )
            .css( "opacity", show ? 0 : 1 )
            .animate( {
                opacity: show ? 1 : 0
            }, {
                queue: false,
                duration: options.duration,
                easing: options.easing,
                complete: done
            } );
    } );
    
    
    /*!
     * jQuery UI Effects Fold 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Fold Effect
    //>>group: Effects
    //>>description: Folds an element first horizontally and then vertically.
    //>>docs: http://api.jqueryui.com/fold-effect/
    //>>demos: http://jqueryui.com/effect/
    
    
    
    var effectsEffectFold = $.effects.define( "fold", "hide", function( options, done ) {
    
        // Create element
        var element = $( this ),
            mode = options.mode,
            show = mode === "show",
            hide = mode === "hide",
            size = options.size || 15,
            percent = /([0-9]+)%/.exec( size ),
            horizFirst = !!options.horizFirst,
            ref = horizFirst ? [ "right", "bottom" ] : [ "bottom", "right" ],
            duration = options.duration / 2,
    
            placeholder = $.effects.createPlaceholder( element ),
    
            start = element.cssClip(),
            animation1 = { clip: $.extend( {}, start ) },
            animation2 = { clip: $.extend( {}, start ) },
    
            distance = [ start[ ref[ 0 ] ], start[ ref[ 1 ] ] ],
    
            queuelen = element.queue().length;
    
        if ( percent ) {
            size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];
        }
        animation1.clip[ ref[ 0 ] ] = size;
        animation2.clip[ ref[ 0 ] ] = size;
        animation2.clip[ ref[ 1 ] ] = 0;
    
        if ( show ) {
            element.cssClip( animation2.clip );
            if ( placeholder ) {
                placeholder.css( $.effects.clipToBox( animation2 ) );
            }
    
            animation2.clip = start;
        }
    
        // Animate
        element
            .queue( function( next ) {
                if ( placeholder ) {
                    placeholder
                        .animate( $.effects.clipToBox( animation1 ), duration, options.easing )
                        .animate( $.effects.clipToBox( animation2 ), duration, options.easing );
                }
    
                next();
            } )
            .animate( animation1, duration, options.easing )
            .animate( animation2, duration, options.easing )
            .queue( done );
    
        $.effects.unshift( element, queuelen, 4 );
    } );
    
    
    /*!
     * jQuery UI Effects Highlight 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Highlight Effect
    //>>group: Effects
    //>>description: Highlights the background of an element in a defined color for a custom duration.
    //>>docs: http://api.jqueryui.com/highlight-effect/
    //>>demos: http://jqueryui.com/effect/
    
    
    
    var effectsEffectHighlight = $.effects.define( "highlight", "show", function( options, done ) {
        var element = $( this ),
            animation = {
                backgroundColor: element.css( "backgroundColor" )
            };
    
        if ( options.mode === "hide" ) {
            animation.opacity = 0;
        }
    
        $.effects.saveStyle( element );
    
        element
            .css( {
                backgroundImage: "none",
                backgroundColor: options.color || "#ffff99"
            } )
            .animate( animation, {
                queue: false,
                duration: options.duration,
                easing: options.easing,
                complete: done
            } );
    } );
    
    
    /*!
     * jQuery UI Effects Size 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Size Effect
    //>>group: Effects
    //>>description: Resize an element to a specified width and height.
    //>>docs: http://api.jqueryui.com/size-effect/
    //>>demos: http://jqueryui.com/effect/
    
    
    
    var effectsEffectSize = $.effects.define( "size", function( options, done ) {
    
        // Create element
        var baseline, factor, temp,
            element = $( this ),
    
            // Copy for children
            cProps = [ "fontSize" ],
            vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],
            hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],
    
            // Set options
            mode = options.mode,
            restore = mode !== "effect",
            scale = options.scale || "both",
            origin = options.origin || [ "middle", "center" ],
            position = element.css( "position" ),
            pos = element.position(),
            original = $.effects.scaledDimensions( element ),
            from = options.from || original,
            to = options.to || $.effects.scaledDimensions( element, 0 );
    
        $.effects.createPlaceholder( element );
    
        if ( mode === "show" ) {
            temp = from;
            from = to;
            to = temp;
        }
    
        // Set scaling factor
        factor = {
            from: {
                y: from.height / original.height,
                x: from.width / original.width
            },
            to: {
                y: to.height / original.height,
                x: to.width / original.width
            }
        };
    
        // Scale the css box
        if ( scale === "box" || scale === "both" ) {
    
            // Vertical props scaling
            if ( factor.from.y !== factor.to.y ) {
                from = $.effects.setTransition( element, vProps, factor.from.y, from );
                to = $.effects.setTransition( element, vProps, factor.to.y, to );
            }
    
            // Horizontal props scaling
            if ( factor.from.x !== factor.to.x ) {
                from = $.effects.setTransition( element, hProps, factor.from.x, from );
                to = $.effects.setTransition( element, hProps, factor.to.x, to );
            }
        }
    
        // Scale the content
        if ( scale === "content" || scale === "both" ) {
    
            // Vertical props scaling
            if ( factor.from.y !== factor.to.y ) {
                from = $.effects.setTransition( element, cProps, factor.from.y, from );
                to = $.effects.setTransition( element, cProps, factor.to.y, to );
            }
        }
    
        // Adjust the position properties based on the provided origin points
        if ( origin ) {
            baseline = $.effects.getBaseline( origin, original );
            from.top = ( original.outerHeight - from.outerHeight ) * baseline.y + pos.top;
            from.left = ( original.outerWidth - from.outerWidth ) * baseline.x + pos.left;
            to.top = ( original.outerHeight - to.outerHeight ) * baseline.y + pos.top;
            to.left = ( original.outerWidth - to.outerWidth ) * baseline.x + pos.left;
        }
        element.css( from );
    
        // Animate the children if desired
        if ( scale === "content" || scale === "both" ) {
    
            vProps = vProps.concat( [ "marginTop", "marginBottom" ] ).concat( cProps );
            hProps = hProps.concat( [ "marginLeft", "marginRight" ] );
    
            // Only animate children with width attributes specified
            // TODO: is this right? should we include anything with css width specified as well
            element.find( "*[width]" ).each( function() {
                var child = $( this ),
                    childOriginal = $.effects.scaledDimensions( child ),
                    childFrom = {
                        height: childOriginal.height * factor.from.y,
                        width: childOriginal.width * factor.from.x,
                        outerHeight: childOriginal.outerHeight * factor.from.y,
                        outerWidth: childOriginal.outerWidth * factor.from.x
                    },
                    childTo = {
                        height: childOriginal.height * factor.to.y,
                        width: childOriginal.width * factor.to.x,
                        outerHeight: childOriginal.height * factor.to.y,
                        outerWidth: childOriginal.width * factor.to.x
                    };
    
                // Vertical props scaling
                if ( factor.from.y !== factor.to.y ) {
                    childFrom = $.effects.setTransition( child, vProps, factor.from.y, childFrom );
                    childTo = $.effects.setTransition( child, vProps, factor.to.y, childTo );
                }
    
                // Horizontal props scaling
                if ( factor.from.x !== factor.to.x ) {
                    childFrom = $.effects.setTransition( child, hProps, factor.from.x, childFrom );
                    childTo = $.effects.setTransition( child, hProps, factor.to.x, childTo );
                }
    
                if ( restore ) {
                    $.effects.saveStyle( child );
                }
    
                // Animate children
                child.css( childFrom );
                child.animate( childTo, options.duration, options.easing, function() {
    
                    // Restore children
                    if ( restore ) {
                        $.effects.restoreStyle( child );
                    }
                } );
            } );
        }
    
        // Animate
        element.animate( to, {
            queue: false,
            duration: options.duration,
            easing: options.easing,
            complete: function() {
    
                var offset = element.offset();
    
                if ( to.opacity === 0 ) {
                    element.css( "opacity", from.opacity );
                }
    
                if ( !restore ) {
                    element
                        .css( "position", position === "static" ? "relative" : position )
                        .offset( offset );
    
                    // Need to save style here so that automatic style restoration
                    // doesn't restore to the original styles from before the animation.
                    $.effects.saveStyle( element );
                }
    
                done();
            }
        } );
    
    } );
    
    
    /*!
     * jQuery UI Effects Scale 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Scale Effect
    //>>group: Effects
    //>>description: Grows or shrinks an element and its content.
    //>>docs: http://api.jqueryui.com/scale-effect/
    //>>demos: http://jqueryui.com/effect/
    
    
    
    var effectsEffectScale = $.effects.define( "scale", function( options, done ) {
    
        // Create element
        var el = $( this ),
            mode = options.mode,
            percent = parseInt( options.percent, 10 ) ||
                ( parseInt( options.percent, 10 ) === 0 ? 0 : ( mode !== "effect" ? 0 : 100 ) ),
    
            newOptions = $.extend( true, {
                from: $.effects.scaledDimensions( el ),
                to: $.effects.scaledDimensions( el, percent, options.direction || "both" ),
                origin: options.origin || [ "middle", "center" ]
            }, options );
    
        // Fade option to support puff
        if ( options.fade ) {
            newOptions.from.opacity = 1;
            newOptions.to.opacity = 0;
        }
    
        $.effects.effect.size.call( this, newOptions, done );
    } );
    
    
    /*!
     * jQuery UI Effects Puff 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Puff Effect
    //>>group: Effects
    //>>description: Creates a puff effect by scaling the element up and hiding it at the same time.
    //>>docs: http://api.jqueryui.com/puff-effect/
    //>>demos: http://jqueryui.com/effect/
    
    
    
    var effectsEffectPuff = $.effects.define( "puff", "hide", function( options, done ) {
        var newOptions = $.extend( true, {}, options, {
            fade: true,
            percent: parseInt( options.percent, 10 ) || 150
        } );
    
        $.effects.effect.scale.call( this, newOptions, done );
    } );
    
    
    /*!
     * jQuery UI Effects Pulsate 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Pulsate Effect
    //>>group: Effects
    //>>description: Pulsates an element n times by changing the opacity to zero and back.
    //>>docs: http://api.jqueryui.com/pulsate-effect/
    //>>demos: http://jqueryui.com/effect/
    
    
    
    var effectsEffectPulsate = $.effects.define( "pulsate", "show", function( options, done ) {
        var element = $( this ),
            mode = options.mode,
            show = mode === "show",
            hide = mode === "hide",
            showhide = show || hide,
    
            // Showing or hiding leaves off the "last" animation
            anims = ( ( options.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
            duration = options.duration / anims,
            animateTo = 0,
            i = 1,
            queuelen = element.queue().length;
    
        if ( show || !element.is( ":visible" ) ) {
            element.css( "opacity", 0 ).show();
            animateTo = 1;
        }
    
        // Anims - 1 opacity "toggles"
        for ( ; i < anims; i++ ) {
            element.animate( { opacity: animateTo }, duration, options.easing );
            animateTo = 1 - animateTo;
        }
    
        element.animate( { opacity: animateTo }, duration, options.easing );
    
        element.queue( done );
    
        $.effects.unshift( element, queuelen, anims + 1 );
    } );
    
    
    /*!
     * jQuery UI Effects Shake 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Shake Effect
    //>>group: Effects
    //>>description: Shakes an element horizontally or vertically n times.
    //>>docs: http://api.jqueryui.com/shake-effect/
    //>>demos: http://jqueryui.com/effect/
    
    
    
    var effectsEffectShake = $.effects.define( "shake", function( options, done ) {
    
        var i = 1,
            element = $( this ),
            direction = options.direction || "left",
            distance = options.distance || 20,
            times = options.times || 3,
            anims = times * 2 + 1,
            speed = Math.round( options.duration / anims ),
            ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
            positiveMotion = ( direction === "up" || direction === "left" ),
            animation = {},
            animation1 = {},
            animation2 = {},
    
            queuelen = element.queue().length;
    
        $.effects.createPlaceholder( element );
    
        // Animation
        animation[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance;
        animation1[ ref ] = ( positiveMotion ? "+=" : "-=" ) + distance * 2;
        animation2[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance * 2;
    
        // Animate
        element.animate( animation, speed, options.easing );
    
        // Shakes
        for ( ; i < times; i++ ) {
            element
                .animate( animation1, speed, options.easing )
                .animate( animation2, speed, options.easing );
        }
    
        element
            .animate( animation1, speed, options.easing )
            .animate( animation, speed / 2, options.easing )
            .queue( done );
    
        $.effects.unshift( element, queuelen, anims + 1 );
    } );
    
    
    /*!
     * jQuery UI Effects Slide 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Slide Effect
    //>>group: Effects
    //>>description: Slides an element in and out of the viewport.
    //>>docs: http://api.jqueryui.com/slide-effect/
    //>>demos: http://jqueryui.com/effect/
    
    
    
    var effectsEffectSlide = $.effects.define( "slide", "show", function( options, done ) {
        var startClip, startRef,
            element = $( this ),
            map = {
                up: [ "bottom", "top" ],
                down: [ "top", "bottom" ],
                left: [ "right", "left" ],
                right: [ "left", "right" ]
            },
            mode = options.mode,
            direction = options.direction || "left",
            ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
            positiveMotion = ( direction === "up" || direction === "left" ),
            distance = options.distance ||
                element[ ref === "top" ? "outerHeight" : "outerWidth" ]( true ),
            animation = {};
    
        $.effects.createPlaceholder( element );
    
        startClip = element.cssClip();
        startRef = element.position()[ ref ];
    
        // Define hide animation
        animation[ ref ] = ( positiveMotion ? -1 : 1 ) * distance + startRef;
        animation.clip = element.cssClip();
        animation.clip[ map[ direction ][ 1 ] ] = animation.clip[ map[ direction ][ 0 ] ];
    
        // Reverse the animation if we're showing
        if ( mode === "show" ) {
            element.cssClip( animation.clip );
            element.css( ref, animation[ ref ] );
            animation.clip = startClip;
            animation[ ref ] = startRef;
        }
    
        // Actually animate
        element.animate( animation, {
            queue: false,
            duration: options.duration,
            easing: options.easing,
            complete: done
        } );
    } );
    
    
    /*!
     * jQuery UI Effects Transfer 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Transfer Effect
    //>>group: Effects
    //>>description: Displays a transfer effect from one element to another.
    //>>docs: http://api.jqueryui.com/transfer-effect/
    //>>demos: http://jqueryui.com/effect/
    
    
    
    var effect;
    if ( $.uiBackCompat !== false ) {
        effect = $.effects.define( "transfer", function( options, done ) {
            $( this ).transfer( options, done );
        } );
    }
    var effectsEffectTransfer = effect;
    
    
    /*!
     * jQuery UI Focusable 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: :focusable Selector
    //>>group: Core
    //>>description: Selects elements which can be focused.
    //>>docs: http://api.jqueryui.com/focusable-selector/
    
    
    
    // Selectors
    $.ui.focusable = function( element, hasTabindex ) {
        var map, mapName, img, focusableIfVisible, fieldset,
            nodeName = element.nodeName.toLowerCase();
    
        if ( "area" === nodeName ) {
            map = element.parentNode;
            mapName = map.name;
            if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
                return false;
            }
            img = $( "img[usemap='#" + mapName + "']" );
            return img.length > 0 && img.is( ":visible" );
        }
    
        if ( /^(input|select|textarea|button|object)$/.test( nodeName ) ) {
            focusableIfVisible = !element.disabled;
    
            if ( focusableIfVisible ) {
    
                // Form controls within a disabled fieldset are disabled.
                // However, controls within the fieldset's legend do not get disabled.
                // Since controls generally aren't placed inside legends, we skip
                // this portion of the check.
                fieldset = $( element ).closest( "fieldset" )[ 0 ];
                if ( fieldset ) {
                    focusableIfVisible = !fieldset.disabled;
                }
            }
        } else if ( "a" === nodeName ) {
            focusableIfVisible = element.href || hasTabindex;
        } else {
            focusableIfVisible = hasTabindex;
        }
    
        return focusableIfVisible && $( element ).is( ":visible" ) && visible( $( element ) );
    };
    
    // Support: IE 8 only
    // IE 8 doesn't resolve inherit to visible/hidden for computed values
    function visible( element ) {
        var visibility = element.css( "visibility" );
        while ( visibility === "inherit" ) {
            element = element.parent();
            visibility = element.css( "visibility" );
        }
        return visibility !== "hidden";
    }
    
    $.extend( $.expr[ ":" ], {
        focusable: function( element ) {
            return $.ui.focusable( element, $.attr( element, "tabindex" ) != null );
        }
    } );
    
    var focusable = $.ui.focusable;
    
    
    
    
    // Support: IE8 Only
    // IE8 does not support the form attribute and when it is supplied. It overwrites the form prop
    // with a string, so we need to find the proper form.
    var form = $.fn.form = function() {
        return typeof this[ 0 ].form === "string" ? this.closest( "form" ) : $( this[ 0 ].form );
    };
    
    
    /*!
     * jQuery UI Form Reset Mixin 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Form Reset Mixin
    //>>group: Core
    //>>description: Refresh input widgets when their form is reset
    //>>docs: http://api.jqueryui.com/form-reset-mixin/
    
    
    
    var formResetMixin = $.ui.formResetMixin = {
        _formResetHandler: function() {
            var form = $( this );
    
            // Wait for the form reset to actually happen before refreshing
            setTimeout( function() {
                var instances = form.data( "ui-form-reset-instances" );
                $.each( instances, function() {
                    this.refresh();
                } );
            } );
        },
    
        _bindFormResetHandler: function() {
            this.form = this.element.form();
            if ( !this.form.length ) {
                return;
            }
    
            var instances = this.form.data( "ui-form-reset-instances" ) || [];
            if ( !instances.length ) {
    
                // We don't use _on() here because we use a single event handler per form
                this.form.on( "reset.ui-form-reset", this._formResetHandler );
            }
            instances.push( this );
            this.form.data( "ui-form-reset-instances", instances );
        },
    
        _unbindFormResetHandler: function() {
            if ( !this.form.length ) {
                return;
            }
    
            var instances = this.form.data( "ui-form-reset-instances" );
            instances.splice( $.inArray( this, instances ), 1 );
            if ( instances.length ) {
                this.form.data( "ui-form-reset-instances", instances );
            } else {
                this.form
                    .removeData( "ui-form-reset-instances" )
                    .off( "reset.ui-form-reset" );
            }
        }
    };
    
    
    /*!
     * jQuery UI Support for jQuery core 1.7.x 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     */
    
    //>>label: jQuery 1.7 Support
    //>>group: Core
    //>>description: Support version 1.7.x of jQuery core
    
    
    
    // Support: jQuery 1.7 only
    // Not a great way to check versions, but since we only support 1.7+ and only
    // need to detect <1.8, this is a simple check that should suffice. Checking
    // for "1.7." would be a bit safer, but the version string is 1.7, not 1.7.0
    // and we'll never reach 1.70.0 (if we do, we certainly won't be supporting
    // 1.7 anymore). See #11197 for why we're not using feature detection.
    if ( $.fn.jquery.substring( 0, 3 ) === "1.7" ) {
    
        // Setters for .innerWidth(), .innerHeight(), .outerWidth(), .outerHeight()
        // Unlike jQuery Core 1.8+, these only support numeric values to set the
        // dimensions in pixels
        $.each( [ "Width", "Height" ], function( i, name ) {
            var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
                type = name.toLowerCase(),
                orig = {
                    innerWidth: $.fn.innerWidth,
                    innerHeight: $.fn.innerHeight,
                    outerWidth: $.fn.outerWidth,
                    outerHeight: $.fn.outerHeight
                };
    
            function reduce( elem, size, border, margin ) {
                $.each( side, function() {
                    size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
                    if ( border ) {
                        size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
                    }
                    if ( margin ) {
                        size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
                    }
                } );
                return size;
            }
    
            $.fn[ "inner" + name ] = function( size ) {
                if ( size === undefined ) {
                    return orig[ "inner" + name ].call( this );
                }
    
                return this.each( function() {
                    $( this ).css( type, reduce( this, size ) + "px" );
                } );
            };
    
            $.fn[ "outer" + name ] = function( size, margin ) {
                if ( typeof size !== "number" ) {
                    return orig[ "outer" + name ].call( this, size );
                }
    
                return this.each( function() {
                    $( this ).css( type, reduce( this, size, true, margin ) + "px" );
                } );
            };
        } );
    
        $.fn.addBack = function( selector ) {
            return this.add( selector == null ?
                this.prevObject : this.prevObject.filter( selector )
            );
        };
    }
    
    ;
    /*!
     * jQuery UI Keycode 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Keycode
    //>>group: Core
    //>>description: Provide keycodes as keynames
    //>>docs: http://api.jqueryui.com/jQuery.ui.keyCode/
    
    
    var keycode = $.ui.keyCode = {
        BACKSPACE: 8,
        COMMA: 188,
        DELETE: 46,
        DOWN: 40,
        END: 35,
        ENTER: 13,
        ESCAPE: 27,
        HOME: 36,
        LEFT: 37,
        PAGE_DOWN: 34,
        PAGE_UP: 33,
        PERIOD: 190,
        RIGHT: 39,
        SPACE: 32,
        TAB: 9,
        UP: 38
    };
    
    
    
    
    // Internal use only
    var escapeSelector = $.ui.escapeSelector = ( function() {
        var selectorEscape = /([!"#$%&'()*+,./:;<=>?@[\]^`{|}~])/g;
        return function( selector ) {
            return selector.replace( selectorEscape, "\\$1" );
        };
    } )();
    
    
    /*!
     * jQuery UI Labels 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: labels
    //>>group: Core
    //>>description: Find all the labels associated with a given input
    //>>docs: http://api.jqueryui.com/labels/
    
    
    
    var labels = $.fn.labels = function() {
        var ancestor, selector, id, labels, ancestors;
    
        // Check control.labels first
        if ( this[ 0 ].labels && this[ 0 ].labels.length ) {
            return this.pushStack( this[ 0 ].labels );
        }
    
        // Support: IE <= 11, FF <= 37, Android <= 2.3 only
        // Above browsers do not support control.labels. Everything below is to support them
        // as well as document fragments. control.labels does not work on document fragments
        labels = this.eq( 0 ).parents( "label" );
    
        // Look for the label based on the id
        id = this.attr( "id" );
        if ( id ) {
    
            // We don't search against the document in case the element
            // is disconnected from the DOM
            ancestor = this.eq( 0 ).parents().last();
    
            // Get a full set of top level ancestors
            ancestors = ancestor.add( ancestor.length ? ancestor.siblings() : this.siblings() );
    
            // Create a selector for the label based on the id
            selector = "label[for='" + $.ui.escapeSelector( id ) + "']";
    
            labels = labels.add( ancestors.find( selector ).addBack( selector ) );
    
        }
    
        // Return whatever we have found for labels
        return this.pushStack( labels );
    };
    
    
    /*!
     * jQuery UI Scroll Parent 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: scrollParent
    //>>group: Core
    //>>description: Get the closest ancestor element that is scrollable.
    //>>docs: http://api.jqueryui.com/scrollParent/
    
    
    
    var scrollParent = $.fn.scrollParent = function( includeHidden ) {
        var position = this.css( "position" ),
            excludeStaticParent = position === "absolute",
            overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
            scrollParent = this.parents().filter( function() {
                var parent = $( this );
                if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
                    return false;
                }
                return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) +
                    parent.css( "overflow-x" ) );
            } ).eq( 0 );
    
        return position === "fixed" || !scrollParent.length ?
            $( this[ 0 ].ownerDocument || document ) :
            scrollParent;
    };
    
    
    /*!
     * jQuery UI Tabbable 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: :tabbable Selector
    //>>group: Core
    //>>description: Selects elements which can be tabbed to.
    //>>docs: http://api.jqueryui.com/tabbable-selector/
    
    
    
    var tabbable = $.extend( $.expr[ ":" ], {
        tabbable: function( element ) {
            var tabIndex = $.attr( element, "tabindex" ),
                hasTabindex = tabIndex != null;
            return ( !hasTabindex || tabIndex >= 0 ) && $.ui.focusable( element, hasTabindex );
        }
    } );
    
    
    /*!
     * jQuery UI Unique ID 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: uniqueId
    //>>group: Core
    //>>description: Functions to generate and remove uniqueId's
    //>>docs: http://api.jqueryui.com/uniqueId/
    
    
    
    var uniqueId = $.fn.extend( {
        uniqueId: ( function() {
            var uuid = 0;
    
            return function() {
                return this.each( function() {
                    if ( !this.id ) {
                        this.id = "ui-id-" + ( ++uuid );
                    }
                } );
            };
        } )(),
    
        removeUniqueId: function() {
            return this.each( function() {
                if ( /^ui-id-\d+$/.test( this.id ) ) {
                    $( this ).removeAttr( "id" );
                }
            } );
        }
    } );
    
    
    /*!
     * jQuery UI Accordion 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Accordion
    //>>group: Widgets
    // jscs:disable maximumLineLength
    //>>description: Displays collapsible content panels for presenting information in a limited amount of space.
    // jscs:enable maximumLineLength
    //>>docs: http://api.jqueryui.com/accordion/
    //>>demos: http://jqueryui.com/accordion/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/accordion.css
    //>>css.theme: ../../themes/base/theme.css
    
    
    
    var widgetsAccordion = $.widget( "ui.accordion", {
        version: "1.12.1",
        options: {
            active: 0,
            animate: {},
            classes: {
                "ui-accordion-header": "ui-corner-top",
                "ui-accordion-header-collapsed": "ui-corner-all",
                "ui-accordion-content": "ui-corner-bottom"
            },
            collapsible: false,
            event: "click",
            header: "> li > :first-child, > :not(li):even",
            heightStyle: "auto",
            icons: {
                activeHeader: "ui-icon-triangle-1-s",
                header: "ui-icon-triangle-1-e"
            },
    
            // Callbacks
            activate: null,
            beforeActivate: null
        },
    
        hideProps: {
            borderTopWidth: "hide",
            borderBottomWidth: "hide",
            paddingTop: "hide",
            paddingBottom: "hide",
            height: "hide"
        },
    
        showProps: {
            borderTopWidth: "show",
            borderBottomWidth: "show",
            paddingTop: "show",
            paddingBottom: "show",
            height: "show"
        },
    
        _create: function() {
            var options = this.options;
    
            this.prevShow = this.prevHide = $();
            this._addClass( "ui-accordion", "ui-widget ui-helper-reset" );
            this.element.attr( "role", "tablist" );
    
            // Don't allow collapsible: false and active: false / null
            if ( !options.collapsible && ( options.active === false || options.active == null ) ) {
                options.active = 0;
            }
    
            this._processPanels();
    
            // handle negative values
            if ( options.active < 0 ) {
                options.active += this.headers.length;
            }
            this._refresh();
        },
    
        _getCreateEventData: function() {
            return {
                header: this.active,
                panel: !this.active.length ? $() : this.active.next()
            };
        },
    
        _createIcons: function() {
            var icon, children,
                icons = this.options.icons;
    
            if ( icons ) {
                icon = $( "<span>" );
                this._addClass( icon, "ui-accordion-header-icon", "ui-icon " + icons.header );
                icon.prependTo( this.headers );
                children = this.active.children( ".ui-accordion-header-icon" );
                this._removeClass( children, icons.header )
                    ._addClass( children, null, icons.activeHeader )
                    ._addClass( this.headers, "ui-accordion-icons" );
            }
        },
    
        _destroyIcons: function() {
            this._removeClass( this.headers, "ui-accordion-icons" );
            this.headers.children( ".ui-accordion-header-icon" ).remove();
        },
    
        _destroy: function() {
            var contents;
    
            // Clean up main element
            this.element.removeAttr( "role" );
    
            // Clean up headers
            this.headers
                .removeAttr( "role aria-expanded aria-selected aria-controls tabIndex" )
                .removeUniqueId();
    
            this._destroyIcons();
    
            // Clean up content panels
            contents = this.headers.next()
                .css( "display", "" )
                .removeAttr( "role aria-hidden aria-labelledby" )
                .removeUniqueId();
    
            if ( this.options.heightStyle !== "content" ) {
                contents.css( "height", "" );
            }
        },
    
        _setOption: function( key, value ) {
            if ( key === "active" ) {
    
                // _activate() will handle invalid values and update this.options
                this._activate( value );
                return;
            }
    
            if ( key === "event" ) {
                if ( this.options.event ) {
                    this._off( this.headers, this.options.event );
                }
                this._setupEvents( value );
            }
    
            this._super( key, value );
    
            // Setting collapsible: false while collapsed; open first panel
            if ( key === "collapsible" && !value && this.options.active === false ) {
                this._activate( 0 );
            }
    
            if ( key === "icons" ) {
                this._destroyIcons();
                if ( value ) {
                    this._createIcons();
                }
            }
        },
    
        _setOptionDisabled: function( value ) {
            this._super( value );
    
            this.element.attr( "aria-disabled", value );
    
            // Support: IE8 Only
            // #5332 / #6059 - opacity doesn't cascade to positioned elements in IE
            // so we need to add the disabled class to the headers and panels
            this._toggleClass( null, "ui-state-disabled", !!value );
            this._toggleClass( this.headers.add( this.headers.next() ), null, "ui-state-disabled",
                !!value );
        },
    
        _keydown: function( event ) {
            if ( event.altKey || event.ctrlKey ) {
                return;
            }
    
            var keyCode = $.ui.keyCode,
                length = this.headers.length,
                currentIndex = this.headers.index( event.target ),
                toFocus = false;
    
            switch ( event.keyCode ) {
            case keyCode.RIGHT:
            case keyCode.DOWN:
                toFocus = this.headers[ ( currentIndex + 1 ) % length ];
                break;
            case keyCode.LEFT:
            case keyCode.UP:
                toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
                break;
            case keyCode.SPACE:
            case keyCode.ENTER:
                this._eventHandler( event );
                break;
            case keyCode.HOME:
                toFocus = this.headers[ 0 ];
                break;
            case keyCode.END:
                toFocus = this.headers[ length - 1 ];
                break;
            }
    
            if ( toFocus ) {
                $( event.target ).attr( "tabIndex", -1 );
                $( toFocus ).attr( "tabIndex", 0 );
                $( toFocus ).trigger( "focus" );
                event.preventDefault();
            }
        },
    
        _panelKeyDown: function( event ) {
            if ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {
                $( event.currentTarget ).prev().trigger( "focus" );
            }
        },
    
        refresh: function() {
            var options = this.options;
            this._processPanels();
    
            // Was collapsed or no panel
            if ( ( options.active === false && options.collapsible === true ) ||
                    !this.headers.length ) {
                options.active = false;
                this.active = $();
    
            // active false only when collapsible is true
            } else if ( options.active === false ) {
                this._activate( 0 );
    
            // was active, but active panel is gone
            } else if ( this.active.length && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
    
                // all remaining panel are disabled
                if ( this.headers.length === this.headers.find( ".ui-state-disabled" ).length ) {
                    options.active = false;
                    this.active = $();
    
                // activate previous panel
                } else {
                    this._activate( Math.max( 0, options.active - 1 ) );
                }
    
            // was active, active panel still exists
            } else {
    
                // make sure active index is correct
                options.active = this.headers.index( this.active );
            }
    
            this._destroyIcons();
    
            this._refresh();
        },
    
        _processPanels: function() {
            var prevHeaders = this.headers,
                prevPanels = this.panels;
    
            this.headers = this.element.find( this.options.header );
            this._addClass( this.headers, "ui-accordion-header ui-accordion-header-collapsed",
                "ui-state-default" );
    
            this.panels = this.headers.next().filter( ":not(.ui-accordion-content-active)" ).hide();
            this._addClass( this.panels, "ui-accordion-content", "ui-helper-reset ui-widget-content" );
    
            // Avoid memory leaks (#10056)
            if ( prevPanels ) {
                this._off( prevHeaders.not( this.headers ) );
                this._off( prevPanels.not( this.panels ) );
            }
        },
    
        _refresh: function() {
            var maxHeight,
                options = this.options,
                heightStyle = options.heightStyle,
                parent = this.element.parent();
    
            this.active = this._findActive( options.active );
            this._addClass( this.active, "ui-accordion-header-active", "ui-state-active" )
                ._removeClass( this.active, "ui-accordion-header-collapsed" );
            this._addClass( this.active.next(), "ui-accordion-content-active" );
            this.active.next().show();
    
            this.headers
                .attr( "role", "tab" )
                .each( function() {
                    var header = $( this ),
                        headerId = header.uniqueId().attr( "id" ),
                        panel = header.next(),
                        panelId = panel.uniqueId().attr( "id" );
                    header.attr( "aria-controls", panelId );
                    panel.attr( "aria-labelledby", headerId );
                } )
                .next()
                    .attr( "role", "tabpanel" );
    
            this.headers
                .not( this.active )
                    .attr( {
                        "aria-selected": "false",
                        "aria-expanded": "false",
                        tabIndex: -1
                    } )
                    .next()
                        .attr( {
                            "aria-hidden": "true"
                        } )
                        .hide();
    
            // Make sure at least one header is in the tab order
            if ( !this.active.length ) {
                this.headers.eq( 0 ).attr( "tabIndex", 0 );
            } else {
                this.active.attr( {
                    "aria-selected": "true",
                    "aria-expanded": "true",
                    tabIndex: 0
                } )
                    .next()
                        .attr( {
                            "aria-hidden": "false"
                        } );
            }
    
            this._createIcons();
    
            this._setupEvents( options.event );
    
            if ( heightStyle === "fill" ) {
                maxHeight = parent.height();
                this.element.siblings( ":visible" ).each( function() {
                    var elem = $( this ),
                        position = elem.css( "position" );
    
                    if ( position === "absolute" || position === "fixed" ) {
                        return;
                    }
                    maxHeight -= elem.outerHeight( true );
                } );
    
                this.headers.each( function() {
                    maxHeight -= $( this ).outerHeight( true );
                } );
    
                this.headers.next()
                    .each( function() {
                        $( this ).height( Math.max( 0, maxHeight -
                            $( this ).innerHeight() + $( this ).height() ) );
                    } )
                    .css( "overflow", "auto" );
            } else if ( heightStyle === "auto" ) {
                maxHeight = 0;
                this.headers.next()
                    .each( function() {
                        var isVisible = $( this ).is( ":visible" );
                        if ( !isVisible ) {
                            $( this ).show();
                        }
                        maxHeight = Math.max( maxHeight, $( this ).css( "height", "" ).height() );
                        if ( !isVisible ) {
                            $( this ).hide();
                        }
                    } )
                    .height( maxHeight );
            }
        },
    
        _activate: function( index ) {
            var active = this._findActive( index )[ 0 ];
    
            // Trying to activate the already active panel
            if ( active === this.active[ 0 ] ) {
                return;
            }
    
            // Trying to collapse, simulate a click on the currently active header
            active = active || this.active[ 0 ];
    
            this._eventHandler( {
                target: active,
                currentTarget: active,
                preventDefault: $.noop
            } );
        },
    
        _findActive: function( selector ) {
            return typeof selector === "number" ? this.headers.eq( selector ) : $();
        },
    
        _setupEvents: function( event ) {
            var events = {
                keydown: "_keydown"
            };
            if ( event ) {
                $.each( event.split( " " ), function( index, eventName ) {
                    events[ eventName ] = "_eventHandler";
                } );
            }
    
            this._off( this.headers.add( this.headers.next() ) );
            this._on( this.headers, events );
            this._on( this.headers.next(), { keydown: "_panelKeyDown" } );
            this._hoverable( this.headers );
            this._focusable( this.headers );
        },
    
        _eventHandler: function( event ) {
            var activeChildren, clickedChildren,
                options = this.options,
                active = this.active,
                clicked = $( event.currentTarget ),
                clickedIsActive = clicked[ 0 ] === active[ 0 ],
                collapsing = clickedIsActive && options.collapsible,
                toShow = collapsing ? $() : clicked.next(),
                toHide = active.next(),
                eventData = {
                    oldHeader: active,
                    oldPanel: toHide,
                    newHeader: collapsing ? $() : clicked,
                    newPanel: toShow
                };
    
            event.preventDefault();
    
            if (
    
                    // click on active header, but not collapsible
                    ( clickedIsActive && !options.collapsible ) ||
    
                    // allow canceling activation
                    ( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
                return;
            }
    
            options.active = collapsing ? false : this.headers.index( clicked );
    
            // When the call to ._toggle() comes after the class changes
            // it causes a very odd bug in IE 8 (see #6720)
            this.active = clickedIsActive ? $() : clicked;
            this._toggle( eventData );
    
            // Switch classes
            // corner classes on the previously active header stay after the animation
            this._removeClass( active, "ui-accordion-header-active", "ui-state-active" );
            if ( options.icons ) {
                activeChildren = active.children( ".ui-accordion-header-icon" );
                this._removeClass( activeChildren, null, options.icons.activeHeader )
                    ._addClass( activeChildren, null, options.icons.header );
            }
    
            if ( !clickedIsActive ) {
                this._removeClass( clicked, "ui-accordion-header-collapsed" )
                    ._addClass( clicked, "ui-accordion-header-active", "ui-state-active" );
                if ( options.icons ) {
                    clickedChildren = clicked.children( ".ui-accordion-header-icon" );
                    this._removeClass( clickedChildren, null, options.icons.header )
                        ._addClass( clickedChildren, null, options.icons.activeHeader );
                }
    
                this._addClass( clicked.next(), "ui-accordion-content-active" );
            }
        },
    
        _toggle: function( data ) {
            var toShow = data.newPanel,
                toHide = this.prevShow.length ? this.prevShow : data.oldPanel;
    
            // Handle activating a panel during the animation for another activation
            this.prevShow.add( this.prevHide ).stop( true, true );
            this.prevShow = toShow;
            this.prevHide = toHide;
    
            if ( this.options.animate ) {
                this._animate( toShow, toHide, data );
            } else {
                toHide.hide();
                toShow.show();
                this._toggleComplete( data );
            }
    
            toHide.attr( {
                "aria-hidden": "true"
            } );
            toHide.prev().attr( {
                "aria-selected": "false",
                "aria-expanded": "false"
            } );
    
            // if we're switching panels, remove the old header from the tab order
            // if we're opening from collapsed state, remove the previous header from the tab order
            // if we're collapsing, then keep the collapsing header in the tab order
            if ( toShow.length && toHide.length ) {
                toHide.prev().attr( {
                    "tabIndex": -1,
                    "aria-expanded": "false"
                } );
            } else if ( toShow.length ) {
                this.headers.filter( function() {
                    return parseInt( $( this ).attr( "tabIndex" ), 10 ) === 0;
                } )
                    .attr( "tabIndex", -1 );
            }
    
            toShow
                .attr( "aria-hidden", "false" )
                .prev()
                    .attr( {
                        "aria-selected": "true",
                        "aria-expanded": "true",
                        tabIndex: 0
                    } );
        },
    
        _animate: function( toShow, toHide, data ) {
            var total, easing, duration,
                that = this,
                adjust = 0,
                boxSizing = toShow.css( "box-sizing" ),
                down = toShow.length &&
                    ( !toHide.length || ( toShow.index() < toHide.index() ) ),
                animate = this.options.animate || {},
                options = down && animate.down || animate,
                complete = function() {
                    that._toggleComplete( data );
                };
    
            if ( typeof options === "number" ) {
                duration = options;
            }
            if ( typeof options === "string" ) {
                easing = options;
            }
    
            // fall back from options to animation in case of partial down settings
            easing = easing || options.easing || animate.easing;
            duration = duration || options.duration || animate.duration;
    
            if ( !toHide.length ) {
                return toShow.animate( this.showProps, duration, easing, complete );
            }
            if ( !toShow.length ) {
                return toHide.animate( this.hideProps, duration, easing, complete );
            }
    
            total = toShow.show().outerHeight();
            toHide.animate( this.hideProps, {
                duration: duration,
                easing: easing,
                step: function( now, fx ) {
                    fx.now = Math.round( now );
                }
            } );
            toShow
                .hide()
                .animate( this.showProps, {
                    duration: duration,
                    easing: easing,
                    complete: complete,
                    step: function( now, fx ) {
                        fx.now = Math.round( now );
                        if ( fx.prop !== "height" ) {
                            if ( boxSizing === "content-box" ) {
                                adjust += fx.now;
                            }
                        } else if ( that.options.heightStyle !== "content" ) {
                            fx.now = Math.round( total - toHide.outerHeight() - adjust );
                            adjust = 0;
                        }
                    }
                } );
        },
    
        _toggleComplete: function( data ) {
            var toHide = data.oldPanel,
                prev = toHide.prev();
    
            this._removeClass( toHide, "ui-accordion-content-active" );
            this._removeClass( prev, "ui-accordion-header-active" )
                ._addClass( prev, "ui-accordion-header-collapsed" );
    
            // Work around for rendering bug in IE (#5421)
            if ( toHide.length ) {
                toHide.parent()[ 0 ].className = toHide.parent()[ 0 ].className;
            }
            this._trigger( "activate", null, data );
        }
    } );
    
    
    
    var safeActiveElement = $.ui.safeActiveElement = function( document ) {
        var activeElement;
    
        // Support: IE 9 only
        // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
        try {
            activeElement = document.activeElement;
        } catch ( error ) {
            activeElement = document.body;
        }
    
        // Support: IE 9 - 11 only
        // IE may return null instead of an element
        // Interestingly, this only seems to occur when NOT in an iframe
        if ( !activeElement ) {
            activeElement = document.body;
        }
    
        // Support: IE 11 only
        // IE11 returns a seemingly empty object in some cases when accessing
        // document.activeElement from an <iframe>
        if ( !activeElement.nodeName ) {
            activeElement = document.body;
        }
    
        return activeElement;
    };
    
    
    /*!
     * jQuery UI Menu 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Menu
    //>>group: Widgets
    //>>description: Creates nestable menus.
    //>>docs: http://api.jqueryui.com/menu/
    //>>demos: http://jqueryui.com/menu/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/menu.css
    //>>css.theme: ../../themes/base/theme.css
    
    
    
    var widgetsMenu = $.widget( "ui.menu", {
        version: "1.12.1",
        defaultElement: "<ul>",
        delay: 300,
        options: {
            icons: {
                submenu: "ui-icon-caret-1-e"
            },
            items: "> *",
            menus: "ul",
            position: {
                my: "left top",
                at: "right top"
            },
            role: "menu",
    
            // Callbacks
            blur: null,
            focus: null,
            select: null
        },
    
        _create: function() {
            this.activeMenu = this.element;
    
            // Flag used to prevent firing of the click handler
            // as the event bubbles up through nested menus
            this.mouseHandled = false;
            this.element
                .uniqueId()
                .attr( {
                    role: this.options.role,
                    tabIndex: 0
                } );
    
            this._addClass( "ui-menu", "ui-widget ui-widget-content" );
            this._on( {
    
                // Prevent focus from sticking to links inside menu after clicking
                // them (focus should always stay on UL during navigation).
                "mousedown .ui-menu-item": function( event ) {
                    event.preventDefault();
                },
                "click .ui-menu-item": function( event ) {
                    var target = $( event.target );
                    var active = $( $.ui.safeActiveElement( this.document[ 0 ] ) );
                    if ( !this.mouseHandled && target.not( ".ui-state-disabled" ).length ) {
                        this.select( event );
    
                        // Only set the mouseHandled flag if the event will bubble, see #9469.
                        if ( !event.isPropagationStopped() ) {
                            this.mouseHandled = true;
                        }
    
                        // Open submenu on click
                        if ( target.has( ".ui-menu" ).length ) {
                            this.expand( event );
                        } else if ( !this.element.is( ":focus" ) &&
                                active.closest( ".ui-menu" ).length ) {
    
                            // Redirect focus to the menu
                            this.element.trigger( "focus", [ true ] );
    
                            // If the active item is on the top level, let it stay active.
                            // Otherwise, blur the active item since it is no longer visible.
                            if ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) {
                                clearTimeout( this.timer );
                            }
                        }
                    }
                },
                "mouseenter .ui-menu-item": function( event ) {
    
                    // Ignore mouse events while typeahead is active, see #10458.
                    // Prevents focusing the wrong item when typeahead causes a scroll while the mouse
                    // is over an item in the menu
                    if ( this.previousFilter ) {
                        return;
                    }
    
                    var actualTarget = $( event.target ).closest( ".ui-menu-item" ),
                        target = $( event.currentTarget );
    
                    // Ignore bubbled events on parent items, see #11641
                    if ( actualTarget[ 0 ] !== target[ 0 ] ) {
                        return;
                    }
    
                    // Remove ui-state-active class from siblings of the newly focused menu item
                    // to avoid a jump caused by adjacent elements both having a class with a border
                    this._removeClass( target.siblings().children( ".ui-state-active" ),
                        null, "ui-state-active" );
                    this.focus( event, target );
                },
                mouseleave: "collapseAll",
                "mouseleave .ui-menu": "collapseAll",
                focus: function( event, keepActiveItem ) {
    
                    // If there's already an active item, keep it active
                    // If not, activate the first item
                    var item = this.active || this.element.find( this.options.items ).eq( 0 );
    
                    if ( !keepActiveItem ) {
                        this.focus( event, item );
                    }
                },
                blur: function( event ) {
                    this._delay( function() {
                        var notContained = !$.contains(
                            this.element[ 0 ],
                            $.ui.safeActiveElement( this.document[ 0 ] )
                        );
                        if ( notContained ) {
                            this.collapseAll( event );
                        }
                    } );
                },
                keydown: "_keydown"
            } );
    
            this.refresh();
    
            // Clicks outside of a menu collapse any open menus
            this._on( this.document, {
                click: function( event ) {
                    if ( this._closeOnDocumentClick( event ) ) {
                        this.collapseAll( event );
                    }
    
                    // Reset the mouseHandled flag
                    this.mouseHandled = false;
                }
            } );
        },
    
        _destroy: function() {
            var items = this.element.find( ".ui-menu-item" )
                    .removeAttr( "role aria-disabled" ),
                submenus = items.children( ".ui-menu-item-wrapper" )
                    .removeUniqueId()
                    .removeAttr( "tabIndex role aria-haspopup" );
    
            // Destroy (sub)menus
            this.element
                .removeAttr( "aria-activedescendant" )
                .find( ".ui-menu" ).addBack()
                    .removeAttr( "role aria-labelledby aria-expanded aria-hidden aria-disabled " +
                        "tabIndex" )
                    .removeUniqueId()
                    .show();
    
            submenus.children().each( function() {
                var elem = $( this );
                if ( elem.data( "ui-menu-submenu-caret" ) ) {
                    elem.remove();
                }
            } );
        },
    
        _keydown: function( event ) {
            var match, prev, character, skip,
                preventDefault = true;
    
            switch ( event.keyCode ) {
            case $.ui.keyCode.PAGE_UP:
                this.previousPage( event );
                break;
            case $.ui.keyCode.PAGE_DOWN:
                this.nextPage( event );
                break;
            case $.ui.keyCode.HOME:
                this._move( "first", "first", event );
                break;
            case $.ui.keyCode.END:
                this._move( "last", "last", event );
                break;
            case $.ui.keyCode.UP:
                this.previous( event );
                break;
            case $.ui.keyCode.DOWN:
                this.next( event );
                break;
            case $.ui.keyCode.LEFT:
                this.collapse( event );
                break;
            case $.ui.keyCode.RIGHT:
                if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
                    this.expand( event );
                }
                break;
            case $.ui.keyCode.ENTER:
            case $.ui.keyCode.SPACE:
                this._activate( event );
                break;
            case $.ui.keyCode.ESCAPE:
                this.collapse( event );
                break;
            default:
                preventDefault = false;
                prev = this.previousFilter || "";
                skip = false;
    
                // Support number pad values
                character = event.keyCode >= 96 && event.keyCode <= 105 ?
                    ( event.keyCode - 96 ).toString() : String.fromCharCode( event.keyCode );
    
                clearTimeout( this.filterTimer );
    
                if ( character === prev ) {
                    skip = true;
                } else {
                    character = prev + character;
                }
    
                match = this._filterMenuItems( character );
                match = skip && match.index( this.active.next() ) !== -1 ?
                    this.active.nextAll( ".ui-menu-item" ) :
                    match;
    
                // If no matches on the current filter, reset to the last character pressed
                // to move down the menu to the first item that starts with that character
                if ( !match.length ) {
                    character = String.fromCharCode( event.keyCode );
                    match = this._filterMenuItems( character );
                }
    
                if ( match.length ) {
                    this.focus( event, match );
                    this.previousFilter = character;
                    this.filterTimer = this._delay( function() {
                        delete this.previousFilter;
                    }, 1000 );
                } else {
                    delete this.previousFilter;
                }
            }
    
            if ( preventDefault ) {
                event.preventDefault();
            }
        },
    
        _activate: function( event ) {
            if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
                if ( this.active.children( "[aria-haspopup='true']" ).length ) {
                    this.expand( event );
                } else {
                    this.select( event );
                }
            }
        },
    
        refresh: function() {
            var menus, items, newSubmenus, newItems, newWrappers,
                that = this,
                icon = this.options.icons.submenu,
                submenus = this.element.find( this.options.menus );
    
            this._toggleClass( "ui-menu-icons", null, !!this.element.find( ".ui-icon" ).length );
    
            // Initialize nested menus
            newSubmenus = submenus.filter( ":not(.ui-menu)" )
                .hide()
                .attr( {
                    role: this.options.role,
                    "aria-hidden": "true",
                    "aria-expanded": "false"
                } )
                .each( function() {
                    var menu = $( this ),
                        item = menu.prev(),
                        submenuCaret = $( "<span>" ).data( "ui-menu-submenu-caret", true );
    
                    that._addClass( submenuCaret, "ui-menu-icon", "ui-icon " + icon );
                    item
                        .attr( "aria-haspopup", "true" )
                        .prepend( submenuCaret );
                    menu.attr( "aria-labelledby", item.attr( "id" ) );
                } );
    
            this._addClass( newSubmenus, "ui-menu", "ui-widget ui-widget-content ui-front" );
    
            menus = submenus.add( this.element );
            items = menus.find( this.options.items );
    
            // Initialize menu-items containing spaces and/or dashes only as dividers
            items.not( ".ui-menu-item" ).each( function() {
                var item = $( this );
                if ( that._isDivider( item ) ) {
                    that._addClass( item, "ui-menu-divider", "ui-widget-content" );
                }
            } );
    
            // Don't refresh list items that are already adapted
            newItems = items.not( ".ui-menu-item, .ui-menu-divider" );
            newWrappers = newItems.children()
                .not( ".ui-menu" )
                    .uniqueId()
                    .attr( {
                        tabIndex: -1,
                        role: this._itemRole()
                    } );
            this._addClass( newItems, "ui-menu-item" )
                ._addClass( newWrappers, "ui-menu-item-wrapper" );
    
            // Add aria-disabled attribute to any disabled menu item
            items.filter( ".ui-state-disabled" ).attr( "aria-disabled", "true" );
    
            // If the active item has been removed, blur the menu
            if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
                this.blur();
            }
        },
    
        _itemRole: function() {
            return {
                menu: "menuitem",
                listbox: "option"
            }[ this.options.role ];
        },
    
        _setOption: function( key, value ) {
            if ( key === "icons" ) {
                var icons = this.element.find( ".ui-menu-icon" );
                this._removeClass( icons, null, this.options.icons.submenu )
                    ._addClass( icons, null, value.submenu );
            }
            this._super( key, value );
        },
    
        _setOptionDisabled: function( value ) {
            this._super( value );
    
            this.element.attr( "aria-disabled", String( value ) );
            this._toggleClass( null, "ui-state-disabled", !!value );
        },
    
        focus: function( event, item ) {
            var nested, focused, activeParent;
            this.blur( event, event && event.type === "focus" );
    
            this._scrollIntoView( item );
    
            this.active = item.first();
    
            focused = this.active.children( ".ui-menu-item-wrapper" );
            this._addClass( focused, null, "ui-state-active" );
    
            // Only update aria-activedescendant if there's a role
            // otherwise we assume focus is managed elsewhere
            if ( this.options.role ) {
                this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
            }
    
            // Highlight active parent menu item, if any
            activeParent = this.active
                .parent()
                    .closest( ".ui-menu-item" )
                        .children( ".ui-menu-item-wrapper" );
            this._addClass( activeParent, null, "ui-state-active" );
    
            if ( event && event.type === "keydown" ) {
                this._close();
            } else {
                this.timer = this._delay( function() {
                    this._close();
                }, this.delay );
            }
    
            nested = item.children( ".ui-menu" );
            if ( nested.length && event && ( /^mouse/.test( event.type ) ) ) {
                this._startOpening( nested );
            }
            this.activeMenu = item.parent();
    
            this._trigger( "focus", event, { item: item } );
        },
    
        _scrollIntoView: function( item ) {
            var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
            if ( this._hasScroll() ) {
                borderTop = parseFloat( $.css( this.activeMenu[ 0 ], "borderTopWidth" ) ) || 0;
                paddingTop = parseFloat( $.css( this.activeMenu[ 0 ], "paddingTop" ) ) || 0;
                offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
                scroll = this.activeMenu.scrollTop();
                elementHeight = this.activeMenu.height();
                itemHeight = item.outerHeight();
    
                if ( offset < 0 ) {
                    this.activeMenu.scrollTop( scroll + offset );
                } else if ( offset + itemHeight > elementHeight ) {
                    this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
                }
            }
        },
    
        blur: function( event, fromFocus ) {
            if ( !fromFocus ) {
                clearTimeout( this.timer );
            }
    
            if ( !this.active ) {
                return;
            }
    
            this._removeClass( this.active.children( ".ui-menu-item-wrapper" ),
                null, "ui-state-active" );
    
            this._trigger( "blur", event, { item: this.active } );
            this.active = null;
        },
    
        _startOpening: function( submenu ) {
            clearTimeout( this.timer );
    
            // Don't open if already open fixes a Firefox bug that caused a .5 pixel
            // shift in the submenu position when mousing over the caret icon
            if ( submenu.attr( "aria-hidden" ) !== "true" ) {
                return;
            }
    
            this.timer = this._delay( function() {
                this._close();
                this._open( submenu );
            }, this.delay );
        },
    
        _open: function( submenu ) {
            var position = $.extend( {
                of: this.active
            }, this.options.position );
    
            clearTimeout( this.timer );
            this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )
                .hide()
                .attr( "aria-hidden", "true" );
    
            submenu
                .show()
                .removeAttr( "aria-hidden" )
                .attr( "aria-expanded", "true" )
                .position( position );
        },
    
        collapseAll: function( event, all ) {
            clearTimeout( this.timer );
            this.timer = this._delay( function() {
    
                // If we were passed an event, look for the submenu that contains the event
                var currentMenu = all ? this.element :
                    $( event && event.target ).closest( this.element.find( ".ui-menu" ) );
    
                // If we found no valid submenu ancestor, use the main menu to close all
                // sub menus anyway
                if ( !currentMenu.length ) {
                    currentMenu = this.element;
                }
    
                this._close( currentMenu );
    
                this.blur( event );
    
                // Work around active item staying active after menu is blurred
                this._removeClass( currentMenu.find( ".ui-state-active" ), null, "ui-state-active" );
    
                this.activeMenu = currentMenu;
            }, this.delay );
        },
    
        // With no arguments, closes the currently active menu - if nothing is active
        // it closes all menus.  If passed an argument, it will search for menus BELOW
        _close: function( startMenu ) {
            if ( !startMenu ) {
                startMenu = this.active ? this.active.parent() : this.element;
            }
    
            startMenu.find( ".ui-menu" )
                .hide()
                .attr( "aria-hidden", "true" )
                .attr( "aria-expanded", "false" );
        },
    
        _closeOnDocumentClick: function( event ) {
            return !$( event.target ).closest( ".ui-menu" ).length;
        },
    
        _isDivider: function( item ) {
    
            // Match hyphen, em dash, en dash
            return !/[^\-\u2014\u2013\s]/.test( item.text() );
        },
    
        collapse: function( event ) {
            var newItem = this.active &&
                this.active.parent().closest( ".ui-menu-item", this.element );
            if ( newItem && newItem.length ) {
                this._close();
                this.focus( event, newItem );
            }
        },
    
        expand: function( event ) {
            var newItem = this.active &&
                this.active
                    .children( ".ui-menu " )
                        .find( this.options.items )
                            .first();
    
            if ( newItem && newItem.length ) {
                this._open( newItem.parent() );
    
                // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
                this._delay( function() {
                    this.focus( event, newItem );
                } );
            }
        },
    
        next: function( event ) {
            this._move( "next", "first", event );
        },
    
        previous: function( event ) {
            this._move( "prev", "last", event );
        },
    
        isFirstItem: function() {
            return this.active && !this.active.prevAll( ".ui-menu-item" ).length;
        },
    
        isLastItem: function() {
            return this.active && !this.active.nextAll( ".ui-menu-item" ).length;
        },
    
        _move: function( direction, filter, event ) {
            var next;
            if ( this.active ) {
                if ( direction === "first" || direction === "last" ) {
                    next = this.active
                        [ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )
                        .eq( -1 );
                } else {
                    next = this.active
                        [ direction + "All" ]( ".ui-menu-item" )
                        .eq( 0 );
                }
            }
            if ( !next || !next.length || !this.active ) {
                next = this.activeMenu.find( this.options.items )[ filter ]();
            }
    
            this.focus( event, next );
        },
    
        nextPage: function( event ) {
            var item, base, height;
    
            if ( !this.active ) {
                this.next( event );
                return;
            }
            if ( this.isLastItem() ) {
                return;
            }
            if ( this._hasScroll() ) {
                base = this.active.offset().top;
                height = this.element.height();
                this.active.nextAll( ".ui-menu-item" ).each( function() {
                    item = $( this );
                    return item.offset().top - base - height < 0;
                } );
    
                this.focus( event, item );
            } else {
                this.focus( event, this.activeMenu.find( this.options.items )
                    [ !this.active ? "first" : "last" ]() );
            }
        },
    
        previousPage: function( event ) {
            var item, base, height;
            if ( !this.active ) {
                this.next( event );
                return;
            }
            if ( this.isFirstItem() ) {
                return;
            }
            if ( this._hasScroll() ) {
                base = this.active.offset().top;
                height = this.element.height();
                this.active.prevAll( ".ui-menu-item" ).each( function() {
                    item = $( this );
                    return item.offset().top - base + height > 0;
                } );
    
                this.focus( event, item );
            } else {
                this.focus( event, this.activeMenu.find( this.options.items ).first() );
            }
        },
    
        _hasScroll: function() {
            return this.element.outerHeight() < this.element.prop( "scrollHeight" );
        },
    
        select: function( event ) {
    
            // TODO: It should never be possible to not have an active item at this
            // point, but the tests don't trigger mouseenter before click.
            this.active = this.active || $( event.target ).closest( ".ui-menu-item" );
            var ui = { item: this.active };
            if ( !this.active.has( ".ui-menu" ).length ) {
                this.collapseAll( event, true );
            }
            this._trigger( "select", event, ui );
        },
    
        _filterMenuItems: function( character ) {
            var escapedCharacter = character.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" ),
                regex = new RegExp( "^" + escapedCharacter, "i" );
    
            return this.activeMenu
                .find( this.options.items )
    
                    // Only match on items, not dividers or other content (#10571)
                    .filter( ".ui-menu-item" )
                        .filter( function() {
                            return regex.test(
                                $.trim( $( this ).children( ".ui-menu-item-wrapper" ).text() ) );
                        } );
        }
    } );
    
    
    /*!
     * jQuery UI Autocomplete 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Autocomplete
    //>>group: Widgets
    //>>description: Lists suggested words as the user is typing.
    //>>docs: http://api.jqueryui.com/autocomplete/
    //>>demos: http://jqueryui.com/autocomplete/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/autocomplete.css
    //>>css.theme: ../../themes/base/theme.css
    
    
    
    $.widget( "ui.autocomplete", {
        version: "1.12.1",
        defaultElement: "<input>",
        options: {
            appendTo: null,
            autoFocus: false,
            delay: 300,
            minLength: 1,
            position: {
                my: "left top",
                at: "left bottom",
                collision: "none"
            },
            source: null,
    
            // Callbacks
            change: null,
            close: null,
            focus: null,
            open: null,
            response: null,
            search: null,
            select: null
        },
    
        requestIndex: 0,
        pending: 0,
    
        _create: function() {
    
            // Some browsers only repeat keydown events, not keypress events,
            // so we use the suppressKeyPress flag to determine if we've already
            // handled the keydown event. #7269
            // Unfortunately the code for & in keypress is the same as the up arrow,
            // so we use the suppressKeyPressRepeat flag to avoid handling keypress
            // events when we know the keydown event was used to modify the
            // search term. #7799
            var suppressKeyPress, suppressKeyPressRepeat, suppressInput,
                nodeName = this.element[ 0 ].nodeName.toLowerCase(),
                isTextarea = nodeName === "textarea",
                isInput = nodeName === "input";
    
            // Textareas are always multi-line
            // Inputs are always single-line, even if inside a contentEditable element
            // IE also treats inputs as contentEditable
            // All other element types are determined by whether or not they're contentEditable
            this.isMultiLine = isTextarea || !isInput && this._isContentEditable( this.element );
    
            this.valueMethod = this.element[ isTextarea || isInput ? "val" : "text" ];
            this.isNewMenu = true;
    
            this._addClass( "ui-autocomplete-input" );
            this.element.attr( "autocomplete", "off" );
    
            this._on( this.element, {
                keydown: function( event ) {
                    if ( this.element.prop( "readOnly" ) ) {
                        suppressKeyPress = true;
                        suppressInput = true;
                        suppressKeyPressRepeat = true;
                        return;
                    }
    
                    suppressKeyPress = false;
                    suppressInput = false;
                    suppressKeyPressRepeat = false;
                    var keyCode = $.ui.keyCode;
                    switch ( event.keyCode ) {
                    case keyCode.PAGE_UP:
                        suppressKeyPress = true;
                        this._move( "previousPage", event );
                        break;
                    case keyCode.PAGE_DOWN:
                        suppressKeyPress = true;
                        this._move( "nextPage", event );
                        break;
                    case keyCode.UP:
                        suppressKeyPress = true;
                        this._keyEvent( "previous", event );
                        break;
                    case keyCode.DOWN:
                        suppressKeyPress = true;
                        this._keyEvent( "next", event );
                        break;
                    case keyCode.ENTER:
    
                        // when menu is open and has focus
                        if ( this.menu.active ) {
    
                            // #6055 - Opera still allows the keypress to occur
                            // which causes forms to submit
                            suppressKeyPress = true;
                            event.preventDefault();
                            this.menu.select( event );
                        }
                        break;
                    case keyCode.TAB:
                        if ( this.menu.active ) {
                            this.menu.select( event );
                        }
                        break;
                    case keyCode.ESCAPE:
                        if ( this.menu.element.is( ":visible" ) ) {
                            if ( !this.isMultiLine ) {
                                this._value( this.term );
                            }
                            this.close( event );
    
                            // Different browsers have different default behavior for escape
                            // Single press can mean undo or clear
                            // Double press in IE means clear the whole form
                            event.preventDefault();
                        }
                        break;
                    default:
                        suppressKeyPressRepeat = true;
    
                        // search timeout should be triggered before the input value is changed
                        this._searchTimeout( event );
                        break;
                    }
                },
                keypress: function( event ) {
                    if ( suppressKeyPress ) {
                        suppressKeyPress = false;
                        if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
                            event.preventDefault();
                        }
                        return;
                    }
                    if ( suppressKeyPressRepeat ) {
                        return;
                    }
    
                    // Replicate some key handlers to allow them to repeat in Firefox and Opera
                    var keyCode = $.ui.keyCode;
                    switch ( event.keyCode ) {
                    case keyCode.PAGE_UP:
                        this._move( "previousPage", event );
                        break;
                    case keyCode.PAGE_DOWN:
                        this._move( "nextPage", event );
                        break;
                    case keyCode.UP:
                        this._keyEvent( "previous", event );
                        break;
                    case keyCode.DOWN:
                        this._keyEvent( "next", event );
                        break;
                    }
                },
                input: function( event ) {
                    if ( suppressInput ) {
                        suppressInput = false;
                        event.preventDefault();
                        return;
                    }
                    this._searchTimeout( event );
                },
                focus: function() {
                    this.selectedItem = null;
                    this.previous = this._value();
                },
                blur: function( event ) {
                    if ( this.cancelBlur ) {
                        delete this.cancelBlur;
                        return;
                    }
    
                    clearTimeout( this.searching );
                    this.close( event );
                    this._change( event );
                }
            } );
    
            this._initSource();
            this.menu = $( "<ul>" )
                .appendTo( this._appendTo() )
                .menu( {
    
                    // disable ARIA support, the live region takes care of that
                    role: null
                } )
                .hide()
                .menu( "instance" );
    
            this._addClass( this.menu.element, "ui-autocomplete", "ui-front" );
            this._on( this.menu.element, {
                mousedown: function( event ) {
    
                    // prevent moving focus out of the text field
                    event.preventDefault();
    
                    // IE doesn't prevent moving focus even with event.preventDefault()
                    // so we set a flag to know when we should ignore the blur event
                    this.cancelBlur = true;
                    this._delay( function() {
                        delete this.cancelBlur;
    
                        // Support: IE 8 only
                        // Right clicking a menu item or selecting text from the menu items will
                        // result in focus moving out of the input. However, we've already received
                        // and ignored the blur event because of the cancelBlur flag set above. So
                        // we restore focus to ensure that the menu closes properly based on the user's
                        // next actions.
                        if ( this.element[ 0 ] !== $.ui.safeActiveElement( this.document[ 0 ] ) ) {
                            this.element.trigger( "focus" );
                        }
                    } );
                },
                menufocus: function( event, ui ) {
                    var label, item;
    
                    // support: Firefox
                    // Prevent accidental activation of menu items in Firefox (#7024 #9118)
                    if ( this.isNewMenu ) {
                        this.isNewMenu = false;
                        if ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {
                            this.menu.blur();
    
                            this.document.one( "mousemove", function() {
                                $( event.target ).trigger( event.originalEvent );
                            } );
    
                            return;
                        }
                    }
    
                    item = ui.item.data( "ui-autocomplete-item" );
                    if ( false !== this._trigger( "focus", event, { item: item } ) ) {
    
                        // use value to match what will end up in the input, if it was a key event
                        if ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {
                            this._value( item.value );
                        }
                    }
    
                    // Announce the value in the liveRegion
                    label = ui.item.attr( "aria-label" ) || item.value;
                    if ( label && $.trim( label ).length ) {
                        this.liveRegion.children().hide();
                        $( "<div>" ).text( label ).appendTo( this.liveRegion );
                    }
                },
                menuselect: function( event, ui ) {
                    var item = ui.item.data( "ui-autocomplete-item" ),
                        previous = this.previous;
    
                    // Only trigger when focus was lost (click on menu)
                    if ( this.element[ 0 ] !== $.ui.safeActiveElement( this.document[ 0 ] ) ) {
                        this.element.trigger( "focus" );
                        this.previous = previous;
    
                        // #6109 - IE triggers two focus events and the second
                        // is asynchronous, so we need to reset the previous
                        // term synchronously and asynchronously :-(
                        this._delay( function() {
                            this.previous = previous;
                            this.selectedItem = item;
                        } );
                    }
    
                    if ( false !== this._trigger( "select", event, { item: item } ) ) {
                        this._value( item.value );
                    }
    
                    // reset the term after the select event
                    // this allows custom select handling to work properly
                    this.term = this._value();
    
                    this.close( event );
                    this.selectedItem = item;
                }
            } );
    
            this.liveRegion = $( "<div>", {
                role: "status",
                "aria-live": "assertive",
                "aria-relevant": "additions"
            } )
                .appendTo( this.document[ 0 ].body );
    
            this._addClass( this.liveRegion, null, "ui-helper-hidden-accessible" );
    
            // Turning off autocomplete prevents the browser from remembering the
            // value when navigating through history, so we re-enable autocomplete
            // if the page is unloaded before the widget is destroyed. #7790
            this._on( this.window, {
                beforeunload: function() {
                    this.element.removeAttr( "autocomplete" );
                }
            } );
        },
    
        _destroy: function() {
            clearTimeout( this.searching );
            this.element.removeAttr( "autocomplete" );
            this.menu.element.remove();
            this.liveRegion.remove();
        },
    
        _setOption: function( key, value ) {
            this._super( key, value );
            if ( key === "source" ) {
                this._initSource();
            }
            if ( key === "appendTo" ) {
                this.menu.element.appendTo( this._appendTo() );
            }
            if ( key === "disabled" && value && this.xhr ) {
                this.xhr.abort();
            }
        },
    
        _isEventTargetInWidget: function( event ) {
            var menuElement = this.menu.element[ 0 ];
    
            return event.target === this.element[ 0 ] ||
                event.target === menuElement ||
                $.contains( menuElement, event.target );
        },
    
        _closeOnClickOutside: function( event ) {
            if ( !this._isEventTargetInWidget( event ) ) {
                this.close();
            }
        },
    
        _appendTo: function() {
            var element = this.options.appendTo;
    
            if ( element ) {
                element = element.jquery || element.nodeType ?
                    $( element ) :
                    this.document.find( element ).eq( 0 );
            }
    
            if ( !element || !element[ 0 ] ) {
                element = this.element.closest( ".ui-front, dialog" );
            }
    
            if ( !element.length ) {
                element = this.document[ 0 ].body;
            }
    
            return element;
        },
    
        _initSource: function() {
            var array, url,
                that = this;
            if ( $.isArray( this.options.source ) ) {
                array = this.options.source;
                this.source = function( request, response ) {
                    response( $.ui.autocomplete.filter( array, request.term ) );
                };
            } else if ( typeof this.options.source === "string" ) {
                url = this.options.source;
                this.source = function( request, response ) {
                    if ( that.xhr ) {
                        that.xhr.abort();
                    }
                    that.xhr = $.ajax( {
                        url: url,
                        data: request,
                        dataType: "json",
                        success: function( data ) {
                            response( data );
                        },
                        error: function() {
                            response( [] );
                        }
                    } );
                };
            } else {
                this.source = this.options.source;
            }
        },
    
        _searchTimeout: function( event ) {
            clearTimeout( this.searching );
            this.searching = this._delay( function() {
    
                // Search if the value has changed, or if the user retypes the same value (see #7434)
                var equalValues = this.term === this._value(),
                    menuVisible = this.menu.element.is( ":visible" ),
                    modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;
    
                if ( !equalValues || ( equalValues && !menuVisible && !modifierKey ) ) {
                    this.selectedItem = null;
                    this.search( null, event );
                }
            }, this.options.delay );
        },
    
        search: function( value, event ) {
            value = value != null ? value : this._value();
    
            // Always save the actual value, not the one passed as an argument
            this.term = this._value();
    
            if ( value.length < this.options.minLength ) {
                return this.close( event );
            }
    
            if ( this._trigger( "search", event ) === false ) {
                return;
            }
    
            return this._search( value );
        },
    
        _search: function( value ) {
            this.pending++;
            this._addClass( "ui-autocomplete-loading" );
            this.cancelSearch = false;
    
            this.source( { term: value }, this._response() );
        },
    
        _response: function() {
            var index = ++this.requestIndex;
    
            return $.proxy( function( content ) {
                if ( index === this.requestIndex ) {
                    this.__response( content );
                }
    
                this.pending--;
                if ( !this.pending ) {
                    this._removeClass( "ui-autocomplete-loading" );
                }
            }, this );
        },
    
        __response: function( content ) {
            if ( content ) {
                content = this._normalize( content );
            }
            this._trigger( "response", null, { content: content } );
            if ( !this.options.disabled && content && content.length && !this.cancelSearch ) {
                this._suggest( content );
                this._trigger( "open" );
            } else {
    
                // use ._close() instead of .close() so we don't cancel future searches
                this._close();
            }
        },
    
        close: function( event ) {
            this.cancelSearch = true;
            this._close( event );
        },
    
        _close: function( event ) {
    
            // Remove the handler that closes the menu on outside clicks
            this._off( this.document, "mousedown" );
    
            if ( this.menu.element.is( ":visible" ) ) {
                this.menu.element.hide();
                this.menu.blur();
                this.isNewMenu = true;
                this._trigger( "close", event );
            }
        },
    
        _change: function( event ) {
            if ( this.previous !== this._value() ) {
                this._trigger( "change", event, { item: this.selectedItem } );
            }
        },
    
        _normalize: function( items ) {
    
            // assume all items have the right format when the first item is complete
            if ( items.length && items[ 0 ].label && items[ 0 ].value ) {
                return items;
            }
            return $.map( items, function( item ) {
                if ( typeof item === "string" ) {
                    return {
                        label: item,
                        value: item
                    };
                }
                return $.extend( {}, item, {
                    label: item.label || item.value,
                    value: item.value || item.label
                } );
            } );
        },
    
        _suggest: function( items ) {
            var ul = this.menu.element.empty();
            this._renderMenu( ul, items );
            this.isNewMenu = true;
            this.menu.refresh();
    
            // Size and position menu
            ul.show();
            this._resizeMenu();
            ul.position( $.extend( {
                of: this.element
            }, this.options.position ) );
    
            if ( this.options.autoFocus ) {
                this.menu.next();
            }
    
            // Listen for interactions outside of the widget (#6642)
            this._on( this.document, {
                mousedown: "_closeOnClickOutside"
            } );
        },
    
        _resizeMenu: function() {
            var ul = this.menu.element;
            ul.outerWidth( Math.max(
    
                // Firefox wraps long text (possibly a rounding bug)
                // so we add 1px to avoid the wrapping (#7513)
                ul.width( "" ).outerWidth() + 1,
                this.element.outerWidth()
            ) );
        },
    
        _renderMenu: function( ul, items ) {
            var that = this;
            $.each( items, function( index, item ) {
                that._renderItemData( ul, item );
            } );
        },
    
        _renderItemData: function( ul, item ) {
            return this._renderItem( ul, item ).data( "ui-autocomplete-item", item );
        },
    
        _renderItem: function( ul, item ) {
            return $( "<li>" )
                .append( $( "<div>" ).text( item.label ) )
                .appendTo( ul );
        },
    
        _move: function( direction, event ) {
            if ( !this.menu.element.is( ":visible" ) ) {
                this.search( null, event );
                return;
            }
            if ( this.menu.isFirstItem() && /^previous/.test( direction ) ||
                    this.menu.isLastItem() && /^next/.test( direction ) ) {
    
                if ( !this.isMultiLine ) {
                    this._value( this.term );
                }
    
                this.menu.blur();
                return;
            }
            this.menu[ direction ]( event );
        },
    
        widget: function() {
            return this.menu.element;
        },
    
        _value: function() {
            return this.valueMethod.apply( this.element, arguments );
        },
    
        _keyEvent: function( keyEvent, event ) {
            if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
                this._move( keyEvent, event );
    
                // Prevents moving cursor to beginning/end of the text field in some browsers
                event.preventDefault();
            }
        },
    
        // Support: Chrome <=50
        // We should be able to just use this.element.prop( "isContentEditable" )
        // but hidden elements always report false in Chrome.
        // https://code.google.com/p/chromium/issues/detail?id=313082
        _isContentEditable: function( element ) {
            if ( !element.length ) {
                return false;
            }
    
            var editable = element.prop( "contentEditable" );
    
            if ( editable === "inherit" ) {
              return this._isContentEditable( element.parent() );
            }
    
            return editable === "true";
        }
    } );
    
    $.extend( $.ui.autocomplete, {
        escapeRegex: function( value ) {
            return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );
        },
        filter: function( array, term ) {
            var matcher = new RegExp( $.ui.autocomplete.escapeRegex( term ), "i" );
            return $.grep( array, function( value ) {
                return matcher.test( value.label || value.value || value );
            } );
        }
    } );
    
    // Live region extension, adding a `messages` option
    // NOTE: This is an experimental API. We are still investigating
    // a full solution for string manipulation and internationalization.
    $.widget( "ui.autocomplete", $.ui.autocomplete, {
        options: {
            messages: {
                noResults: "No search results.",
                results: function( amount ) {
                    return amount + ( amount > 1 ? " results are" : " result is" ) +
                        " available, use up and down arrow keys to navigate.";
                }
            }
        },
    
        __response: function( content ) {
            var message;
            this._superApply( arguments );
            if ( this.options.disabled || this.cancelSearch ) {
                return;
            }
            if ( content && content.length ) {
                message = this.options.messages.results( content.length );
            } else {
                message = this.options.messages.noResults;
            }
            this.liveRegion.children().hide();
            $( "<div>" ).text( message ).appendTo( this.liveRegion );
        }
    } );
    
    var widgetsAutocomplete = $.ui.autocomplete;
    
    
    /*!
     * jQuery UI Controlgroup 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Controlgroup
    //>>group: Widgets
    //>>description: Visually groups form control widgets
    //>>docs: http://api.jqueryui.com/controlgroup/
    //>>demos: http://jqueryui.com/controlgroup/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/controlgroup.css
    //>>css.theme: ../../themes/base/theme.css
    
    
    var controlgroupCornerRegex = /ui-corner-([a-z]){2,6}/g;
    
    var widgetsControlgroup = $.widget( "ui.controlgroup", {
        version: "1.12.1",
        defaultElement: "<div>",
        options: {
            direction: "horizontal",
            disabled: null,
            onlyVisible: true,
            items: {
                "button": "input[type=button], input[type=submit], input[type=reset], button, a",
                "controlgroupLabel": ".ui-controlgroup-label",
                "checkboxradio": "input[type='checkbox'], input[type='radio']",
                "selectmenu": "select",
                "spinner": ".ui-spinner-input"
            }
        },
    
        _create: function() {
            this._enhance();
        },
    
        // To support the enhanced option in jQuery Mobile, we isolate DOM manipulation
        _enhance: function() {
            this.element.attr( "role", "toolbar" );
            this.refresh();
        },
    
        _destroy: function() {
            this._callChildMethod( "destroy" );
            this.childWidgets.removeData( "ui-controlgroup-data" );
            this.element.removeAttr( "role" );
            if ( this.options.items.controlgroupLabel ) {
                this.element
                    .find( this.options.items.controlgroupLabel )
                    .find( ".ui-controlgroup-label-contents" )
                    .contents().unwrap();
            }
        },
    
        _initWidgets: function() {
            var that = this,
                childWidgets = [];
    
            // First we iterate over each of the items options
            $.each( this.options.items, function( widget, selector ) {
                var labels;
                var options = {};
    
                // Make sure the widget has a selector set
                if ( !selector ) {
                    return;
                }
    
                if ( widget === "controlgroupLabel" ) {
                    labels = that.element.find( selector );
                    labels.each( function() {
                        var element = $( this );
    
                        if ( element.children( ".ui-controlgroup-label-contents" ).length ) {
                            return;
                        }
                        element.contents()
                            .wrapAll( "<span class='ui-controlgroup-label-contents'></span>" );
                    } );
                    that._addClass( labels, null, "ui-widget ui-widget-content ui-state-default" );
                    childWidgets = childWidgets.concat( labels.get() );
                    return;
                }
    
                // Make sure the widget actually exists
                if ( !$.fn[ widget ] ) {
                    return;
                }
    
                // We assume everything is in the middle to start because we can't determine
                // first / last elements until all enhancments are done.
                if ( that[ "_" + widget + "Options" ] ) {
                    options = that[ "_" + widget + "Options" ]( "middle" );
                } else {
                    options = { classes: {} };
                }
    
                // Find instances of this widget inside controlgroup and init them
                that.element
                    .find( selector )
                    .each( function() {
                        var element = $( this );
                        var instance = element[ widget ]( "instance" );
    
                        // We need to clone the default options for this type of widget to avoid
                        // polluting the variable options which has a wider scope than a single widget.
                        var instanceOptions = $.widget.extend( {}, options );
    
                        // If the button is the child of a spinner ignore it
                        // TODO: Find a more generic solution
                        if ( widget === "button" && element.parent( ".ui-spinner" ).length ) {
                            return;
                        }
    
                        // Create the widget if it doesn't exist
                        if ( !instance ) {
                            instance = element[ widget ]()[ widget ]( "instance" );
                        }
                        if ( instance ) {
                            instanceOptions.classes =
                                that._resolveClassesValues( instanceOptions.classes, instance );
                        }
                        element[ widget ]( instanceOptions );
    
                        // Store an instance of the controlgroup to be able to reference
                        // from the outermost element for changing options and refresh
                        var widgetElement = element[ widget ]( "widget" );
                        $.data( widgetElement[ 0 ], "ui-controlgroup-data",
                            instance ? instance : element[ widget ]( "instance" ) );
    
                        childWidgets.push( widgetElement[ 0 ] );
                    } );
            } );
    
            this.childWidgets = $( $.unique( childWidgets ) );
            this._addClass( this.childWidgets, "ui-controlgroup-item" );
        },
    
        _callChildMethod: function( method ) {
            this.childWidgets.each( function() {
                var element = $( this ),
                    data = element.data( "ui-controlgroup-data" );
                if ( data && data[ method ] ) {
                    data[ method ]();
                }
            } );
        },
    
        _updateCornerClass: function( element, position ) {
            var remove = "ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all";
            var add = this._buildSimpleOptions( position, "label" ).classes.label;
    
            this._removeClass( element, null, remove );
            this._addClass( element, null, add );
        },
    
        _buildSimpleOptions: function( position, key ) {
            var direction = this.options.direction === "vertical";
            var result = {
                classes: {}
            };
            result.classes[ key ] = {
                "middle": "",
                "first": "ui-corner-" + ( direction ? "top" : "left" ),
                "last": "ui-corner-" + ( direction ? "bottom" : "right" ),
                "only": "ui-corner-all"
            }[ position ];
    
            return result;
        },
    
        _spinnerOptions: function( position ) {
            var options = this._buildSimpleOptions( position, "ui-spinner" );
    
            options.classes[ "ui-spinner-up" ] = "";
            options.classes[ "ui-spinner-down" ] = "";
    
            return options;
        },
    
        _buttonOptions: function( position ) {
            return this._buildSimpleOptions( position, "ui-button" );
        },
    
        _checkboxradioOptions: function( position ) {
            return this._buildSimpleOptions( position, "ui-checkboxradio-label" );
        },
    
        _selectmenuOptions: function( position ) {
            var direction = this.options.direction === "vertical";
            return {
                width: direction ? "auto" : false,
                classes: {
                    middle: {
                        "ui-selectmenu-button-open": "",
                        "ui-selectmenu-button-closed": ""
                    },
                    first: {
                        "ui-selectmenu-button-open": "ui-corner-" + ( direction ? "top" : "tl" ),
                        "ui-selectmenu-button-closed": "ui-corner-" + ( direction ? "top" : "left" )
                    },
                    last: {
                        "ui-selectmenu-button-open": direction ? "" : "ui-corner-tr",
                        "ui-selectmenu-button-closed": "ui-corner-" + ( direction ? "bottom" : "right" )
                    },
                    only: {
                        "ui-selectmenu-button-open": "ui-corner-top",
                        "ui-selectmenu-button-closed": "ui-corner-all"
                    }
    
                }[ position ]
            };
        },
    
        _resolveClassesValues: function( classes, instance ) {
            var result = {};
            $.each( classes, function( key ) {
                var current = instance.options.classes[ key ] || "";
                current = $.trim( current.replace( controlgroupCornerRegex, "" ) );
                result[ key ] = ( current + " " + classes[ key ] ).replace( /\s+/g, " " );
            } );
            return result;
        },
    
        _setOption: function( key, value ) {
            if ( key === "direction" ) {
                this._removeClass( "ui-controlgroup-" + this.options.direction );
            }
    
            this._super( key, value );
            if ( key === "disabled" ) {
                this._callChildMethod( value ? "disable" : "enable" );
                return;
            }
    
            this.refresh();
        },
    
        refresh: function() {
            var children,
                that = this;
    
            this._addClass( "ui-controlgroup ui-controlgroup-" + this.options.direction );
    
            if ( this.options.direction === "horizontal" ) {
                this._addClass( null, "ui-helper-clearfix" );
            }
            this._initWidgets();
    
            children = this.childWidgets;
    
            // We filter here because we need to track all childWidgets not just the visible ones
            if ( this.options.onlyVisible ) {
                children = children.filter( ":visible" );
            }
    
            if ( children.length ) {
    
                // We do this last because we need to make sure all enhancment is done
                // before determining first and last
                $.each( [ "first", "last" ], function( index, value ) {
                    var instance = children[ value ]().data( "ui-controlgroup-data" );
    
                    if ( instance && that[ "_" + instance.widgetName + "Options" ] ) {
                        var options = that[ "_" + instance.widgetName + "Options" ](
                            children.length === 1 ? "only" : value
                        );
                        options.classes = that._resolveClassesValues( options.classes, instance );
                        instance.element[ instance.widgetName ]( options );
                    } else {
                        that._updateCornerClass( children[ value ](), value );
                    }
                } );
    
                // Finally call the refresh method on each of the child widgets.
                this._callChildMethod( "refresh" );
            }
        }
    } );
    
    /*!
     * jQuery UI Checkboxradio 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Checkboxradio
    //>>group: Widgets
    //>>description: Enhances a form with multiple themeable checkboxes or radio buttons.
    //>>docs: http://api.jqueryui.com/checkboxradio/
    //>>demos: http://jqueryui.com/checkboxradio/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/button.css
    //>>css.structure: ../../themes/base/checkboxradio.css
    //>>css.theme: ../../themes/base/theme.css
    
    
    
    $.widget( "ui.checkboxradio", [ $.ui.formResetMixin, {
        version: "1.12.1",
        options: {
            disabled: null,
            label: null,
            icon: true,
            classes: {
                "ui-checkboxradio-label": "ui-corner-all",
                "ui-checkboxradio-icon": "ui-corner-all"
            }
        },
    
        _getCreateOptions: function() {
            var disabled, labels;
            var that = this;
            var options = this._super() || {};
    
            // We read the type here, because it makes more sense to throw a element type error first,
            // rather then the error for lack of a label. Often if its the wrong type, it
            // won't have a label (e.g. calling on a div, btn, etc)
            this._readType();
    
            labels = this.element.labels();
    
            // If there are multiple labels, use the last one
            this.label = $( labels[ labels.length - 1 ] );
            if ( !this.label.length ) {
                $.error( "No label found for checkboxradio widget" );
            }
    
            this.originalLabel = "";
    
            // We need to get the label text but this may also need to make sure it does not contain the
            // input itself.
            this.label.contents().not( this.element[ 0 ] ).each( function() {
    
                // The label contents could be text, html, or a mix. We concat each element to get a
                // string representation of the label, without the input as part of it.
                that.originalLabel += this.nodeType === 3 ? $( this ).text() : this.outerHTML;
            } );
    
            // Set the label option if we found label text
            if ( this.originalLabel ) {
                options.label = this.originalLabel;
            }
    
            disabled = this.element[ 0 ].disabled;
            if ( disabled != null ) {
                options.disabled = disabled;
            }
            return options;
        },
    
        _create: function() {
            var checked = this.element[ 0 ].checked;
    
            this._bindFormResetHandler();
    
            if ( this.options.disabled == null ) {
                this.options.disabled = this.element[ 0 ].disabled;
            }
    
            this._setOption( "disabled", this.options.disabled );
            this._addClass( "ui-checkboxradio", "ui-helper-hidden-accessible" );
            this._addClass( this.label, "ui-checkboxradio-label", "ui-button ui-widget" );
    
            if ( this.type === "radio" ) {
                this._addClass( this.label, "ui-checkboxradio-radio-label" );
            }
    
            if ( this.options.label && this.options.label !== this.originalLabel ) {
                this._updateLabel();
            } else if ( this.originalLabel ) {
                this.options.label = this.originalLabel;
            }
    
            this._enhance();
    
            if ( checked ) {
                this._addClass( this.label, "ui-checkboxradio-checked", "ui-state-active" );
                if ( this.icon ) {
                    this._addClass( this.icon, null, "ui-state-hover" );
                }
            }
    
            this._on( {
                change: "_toggleClasses",
                focus: function() {
                    this._addClass( this.label, null, "ui-state-focus ui-visual-focus" );
                },
                blur: function() {
                    this._removeClass( this.label, null, "ui-state-focus ui-visual-focus" );
                }
            } );
        },
    
        _readType: function() {
            var nodeName = this.element[ 0 ].nodeName.toLowerCase();
            this.type = this.element[ 0 ].type;
            if ( nodeName !== "input" || !/radio|checkbox/.test( this.type ) ) {
                $.error( "Can't create checkboxradio on element.nodeName=" + nodeName +
                    " and element.type=" + this.type );
            }
        },
    
        // Support jQuery Mobile enhanced option
        _enhance: function() {
            this._updateIcon( this.element[ 0 ].checked );
        },
    
        widget: function() {
            return this.label;
        },
    
        _getRadioGroup: function() {
            var group;
            var name = this.element[ 0 ].name;
            var nameSelector = "input[name='" + $.ui.escapeSelector( name ) + "']";
    
            if ( !name ) {
                return $( [] );
            }
    
            if ( this.form.length ) {
                group = $( this.form[ 0 ].elements ).filter( nameSelector );
            } else {
    
                // Not inside a form, check all inputs that also are not inside a form
                group = $( nameSelector ).filter( function() {
                    return $( this ).form().length === 0;
                } );
            }
    
            return group.not( this.element );
        },
    
        _toggleClasses: function() {
            var checked = this.element[ 0 ].checked;
            this._toggleClass( this.label, "ui-checkboxradio-checked", "ui-state-active", checked );
    
            if ( this.options.icon && this.type === "checkbox" ) {
                this._toggleClass( this.icon, null, "ui-icon-check ui-state-checked", checked )
                    ._toggleClass( this.icon, null, "ui-icon-blank", !checked );
            }
    
            if ( this.type === "radio" ) {
                this._getRadioGroup()
                    .each( function() {
                        var instance = $( this ).checkboxradio( "instance" );
    
                        if ( instance ) {
                            instance._removeClass( instance.label,
                                "ui-checkboxradio-checked", "ui-state-active" );
                        }
                    } );
            }
        },
    
        _destroy: function() {
            this._unbindFormResetHandler();
    
            if ( this.icon ) {
                this.icon.remove();
                this.iconSpace.remove();
            }
        },
    
        _setOption: function( key, value ) {
    
            // We don't allow the value to be set to nothing
            if ( key === "label" && !value ) {
                return;
            }
    
            this._super( key, value );
    
            if ( key === "disabled" ) {
                this._toggleClass( this.label, null, "ui-state-disabled", value );
                this.element[ 0 ].disabled = value;
    
                // Don't refresh when setting disabled
                return;
            }
            this.refresh();
        },
    
        _updateIcon: function( checked ) {
            var toAdd = "ui-icon ui-icon-background ";
    
            if ( this.options.icon ) {
                if ( !this.icon ) {
                    this.icon = $( "<span>" );
                    this.iconSpace = $( "<span> </span>" );
                    this._addClass( this.iconSpace, "ui-checkboxradio-icon-space" );
                }
    
                if ( this.type === "checkbox" ) {
                    toAdd += checked ? "ui-icon-check ui-state-checked" : "ui-icon-blank";
                    this._removeClass( this.icon, null, checked ? "ui-icon-blank" : "ui-icon-check" );
                } else {
                    toAdd += "ui-icon-blank";
                }
                this._addClass( this.icon, "ui-checkboxradio-icon", toAdd );
                if ( !checked ) {
                    this._removeClass( this.icon, null, "ui-icon-check ui-state-checked" );
                }
                this.icon.prependTo( this.label ).after( this.iconSpace );
            } else if ( this.icon !== undefined ) {
                this.icon.remove();
                this.iconSpace.remove();
                delete this.icon;
            }
        },
    
        _updateLabel: function() {
    
            // Remove the contents of the label ( minus the icon, icon space, and input )
            var contents = this.label.contents().not( this.element[ 0 ] );
            if ( this.icon ) {
                contents = contents.not( this.icon[ 0 ] );
            }
            if ( this.iconSpace ) {
                contents = contents.not( this.iconSpace[ 0 ] );
            }
            contents.remove();
    
            this.label.append( this.options.label );
        },
    
        refresh: function() {
            var checked = this.element[ 0 ].checked,
                isDisabled = this.element[ 0 ].disabled;
    
            this._updateIcon( checked );
            this._toggleClass( this.label, "ui-checkboxradio-checked", "ui-state-active", checked );
            if ( this.options.label !== null ) {
                this._updateLabel();
            }
    
            if ( isDisabled !== this.options.disabled ) {
                this._setOptions( { "disabled": isDisabled } );
            }
        }
    
    } ] );
    
    var widgetsCheckboxradio = $.ui.checkboxradio;
    
    
    /*!
     * jQuery UI Button 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Button
    //>>group: Widgets
    //>>description: Enhances a form with themeable buttons.
    //>>docs: http://api.jqueryui.com/button/
    //>>demos: http://jqueryui.com/button/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/button.css
    //>>css.theme: ../../themes/base/theme.css
    
    
    
    $.widget( "ui.button", {
        version: "1.12.1",
        defaultElement: "<button>",
        options: {
            classes: {
                "ui-button": "ui-corner-all"
            },
            disabled: null,
            icon: null,
            iconPosition: "beginning",
            label: null,
            showLabel: true
        },
    
        _getCreateOptions: function() {
            var disabled,
    
                // This is to support cases like in jQuery Mobile where the base widget does have
                // an implementation of _getCreateOptions
                options = this._super() || {};
    
            this.isInput = this.element.is( "input" );
    
            disabled = this.element[ 0 ].disabled;
            if ( disabled != null ) {
                options.disabled = disabled;
            }
    
            this.originalLabel = this.isInput ? this.element.val() : this.element.html();
            if ( this.originalLabel ) {
                options.label = this.originalLabel;
            }
    
            return options;
        },
    
        _create: function() {
            if ( !this.option.showLabel & !this.options.icon ) {
                this.options.showLabel = true;
            }
    
            // We have to check the option again here even though we did in _getCreateOptions,
            // because null may have been passed on init which would override what was set in
            // _getCreateOptions
            if ( this.options.disabled == null ) {
                this.options.disabled = this.element[ 0 ].disabled || false;
            }
    
            this.hasTitle = !!this.element.attr( "title" );
    
            // Check to see if the label needs to be set or if its already correct
            if ( this.options.label && this.options.label !== this.originalLabel ) {
                if ( this.isInput ) {
                    this.element.val( this.options.label );
                } else {
                    this.element.html( this.options.label );
                }
            }
            this._addClass( "ui-button", "ui-widget" );
            this._setOption( "disabled", this.options.disabled );
            this._enhance();
    
            if ( this.element.is( "a" ) ) {
                this._on( {
                    "keyup": function( event ) {
                        if ( event.keyCode === $.ui.keyCode.SPACE ) {
                            event.preventDefault();
    
                            // Support: PhantomJS <= 1.9, IE 8 Only
                            // If a native click is available use it so we actually cause navigation
                            // otherwise just trigger a click event
                            if ( this.element[ 0 ].click ) {
                                this.element[ 0 ].click();
                            } else {
                                this.element.trigger( "click" );
                            }
                        }
                    }
                } );
            }
        },
    
        _enhance: function() {
            if ( !this.element.is( "button" ) ) {
                this.element.attr( "role", "button" );
            }
    
            if ( this.options.icon ) {
                this._updateIcon( "icon", this.options.icon );
                this._updateTooltip();
            }
        },
    
        _updateTooltip: function() {
            this.title = this.element.attr( "title" );
    
            if ( !this.options.showLabel && !this.title ) {
                this.element.attr( "title", this.options.label );
            }
        },
    
        _updateIcon: function( option, value ) {
            var icon = option !== "iconPosition",
                position = icon ? this.options.iconPosition : value,
                displayBlock = position === "top" || position === "bottom";
    
            // Create icon
            if ( !this.icon ) {
                this.icon = $( "<span>" );
    
                this._addClass( this.icon, "ui-button-icon", "ui-icon" );
    
                if ( !this.options.showLabel ) {
                    this._addClass( "ui-button-icon-only" );
                }
            } else if ( icon ) {
    
                // If we are updating the icon remove the old icon class
                this._removeClass( this.icon, null, this.options.icon );
            }
    
            // If we are updating the icon add the new icon class
            if ( icon ) {
                this._addClass( this.icon, null, value );
            }
    
            this._attachIcon( position );
    
            // If the icon is on top or bottom we need to add the ui-widget-icon-block class and remove
            // the iconSpace if there is one.
            if ( displayBlock ) {
                this._addClass( this.icon, null, "ui-widget-icon-block" );
                if ( this.iconSpace ) {
                    this.iconSpace.remove();
                }
            } else {
    
                // Position is beginning or end so remove the ui-widget-icon-block class and add the
                // space if it does not exist
                if ( !this.iconSpace ) {
                    this.iconSpace = $( "<span> </span>" );
                    this._addClass( this.iconSpace, "ui-button-icon-space" );
                }
                this._removeClass( this.icon, null, "ui-wiget-icon-block" );
                this._attachIconSpace( position );
            }
        },
    
        _destroy: function() {
            this.element.removeAttr( "role" );
    
            if ( this.icon ) {
                this.icon.remove();
            }
            if ( this.iconSpace ) {
                this.iconSpace.remove();
            }
            if ( !this.hasTitle ) {
                this.element.removeAttr( "title" );
            }
        },
    
        _attachIconSpace: function( iconPosition ) {
            this.icon[ /^(?:end|bottom)/.test( iconPosition ) ? "before" : "after" ]( this.iconSpace );
        },
    
        _attachIcon: function( iconPosition ) {
            this.element[ /^(?:end|bottom)/.test( iconPosition ) ? "append" : "prepend" ]( this.icon );
        },
    
        _setOptions: function( options ) {
            var newShowLabel = options.showLabel === undefined ?
                    this.options.showLabel :
                    options.showLabel,
                newIcon = options.icon === undefined ? this.options.icon : options.icon;
    
            if ( !newShowLabel && !newIcon ) {
                options.showLabel = true;
            }
            this._super( options );
        },
    
        _setOption: function( key, value ) {
            if ( key === "icon" ) {
                if ( value ) {
                    this._updateIcon( key, value );
                } else if ( this.icon ) {
                    this.icon.remove();
                    if ( this.iconSpace ) {
                        this.iconSpace.remove();
                    }
                }
            }
    
            if ( key === "iconPosition" ) {
                this._updateIcon( key, value );
            }
    
            // Make sure we can't end up with a button that has neither text nor icon
            if ( key === "showLabel" ) {
                    this._toggleClass( "ui-button-icon-only", null, !value );
                    this._updateTooltip();
            }
    
            if ( key === "label" ) {
                if ( this.isInput ) {
                    this.element.val( value );
                } else {
    
                    // If there is an icon, append it, else nothing then append the value
                    // this avoids removal of the icon when setting label text
                    this.element.html( value );
                    if ( this.icon ) {
                        this._attachIcon( this.options.iconPosition );
                        this._attachIconSpace( this.options.iconPosition );
                    }
                }
            }
    
            this._super( key, value );
    
            if ( key === "disabled" ) {
                this._toggleClass( null, "ui-state-disabled", value );
                this.element[ 0 ].disabled = value;
                if ( value ) {
                    this.element.blur();
                }
            }
        },
    
        refresh: function() {
    
            // Make sure to only check disabled if its an element that supports this otherwise
            // check for the disabled class to determine state
            var isDisabled = this.element.is( "input, button" ) ?
                this.element[ 0 ].disabled : this.element.hasClass( "ui-button-disabled" );
    
            if ( isDisabled !== this.options.disabled ) {
                this._setOptions( { disabled: isDisabled } );
            }
    
            this._updateTooltip();
        }
    } );
    
    // DEPRECATED
    if ( $.uiBackCompat !== false ) {
    
        // Text and Icons options
        $.widget( "ui.button", $.ui.button, {
            options: {
                text: true,
                icons: {
                    primary: null,
                    secondary: null
                }
            },
    
            _create: function() {
                if ( this.options.showLabel && !this.options.text ) {
                    this.options.showLabel = this.options.text;
                }
                if ( !this.options.showLabel && this.options.text ) {
                    this.options.text = this.options.showLabel;
                }
                if ( !this.options.icon && ( this.options.icons.primary ||
                        this.options.icons.secondary ) ) {
                    if ( this.options.icons.primary ) {
                        this.options.icon = this.options.icons.primary;
                    } else {
                        this.options.icon = this.options.icons.secondary;
                        this.options.iconPosition = "end";
                    }
                } else if ( this.options.icon ) {
                    this.options.icons.primary = this.options.icon;
                }
                this._super();
            },
    
            _setOption: function( key, value ) {
                if ( key === "text" ) {
                    this._super( "showLabel", value );
                    return;
                }
                if ( key === "showLabel" ) {
                    this.options.text = value;
                }
                if ( key === "icon" ) {
                    this.options.icons.primary = value;
                }
                if ( key === "icons" ) {
                    if ( value.primary ) {
                        this._super( "icon", value.primary );
                        this._super( "iconPosition", "beginning" );
                    } else if ( value.secondary ) {
                        this._super( "icon", value.secondary );
                        this._super( "iconPosition", "end" );
                    }
                }
                this._superApply( arguments );
            }
        } );
    
        $.fn.button = ( function( orig ) {
            return function() {
                if ( !this.length || ( this.length && this[ 0 ].tagName !== "INPUT" ) ||
                        ( this.length && this[ 0 ].tagName === "INPUT" && (
                            this.attr( "type" ) !== "checkbox" && this.attr( "type" ) !== "radio"
                        ) ) ) {
                    return orig.apply( this, arguments );
                }
                if ( !$.ui.checkboxradio ) {
                    $.error( "Checkboxradio widget missing" );
                }
                if ( arguments.length === 0 ) {
                    return this.checkboxradio( {
                        "icon": false
                    } );
                }
                return this.checkboxradio.apply( this, arguments );
            };
        } )( $.fn.button );
    
        $.fn.buttonset = function() {
            if ( !$.ui.controlgroup ) {
                $.error( "Controlgroup widget missing" );
            }
            if ( arguments[ 0 ] === "option" && arguments[ 1 ] === "items" && arguments[ 2 ] ) {
                return this.controlgroup.apply( this,
                    [ arguments[ 0 ], "items.button", arguments[ 2 ] ] );
            }
            if ( arguments[ 0 ] === "option" && arguments[ 1 ] === "items" ) {
                return this.controlgroup.apply( this, [ arguments[ 0 ], "items.button" ] );
            }
            if ( typeof arguments[ 0 ] === "object" && arguments[ 0 ].items ) {
                arguments[ 0 ].items = {
                    button: arguments[ 0 ].items
                };
            }
            return this.controlgroup.apply( this, arguments );
        };
    }
    
    var widgetsButton = $.ui.button;
    
    
    // jscs:disable maximumLineLength
    /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
    /*!
     * jQuery UI Datepicker 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Datepicker
    //>>group: Widgets
    //>>description: Displays a calendar from an input or inline for selecting dates.
    //>>docs: http://api.jqueryui.com/datepicker/
    //>>demos: http://jqueryui.com/datepicker/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/datepicker.css
    //>>css.theme: ../../themes/base/theme.css
    
    
    
    $.extend( $.ui, { datepicker: { version: "1.12.1" } } );
    
    var datepicker_instActive;
    
    function datepicker_getZindex( elem ) {
        var position, value;
        while ( elem.length && elem[ 0 ] !== document ) {
    
            // Ignore z-index if position is set to a value where z-index is ignored by the browser
            // This makes behavior of this function consistent across browsers
            // WebKit always returns auto if the element is positioned
            position = elem.css( "position" );
            if ( position === "absolute" || position === "relative" || position === "fixed" ) {
    
                // IE returns 0 when zIndex is not specified
                // other browsers return a string
                // we ignore the case of nested elements with an explicit value of 0
                // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                value = parseInt( elem.css( "zIndex" ), 10 );
                if ( !isNaN( value ) && value !== 0 ) {
                    return value;
                }
            }
            elem = elem.parent();
        }
    
        return 0;
    }
    /* Date picker manager.
       Use the singleton instance of this class, $.datepicker, to interact with the date picker.
       Settings for (groups of) date pickers are maintained in an instance object,
       allowing multiple different settings on the same page. */
    
    function Datepicker() {
        this._curInst = null; // The current instance in use
        this._keyEvent = false; // If the last event was a key event
        this._disabledInputs = []; // List of date picker inputs that have been disabled
        this._datepickerShowing = false; // True if the popup picker is showing , false if not
        this._inDialog = false; // True if showing within a "dialog", false if not
        this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
        this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
        this._appendClass = "ui-datepicker-append"; // The name of the append marker class
        this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
        this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
        this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
        this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
        this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
        this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
        this.regional = []; // Available regional settings, indexed by language code
        this.regional[ "" ] = { // Default regional settings
            closeText: "Done", // Display text for close link
            prevText: "Prev", // Display text for previous month link
            nextText: "Next", // Display text for next month link
            currentText: "Today", // Display text for current month link
            monthNames: [ "January","February","March","April","May","June",
                "July","August","September","October","November","December" ], // Names of months for drop-down and formatting
            monthNamesShort: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ], // For formatting
            dayNames: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], // For formatting
            dayNamesShort: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], // For formatting
            dayNamesMin: [ "Su","Mo","Tu","We","Th","Fr","Sa" ], // Column headings for days starting at Sunday
            weekHeader: "Wk", // Column header for week of the year
            dateFormat: "mm/dd/yy", // See format options on parseDate
            firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
            isRTL: false, // True if right-to-left language, false if left-to-right
            showMonthAfterYear: false, // True if the year select precedes month, false for month then year
            yearSuffix: "" // Additional text to append to the year in the month headers
        };
        this._defaults = { // Global defaults for all the date picker instances
            showOn: "focus", // "focus" for popup on focus,
                // "button" for trigger button, or "both" for either
            showAnim: "fadeIn", // Name of jQuery animation for popup
            showOptions: {}, // Options for enhanced animations
            defaultDate: null, // Used when field is blank: actual date,
                // +/-number for offset from today, null for today
            appendText: "", // Display text following the input box, e.g. showing the format
            buttonText: "...", // Text for trigger button
            buttonImage: "", // URL for trigger button image
            buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
            hideIfNoPrevNext: false, // True to hide next/previous month links
                // if not applicable, false to just disable them
            navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
            gotoCurrent: false, // True if today link goes back to current selection instead
            changeMonth: false, // True if month can be selected directly, false if only prev/next
            changeYear: false, // True if year can be selected directly, false if only prev/next
            yearRange: "c-10:c+10", // Range of years to display in drop-down,
                // either relative to today's year (-nn:+nn), relative to currently displayed year
                // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
            showOtherMonths: false, // True to show dates in other months, false to leave blank
            selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
            showWeek: false, // True to show week of the year, false to not show it
            calculateWeek: this.iso8601Week, // How to calculate the week of the year,
                // takes a Date and returns the number of the week for it
            shortYearCutoff: "+10", // Short year values < this are in the current century,
                // > this are in the previous century,
                // string value starting with "+" for current year + value
            minDate: null, // The earliest selectable date, or null for no limit
            maxDate: null, // The latest selectable date, or null for no limit
            duration: "fast", // Duration of display/closure
            beforeShowDay: null, // Function that takes a date and returns an array with
                // [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
                // [2] = cell title (optional), e.g. $.datepicker.noWeekends
            beforeShow: null, // Function that takes an input field and
                // returns a set of custom settings for the date picker
            onSelect: null, // Define a callback function when a date is selected
            onChangeMonthYear: null, // Define a callback function when the month or year is changed
            onClose: null, // Define a callback function when the datepicker is closed
            numberOfMonths: 1, // Number of months to show at a time
            showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
            stepMonths: 1, // Number of months to step back/forward
            stepBigMonths: 12, // Number of months to step back/forward for the big links
            altField: "", // Selector for an alternate field to store selected dates into
            altFormat: "", // The date format to use for the alternate field
            constrainInput: true, // The input is constrained by the current date format
            showButtonPanel: false, // True to show button panel, false to not show it
            autoSize: false, // True to size the input for the date format, false to leave as is
            disabled: false // The initial disabled state
        };
        $.extend( this._defaults, this.regional[ "" ] );
        this.regional.en = $.extend( true, {}, this.regional[ "" ] );
        this.regional[ "en-US" ] = $.extend( true, {}, this.regional.en );
        this.dpDiv = datepicker_bindHover( $( "<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>" ) );
    }
    
    $.extend( Datepicker.prototype, {
        /* Class name added to elements to indicate already configured with a date picker. */
        markerClassName: "hasDatepicker",
    
        //Keep track of the maximum number of rows displayed (see #7043)
        maxRows: 4,
    
        // TODO rename to "widget" when switching to widget factory
        _widgetDatepicker: function() {
            return this.dpDiv;
        },
    
        /* Override the default settings for all instances of the date picker.
         * @param  settings  object - the new settings to use as defaults (anonymous object)
         * @return the manager object
         */
        setDefaults: function( settings ) {
            datepicker_extendRemove( this._defaults, settings || {} );
            return this;
        },
    
        /* Attach the date picker to a jQuery selection.
         * @param  target	element - the target input field or division or span
         * @param  settings  object - the new settings to use for this date picker instance (anonymous)
         */
        _attachDatepicker: function( target, settings ) {
            var nodeName, inline, inst;
            nodeName = target.nodeName.toLowerCase();
            inline = ( nodeName === "div" || nodeName === "span" );
            if ( !target.id ) {
                this.uuid += 1;
                target.id = "dp" + this.uuid;
            }
            inst = this._newInst( $( target ), inline );
            inst.settings = $.extend( {}, settings || {} );
            if ( nodeName === "input" ) {
                this._connectDatepicker( target, inst );
            } else if ( inline ) {
                this._inlineDatepicker( target, inst );
            }
        },
    
        /* Create a new instance object. */
        _newInst: function( target, inline ) {
            var id = target[ 0 ].id.replace( /([^A-Za-z0-9_\-])/g, "\\\\$1" ); // escape jQuery meta chars
            return { id: id, input: target, // associated target
                selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
                drawMonth: 0, drawYear: 0, // month being drawn
                inline: inline, // is datepicker inline or not
                dpDiv: ( !inline ? this.dpDiv : // presentation div
                datepicker_bindHover( $( "<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>" ) ) ) };
        },
    
        /* Attach the date picker to an input field. */
        _connectDatepicker: function( target, inst ) {
            var input = $( target );
            inst.append = $( [] );
            inst.trigger = $( [] );
            if ( input.hasClass( this.markerClassName ) ) {
                return;
            }
            this._attachments( input, inst );
            input.addClass( this.markerClassName ).on( "keydown", this._doKeyDown ).
                on( "keypress", this._doKeyPress ).on( "keyup", this._doKeyUp );
            this._autoSize( inst );
            $.data( target, "datepicker", inst );
    
            //If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
            if ( inst.settings.disabled ) {
                this._disableDatepicker( target );
            }
        },
    
        /* Make attachments based on settings. */
        _attachments: function( input, inst ) {
            var showOn, buttonText, buttonImage,
                appendText = this._get( inst, "appendText" ),
                isRTL = this._get( inst, "isRTL" );
    
            if ( inst.append ) {
                inst.append.remove();
            }
            if ( appendText ) {
                inst.append = $( "<span class='" + this._appendClass + "'>" + appendText + "</span>" );
                input[ isRTL ? "before" : "after" ]( inst.append );
            }
    
            input.off( "focus", this._showDatepicker );
    
            if ( inst.trigger ) {
                inst.trigger.remove();
            }
    
            showOn = this._get( inst, "showOn" );
            if ( showOn === "focus" || showOn === "both" ) { // pop-up date picker when in the marked field
                input.on( "focus", this._showDatepicker );
            }
            if ( showOn === "button" || showOn === "both" ) { // pop-up date picker when button clicked
                buttonText = this._get( inst, "buttonText" );
                buttonImage = this._get( inst, "buttonImage" );
                inst.trigger = $( this._get( inst, "buttonImageOnly" ) ?
                    $( "<img/>" ).addClass( this._triggerClass ).
                        attr( { src: buttonImage, alt: buttonText, title: buttonText } ) :
                    $( "<button type='button'></button>" ).addClass( this._triggerClass ).
                        html( !buttonImage ? buttonText : $( "<img/>" ).attr(
                        { src:buttonImage, alt:buttonText, title:buttonText } ) ) );
                input[ isRTL ? "before" : "after" ]( inst.trigger );
                inst.trigger.on( "click", function() {
                    if ( $.datepicker._datepickerShowing && $.datepicker._lastInput === input[ 0 ] ) {
                        $.datepicker._hideDatepicker();
                    } else if ( $.datepicker._datepickerShowing && $.datepicker._lastInput !== input[ 0 ] ) {
                        $.datepicker._hideDatepicker();
                        $.datepicker._showDatepicker( input[ 0 ] );
                    } else {
                        $.datepicker._showDatepicker( input[ 0 ] );
                    }
                    return false;
                } );
            }
        },
    
        /* Apply the maximum length for the date format. */
        _autoSize: function( inst ) {
            if ( this._get( inst, "autoSize" ) && !inst.inline ) {
                var findMax, max, maxI, i,
                    date = new Date( 2009, 12 - 1, 20 ), // Ensure double digits
                    dateFormat = this._get( inst, "dateFormat" );
    
                if ( dateFormat.match( /[DM]/ ) ) {
                    findMax = function( names ) {
                        max = 0;
                        maxI = 0;
                        for ( i = 0; i < names.length; i++ ) {
                            if ( names[ i ].length > max ) {
                                max = names[ i ].length;
                                maxI = i;
                            }
                        }
                        return maxI;
                    };
                    date.setMonth( findMax( this._get( inst, ( dateFormat.match( /MM/ ) ?
                        "monthNames" : "monthNamesShort" ) ) ) );
                    date.setDate( findMax( this._get( inst, ( dateFormat.match( /DD/ ) ?
                        "dayNames" : "dayNamesShort" ) ) ) + 20 - date.getDay() );
                }
                inst.input.attr( "size", this._formatDate( inst, date ).length );
            }
        },
    
        /* Attach an inline date picker to a div. */
        _inlineDatepicker: function( target, inst ) {
            var divSpan = $( target );
            if ( divSpan.hasClass( this.markerClassName ) ) {
                return;
            }
            divSpan.addClass( this.markerClassName ).append( inst.dpDiv );
            $.data( target, "datepicker", inst );
            this._setDate( inst, this._getDefaultDate( inst ), true );
            this._updateDatepicker( inst );
            this._updateAlternate( inst );
    
            //If disabled option is true, disable the datepicker before showing it (see ticket #5665)
            if ( inst.settings.disabled ) {
                this._disableDatepicker( target );
            }
    
            // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
            // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
            inst.dpDiv.css( "display", "block" );
        },
    
        /* Pop-up the date picker in a "dialog" box.
         * @param  input element - ignored
         * @param  date	string or Date - the initial date to display
         * @param  onSelect  function - the function to call when a date is selected
         * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
         * @param  pos int[2] - coordinates for the dialog's position within the screen or
         *					event - with x/y coordinates or
         *					leave empty for default (screen centre)
         * @return the manager object
         */
        _dialogDatepicker: function( input, date, onSelect, settings, pos ) {
            var id, browserWidth, browserHeight, scrollX, scrollY,
                inst = this._dialogInst; // internal instance
    
            if ( !inst ) {
                this.uuid += 1;
                id = "dp" + this.uuid;
                this._dialogInput = $( "<input type='text' id='" + id +
                    "' style='position: absolute; top: -100px; width: 0px;'/>" );
                this._dialogInput.on( "keydown", this._doKeyDown );
                $( "body" ).append( this._dialogInput );
                inst = this._dialogInst = this._newInst( this._dialogInput, false );
                inst.settings = {};
                $.data( this._dialogInput[ 0 ], "datepicker", inst );
            }
            datepicker_extendRemove( inst.settings, settings || {} );
            date = ( date && date.constructor === Date ? this._formatDate( inst, date ) : date );
            this._dialogInput.val( date );
    
            this._pos = ( pos ? ( pos.length ? pos : [ pos.pageX, pos.pageY ] ) : null );
            if ( !this._pos ) {
                browserWidth = document.documentElement.clientWidth;
                browserHeight = document.documentElement.clientHeight;
                scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
                scrollY = document.documentElement.scrollTop || document.body.scrollTop;
                this._pos = // should use actual width/height below
                    [ ( browserWidth / 2 ) - 100 + scrollX, ( browserHeight / 2 ) - 150 + scrollY ];
            }
    
            // Move input on screen for focus, but hidden behind dialog
            this._dialogInput.css( "left", ( this._pos[ 0 ] + 20 ) + "px" ).css( "top", this._pos[ 1 ] + "px" );
            inst.settings.onSelect = onSelect;
            this._inDialog = true;
            this.dpDiv.addClass( this._dialogClass );
            this._showDatepicker( this._dialogInput[ 0 ] );
            if ( $.blockUI ) {
                $.blockUI( this.dpDiv );
            }
            $.data( this._dialogInput[ 0 ], "datepicker", inst );
            return this;
        },
    
        /* Detach a datepicker from its control.
         * @param  target	element - the target input field or division or span
         */
        _destroyDatepicker: function( target ) {
            var nodeName,
                $target = $( target ),
                inst = $.data( target, "datepicker" );
    
            if ( !$target.hasClass( this.markerClassName ) ) {
                return;
            }
    
            nodeName = target.nodeName.toLowerCase();
            $.removeData( target, "datepicker" );
            if ( nodeName === "input" ) {
                inst.append.remove();
                inst.trigger.remove();
                $target.removeClass( this.markerClassName ).
                    off( "focus", this._showDatepicker ).
                    off( "keydown", this._doKeyDown ).
                    off( "keypress", this._doKeyPress ).
                    off( "keyup", this._doKeyUp );
            } else if ( nodeName === "div" || nodeName === "span" ) {
                $target.removeClass( this.markerClassName ).empty();
            }
    
            if ( datepicker_instActive === inst ) {
                datepicker_instActive = null;
            }
        },
    
        /* Enable the date picker to a jQuery selection.
         * @param  target	element - the target input field or division or span
         */
        _enableDatepicker: function( target ) {
            var nodeName, inline,
                $target = $( target ),
                inst = $.data( target, "datepicker" );
    
            if ( !$target.hasClass( this.markerClassName ) ) {
                return;
            }
    
            nodeName = target.nodeName.toLowerCase();
            if ( nodeName === "input" ) {
                target.disabled = false;
                inst.trigger.filter( "button" ).
                    each( function() { this.disabled = false; } ).end().
                    filter( "img" ).css( { opacity: "1.0", cursor: "" } );
            } else if ( nodeName === "div" || nodeName === "span" ) {
                inline = $target.children( "." + this._inlineClass );
                inline.children().removeClass( "ui-state-disabled" );
                inline.find( "select.ui-datepicker-month, select.ui-datepicker-year" ).
                    prop( "disabled", false );
            }
            this._disabledInputs = $.map( this._disabledInputs,
                function( value ) { return ( value === target ? null : value ); } ); // delete entry
        },
    
        /* Disable the date picker to a jQuery selection.
         * @param  target	element - the target input field or division or span
         */
        _disableDatepicker: function( target ) {
            var nodeName, inline,
                $target = $( target ),
                inst = $.data( target, "datepicker" );
    
            if ( !$target.hasClass( this.markerClassName ) ) {
                return;
            }
    
            nodeName = target.nodeName.toLowerCase();
            if ( nodeName === "input" ) {
                target.disabled = true;
                inst.trigger.filter( "button" ).
                    each( function() { this.disabled = true; } ).end().
                    filter( "img" ).css( { opacity: "0.5", cursor: "default" } );
            } else if ( nodeName === "div" || nodeName === "span" ) {
                inline = $target.children( "." + this._inlineClass );
                inline.children().addClass( "ui-state-disabled" );
                inline.find( "select.ui-datepicker-month, select.ui-datepicker-year" ).
                    prop( "disabled", true );
            }
            this._disabledInputs = $.map( this._disabledInputs,
                function( value ) { return ( value === target ? null : value ); } ); // delete entry
            this._disabledInputs[ this._disabledInputs.length ] = target;
        },
    
        /* Is the first field in a jQuery collection disabled as a datepicker?
         * @param  target	element - the target input field or division or span
         * @return boolean - true if disabled, false if enabled
         */
        _isDisabledDatepicker: function( target ) {
            if ( !target ) {
                return false;
            }
            for ( var i = 0; i < this._disabledInputs.length; i++ ) {
                if ( this._disabledInputs[ i ] === target ) {
                    return true;
                }
            }
            return false;
        },
    
        /* Retrieve the instance data for the target control.
         * @param  target  element - the target input field or division or span
         * @return  object - the associated instance data
         * @throws  error if a jQuery problem getting data
         */
        _getInst: function( target ) {
            try {
                return $.data( target, "datepicker" );
            }
            catch ( err ) {
                throw "Missing instance data for this datepicker";
            }
        },
    
        /* Update or retrieve the settings for a date picker attached to an input field or division.
         * @param  target  element - the target input field or division or span
         * @param  name	object - the new settings to update or
         *				string - the name of the setting to change or retrieve,
         *				when retrieving also "all" for all instance settings or
         *				"defaults" for all global defaults
         * @param  value   any - the new value for the setting
         *				(omit if above is an object or to retrieve a value)
         */
        _optionDatepicker: function( target, name, value ) {
            var settings, date, minDate, maxDate,
                inst = this._getInst( target );
    
            if ( arguments.length === 2 && typeof name === "string" ) {
                return ( name === "defaults" ? $.extend( {}, $.datepicker._defaults ) :
                    ( inst ? ( name === "all" ? $.extend( {}, inst.settings ) :
                    this._get( inst, name ) ) : null ) );
            }
    
            settings = name || {};
            if ( typeof name === "string" ) {
                settings = {};
                settings[ name ] = value;
            }
    
            if ( inst ) {
                if ( this._curInst === inst ) {
                    this._hideDatepicker();
                }
    
                date = this._getDateDatepicker( target, true );
                minDate = this._getMinMaxDate( inst, "min" );
                maxDate = this._getMinMaxDate( inst, "max" );
                datepicker_extendRemove( inst.settings, settings );
    
                // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
                if ( minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined ) {
                    inst.settings.minDate = this._formatDate( inst, minDate );
                }
                if ( maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined ) {
                    inst.settings.maxDate = this._formatDate( inst, maxDate );
                }
                if ( "disabled" in settings ) {
                    if ( settings.disabled ) {
                        this._disableDatepicker( target );
                    } else {
                        this._enableDatepicker( target );
                    }
                }
                this._attachments( $( target ), inst );
                this._autoSize( inst );
                this._setDate( inst, date );
                this._updateAlternate( inst );
                this._updateDatepicker( inst );
            }
        },
    
        // Change method deprecated
        _changeDatepicker: function( target, name, value ) {
            this._optionDatepicker( target, name, value );
        },
    
        /* Redraw the date picker attached to an input field or division.
         * @param  target  element - the target input field or division or span
         */
        _refreshDatepicker: function( target ) {
            var inst = this._getInst( target );
            if ( inst ) {
                this._updateDatepicker( inst );
            }
        },
    
        /* Set the dates for a jQuery selection.
         * @param  target element - the target input field or division or span
         * @param  date	Date - the new date
         */
        _setDateDatepicker: function( target, date ) {
            var inst = this._getInst( target );
            if ( inst ) {
                this._setDate( inst, date );
                this._updateDatepicker( inst );
                this._updateAlternate( inst );
            }
        },
    
        /* Get the date(s) for the first entry in a jQuery selection.
         * @param  target element - the target input field or division or span
         * @param  noDefault boolean - true if no default date is to be used
         * @return Date - the current date
         */
        _getDateDatepicker: function( target, noDefault ) {
            var inst = this._getInst( target );
            if ( inst && !inst.inline ) {
                this._setDateFromField( inst, noDefault );
            }
            return ( inst ? this._getDate( inst ) : null );
        },
    
        /* Handle keystrokes. */
        _doKeyDown: function( event ) {
            var onSelect, dateStr, sel,
                inst = $.datepicker._getInst( event.target ),
                handled = true,
                isRTL = inst.dpDiv.is( ".ui-datepicker-rtl" );
    
            inst._keyEvent = true;
            if ( $.datepicker._datepickerShowing ) {
                switch ( event.keyCode ) {
                    case 9: $.datepicker._hideDatepicker();
                            handled = false;
                            break; // hide on tab out
                    case 13: sel = $( "td." + $.datepicker._dayOverClass + ":not(." +
                                        $.datepicker._currentClass + ")", inst.dpDiv );
                            if ( sel[ 0 ] ) {
                                $.datepicker._selectDay( event.target, inst.selectedMonth, inst.selectedYear, sel[ 0 ] );
                            }
    
                            onSelect = $.datepicker._get( inst, "onSelect" );
                            if ( onSelect ) {
                                dateStr = $.datepicker._formatDate( inst );
    
                                // Trigger custom callback
                                onSelect.apply( ( inst.input ? inst.input[ 0 ] : null ), [ dateStr, inst ] );
                            } else {
                                $.datepicker._hideDatepicker();
                            }
    
                            return false; // don't submit the form
                    case 27: $.datepicker._hideDatepicker();
                            break; // hide on escape
                    case 33: $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
                                -$.datepicker._get( inst, "stepBigMonths" ) :
                                -$.datepicker._get( inst, "stepMonths" ) ), "M" );
                            break; // previous month/year on page up/+ ctrl
                    case 34: $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
                                +$.datepicker._get( inst, "stepBigMonths" ) :
                                +$.datepicker._get( inst, "stepMonths" ) ), "M" );
                            break; // next month/year on page down/+ ctrl
                    case 35: if ( event.ctrlKey || event.metaKey ) {
                                $.datepicker._clearDate( event.target );
                            }
                            handled = event.ctrlKey || event.metaKey;
                            break; // clear on ctrl or command +end
                    case 36: if ( event.ctrlKey || event.metaKey ) {
                                $.datepicker._gotoToday( event.target );
                            }
                            handled = event.ctrlKey || event.metaKey;
                            break; // current on ctrl or command +home
                    case 37: if ( event.ctrlKey || event.metaKey ) {
                                $.datepicker._adjustDate( event.target, ( isRTL ? +1 : -1 ), "D" );
                            }
                            handled = event.ctrlKey || event.metaKey;
    
                            // -1 day on ctrl or command +left
                            if ( event.originalEvent.altKey ) {
                                $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
                                    -$.datepicker._get( inst, "stepBigMonths" ) :
                                    -$.datepicker._get( inst, "stepMonths" ) ), "M" );
                            }
    
                            // next month/year on alt +left on Mac
                            break;
                    case 38: if ( event.ctrlKey || event.metaKey ) {
                                $.datepicker._adjustDate( event.target, -7, "D" );
                            }
                            handled = event.ctrlKey || event.metaKey;
                            break; // -1 week on ctrl or command +up
                    case 39: if ( event.ctrlKey || event.metaKey ) {
                                $.datepicker._adjustDate( event.target, ( isRTL ? -1 : +1 ), "D" );
                            }
                            handled = event.ctrlKey || event.metaKey;
    
                            // +1 day on ctrl or command +right
                            if ( event.originalEvent.altKey ) {
                                $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
                                    +$.datepicker._get( inst, "stepBigMonths" ) :
                                    +$.datepicker._get( inst, "stepMonths" ) ), "M" );
                            }
    
                            // next month/year on alt +right
                            break;
                    case 40: if ( event.ctrlKey || event.metaKey ) {
                                $.datepicker._adjustDate( event.target, +7, "D" );
                            }
                            handled = event.ctrlKey || event.metaKey;
                            break; // +1 week on ctrl or command +down
                    default: handled = false;
                }
            } else if ( event.keyCode === 36 && event.ctrlKey ) { // display the date picker on ctrl+home
                $.datepicker._showDatepicker( this );
            } else {
                handled = false;
            }
    
            if ( handled ) {
                event.preventDefault();
                event.stopPropagation();
            }
        },
    
        /* Filter entered characters - based on date format. */
        _doKeyPress: function( event ) {
            var chars, chr,
                inst = $.datepicker._getInst( event.target );
    
            if ( $.datepicker._get( inst, "constrainInput" ) ) {
                chars = $.datepicker._possibleChars( $.datepicker._get( inst, "dateFormat" ) );
                chr = String.fromCharCode( event.charCode == null ? event.keyCode : event.charCode );
                return event.ctrlKey || event.metaKey || ( chr < " " || !chars || chars.indexOf( chr ) > -1 );
            }
        },
    
        /* Synchronise manual entry and field/alternate field. */
        _doKeyUp: function( event ) {
            var date,
                inst = $.datepicker._getInst( event.target );
    
            if ( inst.input.val() !== inst.lastVal ) {
                try {
                    date = $.datepicker.parseDate( $.datepicker._get( inst, "dateFormat" ),
                        ( inst.input ? inst.input.val() : null ),
                        $.datepicker._getFormatConfig( inst ) );
    
                    if ( date ) { // only if valid
                        $.datepicker._setDateFromField( inst );
                        $.datepicker._updateAlternate( inst );
                        $.datepicker._updateDatepicker( inst );
                    }
                }
                catch ( err ) {
                }
            }
            return true;
        },
    
        /* Pop-up the date picker for a given input field.
         * If false returned from beforeShow event handler do not show.
         * @param  input  element - the input field attached to the date picker or
         *					event - if triggered by focus
         */
        _showDatepicker: function( input ) {
            input = input.target || input;
            if ( input.nodeName.toLowerCase() !== "input" ) { // find from button/image trigger
                input = $( "input", input.parentNode )[ 0 ];
            }
    
            if ( $.datepicker._isDisabledDatepicker( input ) || $.datepicker._lastInput === input ) { // already here
                return;
            }
    
            var inst, beforeShow, beforeShowSettings, isFixed,
                offset, showAnim, duration;
    
            inst = $.datepicker._getInst( input );
            if ( $.datepicker._curInst && $.datepicker._curInst !== inst ) {
                $.datepicker._curInst.dpDiv.stop( true, true );
                if ( inst && $.datepicker._datepickerShowing ) {
                    $.datepicker._hideDatepicker( $.datepicker._curInst.input[ 0 ] );
                }
            }
    
            beforeShow = $.datepicker._get( inst, "beforeShow" );
            beforeShowSettings = beforeShow ? beforeShow.apply( input, [ input, inst ] ) : {};
            if ( beforeShowSettings === false ) {
                return;
            }
            datepicker_extendRemove( inst.settings, beforeShowSettings );
    
            inst.lastVal = null;
            $.datepicker._lastInput = input;
            $.datepicker._setDateFromField( inst );
    
            if ( $.datepicker._inDialog ) { // hide cursor
                input.value = "";
            }
            if ( !$.datepicker._pos ) { // position below input
                $.datepicker._pos = $.datepicker._findPos( input );
                $.datepicker._pos[ 1 ] += input.offsetHeight; // add the height
            }
    
            isFixed = false;
            $( input ).parents().each( function() {
                isFixed |= $( this ).css( "position" ) === "fixed";
                return !isFixed;
            } );
    
            offset = { left: $.datepicker._pos[ 0 ], top: $.datepicker._pos[ 1 ] };
            $.datepicker._pos = null;
    
            //to avoid flashes on Firefox
            inst.dpDiv.empty();
    
            // determine sizing offscreen
            inst.dpDiv.css( { position: "absolute", display: "block", top: "-1000px" } );
            $.datepicker._updateDatepicker( inst );
    
            // fix width for dynamic number of date pickers
            // and adjust position before showing
            offset = $.datepicker._checkOffset( inst, offset, isFixed );
            inst.dpDiv.css( { position: ( $.datepicker._inDialog && $.blockUI ?
                "static" : ( isFixed ? "fixed" : "absolute" ) ), display: "none",
                left: offset.left + "px", top: offset.top + "px" } );
    
            if ( !inst.inline ) {
                showAnim = $.datepicker._get( inst, "showAnim" );
                duration = $.datepicker._get( inst, "duration" );
                inst.dpDiv.css( "z-index", datepicker_getZindex( $( input ) ) + 1 );
                $.datepicker._datepickerShowing = true;
    
                if ( $.effects && $.effects.effect[ showAnim ] ) {
                    inst.dpDiv.show( showAnim, $.datepicker._get( inst, "showOptions" ), duration );
                } else {
                    inst.dpDiv[ showAnim || "show" ]( showAnim ? duration : null );
                }
    
                if ( $.datepicker._shouldFocusInput( inst ) ) {
                    inst.input.trigger( "focus" );
                }
    
                $.datepicker._curInst = inst;
            }
        },
    
        /* Generate the date picker content. */
        _updateDatepicker: function( inst ) {
            this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
            datepicker_instActive = inst; // for delegate hover events
            inst.dpDiv.empty().append( this._generateHTML( inst ) );
            this._attachHandlers( inst );
    
            var origyearshtml,
                numMonths = this._getNumberOfMonths( inst ),
                cols = numMonths[ 1 ],
                width = 17,
                activeCell = inst.dpDiv.find( "." + this._dayOverClass + " a" );
    
            if ( activeCell.length > 0 ) {
                datepicker_handleMouseover.apply( activeCell.get( 0 ) );
            }
    
            inst.dpDiv.removeClass( "ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4" ).width( "" );
            if ( cols > 1 ) {
                inst.dpDiv.addClass( "ui-datepicker-multi-" + cols ).css( "width", ( width * cols ) + "em" );
            }
            inst.dpDiv[ ( numMonths[ 0 ] !== 1 || numMonths[ 1 ] !== 1 ? "add" : "remove" ) +
                "Class" ]( "ui-datepicker-multi" );
            inst.dpDiv[ ( this._get( inst, "isRTL" ) ? "add" : "remove" ) +
                "Class" ]( "ui-datepicker-rtl" );
    
            if ( inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
                inst.input.trigger( "focus" );
            }
    
            // Deffered render of the years select (to avoid flashes on Firefox)
            if ( inst.yearshtml ) {
                origyearshtml = inst.yearshtml;
                setTimeout( function() {
    
                    //assure that inst.yearshtml didn't change.
                    if ( origyearshtml === inst.yearshtml && inst.yearshtml ) {
                        inst.dpDiv.find( "select.ui-datepicker-year:first" ).replaceWith( inst.yearshtml );
                    }
                    origyearshtml = inst.yearshtml = null;
                }, 0 );
            }
        },
    
        // #6694 - don't focus the input if it's already focused
        // this breaks the change event in IE
        // Support: IE and jQuery <1.9
        _shouldFocusInput: function( inst ) {
            return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );
        },
    
        /* Check positioning to remain on screen. */
        _checkOffset: function( inst, offset, isFixed ) {
            var dpWidth = inst.dpDiv.outerWidth(),
                dpHeight = inst.dpDiv.outerHeight(),
                inputWidth = inst.input ? inst.input.outerWidth() : 0,
                inputHeight = inst.input ? inst.input.outerHeight() : 0,
                viewWidth = document.documentElement.clientWidth + ( isFixed ? 0 : $( document ).scrollLeft() ),
                viewHeight = document.documentElement.clientHeight + ( isFixed ? 0 : $( document ).scrollTop() );
    
            offset.left -= ( this._get( inst, "isRTL" ) ? ( dpWidth - inputWidth ) : 0 );
            offset.left -= ( isFixed && offset.left === inst.input.offset().left ) ? $( document ).scrollLeft() : 0;
            offset.top -= ( isFixed && offset.top === ( inst.input.offset().top + inputHeight ) ) ? $( document ).scrollTop() : 0;
    
            // Now check if datepicker is showing outside window viewport - move to a better place if so.
            offset.left -= Math.min( offset.left, ( offset.left + dpWidth > viewWidth && viewWidth > dpWidth ) ?
                Math.abs( offset.left + dpWidth - viewWidth ) : 0 );
            offset.top -= Math.min( offset.top, ( offset.top + dpHeight > viewHeight && viewHeight > dpHeight ) ?
                Math.abs( dpHeight + inputHeight ) : 0 );
    
            return offset;
        },
    
        /* Find an object's position on the screen. */
        _findPos: function( obj ) {
            var position,
                inst = this._getInst( obj ),
                isRTL = this._get( inst, "isRTL" );
    
            while ( obj && ( obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden( obj ) ) ) {
                obj = obj[ isRTL ? "previousSibling" : "nextSibling" ];
            }
    
            position = $( obj ).offset();
            return [ position.left, position.top ];
        },
    
        /* Hide the date picker from view.
         * @param  input  element - the input field attached to the date picker
         */
        _hideDatepicker: function( input ) {
            var showAnim, duration, postProcess, onClose,
                inst = this._curInst;
    
            if ( !inst || ( input && inst !== $.data( input, "datepicker" ) ) ) {
                return;
            }
    
            if ( this._datepickerShowing ) {
                showAnim = this._get( inst, "showAnim" );
                duration = this._get( inst, "duration" );
                postProcess = function() {
                    $.datepicker._tidyDialog( inst );
                };
    
                // DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
                if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
                    inst.dpDiv.hide( showAnim, $.datepicker._get( inst, "showOptions" ), duration, postProcess );
                } else {
                    inst.dpDiv[ ( showAnim === "slideDown" ? "slideUp" :
                        ( showAnim === "fadeIn" ? "fadeOut" : "hide" ) ) ]( ( showAnim ? duration : null ), postProcess );
                }
    
                if ( !showAnim ) {
                    postProcess();
                }
                this._datepickerShowing = false;
    
                onClose = this._get( inst, "onClose" );
                if ( onClose ) {
                    onClose.apply( ( inst.input ? inst.input[ 0 ] : null ), [ ( inst.input ? inst.input.val() : "" ), inst ] );
                }
    
                this._lastInput = null;
                if ( this._inDialog ) {
                    this._dialogInput.css( { position: "absolute", left: "0", top: "-100px" } );
                    if ( $.blockUI ) {
                        $.unblockUI();
                        $( "body" ).append( this.dpDiv );
                    }
                }
                this._inDialog = false;
            }
        },
    
        /* Tidy up after a dialog display. */
        _tidyDialog: function( inst ) {
            inst.dpDiv.removeClass( this._dialogClass ).off( ".ui-datepicker-calendar" );
        },
    
        /* Close date picker if clicked elsewhere. */
        _checkExternalClick: function( event ) {
            if ( !$.datepicker._curInst ) {
                return;
            }
    
            var $target = $( event.target ),
                inst = $.datepicker._getInst( $target[ 0 ] );
    
            if ( ( ( $target[ 0 ].id !== $.datepicker._mainDivId &&
                    $target.parents( "#" + $.datepicker._mainDivId ).length === 0 &&
                    !$target.hasClass( $.datepicker.markerClassName ) &&
                    !$target.closest( "." + $.datepicker._triggerClass ).length &&
                    $.datepicker._datepickerShowing && !( $.datepicker._inDialog && $.blockUI ) ) ) ||
                ( $target.hasClass( $.datepicker.markerClassName ) && $.datepicker._curInst !== inst ) ) {
                    $.datepicker._hideDatepicker();
            }
        },
    
        /* Adjust one of the date sub-fields. */
        _adjustDate: function( id, offset, period ) {
            var target = $( id ),
                inst = this._getInst( target[ 0 ] );
    
            if ( this._isDisabledDatepicker( target[ 0 ] ) ) {
                return;
            }
            this._adjustInstDate( inst, offset +
                ( period === "M" ? this._get( inst, "showCurrentAtPos" ) : 0 ), // undo positioning
                period );
            this._updateDatepicker( inst );
        },
    
        /* Action for current link. */
        _gotoToday: function( id ) {
            var date,
                target = $( id ),
                inst = this._getInst( target[ 0 ] );
    
            if ( this._get( inst, "gotoCurrent" ) && inst.currentDay ) {
                inst.selectedDay = inst.currentDay;
                inst.drawMonth = inst.selectedMonth = inst.currentMonth;
                inst.drawYear = inst.selectedYear = inst.currentYear;
            } else {
                date = new Date();
                inst.selectedDay = date.getDate();
                inst.drawMonth = inst.selectedMonth = date.getMonth();
                inst.drawYear = inst.selectedYear = date.getFullYear();
            }
            this._notifyChange( inst );
            this._adjustDate( target );
        },
    
        /* Action for selecting a new month/year. */
        _selectMonthYear: function( id, select, period ) {
            var target = $( id ),
                inst = this._getInst( target[ 0 ] );
    
            inst[ "selected" + ( period === "M" ? "Month" : "Year" ) ] =
            inst[ "draw" + ( period === "M" ? "Month" : "Year" ) ] =
                parseInt( select.options[ select.selectedIndex ].value, 10 );
    
            this._notifyChange( inst );
            this._adjustDate( target );
        },
    
        /* Action for selecting a day. */
        _selectDay: function( id, month, year, td ) {
            var inst,
                target = $( id );
    
            if ( $( td ).hasClass( this._unselectableClass ) || this._isDisabledDatepicker( target[ 0 ] ) ) {
                return;
            }
    
            inst = this._getInst( target[ 0 ] );
            inst.selectedDay = inst.currentDay = $( "a", td ).html();
            inst.selectedMonth = inst.currentMonth = month;
            inst.selectedYear = inst.currentYear = year;
            this._selectDate( id, this._formatDate( inst,
                inst.currentDay, inst.currentMonth, inst.currentYear ) );
        },
    
        /* Erase the input field and hide the date picker. */
        _clearDate: function( id ) {
            var target = $( id );
            this._selectDate( target, "" );
        },
    
        /* Update the input field with the selected date. */
        _selectDate: function( id, dateStr ) {
            var onSelect,
                target = $( id ),
                inst = this._getInst( target[ 0 ] );
    
            dateStr = ( dateStr != null ? dateStr : this._formatDate( inst ) );
            if ( inst.input ) {
                inst.input.val( dateStr );
            }
            this._updateAlternate( inst );
    
            onSelect = this._get( inst, "onSelect" );
            if ( onSelect ) {
                onSelect.apply( ( inst.input ? inst.input[ 0 ] : null ), [ dateStr, inst ] );  // trigger custom callback
            } else if ( inst.input ) {
                inst.input.trigger( "change" ); // fire the change event
            }
    
            if ( inst.inline ) {
                this._updateDatepicker( inst );
            } else {
                this._hideDatepicker();
                this._lastInput = inst.input[ 0 ];
                if ( typeof( inst.input[ 0 ] ) !== "object" ) {
                    inst.input.trigger( "focus" ); // restore focus
                }
                this._lastInput = null;
            }
        },
    
        /* Update any alternate field to synchronise with the main field. */
        _updateAlternate: function( inst ) {
            var altFormat, date, dateStr,
                altField = this._get( inst, "altField" );
    
            if ( altField ) { // update alternate field too
                altFormat = this._get( inst, "altFormat" ) || this._get( inst, "dateFormat" );
                date = this._getDate( inst );
                dateStr = this.formatDate( altFormat, date, this._getFormatConfig( inst ) );
                $( altField ).val( dateStr );
            }
        },
    
        /* Set as beforeShowDay function to prevent selection of weekends.
         * @param  date  Date - the date to customise
         * @return [boolean, string] - is this date selectable?, what is its CSS class?
         */
        noWeekends: function( date ) {
            var day = date.getDay();
            return [ ( day > 0 && day < 6 ), "" ];
        },
    
        /* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
         * @param  date  Date - the date to get the week for
         * @return  number - the number of the week within the year that contains this date
         */
        iso8601Week: function( date ) {
            var time,
                checkDate = new Date( date.getTime() );
    
            // Find Thursday of this week starting on Monday
            checkDate.setDate( checkDate.getDate() + 4 - ( checkDate.getDay() || 7 ) );
    
            time = checkDate.getTime();
            checkDate.setMonth( 0 ); // Compare with Jan 1
            checkDate.setDate( 1 );
            return Math.floor( Math.round( ( time - checkDate ) / 86400000 ) / 7 ) + 1;
        },
    
        /* Parse a string value into a date object.
         * See formatDate below for the possible formats.
         *
         * @param  format string - the expected format of the date
         * @param  value string - the date in the above format
         * @param  settings Object - attributes include:
         *					shortYearCutoff  number - the cutoff year for determining the century (optional)
         *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
         *					dayNames		string[7] - names of the days from Sunday (optional)
         *					monthNamesShort string[12] - abbreviated names of the months (optional)
         *					monthNames		string[12] - names of the months (optional)
         * @return  Date - the extracted date value or null if value is blank
         */
        parseDate: function( format, value, settings ) {
            if ( format == null || value == null ) {
                throw "Invalid arguments";
            }
    
            value = ( typeof value === "object" ? value.toString() : value + "" );
            if ( value === "" ) {
                return null;
            }
    
            var iFormat, dim, extra,
                iValue = 0,
                shortYearCutoffTemp = ( settings ? settings.shortYearCutoff : null ) || this._defaults.shortYearCutoff,
                shortYearCutoff = ( typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
                    new Date().getFullYear() % 100 + parseInt( shortYearCutoffTemp, 10 ) ),
                dayNamesShort = ( settings ? settings.dayNamesShort : null ) || this._defaults.dayNamesShort,
                dayNames = ( settings ? settings.dayNames : null ) || this._defaults.dayNames,
                monthNamesShort = ( settings ? settings.monthNamesShort : null ) || this._defaults.monthNamesShort,
                monthNames = ( settings ? settings.monthNames : null ) || this._defaults.monthNames,
                year = -1,
                month = -1,
                day = -1,
                doy = -1,
                literal = false,
                date,
    
                // Check whether a format character is doubled
                lookAhead = function( match ) {
                    var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
                    if ( matches ) {
                        iFormat++;
                    }
                    return matches;
                },
    
                // Extract a number from the string value
                getNumber = function( match ) {
                    var isDoubled = lookAhead( match ),
                        size = ( match === "@" ? 14 : ( match === "!" ? 20 :
                        ( match === "y" && isDoubled ? 4 : ( match === "o" ? 3 : 2 ) ) ) ),
                        minSize = ( match === "y" ? size : 1 ),
                        digits = new RegExp( "^\\d{" + minSize + "," + size + "}" ),
                        num = value.substring( iValue ).match( digits );
                    if ( !num ) {
                        throw "Missing number at position " + iValue;
                    }
                    iValue += num[ 0 ].length;
                    return parseInt( num[ 0 ], 10 );
                },
    
                // Extract a name from the string value and convert to an index
                getName = function( match, shortNames, longNames ) {
                    var index = -1,
                        names = $.map( lookAhead( match ) ? longNames : shortNames, function( v, k ) {
                            return [ [ k, v ] ];
                        } ).sort( function( a, b ) {
                            return -( a[ 1 ].length - b[ 1 ].length );
                        } );
    
                    $.each( names, function( i, pair ) {
                        var name = pair[ 1 ];
                        if ( value.substr( iValue, name.length ).toLowerCase() === name.toLowerCase() ) {
                            index = pair[ 0 ];
                            iValue += name.length;
                            return false;
                        }
                    } );
                    if ( index !== -1 ) {
                        return index + 1;
                    } else {
                        throw "Unknown name at position " + iValue;
                    }
                },
    
                // Confirm that a literal character matches the string value
                checkLiteral = function() {
                    if ( value.charAt( iValue ) !== format.charAt( iFormat ) ) {
                        throw "Unexpected literal at position " + iValue;
                    }
                    iValue++;
                };
    
            for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
                if ( literal ) {
                    if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
                        literal = false;
                    } else {
                        checkLiteral();
                    }
                } else {
                    switch ( format.charAt( iFormat ) ) {
                        case "d":
                            day = getNumber( "d" );
                            break;
                        case "D":
                            getName( "D", dayNamesShort, dayNames );
                            break;
                        case "o":
                            doy = getNumber( "o" );
                            break;
                        case "m":
                            month = getNumber( "m" );
                            break;
                        case "M":
                            month = getName( "M", monthNamesShort, monthNames );
                            break;
                        case "y":
                            year = getNumber( "y" );
                            break;
                        case "@":
                            date = new Date( getNumber( "@" ) );
                            year = date.getFullYear();
                            month = date.getMonth() + 1;
                            day = date.getDate();
                            break;
                        case "!":
                            date = new Date( ( getNumber( "!" ) - this._ticksTo1970 ) / 10000 );
                            year = date.getFullYear();
                            month = date.getMonth() + 1;
                            day = date.getDate();
                            break;
                        case "'":
                            if ( lookAhead( "'" ) ) {
                                checkLiteral();
                            } else {
                                literal = true;
                            }
                            break;
                        default:
                            checkLiteral();
                    }
                }
            }
    
            if ( iValue < value.length ) {
                extra = value.substr( iValue );
                if ( !/^\s+/.test( extra ) ) {
                    throw "Extra/unparsed characters found in date: " + extra;
                }
            }
    
            if ( year === -1 ) {
                year = new Date().getFullYear();
            } else if ( year < 100 ) {
                year += new Date().getFullYear() - new Date().getFullYear() % 100 +
                    ( year <= shortYearCutoff ? 0 : -100 );
            }
    
            if ( doy > -1 ) {
                month = 1;
                day = doy;
                do {
                    dim = this._getDaysInMonth( year, month - 1 );
                    if ( day <= dim ) {
                        break;
                    }
                    month++;
                    day -= dim;
                } while ( true );
            }
    
            date = this._daylightSavingAdjust( new Date( year, month - 1, day ) );
            if ( date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day ) {
                throw "Invalid date"; // E.g. 31/02/00
            }
            return date;
        },
    
        /* Standard date formats. */
        ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
        COOKIE: "D, dd M yy",
        ISO_8601: "yy-mm-dd",
        RFC_822: "D, d M y",
        RFC_850: "DD, dd-M-y",
        RFC_1036: "D, d M y",
        RFC_1123: "D, d M yy",
        RFC_2822: "D, d M yy",
        RSS: "D, d M y", // RFC 822
        TICKS: "!",
        TIMESTAMP: "@",
        W3C: "yy-mm-dd", // ISO 8601
    
        _ticksTo1970: ( ( ( 1970 - 1 ) * 365 + Math.floor( 1970 / 4 ) - Math.floor( 1970 / 100 ) +
            Math.floor( 1970 / 400 ) ) * 24 * 60 * 60 * 10000000 ),
    
        /* Format a date object into a string value.
         * The format can be combinations of the following:
         * d  - day of month (no leading zero)
         * dd - day of month (two digit)
         * o  - day of year (no leading zeros)
         * oo - day of year (three digit)
         * D  - day name short
         * DD - day name long
         * m  - month of year (no leading zero)
         * mm - month of year (two digit)
         * M  - month name short
         * MM - month name long
         * y  - year (two digit)
         * yy - year (four digit)
         * @ - Unix timestamp (ms since 01/01/1970)
         * ! - Windows ticks (100ns since 01/01/0001)
         * "..." - literal text
         * '' - single quote
         *
         * @param  format string - the desired format of the date
         * @param  date Date - the date value to format
         * @param  settings Object - attributes include:
         *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
         *					dayNames		string[7] - names of the days from Sunday (optional)
         *					monthNamesShort string[12] - abbreviated names of the months (optional)
         *					monthNames		string[12] - names of the months (optional)
         * @return  string - the date in the above format
         */
        formatDate: function( format, date, settings ) {
            if ( !date ) {
                return "";
            }
    
            var iFormat,
                dayNamesShort = ( settings ? settings.dayNamesShort : null ) || this._defaults.dayNamesShort,
                dayNames = ( settings ? settings.dayNames : null ) || this._defaults.dayNames,
                monthNamesShort = ( settings ? settings.monthNamesShort : null ) || this._defaults.monthNamesShort,
                monthNames = ( settings ? settings.monthNames : null ) || this._defaults.monthNames,
    
                // Check whether a format character is doubled
                lookAhead = function( match ) {
                    var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
                    if ( matches ) {
                        iFormat++;
                    }
                    return matches;
                },
    
                // Format a number, with leading zero if necessary
                formatNumber = function( match, value, len ) {
                    var num = "" + value;
                    if ( lookAhead( match ) ) {
                        while ( num.length < len ) {
                            num = "0" + num;
                        }
                    }
                    return num;
                },
    
                // Format a name, short or long as requested
                formatName = function( match, value, shortNames, longNames ) {
                    return ( lookAhead( match ) ? longNames[ value ] : shortNames[ value ] );
                },
                output = "",
                literal = false;
    
            if ( date ) {
                for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
                    if ( literal ) {
                        if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
                            literal = false;
                        } else {
                            output += format.charAt( iFormat );
                        }
                    } else {
                        switch ( format.charAt( iFormat ) ) {
                            case "d":
                                output += formatNumber( "d", date.getDate(), 2 );
                                break;
                            case "D":
                                output += formatName( "D", date.getDay(), dayNamesShort, dayNames );
                                break;
                            case "o":
                                output += formatNumber( "o",
                                    Math.round( ( new Date( date.getFullYear(), date.getMonth(), date.getDate() ).getTime() - new Date( date.getFullYear(), 0, 0 ).getTime() ) / 86400000 ), 3 );
                                break;
                            case "m":
                                output += formatNumber( "m", date.getMonth() + 1, 2 );
                                break;
                            case "M":
                                output += formatName( "M", date.getMonth(), monthNamesShort, monthNames );
                                break;
                            case "y":
                                output += ( lookAhead( "y" ) ? date.getFullYear() :
                                    ( date.getFullYear() % 100 < 10 ? "0" : "" ) + date.getFullYear() % 100 );
                                break;
                            case "@":
                                output += date.getTime();
                                break;
                            case "!":
                                output += date.getTime() * 10000 + this._ticksTo1970;
                                break;
                            case "'":
                                if ( lookAhead( "'" ) ) {
                                    output += "'";
                                } else {
                                    literal = true;
                                }
                                break;
                            default:
                                output += format.charAt( iFormat );
                        }
                    }
                }
            }
            return output;
        },
    
        /* Extract all possible characters from the date format. */
        _possibleChars: function( format ) {
            var iFormat,
                chars = "",
                literal = false,
    
                // Check whether a format character is doubled
                lookAhead = function( match ) {
                    var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
                    if ( matches ) {
                        iFormat++;
                    }
                    return matches;
                };
    
            for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
                if ( literal ) {
                    if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
                        literal = false;
                    } else {
                        chars += format.charAt( iFormat );
                    }
                } else {
                    switch ( format.charAt( iFormat ) ) {
                        case "d": case "m": case "y": case "@":
                            chars += "0123456789";
                            break;
                        case "D": case "M":
                            return null; // Accept anything
                        case "'":
                            if ( lookAhead( "'" ) ) {
                                chars += "'";
                            } else {
                                literal = true;
                            }
                            break;
                        default:
                            chars += format.charAt( iFormat );
                    }
                }
            }
            return chars;
        },
    
        /* Get a setting value, defaulting if necessary. */
        _get: function( inst, name ) {
            return inst.settings[ name ] !== undefined ?
                inst.settings[ name ] : this._defaults[ name ];
        },
    
        /* Parse existing date and initialise date picker. */
        _setDateFromField: function( inst, noDefault ) {
            if ( inst.input.val() === inst.lastVal ) {
                return;
            }
    
            var dateFormat = this._get( inst, "dateFormat" ),
                dates = inst.lastVal = inst.input ? inst.input.val() : null,
                defaultDate = this._getDefaultDate( inst ),
                date = defaultDate,
                settings = this._getFormatConfig( inst );
    
            try {
                date = this.parseDate( dateFormat, dates, settings ) || defaultDate;
            } catch ( event ) {
                dates = ( noDefault ? "" : dates );
            }
            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            inst.currentDay = ( dates ? date.getDate() : 0 );
            inst.currentMonth = ( dates ? date.getMonth() : 0 );
            inst.currentYear = ( dates ? date.getFullYear() : 0 );
            this._adjustInstDate( inst );
        },
    
        /* Retrieve the default date shown on opening. */
        _getDefaultDate: function( inst ) {
            return this._restrictMinMax( inst,
                this._determineDate( inst, this._get( inst, "defaultDate" ), new Date() ) );
        },
    
        /* A date may be specified as an exact value or a relative one. */
        _determineDate: function( inst, date, defaultDate ) {
            var offsetNumeric = function( offset ) {
                    var date = new Date();
                    date.setDate( date.getDate() + offset );
                    return date;
                },
                offsetString = function( offset ) {
                    try {
                        return $.datepicker.parseDate( $.datepicker._get( inst, "dateFormat" ),
                            offset, $.datepicker._getFormatConfig( inst ) );
                    }
                    catch ( e ) {
    
                        // Ignore
                    }
    
                    var date = ( offset.toLowerCase().match( /^c/ ) ?
                        $.datepicker._getDate( inst ) : null ) || new Date(),
                        year = date.getFullYear(),
                        month = date.getMonth(),
                        day = date.getDate(),
                        pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
                        matches = pattern.exec( offset );
    
                    while ( matches ) {
                        switch ( matches[ 2 ] || "d" ) {
                            case "d" : case "D" :
                                day += parseInt( matches[ 1 ], 10 ); break;
                            case "w" : case "W" :
                                day += parseInt( matches[ 1 ], 10 ) * 7; break;
                            case "m" : case "M" :
                                month += parseInt( matches[ 1 ], 10 );
                                day = Math.min( day, $.datepicker._getDaysInMonth( year, month ) );
                                break;
                            case "y": case "Y" :
                                year += parseInt( matches[ 1 ], 10 );
                                day = Math.min( day, $.datepicker._getDaysInMonth( year, month ) );
                                break;
                        }
                        matches = pattern.exec( offset );
                    }
                    return new Date( year, month, day );
                },
                newDate = ( date == null || date === "" ? defaultDate : ( typeof date === "string" ? offsetString( date ) :
                    ( typeof date === "number" ? ( isNaN( date ) ? defaultDate : offsetNumeric( date ) ) : new Date( date.getTime() ) ) ) );
    
            newDate = ( newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate );
            if ( newDate ) {
                newDate.setHours( 0 );
                newDate.setMinutes( 0 );
                newDate.setSeconds( 0 );
                newDate.setMilliseconds( 0 );
            }
            return this._daylightSavingAdjust( newDate );
        },
    
        /* Handle switch to/from daylight saving.
         * Hours may be non-zero on daylight saving cut-over:
         * > 12 when midnight changeover, but then cannot generate
         * midnight datetime, so jump to 1AM, otherwise reset.
         * @param  date  (Date) the date to check
         * @return  (Date) the corrected date
         */
        _daylightSavingAdjust: function( date ) {
            if ( !date ) {
                return null;
            }
            date.setHours( date.getHours() > 12 ? date.getHours() + 2 : 0 );
            return date;
        },
    
        /* Set the date(s) directly. */
        _setDate: function( inst, date, noChange ) {
            var clear = !date,
                origMonth = inst.selectedMonth,
                origYear = inst.selectedYear,
                newDate = this._restrictMinMax( inst, this._determineDate( inst, date, new Date() ) );
    
            inst.selectedDay = inst.currentDay = newDate.getDate();
            inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
            inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
            if ( ( origMonth !== inst.selectedMonth || origYear !== inst.selectedYear ) && !noChange ) {
                this._notifyChange( inst );
            }
            this._adjustInstDate( inst );
            if ( inst.input ) {
                inst.input.val( clear ? "" : this._formatDate( inst ) );
            }
        },
    
        /* Retrieve the date(s) directly. */
        _getDate: function( inst ) {
            var startDate = ( !inst.currentYear || ( inst.input && inst.input.val() === "" ) ? null :
                this._daylightSavingAdjust( new Date(
                inst.currentYear, inst.currentMonth, inst.currentDay ) ) );
                return startDate;
        },
    
        /* Attach the onxxx handlers.  These are declared statically so
         * they work with static code transformers like Caja.
         */
        _attachHandlers: function( inst ) {
            var stepMonths = this._get( inst, "stepMonths" ),
                id = "#" + inst.id.replace( /\\\\/g, "\\" );
            inst.dpDiv.find( "[data-handler]" ).map( function() {
                var handler = {
                    prev: function() {
                        $.datepicker._adjustDate( id, -stepMonths, "M" );
                    },
                    next: function() {
                        $.datepicker._adjustDate( id, +stepMonths, "M" );
                    },
                    hide: function() {
                        $.datepicker._hideDatepicker();
                    },
                    today: function() {
                        $.datepicker._gotoToday( id );
                    },
                    selectDay: function() {
                        $.datepicker._selectDay( id, +this.getAttribute( "data-month" ), +this.getAttribute( "data-year" ), this );
                        return false;
                    },
                    selectMonth: function() {
                        $.datepicker._selectMonthYear( id, this, "M" );
                        return false;
                    },
                    selectYear: function() {
                        $.datepicker._selectMonthYear( id, this, "Y" );
                        return false;
                    }
                };
                $( this ).on( this.getAttribute( "data-event" ), handler[ this.getAttribute( "data-handler" ) ] );
            } );
        },
    
        /* Generate the HTML for the current state of the date picker. */
        _generateHTML: function( inst ) {
            var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
                controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
                monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
                selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
                cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
                printDate, dRow, tbody, daySettings, otherMonth, unselectable,
                tempDate = new Date(),
                today = this._daylightSavingAdjust(
                    new Date( tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate() ) ), // clear time
                isRTL = this._get( inst, "isRTL" ),
                showButtonPanel = this._get( inst, "showButtonPanel" ),
                hideIfNoPrevNext = this._get( inst, "hideIfNoPrevNext" ),
                navigationAsDateFormat = this._get( inst, "navigationAsDateFormat" ),
                numMonths = this._getNumberOfMonths( inst ),
                showCurrentAtPos = this._get( inst, "showCurrentAtPos" ),
                stepMonths = this._get( inst, "stepMonths" ),
                isMultiMonth = ( numMonths[ 0 ] !== 1 || numMonths[ 1 ] !== 1 ),
                currentDate = this._daylightSavingAdjust( ( !inst.currentDay ? new Date( 9999, 9, 9 ) :
                    new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) ),
                minDate = this._getMinMaxDate( inst, "min" ),
                maxDate = this._getMinMaxDate( inst, "max" ),
                drawMonth = inst.drawMonth - showCurrentAtPos,
                drawYear = inst.drawYear;
    
            if ( drawMonth < 0 ) {
                drawMonth += 12;
                drawYear--;
            }
            if ( maxDate ) {
                maxDraw = this._daylightSavingAdjust( new Date( maxDate.getFullYear(),
                    maxDate.getMonth() - ( numMonths[ 0 ] * numMonths[ 1 ] ) + 1, maxDate.getDate() ) );
                maxDraw = ( minDate && maxDraw < minDate ? minDate : maxDraw );
                while ( this._daylightSavingAdjust( new Date( drawYear, drawMonth, 1 ) ) > maxDraw ) {
                    drawMonth--;
                    if ( drawMonth < 0 ) {
                        drawMonth = 11;
                        drawYear--;
                    }
                }
            }
            inst.drawMonth = drawMonth;
            inst.drawYear = drawYear;
    
            prevText = this._get( inst, "prevText" );
            prevText = ( !navigationAsDateFormat ? prevText : this.formatDate( prevText,
                this._daylightSavingAdjust( new Date( drawYear, drawMonth - stepMonths, 1 ) ),
                this._getFormatConfig( inst ) ) );
    
            prev = ( this._canAdjustMonth( inst, -1, drawYear, drawMonth ) ?
                "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
                " title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w" ) + "'>" + prevText + "</span></a>" :
                ( hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w" ) + "'>" + prevText + "</span></a>" ) );
    
            nextText = this._get( inst, "nextText" );
            nextText = ( !navigationAsDateFormat ? nextText : this.formatDate( nextText,
                this._daylightSavingAdjust( new Date( drawYear, drawMonth + stepMonths, 1 ) ),
                this._getFormatConfig( inst ) ) );
    
            next = ( this._canAdjustMonth( inst, +1, drawYear, drawMonth ) ?
                "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
                " title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e" ) + "'>" + nextText + "</span></a>" :
                ( hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e" ) + "'>" + nextText + "</span></a>" ) );
    
            currentText = this._get( inst, "currentText" );
            gotoDate = ( this._get( inst, "gotoCurrent" ) && inst.currentDay ? currentDate : today );
            currentText = ( !navigationAsDateFormat ? currentText :
                this.formatDate( currentText, gotoDate, this._getFormatConfig( inst ) ) );
    
            controls = ( !inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
                this._get( inst, "closeText" ) + "</button>" : "" );
    
            buttonPanel = ( showButtonPanel ) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + ( isRTL ? controls : "" ) +
                ( this._isInRange( inst, gotoDate ) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
                ">" + currentText + "</button>" : "" ) + ( isRTL ? "" : controls ) + "</div>" : "";
    
            firstDay = parseInt( this._get( inst, "firstDay" ), 10 );
            firstDay = ( isNaN( firstDay ) ? 0 : firstDay );
    
            showWeek = this._get( inst, "showWeek" );
            dayNames = this._get( inst, "dayNames" );
            dayNamesMin = this._get( inst, "dayNamesMin" );
            monthNames = this._get( inst, "monthNames" );
            monthNamesShort = this._get( inst, "monthNamesShort" );
            beforeShowDay = this._get( inst, "beforeShowDay" );
            showOtherMonths = this._get( inst, "showOtherMonths" );
            selectOtherMonths = this._get( inst, "selectOtherMonths" );
            defaultDate = this._getDefaultDate( inst );
            html = "";
    
            for ( row = 0; row < numMonths[ 0 ]; row++ ) {
                group = "";
                this.maxRows = 4;
                for ( col = 0; col < numMonths[ 1 ]; col++ ) {
                    selectedDate = this._daylightSavingAdjust( new Date( drawYear, drawMonth, inst.selectedDay ) );
                    cornerClass = " ui-corner-all";
                    calender = "";
                    if ( isMultiMonth ) {
                        calender += "<div class='ui-datepicker-group";
                        if ( numMonths[ 1 ] > 1 ) {
                            switch ( col ) {
                                case 0: calender += " ui-datepicker-group-first";
                                    cornerClass = " ui-corner-" + ( isRTL ? "right" : "left" ); break;
                                case numMonths[ 1 ] - 1: calender += " ui-datepicker-group-last";
                                    cornerClass = " ui-corner-" + ( isRTL ? "left" : "right" ); break;
                                default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
                            }
                        }
                        calender += "'>";
                    }
                    calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
                        ( /all|left/.test( cornerClass ) && row === 0 ? ( isRTL ? next : prev ) : "" ) +
                        ( /all|right/.test( cornerClass ) && row === 0 ? ( isRTL ? prev : next ) : "" ) +
                        this._generateMonthYearHeader( inst, drawMonth, drawYear, minDate, maxDate,
                        row > 0 || col > 0, monthNames, monthNamesShort ) + // draw month headers
                        "</div><table class='ui-datepicker-calendar'><thead>" +
                        "<tr>";
                    thead = ( showWeek ? "<th class='ui-datepicker-week-col'>" + this._get( inst, "weekHeader" ) + "</th>" : "" );
                    for ( dow = 0; dow < 7; dow++ ) { // days of the week
                        day = ( dow + firstDay ) % 7;
                        thead += "<th scope='col'" + ( ( dow + firstDay + 6 ) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "" ) + ">" +
                            "<span title='" + dayNames[ day ] + "'>" + dayNamesMin[ day ] + "</span></th>";
                    }
                    calender += thead + "</tr></thead><tbody>";
                    daysInMonth = this._getDaysInMonth( drawYear, drawMonth );
                    if ( drawYear === inst.selectedYear && drawMonth === inst.selectedMonth ) {
                        inst.selectedDay = Math.min( inst.selectedDay, daysInMonth );
                    }
                    leadDays = ( this._getFirstDayOfMonth( drawYear, drawMonth ) - firstDay + 7 ) % 7;
                    curRows = Math.ceil( ( leadDays + daysInMonth ) / 7 ); // calculate the number of rows to generate
                    numRows = ( isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows ); //If multiple months, use the higher number of rows (see #7043)
                    this.maxRows = numRows;
                    printDate = this._daylightSavingAdjust( new Date( drawYear, drawMonth, 1 - leadDays ) );
                    for ( dRow = 0; dRow < numRows; dRow++ ) { // create date picker rows
                        calender += "<tr>";
                        tbody = ( !showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
                            this._get( inst, "calculateWeek" )( printDate ) + "</td>" );
                        for ( dow = 0; dow < 7; dow++ ) { // create date picker days
                            daySettings = ( beforeShowDay ?
                                beforeShowDay.apply( ( inst.input ? inst.input[ 0 ] : null ), [ printDate ] ) : [ true, "" ] );
                            otherMonth = ( printDate.getMonth() !== drawMonth );
                            unselectable = ( otherMonth && !selectOtherMonths ) || !daySettings[ 0 ] ||
                                ( minDate && printDate < minDate ) || ( maxDate && printDate > maxDate );
                            tbody += "<td class='" +
                                ( ( dow + firstDay + 6 ) % 7 >= 5 ? " ui-datepicker-week-end" : "" ) + // highlight weekends
                                ( otherMonth ? " ui-datepicker-other-month" : "" ) + // highlight days from other months
                                ( ( printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent ) || // user pressed key
                                ( defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ) ?
    
                                // or defaultDate is current printedDate and defaultDate is selectedDate
                                " " + this._dayOverClass : "" ) + // highlight selected day
                                ( unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "" ) +  // highlight unselectable days
                                ( otherMonth && !showOtherMonths ? "" : " " + daySettings[ 1 ] + // highlight custom dates
                                ( printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "" ) + // highlight selected day
                                ( printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "" ) ) + "'" + // highlight today (if different)
                                ( ( !otherMonth || showOtherMonths ) && daySettings[ 2 ] ? " title='" + daySettings[ 2 ].replace( /'/g, "&#39;" ) + "'" : "" ) + // cell title
                                ( unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'" ) + ">" + // actions
                                ( otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
                                ( unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
                                ( printDate.getTime() === today.getTime() ? " ui-state-highlight" : "" ) +
                                ( printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "" ) + // highlight selected day
                                ( otherMonth ? " ui-priority-secondary" : "" ) + // distinguish dates from other months
                                "' href='#'>" + printDate.getDate() + "</a>" ) ) + "</td>"; // display selectable date
                            printDate.setDate( printDate.getDate() + 1 );
                            printDate = this._daylightSavingAdjust( printDate );
                        }
                        calender += tbody + "</tr>";
                    }
                    drawMonth++;
                    if ( drawMonth > 11 ) {
                        drawMonth = 0;
                        drawYear++;
                    }
                    calender += "</tbody></table>" + ( isMultiMonth ? "</div>" +
                                ( ( numMonths[ 0 ] > 0 && col === numMonths[ 1 ] - 1 ) ? "<div class='ui-datepicker-row-break'></div>" : "" ) : "" );
                    group += calender;
                }
                html += group;
            }
            html += buttonPanel;
            inst._keyEvent = false;
            return html;
        },
    
        /* Generate the month and year header. */
        _generateMonthYearHeader: function( inst, drawMonth, drawYear, minDate, maxDate,
                secondary, monthNames, monthNamesShort ) {
    
            var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
                changeMonth = this._get( inst, "changeMonth" ),
                changeYear = this._get( inst, "changeYear" ),
                showMonthAfterYear = this._get( inst, "showMonthAfterYear" ),
                html = "<div class='ui-datepicker-title'>",
                monthHtml = "";
    
            // Month selection
            if ( secondary || !changeMonth ) {
                monthHtml += "<span class='ui-datepicker-month'>" + monthNames[ drawMonth ] + "</span>";
            } else {
                inMinYear = ( minDate && minDate.getFullYear() === drawYear );
                inMaxYear = ( maxDate && maxDate.getFullYear() === drawYear );
                monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
                for ( month = 0; month < 12; month++ ) {
                    if ( ( !inMinYear || month >= minDate.getMonth() ) && ( !inMaxYear || month <= maxDate.getMonth() ) ) {
                        monthHtml += "<option value='" + month + "'" +
                            ( month === drawMonth ? " selected='selected'" : "" ) +
                            ">" + monthNamesShort[ month ] + "</option>";
                    }
                }
                monthHtml += "</select>";
            }
    
            if ( !showMonthAfterYear ) {
                html += monthHtml + ( secondary || !( changeMonth && changeYear ) ? "&#xa0;" : "" );
            }
    
            // Year selection
            if ( !inst.yearshtml ) {
                inst.yearshtml = "";
                if ( secondary || !changeYear ) {
                    html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
                } else {
    
                    // determine range of years to display
                    years = this._get( inst, "yearRange" ).split( ":" );
                    thisYear = new Date().getFullYear();
                    determineYear = function( value ) {
                        var year = ( value.match( /c[+\-].*/ ) ? drawYear + parseInt( value.substring( 1 ), 10 ) :
                            ( value.match( /[+\-].*/ ) ? thisYear + parseInt( value, 10 ) :
                            parseInt( value, 10 ) ) );
                        return ( isNaN( year ) ? thisYear : year );
                    };
                    year = determineYear( years[ 0 ] );
                    endYear = Math.max( year, determineYear( years[ 1 ] || "" ) );
                    year = ( minDate ? Math.max( year, minDate.getFullYear() ) : year );
                    endYear = ( maxDate ? Math.min( endYear, maxDate.getFullYear() ) : endYear );
                    inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
                    for ( ; year <= endYear; year++ ) {
                        inst.yearshtml += "<option value='" + year + "'" +
                            ( year === drawYear ? " selected='selected'" : "" ) +
                            ">" + year + "</option>";
                    }
                    inst.yearshtml += "</select>";
    
                    html += inst.yearshtml;
                    inst.yearshtml = null;
                }
            }
    
            html += this._get( inst, "yearSuffix" );
            if ( showMonthAfterYear ) {
                html += ( secondary || !( changeMonth && changeYear ) ? "&#xa0;" : "" ) + monthHtml;
            }
            html += "</div>"; // Close datepicker_header
            return html;
        },
    
        /* Adjust one of the date sub-fields. */
        _adjustInstDate: function( inst, offset, period ) {
            var year = inst.selectedYear + ( period === "Y" ? offset : 0 ),
                month = inst.selectedMonth + ( period === "M" ? offset : 0 ),
                day = Math.min( inst.selectedDay, this._getDaysInMonth( year, month ) ) + ( period === "D" ? offset : 0 ),
                date = this._restrictMinMax( inst, this._daylightSavingAdjust( new Date( year, month, day ) ) );
    
            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            if ( period === "M" || period === "Y" ) {
                this._notifyChange( inst );
            }
        },
    
        /* Ensure a date is within any min/max bounds. */
        _restrictMinMax: function( inst, date ) {
            var minDate = this._getMinMaxDate( inst, "min" ),
                maxDate = this._getMinMaxDate( inst, "max" ),
                newDate = ( minDate && date < minDate ? minDate : date );
            return ( maxDate && newDate > maxDate ? maxDate : newDate );
        },
    
        /* Notify change of month/year. */
        _notifyChange: function( inst ) {
            var onChange = this._get( inst, "onChangeMonthYear" );
            if ( onChange ) {
                onChange.apply( ( inst.input ? inst.input[ 0 ] : null ),
                    [ inst.selectedYear, inst.selectedMonth + 1, inst ] );
            }
        },
    
        /* Determine the number of months to show. */
        _getNumberOfMonths: function( inst ) {
            var numMonths = this._get( inst, "numberOfMonths" );
            return ( numMonths == null ? [ 1, 1 ] : ( typeof numMonths === "number" ? [ 1, numMonths ] : numMonths ) );
        },
    
        /* Determine the current maximum date - ensure no time components are set. */
        _getMinMaxDate: function( inst, minMax ) {
            return this._determineDate( inst, this._get( inst, minMax + "Date" ), null );
        },
    
        /* Find the number of days in a given month. */
        _getDaysInMonth: function( year, month ) {
            return 32 - this._daylightSavingAdjust( new Date( year, month, 32 ) ).getDate();
        },
    
        /* Find the day of the week of the first of a month. */
        _getFirstDayOfMonth: function( year, month ) {
            return new Date( year, month, 1 ).getDay();
        },
    
        /* Determines if we should allow a "next/prev" month display change. */
        _canAdjustMonth: function( inst, offset, curYear, curMonth ) {
            var numMonths = this._getNumberOfMonths( inst ),
                date = this._daylightSavingAdjust( new Date( curYear,
                curMonth + ( offset < 0 ? offset : numMonths[ 0 ] * numMonths[ 1 ] ), 1 ) );
    
            if ( offset < 0 ) {
                date.setDate( this._getDaysInMonth( date.getFullYear(), date.getMonth() ) );
            }
            return this._isInRange( inst, date );
        },
    
        /* Is the given date in the accepted range? */
        _isInRange: function( inst, date ) {
            var yearSplit, currentYear,
                minDate = this._getMinMaxDate( inst, "min" ),
                maxDate = this._getMinMaxDate( inst, "max" ),
                minYear = null,
                maxYear = null,
                years = this._get( inst, "yearRange" );
                if ( years ) {
                    yearSplit = years.split( ":" );
                    currentYear = new Date().getFullYear();
                    minYear = parseInt( yearSplit[ 0 ], 10 );
                    maxYear = parseInt( yearSplit[ 1 ], 10 );
                    if ( yearSplit[ 0 ].match( /[+\-].*/ ) ) {
                        minYear += currentYear;
                    }
                    if ( yearSplit[ 1 ].match( /[+\-].*/ ) ) {
                        maxYear += currentYear;
                    }
                }
    
            return ( ( !minDate || date.getTime() >= minDate.getTime() ) &&
                ( !maxDate || date.getTime() <= maxDate.getTime() ) &&
                ( !minYear || date.getFullYear() >= minYear ) &&
                ( !maxYear || date.getFullYear() <= maxYear ) );
        },
    
        /* Provide the configuration settings for formatting/parsing. */
        _getFormatConfig: function( inst ) {
            var shortYearCutoff = this._get( inst, "shortYearCutoff" );
            shortYearCutoff = ( typeof shortYearCutoff !== "string" ? shortYearCutoff :
                new Date().getFullYear() % 100 + parseInt( shortYearCutoff, 10 ) );
            return { shortYearCutoff: shortYearCutoff,
                dayNamesShort: this._get( inst, "dayNamesShort" ), dayNames: this._get( inst, "dayNames" ),
                monthNamesShort: this._get( inst, "monthNamesShort" ), monthNames: this._get( inst, "monthNames" ) };
        },
    
        /* Format the given date for display. */
        _formatDate: function( inst, day, month, year ) {
            if ( !day ) {
                inst.currentDay = inst.selectedDay;
                inst.currentMonth = inst.selectedMonth;
                inst.currentYear = inst.selectedYear;
            }
            var date = ( day ? ( typeof day === "object" ? day :
                this._daylightSavingAdjust( new Date( year, month, day ) ) ) :
                this._daylightSavingAdjust( new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) );
            return this.formatDate( this._get( inst, "dateFormat" ), date, this._getFormatConfig( inst ) );
        }
    } );
    
    /*
     * Bind hover events for datepicker elements.
     * Done via delegate so the binding only occurs once in the lifetime of the parent div.
     * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
     */
    function datepicker_bindHover( dpDiv ) {
        var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
        return dpDiv.on( "mouseout", selector, function() {
                $( this ).removeClass( "ui-state-hover" );
                if ( this.className.indexOf( "ui-datepicker-prev" ) !== -1 ) {
                    $( this ).removeClass( "ui-datepicker-prev-hover" );
                }
                if ( this.className.indexOf( "ui-datepicker-next" ) !== -1 ) {
                    $( this ).removeClass( "ui-datepicker-next-hover" );
                }
            } )
            .on( "mouseover", selector, datepicker_handleMouseover );
    }
    
    function datepicker_handleMouseover() {
        if ( !$.datepicker._isDisabledDatepicker( datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[ 0 ] : datepicker_instActive.input[ 0 ] ) ) {
            $( this ).parents( ".ui-datepicker-calendar" ).find( "a" ).removeClass( "ui-state-hover" );
            $( this ).addClass( "ui-state-hover" );
            if ( this.className.indexOf( "ui-datepicker-prev" ) !== -1 ) {
                $( this ).addClass( "ui-datepicker-prev-hover" );
            }
            if ( this.className.indexOf( "ui-datepicker-next" ) !== -1 ) {
                $( this ).addClass( "ui-datepicker-next-hover" );
            }
        }
    }
    
    /* jQuery extend now ignores nulls! */
    function datepicker_extendRemove( target, props ) {
        $.extend( target, props );
        for ( var name in props ) {
            if ( props[ name ] == null ) {
                target[ name ] = props[ name ];
            }
        }
        return target;
    }
    
    /* Invoke the datepicker functionality.
       @param  options  string - a command, optionally followed by additional parameters or
                        Object - settings for attaching new datepicker functionality
       @return  jQuery object */
    $.fn.datepicker = function( options ) {
    
        /* Verify an empty collection wasn't passed - Fixes #6976 */
        if ( !this.length ) {
            return this;
        }
    
        /* Initialise the date picker. */
        if ( !$.datepicker.initialized ) {
            $( document ).on( "mousedown", $.datepicker._checkExternalClick );
            $.datepicker.initialized = true;
        }
    
        /* Append datepicker main container to body if not exist. */
        if ( $( "#" + $.datepicker._mainDivId ).length === 0 ) {
            $( "body" ).append( $.datepicker.dpDiv );
        }
    
        var otherArgs = Array.prototype.slice.call( arguments, 1 );
        if ( typeof options === "string" && ( options === "isDisabled" || options === "getDate" || options === "widget" ) ) {
            return $.datepicker[ "_" + options + "Datepicker" ].
                apply( $.datepicker, [ this[ 0 ] ].concat( otherArgs ) );
        }
        if ( options === "option" && arguments.length === 2 && typeof arguments[ 1 ] === "string" ) {
            return $.datepicker[ "_" + options + "Datepicker" ].
                apply( $.datepicker, [ this[ 0 ] ].concat( otherArgs ) );
        }
        return this.each( function() {
            typeof options === "string" ?
                $.datepicker[ "_" + options + "Datepicker" ].
                    apply( $.datepicker, [ this ].concat( otherArgs ) ) :
                $.datepicker._attachDatepicker( this, options );
        } );
    };
    
    $.datepicker = new Datepicker(); // singleton instance
    $.datepicker.initialized = false;
    $.datepicker.uuid = new Date().getTime();
    $.datepicker.version = "1.12.1";
    
    var widgetsDatepicker = $.datepicker;
    
    
    
    
    // This file is deprecated
    var ie = $.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );
    
    /*!
     * jQuery UI Mouse 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Mouse
    //>>group: Widgets
    //>>description: Abstracts mouse-based interactions to assist in creating certain widgets.
    //>>docs: http://api.jqueryui.com/mouse/
    
    
    
    var mouseHandled = false;
    $( document ).on( "mouseup", function() {
        mouseHandled = false;
    } );
    
    var widgetsMouse = $.widget( "ui.mouse", {
        version: "1.12.1",
        options: {
            cancel: "input, textarea, button, select, option",
            distance: 1,
            delay: 0
        },
        _mouseInit: function() {
            var that = this;
    
            this.element
                .on( "mousedown." + this.widgetName, function( event ) {
                    return that._mouseDown( event );
                } )
                .on( "click." + this.widgetName, function( event ) {
                    if ( true === $.data( event.target, that.widgetName + ".preventClickEvent" ) ) {
                        $.removeData( event.target, that.widgetName + ".preventClickEvent" );
                        event.stopImmediatePropagation();
                        return false;
                    }
                } );
    
            this.started = false;
        },
    
        // TODO: make sure destroying one instance of mouse doesn't mess with
        // other instances of mouse
        _mouseDestroy: function() {
            this.element.off( "." + this.widgetName );
            if ( this._mouseMoveDelegate ) {
                this.document
                    .off( "mousemove." + this.widgetName, this._mouseMoveDelegate )
                    .off( "mouseup." + this.widgetName, this._mouseUpDelegate );
            }
        },
    
        _mouseDown: function( event ) {
    
            // don't let more than one widget handle mouseStart
            if ( mouseHandled ) {
                return;
            }
    
            this._mouseMoved = false;
    
            // We may have missed mouseup (out of window)
            ( this._mouseStarted && this._mouseUp( event ) );
    
            this._mouseDownEvent = event;
    
            var that = this,
                btnIsLeft = ( event.which === 1 ),
    
                // event.target.nodeName works around a bug in IE 8 with
                // disabled inputs (#7620)
                elIsCancel = ( typeof this.options.cancel === "string" && event.target.nodeName ?
                    $( event.target ).closest( this.options.cancel ).length : false );
            if ( !btnIsLeft || elIsCancel || !this._mouseCapture( event ) ) {
                return true;
            }
    
            this.mouseDelayMet = !this.options.delay;
            if ( !this.mouseDelayMet ) {
                this._mouseDelayTimer = setTimeout( function() {
                    that.mouseDelayMet = true;
                }, this.options.delay );
            }
    
            if ( this._mouseDistanceMet( event ) && this._mouseDelayMet( event ) ) {
                this._mouseStarted = ( this._mouseStart( event ) !== false );
                if ( !this._mouseStarted ) {
                    event.preventDefault();
                    return true;
                }
            }
    
            // Click event may never have fired (Gecko & Opera)
            if ( true === $.data( event.target, this.widgetName + ".preventClickEvent" ) ) {
                $.removeData( event.target, this.widgetName + ".preventClickEvent" );
            }
    
            // These delegates are required to keep context
            this._mouseMoveDelegate = function( event ) {
                return that._mouseMove( event );
            };
            this._mouseUpDelegate = function( event ) {
                return that._mouseUp( event );
            };
    
            this.document
                .on( "mousemove." + this.widgetName, this._mouseMoveDelegate )
                .on( "mouseup." + this.widgetName, this._mouseUpDelegate );
    
            event.preventDefault();
    
            mouseHandled = true;
            return true;
        },
    
        _mouseMove: function( event ) {
    
            // Only check for mouseups outside the document if you've moved inside the document
            // at least once. This prevents the firing of mouseup in the case of IE<9, which will
            // fire a mousemove event if content is placed under the cursor. See #7778
            // Support: IE <9
            if ( this._mouseMoved ) {
    
                // IE mouseup check - mouseup happened when mouse was out of window
                if ( $.ui.ie && ( !document.documentMode || document.documentMode < 9 ) &&
                        !event.button ) {
                    return this._mouseUp( event );
    
                // Iframe mouseup check - mouseup occurred in another document
                } else if ( !event.which ) {
    
                    // Support: Safari <=8 - 9
                    // Safari sets which to 0 if you press any of the following keys
                    // during a drag (#14461)
                    if ( event.originalEvent.altKey || event.originalEvent.ctrlKey ||
                            event.originalEvent.metaKey || event.originalEvent.shiftKey ) {
                        this.ignoreMissingWhich = true;
                    } else if ( !this.ignoreMissingWhich ) {
                        return this._mouseUp( event );
                    }
                }
            }
    
            if ( event.which || event.button ) {
                this._mouseMoved = true;
            }
    
            if ( this._mouseStarted ) {
                this._mouseDrag( event );
                return event.preventDefault();
            }
    
            if ( this._mouseDistanceMet( event ) && this._mouseDelayMet( event ) ) {
                this._mouseStarted =
                    ( this._mouseStart( this._mouseDownEvent, event ) !== false );
                ( this._mouseStarted ? this._mouseDrag( event ) : this._mouseUp( event ) );
            }
    
            return !this._mouseStarted;
        },
    
        _mouseUp: function( event ) {
            this.document
                .off( "mousemove." + this.widgetName, this._mouseMoveDelegate )
                .off( "mouseup." + this.widgetName, this._mouseUpDelegate );
    
            if ( this._mouseStarted ) {
                this._mouseStarted = false;
    
                if ( event.target === this._mouseDownEvent.target ) {
                    $.data( event.target, this.widgetName + ".preventClickEvent", true );
                }
    
                this._mouseStop( event );
            }
    
            if ( this._mouseDelayTimer ) {
                clearTimeout( this._mouseDelayTimer );
                delete this._mouseDelayTimer;
            }
    
            this.ignoreMissingWhich = false;
            mouseHandled = false;
            event.preventDefault();
        },
    
        _mouseDistanceMet: function( event ) {
            return ( Math.max(
                    Math.abs( this._mouseDownEvent.pageX - event.pageX ),
                    Math.abs( this._mouseDownEvent.pageY - event.pageY )
                ) >= this.options.distance
            );
        },
    
        _mouseDelayMet: function( /* event */ ) {
            return this.mouseDelayMet;
        },
    
        // These are placeholder methods, to be overriden by extending plugin
        _mouseStart: function( /* event */ ) {},
        _mouseDrag: function( /* event */ ) {},
        _mouseStop: function( /* event */ ) {},
        _mouseCapture: function( /* event */ ) { return true; }
    } );
    
    
    
    
    // $.ui.plugin is deprecated. Use $.widget() extensions instead.
    var plugin = $.ui.plugin = {
        add: function( module, option, set ) {
            var i,
                proto = $.ui[ module ].prototype;
            for ( i in set ) {
                proto.plugins[ i ] = proto.plugins[ i ] || [];
                proto.plugins[ i ].push( [ option, set[ i ] ] );
            }
        },
        call: function( instance, name, args, allowDisconnected ) {
            var i,
                set = instance.plugins[ name ];
    
            if ( !set ) {
                return;
            }
    
            if ( !allowDisconnected && ( !instance.element[ 0 ].parentNode ||
                    instance.element[ 0 ].parentNode.nodeType === 11 ) ) {
                return;
            }
    
            for ( i = 0; i < set.length; i++ ) {
                if ( instance.options[ set[ i ][ 0 ] ] ) {
                    set[ i ][ 1 ].apply( instance.element, args );
                }
            }
        }
    };
    
    
    
    var safeBlur = $.ui.safeBlur = function( element ) {
    
        // Support: IE9 - 10 only
        // If the <body> is blurred, IE will switch windows, see #9420
        if ( element && element.nodeName.toLowerCase() !== "body" ) {
            $( element ).trigger( "blur" );
        }
    };
    
    
    /*!
     * jQuery UI Draggable 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Draggable
    //>>group: Interactions
    //>>description: Enables dragging functionality for any element.
    //>>docs: http://api.jqueryui.com/draggable/
    //>>demos: http://jqueryui.com/draggable/
    //>>css.structure: ../../themes/base/draggable.css
    
    
    
    $.widget( "ui.draggable", $.ui.mouse, {
        version: "1.12.1",
        widgetEventPrefix: "drag",
        options: {
            addClasses: true,
            appendTo: "parent",
            axis: false,
            connectToSortable: false,
            containment: false,
            cursor: "auto",
            cursorAt: false,
            grid: false,
            handle: false,
            helper: "original",
            iframeFix: false,
            opacity: false,
            refreshPositions: false,
            revert: false,
            revertDuration: 500,
            scope: "default",
            scroll: true,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            snap: false,
            snapMode: "both",
            snapTolerance: 20,
            stack: false,
            zIndex: false,
    
            // Callbacks
            drag: null,
            start: null,
            stop: null
        },
        _create: function() {
    
            if ( this.options.helper === "original" ) {
                this._setPositionRelative();
            }
            if ( this.options.addClasses ) {
                this._addClass( "ui-draggable" );
            }
            this._setHandleClassName();
    
            this._mouseInit();
        },
    
        _setOption: function( key, value ) {
            this._super( key, value );
            if ( key === "handle" ) {
                this._removeHandleClassName();
                this._setHandleClassName();
            }
        },
    
        _destroy: function() {
            if ( ( this.helper || this.element ).is( ".ui-draggable-dragging" ) ) {
                this.destroyOnClear = true;
                return;
            }
            this._removeHandleClassName();
            this._mouseDestroy();
        },
    
        _mouseCapture: function( event ) {
            var o = this.options;
    
            // Among others, prevent a drag on a resizable-handle
            if ( this.helper || o.disabled ||
                    $( event.target ).closest( ".ui-resizable-handle" ).length > 0 ) {
                return false;
            }
    
            //Quit if we're not on a valid handle
            this.handle = this._getHandle( event );
            if ( !this.handle ) {
                return false;
            }
    
            this._blurActiveElement( event );
    
            this._blockFrames( o.iframeFix === true ? "iframe" : o.iframeFix );
    
            return true;
    
        },
    
        _blockFrames: function( selector ) {
            this.iframeBlocks = this.document.find( selector ).map( function() {
                var iframe = $( this );
    
                return $( "<div>" )
                    .css( "position", "absolute" )
                    .appendTo( iframe.parent() )
                    .outerWidth( iframe.outerWidth() )
                    .outerHeight( iframe.outerHeight() )
                    .offset( iframe.offset() )[ 0 ];
            } );
        },
    
        _unblockFrames: function() {
            if ( this.iframeBlocks ) {
                this.iframeBlocks.remove();
                delete this.iframeBlocks;
            }
        },
    
        _blurActiveElement: function( event ) {
            var activeElement = $.ui.safeActiveElement( this.document[ 0 ] ),
                target = $( event.target );
    
            // Don't blur if the event occurred on an element that is within
            // the currently focused element
            // See #10527, #12472
            if ( target.closest( activeElement ).length ) {
                return;
            }
    
            // Blur any element that currently has focus, see #4261
            $.ui.safeBlur( activeElement );
        },
    
        _mouseStart: function( event ) {
    
            var o = this.options;
    
            //Create and append the visible helper
            this.helper = this._createHelper( event );
    
            this._addClass( this.helper, "ui-draggable-dragging" );
    
            //Cache the helper size
            this._cacheHelperProportions();
    
            //If ddmanager is used for droppables, set the global draggable
            if ( $.ui.ddmanager ) {
                $.ui.ddmanager.current = this;
            }
    
            /*
             * - Position generation -
             * This block generates everything position related - it's the core of draggables.
             */
    
            //Cache the margins of the original element
            this._cacheMargins();
    
            //Store the helper's css position
            this.cssPosition = this.helper.css( "position" );
            this.scrollParent = this.helper.scrollParent( true );
            this.offsetParent = this.helper.offsetParent();
            this.hasFixedAncestor = this.helper.parents().filter( function() {
                    return $( this ).css( "position" ) === "fixed";
                } ).length > 0;
    
            //The element's absolute position on the page minus margins
            this.positionAbs = this.element.offset();
            this._refreshOffsets( event );
    
            //Generate the original position
            this.originalPosition = this.position = this._generatePosition( event, false );
            this.originalPageX = event.pageX;
            this.originalPageY = event.pageY;
    
            //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
            ( o.cursorAt && this._adjustOffsetFromHelper( o.cursorAt ) );
    
            //Set a containment if given in the options
            this._setContainment();
    
            //Trigger event + callbacks
            if ( this._trigger( "start", event ) === false ) {
                this._clear();
                return false;
            }
    
            //Recache the helper size
            this._cacheHelperProportions();
    
            //Prepare the droppable offsets
            if ( $.ui.ddmanager && !o.dropBehaviour ) {
                $.ui.ddmanager.prepareOffsets( this, event );
            }
    
            // Execute the drag once - this causes the helper not to be visible before getting its
            // correct position
            this._mouseDrag( event, true );
    
            // If the ddmanager is used for droppables, inform the manager that dragging has started
            // (see #5003)
            if ( $.ui.ddmanager ) {
                $.ui.ddmanager.dragStart( this, event );
            }
    
            return true;
        },
    
        _refreshOffsets: function( event ) {
            this.offset = {
                top: this.positionAbs.top - this.margins.top,
                left: this.positionAbs.left - this.margins.left,
                scroll: false,
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset()
            };
    
            this.offset.click = {
                left: event.pageX - this.offset.left,
                top: event.pageY - this.offset.top
            };
        },
    
        _mouseDrag: function( event, noPropagation ) {
    
            // reset any necessary cached properties (see #5009)
            if ( this.hasFixedAncestor ) {
                this.offset.parent = this._getParentOffset();
            }
    
            //Compute the helpers position
            this.position = this._generatePosition( event, true );
            this.positionAbs = this._convertPositionTo( "absolute" );
    
            //Call plugins and callbacks and use the resulting position if something is returned
            if ( !noPropagation ) {
                var ui = this._uiHash();
                if ( this._trigger( "drag", event, ui ) === false ) {
                    this._mouseUp( new $.Event( "mouseup", event ) );
                    return false;
                }
                this.position = ui.position;
            }
    
            this.helper[ 0 ].style.left = this.position.left + "px";
            this.helper[ 0 ].style.top = this.position.top + "px";
    
            if ( $.ui.ddmanager ) {
                $.ui.ddmanager.drag( this, event );
            }
    
            return false;
        },
    
        _mouseStop: function( event ) {
    
            //If we are using droppables, inform the manager about the drop
            var that = this,
                dropped = false;
            if ( $.ui.ddmanager && !this.options.dropBehaviour ) {
                dropped = $.ui.ddmanager.drop( this, event );
            }
    
            //if a drop comes from outside (a sortable)
            if ( this.dropped ) {
                dropped = this.dropped;
                this.dropped = false;
            }
    
            if ( ( this.options.revert === "invalid" && !dropped ) ||
                    ( this.options.revert === "valid" && dropped ) ||
                    this.options.revert === true || ( $.isFunction( this.options.revert ) &&
                    this.options.revert.call( this.element, dropped ) )
            ) {
                $( this.helper ).animate(
                    this.originalPosition,
                    parseInt( this.options.revertDuration, 10 ),
                    function() {
                        if ( that._trigger( "stop", event ) !== false ) {
                            that._clear();
                        }
                    }
                );
            } else {
                if ( this._trigger( "stop", event ) !== false ) {
                    this._clear();
                }
            }
    
            return false;
        },
    
        _mouseUp: function( event ) {
            this._unblockFrames();
    
            // If the ddmanager is used for droppables, inform the manager that dragging has stopped
            // (see #5003)
            if ( $.ui.ddmanager ) {
                $.ui.ddmanager.dragStop( this, event );
            }
    
            // Only need to focus if the event occurred on the draggable itself, see #10527
            if ( this.handleElement.is( event.target ) ) {
    
                // The interaction is over; whether or not the click resulted in a drag,
                // focus the element
                this.element.trigger( "focus" );
            }
    
            return $.ui.mouse.prototype._mouseUp.call( this, event );
        },
    
        cancel: function() {
    
            if ( this.helper.is( ".ui-draggable-dragging" ) ) {
                this._mouseUp( new $.Event( "mouseup", { target: this.element[ 0 ] } ) );
            } else {
                this._clear();
            }
    
            return this;
    
        },
    
        _getHandle: function( event ) {
            return this.options.handle ?
                !!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
                true;
        },
    
        _setHandleClassName: function() {
            this.handleElement = this.options.handle ?
                this.element.find( this.options.handle ) : this.element;
            this._addClass( this.handleElement, "ui-draggable-handle" );
        },
    
        _removeHandleClassName: function() {
            this._removeClass( this.handleElement, "ui-draggable-handle" );
        },
    
        _createHelper: function( event ) {
    
            var o = this.options,
                helperIsFunction = $.isFunction( o.helper ),
                helper = helperIsFunction ?
                    $( o.helper.apply( this.element[ 0 ], [ event ] ) ) :
                    ( o.helper === "clone" ?
                        this.element.clone().removeAttr( "id" ) :
                        this.element );
    
            if ( !helper.parents( "body" ).length ) {
                helper.appendTo( ( o.appendTo === "parent" ?
                    this.element[ 0 ].parentNode :
                    o.appendTo ) );
            }
    
            // Http://bugs.jqueryui.com/ticket/9446
            // a helper function can return the original element
            // which wouldn't have been set to relative in _create
            if ( helperIsFunction && helper[ 0 ] === this.element[ 0 ] ) {
                this._setPositionRelative();
            }
    
            if ( helper[ 0 ] !== this.element[ 0 ] &&
                    !( /(fixed|absolute)/ ).test( helper.css( "position" ) ) ) {
                helper.css( "position", "absolute" );
            }
    
            return helper;
    
        },
    
        _setPositionRelative: function() {
            if ( !( /^(?:r|a|f)/ ).test( this.element.css( "position" ) ) ) {
                this.element[ 0 ].style.position = "relative";
            }
        },
    
        _adjustOffsetFromHelper: function( obj ) {
            if ( typeof obj === "string" ) {
                obj = obj.split( " " );
            }
            if ( $.isArray( obj ) ) {
                obj = { left: +obj[ 0 ], top: +obj[ 1 ] || 0 };
            }
            if ( "left" in obj ) {
                this.offset.click.left = obj.left + this.margins.left;
            }
            if ( "right" in obj ) {
                this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
            }
            if ( "top" in obj ) {
                this.offset.click.top = obj.top + this.margins.top;
            }
            if ( "bottom" in obj ) {
                this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
            }
        },
    
        _isRootNode: function( element ) {
            return ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];
        },
    
        _getParentOffset: function() {
    
            //Get the offsetParent and cache its position
            var po = this.offsetParent.offset(),
                document = this.document[ 0 ];
    
            // This is a special case where we need to modify a offset calculated on start, since the
            // following happened:
            // 1. The position of the helper is absolute, so it's position is calculated based on the
            // next positioned parent
            // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't
            // the document, which means that the scroll is included in the initial calculation of the
            // offset of the parent, and never recalculated upon drag
            if ( this.cssPosition === "absolute" && this.scrollParent[ 0 ] !== document &&
                    $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) {
                po.left += this.scrollParent.scrollLeft();
                po.top += this.scrollParent.scrollTop();
            }
    
            if ( this._isRootNode( this.offsetParent[ 0 ] ) ) {
                po = { top: 0, left: 0 };
            }
    
            return {
                top: po.top + ( parseInt( this.offsetParent.css( "borderTopWidth" ), 10 ) || 0 ),
                left: po.left + ( parseInt( this.offsetParent.css( "borderLeftWidth" ), 10 ) || 0 )
            };
    
        },
    
        _getRelativeOffset: function() {
            if ( this.cssPosition !== "relative" ) {
                return { top: 0, left: 0 };
            }
    
            var p = this.element.position(),
                scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );
    
            return {
                top: p.top - ( parseInt( this.helper.css( "top" ), 10 ) || 0 ) +
                    ( !scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),
                left: p.left - ( parseInt( this.helper.css( "left" ), 10 ) || 0 ) +
                    ( !scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )
            };
    
        },
    
        _cacheMargins: function() {
            this.margins = {
                left: ( parseInt( this.element.css( "marginLeft" ), 10 ) || 0 ),
                top: ( parseInt( this.element.css( "marginTop" ), 10 ) || 0 ),
                right: ( parseInt( this.element.css( "marginRight" ), 10 ) || 0 ),
                bottom: ( parseInt( this.element.css( "marginBottom" ), 10 ) || 0 )
            };
        },
    
        _cacheHelperProportions: function() {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            };
        },
    
        _setContainment: function() {
    
            var isUserScrollable, c, ce,
                o = this.options,
                document = this.document[ 0 ];
    
            this.relativeContainer = null;
    
            if ( !o.containment ) {
                this.containment = null;
                return;
            }
    
            if ( o.containment === "window" ) {
                this.containment = [
                    $( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
                    $( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
                    $( window ).scrollLeft() + $( window ).width() -
                        this.helperProportions.width - this.margins.left,
                    $( window ).scrollTop() +
                        ( $( window ).height() || document.body.parentNode.scrollHeight ) -
                        this.helperProportions.height - this.margins.top
                ];
                return;
            }
    
            if ( o.containment === "document" ) {
                this.containment = [
                    0,
                    0,
                    $( document ).width() - this.helperProportions.width - this.margins.left,
                    ( $( document ).height() || document.body.parentNode.scrollHeight ) -
                        this.helperProportions.height - this.margins.top
                ];
                return;
            }
    
            if ( o.containment.constructor === Array ) {
                this.containment = o.containment;
                return;
            }
    
            if ( o.containment === "parent" ) {
                o.containment = this.helper[ 0 ].parentNode;
            }
    
            c = $( o.containment );
            ce = c[ 0 ];
    
            if ( !ce ) {
                return;
            }
    
            isUserScrollable = /(scroll|auto)/.test( c.css( "overflow" ) );
    
            this.containment = [
                ( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) +
                    ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
                ( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) +
                    ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ),
                ( isUserScrollable ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
                    ( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) -
                    ( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) -
                    this.helperProportions.width -
                    this.margins.left -
                    this.margins.right,
                ( isUserScrollable ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
                    ( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) -
                    ( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) -
                    this.helperProportions.height -
                    this.margins.top -
                    this.margins.bottom
            ];
            this.relativeContainer = c;
        },
    
        _convertPositionTo: function( d, pos ) {
    
            if ( !pos ) {
                pos = this.position;
            }
    
            var mod = d === "absolute" ? 1 : -1,
                scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );
    
            return {
                top: (
    
                    // The absolute mouse position
                    pos.top	+
    
                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.relative.top * mod +
    
                    // The offsetParent's offset without borders (offset + border)
                    this.offset.parent.top * mod -
                    ( ( this.cssPosition === "fixed" ?
                        -this.offset.scroll.top :
                        ( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod )
                ),
                left: (
    
                    // The absolute mouse position
                    pos.left +
    
                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.relative.left * mod +
    
                    // The offsetParent's offset without borders (offset + border)
                    this.offset.parent.left * mod	-
                    ( ( this.cssPosition === "fixed" ?
                        -this.offset.scroll.left :
                        ( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod )
                )
            };
    
        },
    
        _generatePosition: function( event, constrainPosition ) {
    
            var containment, co, top, left,
                o = this.options,
                scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),
                pageX = event.pageX,
                pageY = event.pageY;
    
            // Cache the scroll
            if ( !scrollIsRootNode || !this.offset.scroll ) {
                this.offset.scroll = {
                    top: this.scrollParent.scrollTop(),
                    left: this.scrollParent.scrollLeft()
                };
            }
    
            /*
             * - Position constraining -
             * Constrain the position to a mix of grid, containment.
             */
    
            // If we are not dragging yet, we won't check for options
            if ( constrainPosition ) {
                if ( this.containment ) {
                    if ( this.relativeContainer ) {
                        co = this.relativeContainer.offset();
                        containment = [
                            this.containment[ 0 ] + co.left,
                            this.containment[ 1 ] + co.top,
                            this.containment[ 2 ] + co.left,
                            this.containment[ 3 ] + co.top
                        ];
                    } else {
                        containment = this.containment;
                    }
    
                    if ( event.pageX - this.offset.click.left < containment[ 0 ] ) {
                        pageX = containment[ 0 ] + this.offset.click.left;
                    }
                    if ( event.pageY - this.offset.click.top < containment[ 1 ] ) {
                        pageY = containment[ 1 ] + this.offset.click.top;
                    }
                    if ( event.pageX - this.offset.click.left > containment[ 2 ] ) {
                        pageX = containment[ 2 ] + this.offset.click.left;
                    }
                    if ( event.pageY - this.offset.click.top > containment[ 3 ] ) {
                        pageY = containment[ 3 ] + this.offset.click.top;
                    }
                }
    
                if ( o.grid ) {
    
                    //Check for grid elements set to 0 to prevent divide by 0 error causing invalid
                    // argument errors in IE (see ticket #6950)
                    top = o.grid[ 1 ] ? this.originalPageY + Math.round( ( pageY -
                        this.originalPageY ) / o.grid[ 1 ] ) * o.grid[ 1 ] : this.originalPageY;
                    pageY = containment ? ( ( top - this.offset.click.top >= containment[ 1 ] ||
                        top - this.offset.click.top > containment[ 3 ] ) ?
                            top :
                            ( ( top - this.offset.click.top >= containment[ 1 ] ) ?
                                top - o.grid[ 1 ] : top + o.grid[ 1 ] ) ) : top;
    
                    left = o.grid[ 0 ] ? this.originalPageX +
                        Math.round( ( pageX - this.originalPageX ) / o.grid[ 0 ] ) * o.grid[ 0 ] :
                        this.originalPageX;
                    pageX = containment ? ( ( left - this.offset.click.left >= containment[ 0 ] ||
                        left - this.offset.click.left > containment[ 2 ] ) ?
                            left :
                            ( ( left - this.offset.click.left >= containment[ 0 ] ) ?
                                left - o.grid[ 0 ] : left + o.grid[ 0 ] ) ) : left;
                }
    
                if ( o.axis === "y" ) {
                    pageX = this.originalPageX;
                }
    
                if ( o.axis === "x" ) {
                    pageY = this.originalPageY;
                }
            }
    
            return {
                top: (
    
                    // The absolute mouse position
                    pageY -
    
                    // Click offset (relative to the element)
                    this.offset.click.top -
    
                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.relative.top -
    
                    // The offsetParent's offset without borders (offset + border)
                    this.offset.parent.top +
                    ( this.cssPosition === "fixed" ?
                        -this.offset.scroll.top :
                        ( scrollIsRootNode ? 0 : this.offset.scroll.top ) )
                ),
                left: (
    
                    // The absolute mouse position
                    pageX -
    
                    // Click offset (relative to the element)
                    this.offset.click.left -
    
                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.relative.left -
    
                    // The offsetParent's offset without borders (offset + border)
                    this.offset.parent.left +
                    ( this.cssPosition === "fixed" ?
                        -this.offset.scroll.left :
                        ( scrollIsRootNode ? 0 : this.offset.scroll.left ) )
                )
            };
    
        },
    
        _clear: function() {
            this._removeClass( this.helper, "ui-draggable-dragging" );
            if ( this.helper[ 0 ] !== this.element[ 0 ] && !this.cancelHelperRemoval ) {
                this.helper.remove();
            }
            this.helper = null;
            this.cancelHelperRemoval = false;
            if ( this.destroyOnClear ) {
                this.destroy();
            }
        },
    
        // From now on bulk stuff - mainly helpers
    
        _trigger: function( type, event, ui ) {
            ui = ui || this._uiHash();
            $.ui.plugin.call( this, type, [ event, ui, this ], true );
    
            // Absolute position and offset (see #6884 ) have to be recalculated after plugins
            if ( /^(drag|start|stop)/.test( type ) ) {
                this.positionAbs = this._convertPositionTo( "absolute" );
                ui.offset = this.positionAbs;
            }
            return $.Widget.prototype._trigger.call( this, type, event, ui );
        },
    
        plugins: {},
    
        _uiHash: function() {
            return {
                helper: this.helper,
                position: this.position,
                originalPosition: this.originalPosition,
                offset: this.positionAbs
            };
        }
    
    } );
    
    $.ui.plugin.add( "draggable", "connectToSortable", {
        start: function( event, ui, draggable ) {
            var uiSortable = $.extend( {}, ui, {
                item: draggable.element
            } );
    
            draggable.sortables = [];
            $( draggable.options.connectToSortable ).each( function() {
                var sortable = $( this ).sortable( "instance" );
    
                if ( sortable && !sortable.options.disabled ) {
                    draggable.sortables.push( sortable );
    
                    // RefreshPositions is called at drag start to refresh the containerCache
                    // which is used in drag. This ensures it's initialized and synchronized
                    // with any changes that might have happened on the page since initialization.
                    sortable.refreshPositions();
                    sortable._trigger( "activate", event, uiSortable );
                }
            } );
        },
        stop: function( event, ui, draggable ) {
            var uiSortable = $.extend( {}, ui, {
                item: draggable.element
            } );
    
            draggable.cancelHelperRemoval = false;
    
            $.each( draggable.sortables, function() {
                var sortable = this;
    
                if ( sortable.isOver ) {
                    sortable.isOver = 0;
    
                    // Allow this sortable to handle removing the helper
                    draggable.cancelHelperRemoval = true;
                    sortable.cancelHelperRemoval = false;
    
                    // Use _storedCSS To restore properties in the sortable,
                    // as this also handles revert (#9675) since the draggable
                    // may have modified them in unexpected ways (#8809)
                    sortable._storedCSS = {
                        position: sortable.placeholder.css( "position" ),
                        top: sortable.placeholder.css( "top" ),
                        left: sortable.placeholder.css( "left" )
                    };
    
                    sortable._mouseStop( event );
    
                    // Once drag has ended, the sortable should return to using
                    // its original helper, not the shared helper from draggable
                    sortable.options.helper = sortable.options._helper;
                } else {
    
                    // Prevent this Sortable from removing the helper.
                    // However, don't set the draggable to remove the helper
                    // either as another connected Sortable may yet handle the removal.
                    sortable.cancelHelperRemoval = true;
    
                    sortable._trigger( "deactivate", event, uiSortable );
                }
            } );
        },
        drag: function( event, ui, draggable ) {
            $.each( draggable.sortables, function() {
                var innermostIntersecting = false,
                    sortable = this;
    
                // Copy over variables that sortable's _intersectsWith uses
                sortable.positionAbs = draggable.positionAbs;
                sortable.helperProportions = draggable.helperProportions;
                sortable.offset.click = draggable.offset.click;
    
                if ( sortable._intersectsWith( sortable.containerCache ) ) {
                    innermostIntersecting = true;
    
                    $.each( draggable.sortables, function() {
    
                        // Copy over variables that sortable's _intersectsWith uses
                        this.positionAbs = draggable.positionAbs;
                        this.helperProportions = draggable.helperProportions;
                        this.offset.click = draggable.offset.click;
    
                        if ( this !== sortable &&
                                this._intersectsWith( this.containerCache ) &&
                                $.contains( sortable.element[ 0 ], this.element[ 0 ] ) ) {
                            innermostIntersecting = false;
                        }
    
                        return innermostIntersecting;
                    } );
                }
    
                if ( innermostIntersecting ) {
    
                    // If it intersects, we use a little isOver variable and set it once,
                    // so that the move-in stuff gets fired only once.
                    if ( !sortable.isOver ) {
                        sortable.isOver = 1;
    
                        // Store draggable's parent in case we need to reappend to it later.
                        draggable._parent = ui.helper.parent();
    
                        sortable.currentItem = ui.helper
                            .appendTo( sortable.element )
                            .data( "ui-sortable-item", true );
    
                        // Store helper option to later restore it
                        sortable.options._helper = sortable.options.helper;
    
                        sortable.options.helper = function() {
                            return ui.helper[ 0 ];
                        };
    
                        // Fire the start events of the sortable with our passed browser event,
                        // and our own helper (so it doesn't create a new one)
                        event.target = sortable.currentItem[ 0 ];
                        sortable._mouseCapture( event, true );
                        sortable._mouseStart( event, true, true );
    
                        // Because the browser event is way off the new appended portlet,
                        // modify necessary variables to reflect the changes
                        sortable.offset.click.top = draggable.offset.click.top;
                        sortable.offset.click.left = draggable.offset.click.left;
                        sortable.offset.parent.left -= draggable.offset.parent.left -
                            sortable.offset.parent.left;
                        sortable.offset.parent.top -= draggable.offset.parent.top -
                            sortable.offset.parent.top;
    
                        draggable._trigger( "toSortable", event );
    
                        // Inform draggable that the helper is in a valid drop zone,
                        // used solely in the revert option to handle "valid/invalid".
                        draggable.dropped = sortable.element;
    
                        // Need to refreshPositions of all sortables in the case that
                        // adding to one sortable changes the location of the other sortables (#9675)
                        $.each( draggable.sortables, function() {
                            this.refreshPositions();
                        } );
    
                        // Hack so receive/update callbacks work (mostly)
                        draggable.currentItem = draggable.element;
                        sortable.fromOutside = draggable;
                    }
    
                    if ( sortable.currentItem ) {
                        sortable._mouseDrag( event );
    
                        // Copy the sortable's position because the draggable's can potentially reflect
                        // a relative position, while sortable is always absolute, which the dragged
                        // element has now become. (#8809)
                        ui.position = sortable.position;
                    }
                } else {
    
                    // If it doesn't intersect with the sortable, and it intersected before,
                    // we fake the drag stop of the sortable, but make sure it doesn't remove
                    // the helper by using cancelHelperRemoval.
                    if ( sortable.isOver ) {
    
                        sortable.isOver = 0;
                        sortable.cancelHelperRemoval = true;
    
                        // Calling sortable's mouseStop would trigger a revert,
                        // so revert must be temporarily false until after mouseStop is called.
                        sortable.options._revert = sortable.options.revert;
                        sortable.options.revert = false;
    
                        sortable._trigger( "out", event, sortable._uiHash( sortable ) );
                        sortable._mouseStop( event, true );
    
                        // Restore sortable behaviors that were modfied
                        // when the draggable entered the sortable area (#9481)
                        sortable.options.revert = sortable.options._revert;
                        sortable.options.helper = sortable.options._helper;
    
                        if ( sortable.placeholder ) {
                            sortable.placeholder.remove();
                        }
    
                        // Restore and recalculate the draggable's offset considering the sortable
                        // may have modified them in unexpected ways. (#8809, #10669)
                        ui.helper.appendTo( draggable._parent );
                        draggable._refreshOffsets( event );
                        ui.position = draggable._generatePosition( event, true );
    
                        draggable._trigger( "fromSortable", event );
    
                        // Inform draggable that the helper is no longer in a valid drop zone
                        draggable.dropped = false;
    
                        // Need to refreshPositions of all sortables just in case removing
                        // from one sortable changes the location of other sortables (#9675)
                        $.each( draggable.sortables, function() {
                            this.refreshPositions();
                        } );
                    }
                }
            } );
        }
    } );
    
    $.ui.plugin.add( "draggable", "cursor", {
        start: function( event, ui, instance ) {
            var t = $( "body" ),
                o = instance.options;
    
            if ( t.css( "cursor" ) ) {
                o._cursor = t.css( "cursor" );
            }
            t.css( "cursor", o.cursor );
        },
        stop: function( event, ui, instance ) {
            var o = instance.options;
            if ( o._cursor ) {
                $( "body" ).css( "cursor", o._cursor );
            }
        }
    } );
    
    $.ui.plugin.add( "draggable", "opacity", {
        start: function( event, ui, instance ) {
            var t = $( ui.helper ),
                o = instance.options;
            if ( t.css( "opacity" ) ) {
                o._opacity = t.css( "opacity" );
            }
            t.css( "opacity", o.opacity );
        },
        stop: function( event, ui, instance ) {
            var o = instance.options;
            if ( o._opacity ) {
                $( ui.helper ).css( "opacity", o._opacity );
            }
        }
    } );
    
    $.ui.plugin.add( "draggable", "scroll", {
        start: function( event, ui, i ) {
            if ( !i.scrollParentNotHidden ) {
                i.scrollParentNotHidden = i.helper.scrollParent( false );
            }
    
            if ( i.scrollParentNotHidden[ 0 ] !== i.document[ 0 ] &&
                    i.scrollParentNotHidden[ 0 ].tagName !== "HTML" ) {
                i.overflowOffset = i.scrollParentNotHidden.offset();
            }
        },
        drag: function( event, ui, i  ) {
    
            var o = i.options,
                scrolled = false,
                scrollParent = i.scrollParentNotHidden[ 0 ],
                document = i.document[ 0 ];
    
            if ( scrollParent !== document && scrollParent.tagName !== "HTML" ) {
                if ( !o.axis || o.axis !== "x" ) {
                    if ( ( i.overflowOffset.top + scrollParent.offsetHeight ) - event.pageY <
                            o.scrollSensitivity ) {
                        scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
                    } else if ( event.pageY - i.overflowOffset.top < o.scrollSensitivity ) {
                        scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
                    }
                }
    
                if ( !o.axis || o.axis !== "y" ) {
                    if ( ( i.overflowOffset.left + scrollParent.offsetWidth ) - event.pageX <
                            o.scrollSensitivity ) {
                        scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
                    } else if ( event.pageX - i.overflowOffset.left < o.scrollSensitivity ) {
                        scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
                    }
                }
    
            } else {
    
                if ( !o.axis || o.axis !== "x" ) {
                    if ( event.pageY - $( document ).scrollTop() < o.scrollSensitivity ) {
                        scrolled = $( document ).scrollTop( $( document ).scrollTop() - o.scrollSpeed );
                    } else if ( $( window ).height() - ( event.pageY - $( document ).scrollTop() ) <
                            o.scrollSensitivity ) {
                        scrolled = $( document ).scrollTop( $( document ).scrollTop() + o.scrollSpeed );
                    }
                }
    
                if ( !o.axis || o.axis !== "y" ) {
                    if ( event.pageX - $( document ).scrollLeft() < o.scrollSensitivity ) {
                        scrolled = $( document ).scrollLeft(
                            $( document ).scrollLeft() - o.scrollSpeed
                        );
                    } else if ( $( window ).width() - ( event.pageX - $( document ).scrollLeft() ) <
                            o.scrollSensitivity ) {
                        scrolled = $( document ).scrollLeft(
                            $( document ).scrollLeft() + o.scrollSpeed
                        );
                    }
                }
    
            }
    
            if ( scrolled !== false && $.ui.ddmanager && !o.dropBehaviour ) {
                $.ui.ddmanager.prepareOffsets( i, event );
            }
    
        }
    } );
    
    $.ui.plugin.add( "draggable", "snap", {
        start: function( event, ui, i ) {
    
            var o = i.options;
    
            i.snapElements = [];
    
            $( o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap )
                .each( function() {
                    var $t = $( this ),
                        $o = $t.offset();
                    if ( this !== i.element[ 0 ] ) {
                        i.snapElements.push( {
                            item: this,
                            width: $t.outerWidth(), height: $t.outerHeight(),
                            top: $o.top, left: $o.left
                        } );
                    }
                } );
    
        },
        drag: function( event, ui, inst ) {
    
            var ts, bs, ls, rs, l, r, t, b, i, first,
                o = inst.options,
                d = o.snapTolerance,
                x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
                y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;
    
            for ( i = inst.snapElements.length - 1; i >= 0; i-- ) {
    
                l = inst.snapElements[ i ].left - inst.margins.left;
                r = l + inst.snapElements[ i ].width;
                t = inst.snapElements[ i ].top - inst.margins.top;
                b = t + inst.snapElements[ i ].height;
    
                if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d ||
                        !$.contains( inst.snapElements[ i ].item.ownerDocument,
                        inst.snapElements[ i ].item ) ) {
                    if ( inst.snapElements[ i ].snapping ) {
                        ( inst.options.snap.release &&
                            inst.options.snap.release.call(
                                inst.element,
                                event,
                                $.extend( inst._uiHash(), { snapItem: inst.snapElements[ i ].item } )
                            ) );
                    }
                    inst.snapElements[ i ].snapping = false;
                    continue;
                }
    
                if ( o.snapMode !== "inner" ) {
                    ts = Math.abs( t - y2 ) <= d;
                    bs = Math.abs( b - y1 ) <= d;
                    ls = Math.abs( l - x2 ) <= d;
                    rs = Math.abs( r - x1 ) <= d;
                    if ( ts ) {
                        ui.position.top = inst._convertPositionTo( "relative", {
                            top: t - inst.helperProportions.height,
                            left: 0
                        } ).top;
                    }
                    if ( bs ) {
                        ui.position.top = inst._convertPositionTo( "relative", {
                            top: b,
                            left: 0
                        } ).top;
                    }
                    if ( ls ) {
                        ui.position.left = inst._convertPositionTo( "relative", {
                            top: 0,
                            left: l - inst.helperProportions.width
                        } ).left;
                    }
                    if ( rs ) {
                        ui.position.left = inst._convertPositionTo( "relative", {
                            top: 0,
                            left: r
                        } ).left;
                    }
                }
    
                first = ( ts || bs || ls || rs );
    
                if ( o.snapMode !== "outer" ) {
                    ts = Math.abs( t - y1 ) <= d;
                    bs = Math.abs( b - y2 ) <= d;
                    ls = Math.abs( l - x1 ) <= d;
                    rs = Math.abs( r - x2 ) <= d;
                    if ( ts ) {
                        ui.position.top = inst._convertPositionTo( "relative", {
                            top: t,
                            left: 0
                        } ).top;
                    }
                    if ( bs ) {
                        ui.position.top = inst._convertPositionTo( "relative", {
                            top: b - inst.helperProportions.height,
                            left: 0
                        } ).top;
                    }
                    if ( ls ) {
                        ui.position.left = inst._convertPositionTo( "relative", {
                            top: 0,
                            left: l
                        } ).left;
                    }
                    if ( rs ) {
                        ui.position.left = inst._convertPositionTo( "relative", {
                            top: 0,
                            left: r - inst.helperProportions.width
                        } ).left;
                    }
                }
    
                if ( !inst.snapElements[ i ].snapping && ( ts || bs || ls || rs || first ) ) {
                    ( inst.options.snap.snap &&
                        inst.options.snap.snap.call(
                            inst.element,
                            event,
                            $.extend( inst._uiHash(), {
                                snapItem: inst.snapElements[ i ].item
                            } ) ) );
                }
                inst.snapElements[ i ].snapping = ( ts || bs || ls || rs || first );
    
            }
    
        }
    } );
    
    $.ui.plugin.add( "draggable", "stack", {
        start: function( event, ui, instance ) {
            var min,
                o = instance.options,
                group = $.makeArray( $( o.stack ) ).sort( function( a, b ) {
                    return ( parseInt( $( a ).css( "zIndex" ), 10 ) || 0 ) -
                        ( parseInt( $( b ).css( "zIndex" ), 10 ) || 0 );
                } );
    
            if ( !group.length ) { return; }
    
            min = parseInt( $( group[ 0 ] ).css( "zIndex" ), 10 ) || 0;
            $( group ).each( function( i ) {
                $( this ).css( "zIndex", min + i );
            } );
            this.css( "zIndex", ( min + group.length ) );
        }
    } );
    
    $.ui.plugin.add( "draggable", "zIndex", {
        start: function( event, ui, instance ) {
            var t = $( ui.helper ),
                o = instance.options;
    
            if ( t.css( "zIndex" ) ) {
                o._zIndex = t.css( "zIndex" );
            }
            t.css( "zIndex", o.zIndex );
        },
        stop: function( event, ui, instance ) {
            var o = instance.options;
    
            if ( o._zIndex ) {
                $( ui.helper ).css( "zIndex", o._zIndex );
            }
        }
    } );
    
    var widgetsDraggable = $.ui.draggable;
    
    
    /*!
     * jQuery UI Resizable 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Resizable
    //>>group: Interactions
    //>>description: Enables resize functionality for any element.
    //>>docs: http://api.jqueryui.com/resizable/
    //>>demos: http://jqueryui.com/resizable/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/resizable.css
    //>>css.theme: ../../themes/base/theme.css
    
    
    
    $.widget( "ui.resizable", $.ui.mouse, {
        version: "1.12.1",
        widgetEventPrefix: "resize",
        options: {
            alsoResize: false,
            animate: false,
            animateDuration: "slow",
            animateEasing: "swing",
            aspectRatio: false,
            autoHide: false,
            classes: {
                "ui-resizable-se": "ui-icon ui-icon-gripsmall-diagonal-se"
            },
            containment: false,
            ghost: false,
            grid: false,
            handles: "e,s,se",
            helper: false,
            maxHeight: null,
            maxWidth: null,
            minHeight: 10,
            minWidth: 10,
    
            // See #7960
            zIndex: 90,
    
            // Callbacks
            resize: null,
            start: null,
            stop: null
        },
    
        _num: function( value ) {
            return parseFloat( value ) || 0;
        },
    
        _isNumber: function( value ) {
            return !isNaN( parseFloat( value ) );
        },
    
        _hasScroll: function( el, a ) {
    
            if ( $( el ).css( "overflow" ) === "hidden" ) {
                return false;
            }
    
            var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
                has = false;
    
            if ( el[ scroll ] > 0 ) {
                return true;
            }
    
            // TODO: determine which cases actually cause this to happen
            // if the element doesn't have the scroll set, see if it's possible to
            // set the scroll
            el[ scroll ] = 1;
            has = ( el[ scroll ] > 0 );
            el[ scroll ] = 0;
            return has;
        },
    
        _create: function() {
    
            var margins,
                o = this.options,
                that = this;
            this._addClass( "ui-resizable" );
    
            $.extend( this, {
                _aspectRatio: !!( o.aspectRatio ),
                aspectRatio: o.aspectRatio,
                originalElement: this.element,
                _proportionallyResizeElements: [],
                _helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
            } );
    
            // Wrap the element if it cannot hold child nodes
            if ( this.element[ 0 ].nodeName.match( /^(canvas|textarea|input|select|button|img)$/i ) ) {
    
                this.element.wrap(
                    $( "<div class='ui-wrapper' style='overflow: hidden;'></div>" ).css( {
                        position: this.element.css( "position" ),
                        width: this.element.outerWidth(),
                        height: this.element.outerHeight(),
                        top: this.element.css( "top" ),
                        left: this.element.css( "left" )
                    } )
                );
    
                this.element = this.element.parent().data(
                    "ui-resizable", this.element.resizable( "instance" )
                );
    
                this.elementIsWrapper = true;
    
                margins = {
                    marginTop: this.originalElement.css( "marginTop" ),
                    marginRight: this.originalElement.css( "marginRight" ),
                    marginBottom: this.originalElement.css( "marginBottom" ),
                    marginLeft: this.originalElement.css( "marginLeft" )
                };
    
                this.element.css( margins );
                this.originalElement.css( "margin", 0 );
    
                // support: Safari
                // Prevent Safari textarea resize
                this.originalResizeStyle = this.originalElement.css( "resize" );
                this.originalElement.css( "resize", "none" );
    
                this._proportionallyResizeElements.push( this.originalElement.css( {
                    position: "static",
                    zoom: 1,
                    display: "block"
                } ) );
    
                // Support: IE9
                // avoid IE jump (hard set the margin)
                this.originalElement.css( margins );
    
                this._proportionallyResize();
            }
    
            this._setupHandles();
    
            if ( o.autoHide ) {
                $( this.element )
                    .on( "mouseenter", function() {
                        if ( o.disabled ) {
                            return;
                        }
                        that._removeClass( "ui-resizable-autohide" );
                        that._handles.show();
                    } )
                    .on( "mouseleave", function() {
                        if ( o.disabled ) {
                            return;
                        }
                        if ( !that.resizing ) {
                            that._addClass( "ui-resizable-autohide" );
                            that._handles.hide();
                        }
                    } );
            }
    
            this._mouseInit();
        },
    
        _destroy: function() {
    
            this._mouseDestroy();
    
            var wrapper,
                _destroy = function( exp ) {
                    $( exp )
                        .removeData( "resizable" )
                        .removeData( "ui-resizable" )
                        .off( ".resizable" )
                        .find( ".ui-resizable-handle" )
                            .remove();
                };
    
            // TODO: Unwrap at same DOM position
            if ( this.elementIsWrapper ) {
                _destroy( this.element );
                wrapper = this.element;
                this.originalElement.css( {
                    position: wrapper.css( "position" ),
                    width: wrapper.outerWidth(),
                    height: wrapper.outerHeight(),
                    top: wrapper.css( "top" ),
                    left: wrapper.css( "left" )
                } ).insertAfter( wrapper );
                wrapper.remove();
            }
    
            this.originalElement.css( "resize", this.originalResizeStyle );
            _destroy( this.originalElement );
    
            return this;
        },
    
        _setOption: function( key, value ) {
            this._super( key, value );
    
            switch ( key ) {
            case "handles":
                this._removeHandles();
                this._setupHandles();
                break;
            default:
                break;
            }
        },
    
        _setupHandles: function() {
            var o = this.options, handle, i, n, hname, axis, that = this;
            this.handles = o.handles ||
                ( !$( ".ui-resizable-handle", this.element ).length ?
                    "e,s,se" : {
                        n: ".ui-resizable-n",
                        e: ".ui-resizable-e",
                        s: ".ui-resizable-s",
                        w: ".ui-resizable-w",
                        se: ".ui-resizable-se",
                        sw: ".ui-resizable-sw",
                        ne: ".ui-resizable-ne",
                        nw: ".ui-resizable-nw"
                    } );
    
            this._handles = $();
            if ( this.handles.constructor === String ) {
    
                if ( this.handles === "all" ) {
                    this.handles = "n,e,s,w,se,sw,ne,nw";
                }
    
                n = this.handles.split( "," );
                this.handles = {};
    
                for ( i = 0; i < n.length; i++ ) {
    
                    handle = $.trim( n[ i ] );
                    hname = "ui-resizable-" + handle;
                    axis = $( "<div>" );
                    this._addClass( axis, "ui-resizable-handle " + hname );
    
                    axis.css( { zIndex: o.zIndex } );
    
                    this.handles[ handle ] = ".ui-resizable-" + handle;
                    this.element.append( axis );
                }
    
            }
    
            this._renderAxis = function( target ) {
    
                var i, axis, padPos, padWrapper;
    
                target = target || this.element;
    
                for ( i in this.handles ) {
    
                    if ( this.handles[ i ].constructor === String ) {
                        this.handles[ i ] = this.element.children( this.handles[ i ] ).first().show();
                    } else if ( this.handles[ i ].jquery || this.handles[ i ].nodeType ) {
                        this.handles[ i ] = $( this.handles[ i ] );
                        this._on( this.handles[ i ], { "mousedown": that._mouseDown } );
                    }
    
                    if ( this.elementIsWrapper &&
                            this.originalElement[ 0 ]
                                .nodeName
                                .match( /^(textarea|input|select|button)$/i ) ) {
                        axis = $( this.handles[ i ], this.element );
    
                        padWrapper = /sw|ne|nw|se|n|s/.test( i ) ?
                            axis.outerHeight() :
                            axis.outerWidth();
    
                        padPos = [ "padding",
                            /ne|nw|n/.test( i ) ? "Top" :
                            /se|sw|s/.test( i ) ? "Bottom" :
                            /^e$/.test( i ) ? "Right" : "Left" ].join( "" );
    
                        target.css( padPos, padWrapper );
    
                        this._proportionallyResize();
                    }
    
                    this._handles = this._handles.add( this.handles[ i ] );
                }
            };
    
            // TODO: make renderAxis a prototype function
            this._renderAxis( this.element );
    
            this._handles = this._handles.add( this.element.find( ".ui-resizable-handle" ) );
            this._handles.disableSelection();
    
            this._handles.on( "mouseover", function() {
                if ( !that.resizing ) {
                    if ( this.className ) {
                        axis = this.className.match( /ui-resizable-(se|sw|ne|nw|n|e|s|w)/i );
                    }
                    that.axis = axis && axis[ 1 ] ? axis[ 1 ] : "se";
                }
            } );
    
            if ( o.autoHide ) {
                this._handles.hide();
                this._addClass( "ui-resizable-autohide" );
            }
        },
    
        _removeHandles: function() {
            this._handles.remove();
        },
    
        _mouseCapture: function( event ) {
            var i, handle,
                capture = false;
    
            for ( i in this.handles ) {
                handle = $( this.handles[ i ] )[ 0 ];
                if ( handle === event.target || $.contains( handle, event.target ) ) {
                    capture = true;
                }
            }
    
            return !this.options.disabled && capture;
        },
    
        _mouseStart: function( event ) {
    
            var curleft, curtop, cursor,
                o = this.options,
                el = this.element;
    
            this.resizing = true;
    
            this._renderProxy();
    
            curleft = this._num( this.helper.css( "left" ) );
            curtop = this._num( this.helper.css( "top" ) );
    
            if ( o.containment ) {
                curleft += $( o.containment ).scrollLeft() || 0;
                curtop += $( o.containment ).scrollTop() || 0;
            }
    
            this.offset = this.helper.offset();
            this.position = { left: curleft, top: curtop };
    
            this.size = this._helper ? {
                    width: this.helper.width(),
                    height: this.helper.height()
                } : {
                    width: el.width(),
                    height: el.height()
                };
    
            this.originalSize = this._helper ? {
                    width: el.outerWidth(),
                    height: el.outerHeight()
                } : {
                    width: el.width(),
                    height: el.height()
                };
    
            this.sizeDiff = {
                width: el.outerWidth() - el.width(),
                height: el.outerHeight() - el.height()
            };
    
            this.originalPosition = { left: curleft, top: curtop };
            this.originalMousePosition = { left: event.pageX, top: event.pageY };
    
            this.aspectRatio = ( typeof o.aspectRatio === "number" ) ?
                o.aspectRatio :
                ( ( this.originalSize.width / this.originalSize.height ) || 1 );
    
            cursor = $( ".ui-resizable-" + this.axis ).css( "cursor" );
            $( "body" ).css( "cursor", cursor === "auto" ? this.axis + "-resize" : cursor );
    
            this._addClass( "ui-resizable-resizing" );
            this._propagate( "start", event );
            return true;
        },
    
        _mouseDrag: function( event ) {
    
            var data, props,
                smp = this.originalMousePosition,
                a = this.axis,
                dx = ( event.pageX - smp.left ) || 0,
                dy = ( event.pageY - smp.top ) || 0,
                trigger = this._change[ a ];
    
            this._updatePrevProperties();
    
            if ( !trigger ) {
                return false;
            }
    
            data = trigger.apply( this, [ event, dx, dy ] );
    
            this._updateVirtualBoundaries( event.shiftKey );
            if ( this._aspectRatio || event.shiftKey ) {
                data = this._updateRatio( data, event );
            }
    
            data = this._respectSize( data, event );
    
            this._updateCache( data );
    
            this._propagate( "resize", event );
    
            props = this._applyChanges();
    
            if ( !this._helper && this._proportionallyResizeElements.length ) {
                this._proportionallyResize();
            }
    
            if ( !$.isEmptyObject( props ) ) {
                this._updatePrevProperties();
                this._trigger( "resize", event, this.ui() );
                this._applyChanges();
            }
    
            return false;
        },
    
        _mouseStop: function( event ) {
    
            this.resizing = false;
            var pr, ista, soffseth, soffsetw, s, left, top,
                o = this.options, that = this;
    
            if ( this._helper ) {
    
                pr = this._proportionallyResizeElements;
                ista = pr.length && ( /textarea/i ).test( pr[ 0 ].nodeName );
                soffseth = ista && this._hasScroll( pr[ 0 ], "left" ) ? 0 : that.sizeDiff.height;
                soffsetw = ista ? 0 : that.sizeDiff.width;
    
                s = {
                    width: ( that.helper.width()  - soffsetw ),
                    height: ( that.helper.height() - soffseth )
                };
                left = ( parseFloat( that.element.css( "left" ) ) +
                    ( that.position.left - that.originalPosition.left ) ) || null;
                top = ( parseFloat( that.element.css( "top" ) ) +
                    ( that.position.top - that.originalPosition.top ) ) || null;
    
                if ( !o.animate ) {
                    this.element.css( $.extend( s, { top: top, left: left } ) );
                }
    
                that.helper.height( that.size.height );
                that.helper.width( that.size.width );
    
                if ( this._helper && !o.animate ) {
                    this._proportionallyResize();
                }
            }
    
            $( "body" ).css( "cursor", "auto" );
    
            this._removeClass( "ui-resizable-resizing" );
    
            this._propagate( "stop", event );
    
            if ( this._helper ) {
                this.helper.remove();
            }
    
            return false;
    
        },
    
        _updatePrevProperties: function() {
            this.prevPosition = {
                top: this.position.top,
                left: this.position.left
            };
            this.prevSize = {
                width: this.size.width,
                height: this.size.height
            };
        },
    
        _applyChanges: function() {
            var props = {};
    
            if ( this.position.top !== this.prevPosition.top ) {
                props.top = this.position.top + "px";
            }
            if ( this.position.left !== this.prevPosition.left ) {
                props.left = this.position.left + "px";
            }
            if ( this.size.width !== this.prevSize.width ) {
                props.width = this.size.width + "px";
            }
            if ( this.size.height !== this.prevSize.height ) {
                props.height = this.size.height + "px";
            }
    
            this.helper.css( props );
    
            return props;
        },
    
        _updateVirtualBoundaries: function( forceAspectRatio ) {
            var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
                o = this.options;
    
            b = {
                minWidth: this._isNumber( o.minWidth ) ? o.minWidth : 0,
                maxWidth: this._isNumber( o.maxWidth ) ? o.maxWidth : Infinity,
                minHeight: this._isNumber( o.minHeight ) ? o.minHeight : 0,
                maxHeight: this._isNumber( o.maxHeight ) ? o.maxHeight : Infinity
            };
    
            if ( this._aspectRatio || forceAspectRatio ) {
                pMinWidth = b.minHeight * this.aspectRatio;
                pMinHeight = b.minWidth / this.aspectRatio;
                pMaxWidth = b.maxHeight * this.aspectRatio;
                pMaxHeight = b.maxWidth / this.aspectRatio;
    
                if ( pMinWidth > b.minWidth ) {
                    b.minWidth = pMinWidth;
                }
                if ( pMinHeight > b.minHeight ) {
                    b.minHeight = pMinHeight;
                }
                if ( pMaxWidth < b.maxWidth ) {
                    b.maxWidth = pMaxWidth;
                }
                if ( pMaxHeight < b.maxHeight ) {
                    b.maxHeight = pMaxHeight;
                }
            }
            this._vBoundaries = b;
        },
    
        _updateCache: function( data ) {
            this.offset = this.helper.offset();
            if ( this._isNumber( data.left ) ) {
                this.position.left = data.left;
            }
            if ( this._isNumber( data.top ) ) {
                this.position.top = data.top;
            }
            if ( this._isNumber( data.height ) ) {
                this.size.height = data.height;
            }
            if ( this._isNumber( data.width ) ) {
                this.size.width = data.width;
            }
        },
    
        _updateRatio: function( data ) {
    
            var cpos = this.position,
                csize = this.size,
                a = this.axis;
    
            if ( this._isNumber( data.height ) ) {
                data.width = ( data.height * this.aspectRatio );
            } else if ( this._isNumber( data.width ) ) {
                data.height = ( data.width / this.aspectRatio );
            }
    
            if ( a === "sw" ) {
                data.left = cpos.left + ( csize.width - data.width );
                data.top = null;
            }
            if ( a === "nw" ) {
                data.top = cpos.top + ( csize.height - data.height );
                data.left = cpos.left + ( csize.width - data.width );
            }
    
            return data;
        },
    
        _respectSize: function( data ) {
    
            var o = this._vBoundaries,
                a = this.axis,
                ismaxw = this._isNumber( data.width ) && o.maxWidth && ( o.maxWidth < data.width ),
                ismaxh = this._isNumber( data.height ) && o.maxHeight && ( o.maxHeight < data.height ),
                isminw = this._isNumber( data.width ) && o.minWidth && ( o.minWidth > data.width ),
                isminh = this._isNumber( data.height ) && o.minHeight && ( o.minHeight > data.height ),
                dw = this.originalPosition.left + this.originalSize.width,
                dh = this.originalPosition.top + this.originalSize.height,
                cw = /sw|nw|w/.test( a ), ch = /nw|ne|n/.test( a );
            if ( isminw ) {
                data.width = o.minWidth;
            }
            if ( isminh ) {
                data.height = o.minHeight;
            }
            if ( ismaxw ) {
                data.width = o.maxWidth;
            }
            if ( ismaxh ) {
                data.height = o.maxHeight;
            }
    
            if ( isminw && cw ) {
                data.left = dw - o.minWidth;
            }
            if ( ismaxw && cw ) {
                data.left = dw - o.maxWidth;
            }
            if ( isminh && ch ) {
                data.top = dh - o.minHeight;
            }
            if ( ismaxh && ch ) {
                data.top = dh - o.maxHeight;
            }
    
            // Fixing jump error on top/left - bug #2330
            if ( !data.width && !data.height && !data.left && data.top ) {
                data.top = null;
            } else if ( !data.width && !data.height && !data.top && data.left ) {
                data.left = null;
            }
    
            return data;
        },
    
        _getPaddingPlusBorderDimensions: function( element ) {
            var i = 0,
                widths = [],
                borders = [
                    element.css( "borderTopWidth" ),
                    element.css( "borderRightWidth" ),
                    element.css( "borderBottomWidth" ),
                    element.css( "borderLeftWidth" )
                ],
                paddings = [
                    element.css( "paddingTop" ),
                    element.css( "paddingRight" ),
                    element.css( "paddingBottom" ),
                    element.css( "paddingLeft" )
                ];
    
            for ( ; i < 4; i++ ) {
                widths[ i ] = ( parseFloat( borders[ i ] ) || 0 );
                widths[ i ] += ( parseFloat( paddings[ i ] ) || 0 );
            }
    
            return {
                height: widths[ 0 ] + widths[ 2 ],
                width: widths[ 1 ] + widths[ 3 ]
            };
        },
    
        _proportionallyResize: function() {
    
            if ( !this._proportionallyResizeElements.length ) {
                return;
            }
    
            var prel,
                i = 0,
                element = this.helper || this.element;
    
            for ( ; i < this._proportionallyResizeElements.length; i++ ) {
    
                prel = this._proportionallyResizeElements[ i ];
    
                // TODO: Seems like a bug to cache this.outerDimensions
                // considering that we are in a loop.
                if ( !this.outerDimensions ) {
                    this.outerDimensions = this._getPaddingPlusBorderDimensions( prel );
                }
    
                prel.css( {
                    height: ( element.height() - this.outerDimensions.height ) || 0,
                    width: ( element.width() - this.outerDimensions.width ) || 0
                } );
    
            }
    
        },
    
        _renderProxy: function() {
    
            var el = this.element, o = this.options;
            this.elementOffset = el.offset();
    
            if ( this._helper ) {
    
                this.helper = this.helper || $( "<div style='overflow:hidden;'></div>" );
    
                this._addClass( this.helper, this._helper );
                this.helper.css( {
                    width: this.element.outerWidth(),
                    height: this.element.outerHeight(),
                    position: "absolute",
                    left: this.elementOffset.left + "px",
                    top: this.elementOffset.top + "px",
                    zIndex: ++o.zIndex //TODO: Don't modify option
                } );
    
                this.helper
                    .appendTo( "body" )
                    .disableSelection();
    
            } else {
                this.helper = this.element;
            }
    
        },
    
        _change: {
            e: function( event, dx ) {
                return { width: this.originalSize.width + dx };
            },
            w: function( event, dx ) {
                var cs = this.originalSize, sp = this.originalPosition;
                return { left: sp.left + dx, width: cs.width - dx };
            },
            n: function( event, dx, dy ) {
                var cs = this.originalSize, sp = this.originalPosition;
                return { top: sp.top + dy, height: cs.height - dy };
            },
            s: function( event, dx, dy ) {
                return { height: this.originalSize.height + dy };
            },
            se: function( event, dx, dy ) {
                return $.extend( this._change.s.apply( this, arguments ),
                    this._change.e.apply( this, [ event, dx, dy ] ) );
            },
            sw: function( event, dx, dy ) {
                return $.extend( this._change.s.apply( this, arguments ),
                    this._change.w.apply( this, [ event, dx, dy ] ) );
            },
            ne: function( event, dx, dy ) {
                return $.extend( this._change.n.apply( this, arguments ),
                    this._change.e.apply( this, [ event, dx, dy ] ) );
            },
            nw: function( event, dx, dy ) {
                return $.extend( this._change.n.apply( this, arguments ),
                    this._change.w.apply( this, [ event, dx, dy ] ) );
            }
        },
    
        _propagate: function( n, event ) {
            $.ui.plugin.call( this, n, [ event, this.ui() ] );
            ( n !== "resize" && this._trigger( n, event, this.ui() ) );
        },
    
        plugins: {},
    
        ui: function() {
            return {
                originalElement: this.originalElement,
                element: this.element,
                helper: this.helper,
                position: this.position,
                size: this.size,
                originalSize: this.originalSize,
                originalPosition: this.originalPosition
            };
        }
    
    } );
    
    /*
     * Resizable Extensions
     */
    
    $.ui.plugin.add( "resizable", "animate", {
    
        stop: function( event ) {
            var that = $( this ).resizable( "instance" ),
                o = that.options,
                pr = that._proportionallyResizeElements,
                ista = pr.length && ( /textarea/i ).test( pr[ 0 ].nodeName ),
                soffseth = ista && that._hasScroll( pr[ 0 ], "left" ) ? 0 : that.sizeDiff.height,
                soffsetw = ista ? 0 : that.sizeDiff.width,
                style = {
                    width: ( that.size.width - soffsetw ),
                    height: ( that.size.height - soffseth )
                },
                left = ( parseFloat( that.element.css( "left" ) ) +
                    ( that.position.left - that.originalPosition.left ) ) || null,
                top = ( parseFloat( that.element.css( "top" ) ) +
                    ( that.position.top - that.originalPosition.top ) ) || null;
    
            that.element.animate(
                $.extend( style, top && left ? { top: top, left: left } : {} ), {
                    duration: o.animateDuration,
                    easing: o.animateEasing,
                    step: function() {
    
                        var data = {
                            width: parseFloat( that.element.css( "width" ) ),
                            height: parseFloat( that.element.css( "height" ) ),
                            top: parseFloat( that.element.css( "top" ) ),
                            left: parseFloat( that.element.css( "left" ) )
                        };
    
                        if ( pr && pr.length ) {
                            $( pr[ 0 ] ).css( { width: data.width, height: data.height } );
                        }
    
                        // Propagating resize, and updating values for each animation step
                        that._updateCache( data );
                        that._propagate( "resize", event );
    
                    }
                }
            );
        }
    
    } );
    
    $.ui.plugin.add( "resizable", "containment", {
    
        start: function() {
            var element, p, co, ch, cw, width, height,
                that = $( this ).resizable( "instance" ),
                o = that.options,
                el = that.element,
                oc = o.containment,
                ce = ( oc instanceof $ ) ?
                    oc.get( 0 ) :
                    ( /parent/.test( oc ) ) ? el.parent().get( 0 ) : oc;
    
            if ( !ce ) {
                return;
            }
    
            that.containerElement = $( ce );
    
            if ( /document/.test( oc ) || oc === document ) {
                that.containerOffset = {
                    left: 0,
                    top: 0
                };
                that.containerPosition = {
                    left: 0,
                    top: 0
                };
    
                that.parentData = {
                    element: $( document ),
                    left: 0,
                    top: 0,
                    width: $( document ).width(),
                    height: $( document ).height() || document.body.parentNode.scrollHeight
                };
            } else {
                element = $( ce );
                p = [];
                $( [ "Top", "Right", "Left", "Bottom" ] ).each( function( i, name ) {
                    p[ i ] = that._num( element.css( "padding" + name ) );
                } );
    
                that.containerOffset = element.offset();
                that.containerPosition = element.position();
                that.containerSize = {
                    height: ( element.innerHeight() - p[ 3 ] ),
                    width: ( element.innerWidth() - p[ 1 ] )
                };
    
                co = that.containerOffset;
                ch = that.containerSize.height;
                cw = that.containerSize.width;
                width = ( that._hasScroll ( ce, "left" ) ? ce.scrollWidth : cw );
                height = ( that._hasScroll ( ce ) ? ce.scrollHeight : ch ) ;
    
                that.parentData = {
                    element: ce,
                    left: co.left,
                    top: co.top,
                    width: width,
                    height: height
                };
            }
        },
    
        resize: function( event ) {
            var woset, hoset, isParent, isOffsetRelative,
                that = $( this ).resizable( "instance" ),
                o = that.options,
                co = that.containerOffset,
                cp = that.position,
                pRatio = that._aspectRatio || event.shiftKey,
                cop = {
                    top: 0,
                    left: 0
                },
                ce = that.containerElement,
                continueResize = true;
    
            if ( ce[ 0 ] !== document && ( /static/ ).test( ce.css( "position" ) ) ) {
                cop = co;
            }
    
            if ( cp.left < ( that._helper ? co.left : 0 ) ) {
                that.size.width = that.size.width +
                    ( that._helper ?
                        ( that.position.left - co.left ) :
                        ( that.position.left - cop.left ) );
    
                if ( pRatio ) {
                    that.size.height = that.size.width / that.aspectRatio;
                    continueResize = false;
                }
                that.position.left = o.helper ? co.left : 0;
            }
    
            if ( cp.top < ( that._helper ? co.top : 0 ) ) {
                that.size.height = that.size.height +
                    ( that._helper ?
                        ( that.position.top - co.top ) :
                        that.position.top );
    
                if ( pRatio ) {
                    that.size.width = that.size.height * that.aspectRatio;
                    continueResize = false;
                }
                that.position.top = that._helper ? co.top : 0;
            }
    
            isParent = that.containerElement.get( 0 ) === that.element.parent().get( 0 );
            isOffsetRelative = /relative|absolute/.test( that.containerElement.css( "position" ) );
    
            if ( isParent && isOffsetRelative ) {
                that.offset.left = that.parentData.left + that.position.left;
                that.offset.top = that.parentData.top + that.position.top;
            } else {
                that.offset.left = that.element.offset().left;
                that.offset.top = that.element.offset().top;
            }
    
            woset = Math.abs( that.sizeDiff.width +
                ( that._helper ?
                    that.offset.left - cop.left :
                    ( that.offset.left - co.left ) ) );
    
            hoset = Math.abs( that.sizeDiff.height +
                ( that._helper ?
                    that.offset.top - cop.top :
                    ( that.offset.top - co.top ) ) );
    
            if ( woset + that.size.width >= that.parentData.width ) {
                that.size.width = that.parentData.width - woset;
                if ( pRatio ) {
                    that.size.height = that.size.width / that.aspectRatio;
                    continueResize = false;
                }
            }
    
            if ( hoset + that.size.height >= that.parentData.height ) {
                that.size.height = that.parentData.height - hoset;
                if ( pRatio ) {
                    that.size.width = that.size.height * that.aspectRatio;
                    continueResize = false;
                }
            }
    
            if ( !continueResize ) {
                that.position.left = that.prevPosition.left;
                that.position.top = that.prevPosition.top;
                that.size.width = that.prevSize.width;
                that.size.height = that.prevSize.height;
            }
        },
    
        stop: function() {
            var that = $( this ).resizable( "instance" ),
                o = that.options,
                co = that.containerOffset,
                cop = that.containerPosition,
                ce = that.containerElement,
                helper = $( that.helper ),
                ho = helper.offset(),
                w = helper.outerWidth() - that.sizeDiff.width,
                h = helper.outerHeight() - that.sizeDiff.height;
    
            if ( that._helper && !o.animate && ( /relative/ ).test( ce.css( "position" ) ) ) {
                $( this ).css( {
                    left: ho.left - cop.left - co.left,
                    width: w,
                    height: h
                } );
            }
    
            if ( that._helper && !o.animate && ( /static/ ).test( ce.css( "position" ) ) ) {
                $( this ).css( {
                    left: ho.left - cop.left - co.left,
                    width: w,
                    height: h
                } );
            }
        }
    } );
    
    $.ui.plugin.add( "resizable", "alsoResize", {
    
        start: function() {
            var that = $( this ).resizable( "instance" ),
                o = that.options;
    
            $( o.alsoResize ).each( function() {
                var el = $( this );
                el.data( "ui-resizable-alsoresize", {
                    width: parseFloat( el.width() ), height: parseFloat( el.height() ),
                    left: parseFloat( el.css( "left" ) ), top: parseFloat( el.css( "top" ) )
                } );
            } );
        },
    
        resize: function( event, ui ) {
            var that = $( this ).resizable( "instance" ),
                o = that.options,
                os = that.originalSize,
                op = that.originalPosition,
                delta = {
                    height: ( that.size.height - os.height ) || 0,
                    width: ( that.size.width - os.width ) || 0,
                    top: ( that.position.top - op.top ) || 0,
                    left: ( that.position.left - op.left ) || 0
                };
    
                $( o.alsoResize ).each( function() {
                    var el = $( this ), start = $( this ).data( "ui-resizable-alsoresize" ), style = {},
                        css = el.parents( ui.originalElement[ 0 ] ).length ?
                                [ "width", "height" ] :
                                [ "width", "height", "top", "left" ];
    
                    $.each( css, function( i, prop ) {
                        var sum = ( start[ prop ] || 0 ) + ( delta[ prop ] || 0 );
                        if ( sum && sum >= 0 ) {
                            style[ prop ] = sum || null;
                        }
                    } );
    
                    el.css( style );
                } );
        },
    
        stop: function() {
            $( this ).removeData( "ui-resizable-alsoresize" );
        }
    } );
    
    $.ui.plugin.add( "resizable", "ghost", {
    
        start: function() {
    
            var that = $( this ).resizable( "instance" ), cs = that.size;
    
            that.ghost = that.originalElement.clone();
            that.ghost.css( {
                opacity: 0.25,
                display: "block",
                position: "relative",
                height: cs.height,
                width: cs.width,
                margin: 0,
                left: 0,
                top: 0
            } );
    
            that._addClass( that.ghost, "ui-resizable-ghost" );
    
            // DEPRECATED
            // TODO: remove after 1.12
            if ( $.uiBackCompat !== false && typeof that.options.ghost === "string" ) {
    
                // Ghost option
                that.ghost.addClass( this.options.ghost );
            }
    
            that.ghost.appendTo( that.helper );
    
        },
    
        resize: function() {
            var that = $( this ).resizable( "instance" );
            if ( that.ghost ) {
                that.ghost.css( {
                    position: "relative",
                    height: that.size.height,
                    width: that.size.width
                } );
            }
        },
    
        stop: function() {
            var that = $( this ).resizable( "instance" );
            if ( that.ghost && that.helper ) {
                that.helper.get( 0 ).removeChild( that.ghost.get( 0 ) );
            }
        }
    
    } );
    
    $.ui.plugin.add( "resizable", "grid", {
    
        resize: function() {
            var outerDimensions,
                that = $( this ).resizable( "instance" ),
                o = that.options,
                cs = that.size,
                os = that.originalSize,
                op = that.originalPosition,
                a = that.axis,
                grid = typeof o.grid === "number" ? [ o.grid, o.grid ] : o.grid,
                gridX = ( grid[ 0 ] || 1 ),
                gridY = ( grid[ 1 ] || 1 ),
                ox = Math.round( ( cs.width - os.width ) / gridX ) * gridX,
                oy = Math.round( ( cs.height - os.height ) / gridY ) * gridY,
                newWidth = os.width + ox,
                newHeight = os.height + oy,
                isMaxWidth = o.maxWidth && ( o.maxWidth < newWidth ),
                isMaxHeight = o.maxHeight && ( o.maxHeight < newHeight ),
                isMinWidth = o.minWidth && ( o.minWidth > newWidth ),
                isMinHeight = o.minHeight && ( o.minHeight > newHeight );
    
            o.grid = grid;
    
            if ( isMinWidth ) {
                newWidth += gridX;
            }
            if ( isMinHeight ) {
                newHeight += gridY;
            }
            if ( isMaxWidth ) {
                newWidth -= gridX;
            }
            if ( isMaxHeight ) {
                newHeight -= gridY;
            }
    
            if ( /^(se|s|e)$/.test( a ) ) {
                that.size.width = newWidth;
                that.size.height = newHeight;
            } else if ( /^(ne)$/.test( a ) ) {
                that.size.width = newWidth;
                that.size.height = newHeight;
                that.position.top = op.top - oy;
            } else if ( /^(sw)$/.test( a ) ) {
                that.size.width = newWidth;
                that.size.height = newHeight;
                that.position.left = op.left - ox;
            } else {
                if ( newHeight - gridY <= 0 || newWidth - gridX <= 0 ) {
                    outerDimensions = that._getPaddingPlusBorderDimensions( this );
                }
    
                if ( newHeight - gridY > 0 ) {
                    that.size.height = newHeight;
                    that.position.top = op.top - oy;
                } else {
                    newHeight = gridY - outerDimensions.height;
                    that.size.height = newHeight;
                    that.position.top = op.top + os.height - newHeight;
                }
                if ( newWidth - gridX > 0 ) {
                    that.size.width = newWidth;
                    that.position.left = op.left - ox;
                } else {
                    newWidth = gridX - outerDimensions.width;
                    that.size.width = newWidth;
                    that.position.left = op.left + os.width - newWidth;
                }
            }
        }
    
    } );
    
    var widgetsResizable = $.ui.resizable;
    
    
    /*!
     * jQuery UI Dialog 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Dialog
    //>>group: Widgets
    //>>description: Displays customizable dialog windows.
    //>>docs: http://api.jqueryui.com/dialog/
    //>>demos: http://jqueryui.com/dialog/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/dialog.css
    //>>css.theme: ../../themes/base/theme.css
    
    
    
    $.widget( "ui.dialog", {
        version: "1.12.1",
        options: {
            appendTo: "body",
            autoOpen: true,
            buttons: [],
            classes: {
                "ui-dialog": "ui-corner-all",
                "ui-dialog-titlebar": "ui-corner-all"
            },
            closeOnEscape: true,
            closeText: "Close",
            draggable: true,
            hide: null,
            height: "auto",
            maxHeight: null,
            maxWidth: null,
            minHeight: 150,
            minWidth: 150,
            modal: false,
            position: {
                my: "center",
                at: "center",
                of: window,
                collision: "fit",
    
                // Ensure the titlebar is always visible
                using: function( pos ) {
                    var topOffset = $( this ).css( pos ).offset().top;
                    if ( topOffset < 0 ) {
                        $( this ).css( "top", pos.top - topOffset );
                    }
                }
            },
            resizable: true,
            show: null,
            title: null,
            width: 300,
    
            // Callbacks
            beforeClose: null,
            close: null,
            drag: null,
            dragStart: null,
            dragStop: null,
            focus: null,
            open: null,
            resize: null,
            resizeStart: null,
            resizeStop: null
        },
    
        sizeRelatedOptions: {
            buttons: true,
            height: true,
            maxHeight: true,
            maxWidth: true,
            minHeight: true,
            minWidth: true,
            width: true
        },
    
        resizableRelatedOptions: {
            maxHeight: true,
            maxWidth: true,
            minHeight: true,
            minWidth: true
        },
    
        _create: function() {
            this.originalCss = {
                display: this.element[ 0 ].style.display,
                width: this.element[ 0 ].style.width,
                minHeight: this.element[ 0 ].style.minHeight,
                maxHeight: this.element[ 0 ].style.maxHeight,
                height: this.element[ 0 ].style.height
            };
            this.originalPosition = {
                parent: this.element.parent(),
                index: this.element.parent().children().index( this.element )
            };
            this.originalTitle = this.element.attr( "title" );
            if ( this.options.title == null && this.originalTitle != null ) {
                this.options.title = this.originalTitle;
            }
    
            // Dialogs can't be disabled
            if ( this.options.disabled ) {
                this.options.disabled = false;
            }
    
            this._createWrapper();
    
            this.element
                .show()
                .removeAttr( "title" )
                .appendTo( this.uiDialog );
    
            this._addClass( "ui-dialog-content", "ui-widget-content" );
    
            this._createTitlebar();
            this._createButtonPane();
    
            if ( this.options.draggable && $.fn.draggable ) {
                this._makeDraggable();
            }
            if ( this.options.resizable && $.fn.resizable ) {
                this._makeResizable();
            }
    
            this._isOpen = false;
    
            this._trackFocus();
        },
    
        _init: function() {
            if ( this.options.autoOpen ) {
                this.open();
            }
        },
    
        _appendTo: function() {
            var element = this.options.appendTo;
            if ( element && ( element.jquery || element.nodeType ) ) {
                return $( element );
            }
            return this.document.find( element || "body" ).eq( 0 );
        },
    
        _destroy: function() {
            var next,
                originalPosition = this.originalPosition;
    
            this._untrackInstance();
            this._destroyOverlay();
    
            this.element
                .removeUniqueId()
                .css( this.originalCss )
    
                // Without detaching first, the following becomes really slow
                .detach();
    
            this.uiDialog.remove();
    
            if ( this.originalTitle ) {
                this.element.attr( "title", this.originalTitle );
            }
    
            next = originalPosition.parent.children().eq( originalPosition.index );
    
            // Don't try to place the dialog next to itself (#8613)
            if ( next.length && next[ 0 ] !== this.element[ 0 ] ) {
                next.before( this.element );
            } else {
                originalPosition.parent.append( this.element );
            }
        },
    
        widget: function() {
            return this.uiDialog;
        },
    
        disable: $.noop,
        enable: $.noop,
    
        close: function( event ) {
            var that = this;
    
            if ( !this._isOpen || this._trigger( "beforeClose", event ) === false ) {
                return;
            }
    
            this._isOpen = false;
            this._focusedElement = null;
            this._destroyOverlay();
            this._untrackInstance();
    
            if ( !this.opener.filter( ":focusable" ).trigger( "focus" ).length ) {
    
                // Hiding a focused element doesn't trigger blur in WebKit
                // so in case we have nothing to focus on, explicitly blur the active element
                // https://bugs.webkit.org/show_bug.cgi?id=47182
                $.ui.safeBlur( $.ui.safeActiveElement( this.document[ 0 ] ) );
            }
    
            this._hide( this.uiDialog, this.options.hide, function() {
                that._trigger( "close", event );
            } );
        },
    
        isOpen: function() {
            return this._isOpen;
        },
    
        moveToTop: function() {
            this._moveToTop();
        },
    
        _moveToTop: function( event, silent ) {
            var moved = false,
                zIndices = this.uiDialog.siblings( ".ui-front:visible" ).map( function() {
                    return +$( this ).css( "z-index" );
                } ).get(),
                zIndexMax = Math.max.apply( null, zIndices );
    
            if ( zIndexMax >= +this.uiDialog.css( "z-index" ) ) {
                this.uiDialog.css( "z-index", zIndexMax + 1 );
                moved = true;
            }
    
            if ( moved && !silent ) {
                this._trigger( "focus", event );
            }
            return moved;
        },
    
        open: function() {
            var that = this;
            if ( this._isOpen ) {
                if ( this._moveToTop() ) {
                    this._focusTabbable();
                }
                return;
            }
    
            this._isOpen = true;
            this.opener = $( $.ui.safeActiveElement( this.document[ 0 ] ) );
    
            this._size();
            this._position();
            this._createOverlay();
            this._moveToTop( null, true );
    
            // Ensure the overlay is moved to the top with the dialog, but only when
            // opening. The overlay shouldn't move after the dialog is open so that
            // modeless dialogs opened after the modal dialog stack properly.
            if ( this.overlay ) {
                this.overlay.css( "z-index", this.uiDialog.css( "z-index" ) - 1 );
            }
    
            this._show( this.uiDialog, this.options.show, function() {
                that._focusTabbable();
                that._trigger( "focus" );
            } );
    
            // Track the dialog immediately upon openening in case a focus event
            // somehow occurs outside of the dialog before an element inside the
            // dialog is focused (#10152)
            this._makeFocusTarget();
    
            this._trigger( "open" );
        },
    
        _focusTabbable: function() {
    
            // Set focus to the first match:
            // 1. An element that was focused previously
            // 2. First element inside the dialog matching [autofocus]
            // 3. Tabbable element inside the content element
            // 4. Tabbable element inside the buttonpane
            // 5. The close button
            // 6. The dialog itself
            var hasFocus = this._focusedElement;
            if ( !hasFocus ) {
                hasFocus = this.element.find( "[autofocus]" );
            }
            if ( !hasFocus.length ) {
                hasFocus = this.element.find( ":tabbable" );
            }
            if ( !hasFocus.length ) {
                hasFocus = this.uiDialogButtonPane.find( ":tabbable" );
            }
            if ( !hasFocus.length ) {
                hasFocus = this.uiDialogTitlebarClose.filter( ":tabbable" );
            }
            if ( !hasFocus.length ) {
                hasFocus = this.uiDialog;
            }
            hasFocus.eq( 0 ).trigger( "focus" );
        },
    
        _keepFocus: function( event ) {
            function checkFocus() {
                var activeElement = $.ui.safeActiveElement( this.document[ 0 ] ),
                    isActive = this.uiDialog[ 0 ] === activeElement ||
                        $.contains( this.uiDialog[ 0 ], activeElement );
                if ( !isActive ) {
                    this._focusTabbable();
                }
            }
            event.preventDefault();
            checkFocus.call( this );
    
            // support: IE
            // IE <= 8 doesn't prevent moving focus even with event.preventDefault()
            // so we check again later
            this._delay( checkFocus );
        },
    
        _createWrapper: function() {
            this.uiDialog = $( "<div>" )
                .hide()
                .attr( {
    
                    // Setting tabIndex makes the div focusable
                    tabIndex: -1,
                    role: "dialog"
                } )
                .appendTo( this._appendTo() );
    
            this._addClass( this.uiDialog, "ui-dialog", "ui-widget ui-widget-content ui-front" );
            this._on( this.uiDialog, {
                keydown: function( event ) {
                    if ( this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
                            event.keyCode === $.ui.keyCode.ESCAPE ) {
                        event.preventDefault();
                        this.close( event );
                        return;
                    }
    
                    // Prevent tabbing out of dialogs
                    if ( event.keyCode !== $.ui.keyCode.TAB || event.isDefaultPrevented() ) {
                        return;
                    }
                    var tabbables = this.uiDialog.find( ":tabbable" ),
                        first = tabbables.filter( ":first" ),
                        last = tabbables.filter( ":last" );
    
                    if ( ( event.target === last[ 0 ] || event.target === this.uiDialog[ 0 ] ) &&
                            !event.shiftKey ) {
                        this._delay( function() {
                            first.trigger( "focus" );
                        } );
                        event.preventDefault();
                    } else if ( ( event.target === first[ 0 ] ||
                            event.target === this.uiDialog[ 0 ] ) && event.shiftKey ) {
                        this._delay( function() {
                            last.trigger( "focus" );
                        } );
                        event.preventDefault();
                    }
                },
                mousedown: function( event ) {
                    if ( this._moveToTop( event ) ) {
                        this._focusTabbable();
                    }
                }
            } );
    
            // We assume that any existing aria-describedby attribute means
            // that the dialog content is marked up properly
            // otherwise we brute force the content as the description
            if ( !this.element.find( "[aria-describedby]" ).length ) {
                this.uiDialog.attr( {
                    "aria-describedby": this.element.uniqueId().attr( "id" )
                } );
            }
        },
    
        _createTitlebar: function() {
            var uiDialogTitle;
    
            this.uiDialogTitlebar = $( "<div>" );
            this._addClass( this.uiDialogTitlebar,
                "ui-dialog-titlebar", "ui-widget-header ui-helper-clearfix" );
            this._on( this.uiDialogTitlebar, {
                mousedown: function( event ) {
    
                    // Don't prevent click on close button (#8838)
                    // Focusing a dialog that is partially scrolled out of view
                    // causes the browser to scroll it into view, preventing the click event
                    if ( !$( event.target ).closest( ".ui-dialog-titlebar-close" ) ) {
    
                        // Dialog isn't getting focus when dragging (#8063)
                        this.uiDialog.trigger( "focus" );
                    }
                }
            } );
    
            // Support: IE
            // Use type="button" to prevent enter keypresses in textboxes from closing the
            // dialog in IE (#9312)
            this.uiDialogTitlebarClose = $( "<button type='button'></button>" )
                .button( {
                    label: $( "<a>" ).text( this.options.closeText ).html(),
                    icon: "ui-icon-closethick",
                    showLabel: false
                } )
                .appendTo( this.uiDialogTitlebar );
    
            this._addClass( this.uiDialogTitlebarClose, "ui-dialog-titlebar-close" );
            this._on( this.uiDialogTitlebarClose, {
                click: function( event ) {
                    event.preventDefault();
                    this.close( event );
                }
            } );
    
            uiDialogTitle = $( "<span>" ).uniqueId().prependTo( this.uiDialogTitlebar );
            this._addClass( uiDialogTitle, "ui-dialog-title" );
            this._title( uiDialogTitle );
    
            this.uiDialogTitlebar.prependTo( this.uiDialog );
    
            this.uiDialog.attr( {
                "aria-labelledby": uiDialogTitle.attr( "id" )
            } );
        },
    
        _title: function( title ) {
            if ( this.options.title ) {
                title.text( this.options.title );
            } else {
                title.html( "&#160;" );
            }
        },
    
        _createButtonPane: function() {
            this.uiDialogButtonPane = $( "<div>" );
            this._addClass( this.uiDialogButtonPane, "ui-dialog-buttonpane",
                "ui-widget-content ui-helper-clearfix" );
    
            this.uiButtonSet = $( "<div>" )
                .appendTo( this.uiDialogButtonPane );
            this._addClass( this.uiButtonSet, "ui-dialog-buttonset" );
    
            this._createButtons();
        },
    
        _createButtons: function() {
            var that = this,
                buttons = this.options.buttons;
    
            // If we already have a button pane, remove it
            this.uiDialogButtonPane.remove();
            this.uiButtonSet.empty();
    
            if ( $.isEmptyObject( buttons ) || ( $.isArray( buttons ) && !buttons.length ) ) {
                this._removeClass( this.uiDialog, "ui-dialog-buttons" );
                return;
            }
    
            $.each( buttons, function( name, props ) {
                var click, buttonOptions;
                props = $.isFunction( props ) ?
                    { click: props, text: name } :
                    props;
    
                // Default to a non-submitting button
                props = $.extend( { type: "button" }, props );
    
                // Change the context for the click callback to be the main element
                click = props.click;
                buttonOptions = {
                    icon: props.icon,
                    iconPosition: props.iconPosition,
                    showLabel: props.showLabel,
    
                    // Deprecated options
                    icons: props.icons,
                    text: props.text
                };
    
                delete props.click;
                delete props.icon;
                delete props.iconPosition;
                delete props.showLabel;
    
                // Deprecated options
                delete props.icons;
                if ( typeof props.text === "boolean" ) {
                    delete props.text;
                }
    
                $( "<button></button>", props )
                    .button( buttonOptions )
                    .appendTo( that.uiButtonSet )
                    .on( "click", function() {
                        click.apply( that.element[ 0 ], arguments );
                    } );
            } );
            this._addClass( this.uiDialog, "ui-dialog-buttons" );
            this.uiDialogButtonPane.appendTo( this.uiDialog );
        },
    
        _makeDraggable: function() {
            var that = this,
                options = this.options;
    
            function filteredUi( ui ) {
                return {
                    position: ui.position,
                    offset: ui.offset
                };
            }
    
            this.uiDialog.draggable( {
                cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
                handle: ".ui-dialog-titlebar",
                containment: "document",
                start: function( event, ui ) {
                    that._addClass( $( this ), "ui-dialog-dragging" );
                    that._blockFrames();
                    that._trigger( "dragStart", event, filteredUi( ui ) );
                },
                drag: function( event, ui ) {
                    that._trigger( "drag", event, filteredUi( ui ) );
                },
                stop: function( event, ui ) {
                    var left = ui.offset.left - that.document.scrollLeft(),
                        top = ui.offset.top - that.document.scrollTop();
    
                    options.position = {
                        my: "left top",
                        at: "left" + ( left >= 0 ? "+" : "" ) + left + " " +
                            "top" + ( top >= 0 ? "+" : "" ) + top,
                        of: that.window
                    };
                    that._removeClass( $( this ), "ui-dialog-dragging" );
                    that._unblockFrames();
                    that._trigger( "dragStop", event, filteredUi( ui ) );
                }
            } );
        },
    
        _makeResizable: function() {
            var that = this,
                options = this.options,
                handles = options.resizable,
    
                // .ui-resizable has position: relative defined in the stylesheet
                // but dialogs have to use absolute or fixed positioning
                position = this.uiDialog.css( "position" ),
                resizeHandles = typeof handles === "string" ?
                    handles :
                    "n,e,s,w,se,sw,ne,nw";
    
            function filteredUi( ui ) {
                return {
                    originalPosition: ui.originalPosition,
                    originalSize: ui.originalSize,
                    position: ui.position,
                    size: ui.size
                };
            }
    
            this.uiDialog.resizable( {
                cancel: ".ui-dialog-content",
                containment: "document",
                alsoResize: this.element,
                maxWidth: options.maxWidth,
                maxHeight: options.maxHeight,
                minWidth: options.minWidth,
                minHeight: this._minHeight(),
                handles: resizeHandles,
                start: function( event, ui ) {
                    that._addClass( $( this ), "ui-dialog-resizing" );
                    that._blockFrames();
                    that._trigger( "resizeStart", event, filteredUi( ui ) );
                },
                resize: function( event, ui ) {
                    that._trigger( "resize", event, filteredUi( ui ) );
                },
                stop: function( event, ui ) {
                    var offset = that.uiDialog.offset(),
                        left = offset.left - that.document.scrollLeft(),
                        top = offset.top - that.document.scrollTop();
    
                    options.height = that.uiDialog.height();
                    options.width = that.uiDialog.width();
                    options.position = {
                        my: "left top",
                        at: "left" + ( left >= 0 ? "+" : "" ) + left + " " +
                            "top" + ( top >= 0 ? "+" : "" ) + top,
                        of: that.window
                    };
                    that._removeClass( $( this ), "ui-dialog-resizing" );
                    that._unblockFrames();
                    that._trigger( "resizeStop", event, filteredUi( ui ) );
                }
            } )
                .css( "position", position );
        },
    
        _trackFocus: function() {
            this._on( this.widget(), {
                focusin: function( event ) {
                    this._makeFocusTarget();
                    this._focusedElement = $( event.target );
                }
            } );
        },
    
        _makeFocusTarget: function() {
            this._untrackInstance();
            this._trackingInstances().unshift( this );
        },
    
        _untrackInstance: function() {
            var instances = this._trackingInstances(),
                exists = $.inArray( this, instances );
            if ( exists !== -1 ) {
                instances.splice( exists, 1 );
            }
        },
    
        _trackingInstances: function() {
            var instances = this.document.data( "ui-dialog-instances" );
            if ( !instances ) {
                instances = [];
                this.document.data( "ui-dialog-instances", instances );
            }
            return instances;
        },
    
        _minHeight: function() {
            var options = this.options;
    
            return options.height === "auto" ?
                options.minHeight :
                Math.min( options.minHeight, options.height );
        },
    
        _position: function() {
    
            // Need to show the dialog to get the actual offset in the position plugin
            var isVisible = this.uiDialog.is( ":visible" );
            if ( !isVisible ) {
                this.uiDialog.show();
            }
            this.uiDialog.position( this.options.position );
            if ( !isVisible ) {
                this.uiDialog.hide();
            }
        },
    
        _setOptions: function( options ) {
            var that = this,
                resize = false,
                resizableOptions = {};
    
            $.each( options, function( key, value ) {
                that._setOption( key, value );
    
                if ( key in that.sizeRelatedOptions ) {
                    resize = true;
                }
                if ( key in that.resizableRelatedOptions ) {
                    resizableOptions[ key ] = value;
                }
            } );
    
            if ( resize ) {
                this._size();
                this._position();
            }
            if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {
                this.uiDialog.resizable( "option", resizableOptions );
            }
        },
    
        _setOption: function( key, value ) {
            var isDraggable, isResizable,
                uiDialog = this.uiDialog;
    
            if ( key === "disabled" ) {
                return;
            }
    
            this._super( key, value );
    
            if ( key === "appendTo" ) {
                this.uiDialog.appendTo( this._appendTo() );
            }
    
            if ( key === "buttons" ) {
                this._createButtons();
            }
    
            if ( key === "closeText" ) {
                this.uiDialogTitlebarClose.button( {
    
                    // Ensure that we always pass a string
                    label: $( "<a>" ).text( "" + this.options.closeText ).html()
                } );
            }
    
            if ( key === "draggable" ) {
                isDraggable = uiDialog.is( ":data(ui-draggable)" );
                if ( isDraggable && !value ) {
                    uiDialog.draggable( "destroy" );
                }
    
                if ( !isDraggable && value ) {
                    this._makeDraggable();
                }
            }
    
            if ( key === "position" ) {
                this._position();
            }
    
            if ( key === "resizable" ) {
    
                // currently resizable, becoming non-resizable
                isResizable = uiDialog.is( ":data(ui-resizable)" );
                if ( isResizable && !value ) {
                    uiDialog.resizable( "destroy" );
                }
    
                // Currently resizable, changing handles
                if ( isResizable && typeof value === "string" ) {
                    uiDialog.resizable( "option", "handles", value );
                }
    
                // Currently non-resizable, becoming resizable
                if ( !isResizable && value !== false ) {
                    this._makeResizable();
                }
            }
    
            if ( key === "title" ) {
                this._title( this.uiDialogTitlebar.find( ".ui-dialog-title" ) );
            }
        },
    
        _size: function() {
    
            // If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
            // divs will both have width and height set, so we need to reset them
            var nonContentHeight, minContentHeight, maxContentHeight,
                options = this.options;
    
            // Reset content sizing
            this.element.show().css( {
                width: "auto",
                minHeight: 0,
                maxHeight: "none",
                height: 0
            } );
    
            if ( options.minWidth > options.width ) {
                options.width = options.minWidth;
            }
    
            // Reset wrapper sizing
            // determine the height of all the non-content elements
            nonContentHeight = this.uiDialog.css( {
                height: "auto",
                width: options.width
            } )
                .outerHeight();
            minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );
            maxContentHeight = typeof options.maxHeight === "number" ?
                Math.max( 0, options.maxHeight - nonContentHeight ) :
                "none";
    
            if ( options.height === "auto" ) {
                this.element.css( {
                    minHeight: minContentHeight,
                    maxHeight: maxContentHeight,
                    height: "auto"
                } );
            } else {
                this.element.height( Math.max( 0, options.height - nonContentHeight ) );
            }
    
            if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {
                this.uiDialog.resizable( "option", "minHeight", this._minHeight() );
            }
        },
    
        _blockFrames: function() {
            this.iframeBlocks = this.document.find( "iframe" ).map( function() {
                var iframe = $( this );
    
                return $( "<div>" )
                    .css( {
                        position: "absolute",
                        width: iframe.outerWidth(),
                        height: iframe.outerHeight()
                    } )
                    .appendTo( iframe.parent() )
                    .offset( iframe.offset() )[ 0 ];
            } );
        },
    
        _unblockFrames: function() {
            if ( this.iframeBlocks ) {
                this.iframeBlocks.remove();
                delete this.iframeBlocks;
            }
        },
    
        _allowInteraction: function( event ) {
            if ( $( event.target ).closest( ".ui-dialog" ).length ) {
                return true;
            }
    
            // TODO: Remove hack when datepicker implements
            // the .ui-front logic (#8989)
            return !!$( event.target ).closest( ".ui-datepicker" ).length;
        },
    
        _createOverlay: function() {
            if ( !this.options.modal ) {
                return;
            }
    
            // We use a delay in case the overlay is created from an
            // event that we're going to be cancelling (#2804)
            var isOpening = true;
            this._delay( function() {
                isOpening = false;
            } );
    
            if ( !this.document.data( "ui-dialog-overlays" ) ) {
    
                // Prevent use of anchors and inputs
                // Using _on() for an event handler shared across many instances is
                // safe because the dialogs stack and must be closed in reverse order
                this._on( this.document, {
                    focusin: function( event ) {
                        if ( isOpening ) {
                            return;
                        }
    
                        if ( !this._allowInteraction( event ) ) {
                            event.preventDefault();
                            this._trackingInstances()[ 0 ]._focusTabbable();
                        }
                    }
                } );
            }
    
            this.overlay = $( "<div>" )
                .appendTo( this._appendTo() );
    
            this._addClass( this.overlay, null, "ui-widget-overlay ui-front" );
            this._on( this.overlay, {
                mousedown: "_keepFocus"
            } );
            this.document.data( "ui-dialog-overlays",
                ( this.document.data( "ui-dialog-overlays" ) || 0 ) + 1 );
        },
    
        _destroyOverlay: function() {
            if ( !this.options.modal ) {
                return;
            }
    
            if ( this.overlay ) {
                var overlays = this.document.data( "ui-dialog-overlays" ) - 1;
    
                if ( !overlays ) {
                    this._off( this.document, "focusin" );
                    this.document.removeData( "ui-dialog-overlays" );
                } else {
                    this.document.data( "ui-dialog-overlays", overlays );
                }
    
                this.overlay.remove();
                this.overlay = null;
            }
        }
    } );
    
    // DEPRECATED
    // TODO: switch return back to widget declaration at top of file when this is removed
    if ( $.uiBackCompat !== false ) {
    
        // Backcompat for dialogClass option
        $.widget( "ui.dialog", $.ui.dialog, {
            options: {
                dialogClass: ""
            },
            _createWrapper: function() {
                this._super();
                this.uiDialog.addClass( this.options.dialogClass );
            },
            _setOption: function( key, value ) {
                if ( key === "dialogClass" ) {
                    this.uiDialog
                        .removeClass( this.options.dialogClass )
                        .addClass( value );
                }
                this._superApply( arguments );
            }
        } );
    }
    
    var widgetsDialog = $.ui.dialog;
    
    
    /*!
     * jQuery UI Droppable 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Droppable
    //>>group: Interactions
    //>>description: Enables drop targets for draggable elements.
    //>>docs: http://api.jqueryui.com/droppable/
    //>>demos: http://jqueryui.com/droppable/
    
    
    
    $.widget( "ui.droppable", {
        version: "1.12.1",
        widgetEventPrefix: "drop",
        options: {
            accept: "*",
            addClasses: true,
            greedy: false,
            scope: "default",
            tolerance: "intersect",
    
            // Callbacks
            activate: null,
            deactivate: null,
            drop: null,
            out: null,
            over: null
        },
        _create: function() {
    
            var proportions,
                o = this.options,
                accept = o.accept;
    
            this.isover = false;
            this.isout = true;
    
            this.accept = $.isFunction( accept ) ? accept : function( d ) {
                return d.is( accept );
            };
    
            this.proportions = function( /* valueToWrite */ ) {
                if ( arguments.length ) {
    
                    // Store the droppable's proportions
                    proportions = arguments[ 0 ];
                } else {
    
                    // Retrieve or derive the droppable's proportions
                    return proportions ?
                        proportions :
                        proportions = {
                            width: this.element[ 0 ].offsetWidth,
                            height: this.element[ 0 ].offsetHeight
                        };
                }
            };
    
            this._addToManager( o.scope );
    
            o.addClasses && this._addClass( "ui-droppable" );
    
        },
    
        _addToManager: function( scope ) {
    
            // Add the reference and positions to the manager
            $.ui.ddmanager.droppables[ scope ] = $.ui.ddmanager.droppables[ scope ] || [];
            $.ui.ddmanager.droppables[ scope ].push( this );
        },
    
        _splice: function( drop ) {
            var i = 0;
            for ( ; i < drop.length; i++ ) {
                if ( drop[ i ] === this ) {
                    drop.splice( i, 1 );
                }
            }
        },
    
        _destroy: function() {
            var drop = $.ui.ddmanager.droppables[ this.options.scope ];
    
            this._splice( drop );
        },
    
        _setOption: function( key, value ) {
    
            if ( key === "accept" ) {
                this.accept = $.isFunction( value ) ? value : function( d ) {
                    return d.is( value );
                };
            } else if ( key === "scope" ) {
                var drop = $.ui.ddmanager.droppables[ this.options.scope ];
    
                this._splice( drop );
                this._addToManager( value );
            }
    
            this._super( key, value );
        },
    
        _activate: function( event ) {
            var draggable = $.ui.ddmanager.current;
    
            this._addActiveClass();
            if ( draggable ) {
                this._trigger( "activate", event, this.ui( draggable ) );
            }
        },
    
        _deactivate: function( event ) {
            var draggable = $.ui.ddmanager.current;
    
            this._removeActiveClass();
            if ( draggable ) {
                this._trigger( "deactivate", event, this.ui( draggable ) );
            }
        },
    
        _over: function( event ) {
    
            var draggable = $.ui.ddmanager.current;
    
            // Bail if draggable and droppable are same element
            if ( !draggable || ( draggable.currentItem ||
                    draggable.element )[ 0 ] === this.element[ 0 ] ) {
                return;
            }
    
            if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem ||
                    draggable.element ) ) ) {
                this._addHoverClass();
                this._trigger( "over", event, this.ui( draggable ) );
            }
    
        },
    
        _out: function( event ) {
    
            var draggable = $.ui.ddmanager.current;
    
            // Bail if draggable and droppable are same element
            if ( !draggable || ( draggable.currentItem ||
                    draggable.element )[ 0 ] === this.element[ 0 ] ) {
                return;
            }
    
            if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem ||
                    draggable.element ) ) ) {
                this._removeHoverClass();
                this._trigger( "out", event, this.ui( draggable ) );
            }
    
        },
    
        _drop: function( event, custom ) {
    
            var draggable = custom || $.ui.ddmanager.current,
                childrenIntersection = false;
    
            // Bail if draggable and droppable are same element
            if ( !draggable || ( draggable.currentItem ||
                    draggable.element )[ 0 ] === this.element[ 0 ] ) {
                return false;
            }
    
            this.element
                .find( ":data(ui-droppable)" )
                .not( ".ui-draggable-dragging" )
                .each( function() {
                    var inst = $( this ).droppable( "instance" );
                    if (
                        inst.options.greedy &&
                        !inst.options.disabled &&
                        inst.options.scope === draggable.options.scope &&
                        inst.accept.call(
                            inst.element[ 0 ], ( draggable.currentItem || draggable.element )
                        ) &&
                        intersect(
                            draggable,
                            $.extend( inst, { offset: inst.element.offset() } ),
                            inst.options.tolerance, event
                        )
                    ) {
                        childrenIntersection = true;
                        return false; }
                } );
            if ( childrenIntersection ) {
                return false;
            }
    
            if ( this.accept.call( this.element[ 0 ],
                    ( draggable.currentItem || draggable.element ) ) ) {
                this._removeActiveClass();
                this._removeHoverClass();
    
                this._trigger( "drop", event, this.ui( draggable ) );
                return this.element;
            }
    
            return false;
    
        },
    
        ui: function( c ) {
            return {
                draggable: ( c.currentItem || c.element ),
                helper: c.helper,
                position: c.position,
                offset: c.positionAbs
            };
        },
    
        // Extension points just to make backcompat sane and avoid duplicating logic
        // TODO: Remove in 1.13 along with call to it below
        _addHoverClass: function() {
            this._addClass( "ui-droppable-hover" );
        },
    
        _removeHoverClass: function() {
            this._removeClass( "ui-droppable-hover" );
        },
    
        _addActiveClass: function() {
            this._addClass( "ui-droppable-active" );
        },
    
        _removeActiveClass: function() {
            this._removeClass( "ui-droppable-active" );
        }
    } );
    
    var intersect = $.ui.intersect = ( function() {
        function isOverAxis( x, reference, size ) {
            return ( x >= reference ) && ( x < ( reference + size ) );
        }
    
        return function( draggable, droppable, toleranceMode, event ) {
    
            if ( !droppable.offset ) {
                return false;
            }
    
            var x1 = ( draggable.positionAbs ||
                    draggable.position.absolute ).left + draggable.margins.left,
                y1 = ( draggable.positionAbs ||
                    draggable.position.absolute ).top + draggable.margins.top,
                x2 = x1 + draggable.helperProportions.width,
                y2 = y1 + draggable.helperProportions.height,
                l = droppable.offset.left,
                t = droppable.offset.top,
                r = l + droppable.proportions().width,
                b = t + droppable.proportions().height;
    
            switch ( toleranceMode ) {
            case "fit":
                return ( l <= x1 && x2 <= r && t <= y1 && y2 <= b );
            case "intersect":
                return ( l < x1 + ( draggable.helperProportions.width / 2 ) && // Right Half
                    x2 - ( draggable.helperProportions.width / 2 ) < r && // Left Half
                    t < y1 + ( draggable.helperProportions.height / 2 ) && // Bottom Half
                    y2 - ( draggable.helperProportions.height / 2 ) < b ); // Top Half
            case "pointer":
                return isOverAxis( event.pageY, t, droppable.proportions().height ) &&
                    isOverAxis( event.pageX, l, droppable.proportions().width );
            case "touch":
                return (
                    ( y1 >= t && y1 <= b ) || // Top edge touching
                    ( y2 >= t && y2 <= b ) || // Bottom edge touching
                    ( y1 < t && y2 > b ) // Surrounded vertically
                ) && (
                    ( x1 >= l && x1 <= r ) || // Left edge touching
                    ( x2 >= l && x2 <= r ) || // Right edge touching
                    ( x1 < l && x2 > r ) // Surrounded horizontally
                );
            default:
                return false;
            }
        };
    } )();
    
    /*
        This manager tracks offsets of draggables and droppables
    */
    $.ui.ddmanager = {
        current: null,
        droppables: { "default": [] },
        prepareOffsets: function( t, event ) {
    
            var i, j,
                m = $.ui.ddmanager.droppables[ t.options.scope ] || [],
                type = event ? event.type : null, // workaround for #2317
                list = ( t.currentItem || t.element ).find( ":data(ui-droppable)" ).addBack();
    
            droppablesLoop: for ( i = 0; i < m.length; i++ ) {
    
                // No disabled and non-accepted
                if ( m[ i ].options.disabled || ( t && !m[ i ].accept.call( m[ i ].element[ 0 ],
                        ( t.currentItem || t.element ) ) ) ) {
                    continue;
                }
    
                // Filter out elements in the current dragged item
                for ( j = 0; j < list.length; j++ ) {
                    if ( list[ j ] === m[ i ].element[ 0 ] ) {
                        m[ i ].proportions().height = 0;
                        continue droppablesLoop;
                    }
                }
    
                m[ i ].visible = m[ i ].element.css( "display" ) !== "none";
                if ( !m[ i ].visible ) {
                    continue;
                }
    
                // Activate the droppable if used directly from draggables
                if ( type === "mousedown" ) {
                    m[ i ]._activate.call( m[ i ], event );
                }
    
                m[ i ].offset = m[ i ].element.offset();
                m[ i ].proportions( {
                    width: m[ i ].element[ 0 ].offsetWidth,
                    height: m[ i ].element[ 0 ].offsetHeight
                } );
    
            }
    
        },
        drop: function( draggable, event ) {
    
            var dropped = false;
    
            // Create a copy of the droppables in case the list changes during the drop (#9116)
            $.each( ( $.ui.ddmanager.droppables[ draggable.options.scope ] || [] ).slice(), function() {
    
                if ( !this.options ) {
                    return;
                }
                if ( !this.options.disabled && this.visible &&
                        intersect( draggable, this, this.options.tolerance, event ) ) {
                    dropped = this._drop.call( this, event ) || dropped;
                }
    
                if ( !this.options.disabled && this.visible && this.accept.call( this.element[ 0 ],
                        ( draggable.currentItem || draggable.element ) ) ) {
                    this.isout = true;
                    this.isover = false;
                    this._deactivate.call( this, event );
                }
    
            } );
            return dropped;
    
        },
        dragStart: function( draggable, event ) {
    
            // Listen for scrolling so that if the dragging causes scrolling the position of the
            // droppables can be recalculated (see #5003)
            draggable.element.parentsUntil( "body" ).on( "scroll.droppable", function() {
                if ( !draggable.options.refreshPositions ) {
                    $.ui.ddmanager.prepareOffsets( draggable, event );
                }
            } );
        },
        drag: function( draggable, event ) {
    
            // If you have a highly dynamic page, you might try this option. It renders positions
            // every time you move the mouse.
            if ( draggable.options.refreshPositions ) {
                $.ui.ddmanager.prepareOffsets( draggable, event );
            }
    
            // Run through all droppables and check their positions based on specific tolerance options
            $.each( $.ui.ddmanager.droppables[ draggable.options.scope ] || [], function() {
    
                if ( this.options.disabled || this.greedyChild || !this.visible ) {
                    return;
                }
    
                var parentInstance, scope, parent,
                    intersects = intersect( draggable, this, this.options.tolerance, event ),
                    c = !intersects && this.isover ?
                        "isout" :
                        ( intersects && !this.isover ? "isover" : null );
                if ( !c ) {
                    return;
                }
    
                if ( this.options.greedy ) {
    
                    // find droppable parents with same scope
                    scope = this.options.scope;
                    parent = this.element.parents( ":data(ui-droppable)" ).filter( function() {
                        return $( this ).droppable( "instance" ).options.scope === scope;
                    } );
    
                    if ( parent.length ) {
                        parentInstance = $( parent[ 0 ] ).droppable( "instance" );
                        parentInstance.greedyChild = ( c === "isover" );
                    }
                }
    
                // We just moved into a greedy child
                if ( parentInstance && c === "isover" ) {
                    parentInstance.isover = false;
                    parentInstance.isout = true;
                    parentInstance._out.call( parentInstance, event );
                }
    
                this[ c ] = true;
                this[ c === "isout" ? "isover" : "isout" ] = false;
                this[ c === "isover" ? "_over" : "_out" ].call( this, event );
    
                // We just moved out of a greedy child
                if ( parentInstance && c === "isout" ) {
                    parentInstance.isout = false;
                    parentInstance.isover = true;
                    parentInstance._over.call( parentInstance, event );
                }
            } );
    
        },
        dragStop: function( draggable, event ) {
            draggable.element.parentsUntil( "body" ).off( "scroll.droppable" );
    
            // Call prepareOffsets one final time since IE does not fire return scroll events when
            // overflow was caused by drag (see #5003)
            if ( !draggable.options.refreshPositions ) {
                $.ui.ddmanager.prepareOffsets( draggable, event );
            }
        }
    };
    
    // DEPRECATED
    // TODO: switch return back to widget declaration at top of file when this is removed
    if ( $.uiBackCompat !== false ) {
    
        // Backcompat for activeClass and hoverClass options
        $.widget( "ui.droppable", $.ui.droppable, {
            options: {
                hoverClass: false,
                activeClass: false
            },
            _addActiveClass: function() {
                this._super();
                if ( this.options.activeClass ) {
                    this.element.addClass( this.options.activeClass );
                }
            },
            _removeActiveClass: function() {
                this._super();
                if ( this.options.activeClass ) {
                    this.element.removeClass( this.options.activeClass );
                }
            },
            _addHoverClass: function() {
                this._super();
                if ( this.options.hoverClass ) {
                    this.element.addClass( this.options.hoverClass );
                }
            },
            _removeHoverClass: function() {
                this._super();
                if ( this.options.hoverClass ) {
                    this.element.removeClass( this.options.hoverClass );
                }
            }
        } );
    }
    
    var widgetsDroppable = $.ui.droppable;
    
    
    /*!
     * jQuery UI Progressbar 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Progressbar
    //>>group: Widgets
    // jscs:disable maximumLineLength
    //>>description: Displays a status indicator for loading state, standard percentage, and other progress indicators.
    // jscs:enable maximumLineLength
    //>>docs: http://api.jqueryui.com/progressbar/
    //>>demos: http://jqueryui.com/progressbar/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/progressbar.css
    //>>css.theme: ../../themes/base/theme.css
    
    
    
    var widgetsProgressbar = $.widget( "ui.progressbar", {
        version: "1.12.1",
        options: {
            classes: {
                "ui-progressbar": "ui-corner-all",
                "ui-progressbar-value": "ui-corner-left",
                "ui-progressbar-complete": "ui-corner-right"
            },
            max: 100,
            value: 0,
    
            change: null,
            complete: null
        },
    
        min: 0,
    
        _create: function() {
    
            // Constrain initial value
            this.oldValue = this.options.value = this._constrainedValue();
    
            this.element.attr( {
    
                // Only set static values; aria-valuenow and aria-valuemax are
                // set inside _refreshValue()
                role: "progressbar",
                "aria-valuemin": this.min
            } );
            this._addClass( "ui-progressbar", "ui-widget ui-widget-content" );
    
            this.valueDiv = $( "<div>" ).appendTo( this.element );
            this._addClass( this.valueDiv, "ui-progressbar-value", "ui-widget-header" );
            this._refreshValue();
        },
    
        _destroy: function() {
            this.element.removeAttr( "role aria-valuemin aria-valuemax aria-valuenow" );
    
            this.valueDiv.remove();
        },
    
        value: function( newValue ) {
            if ( newValue === undefined ) {
                return this.options.value;
            }
    
            this.options.value = this._constrainedValue( newValue );
            this._refreshValue();
        },
    
        _constrainedValue: function( newValue ) {
            if ( newValue === undefined ) {
                newValue = this.options.value;
            }
    
            this.indeterminate = newValue === false;
    
            // Sanitize value
            if ( typeof newValue !== "number" ) {
                newValue = 0;
            }
    
            return this.indeterminate ? false :
                Math.min( this.options.max, Math.max( this.min, newValue ) );
        },
    
        _setOptions: function( options ) {
    
            // Ensure "value" option is set after other values (like max)
            var value = options.value;
            delete options.value;
    
            this._super( options );
    
            this.options.value = this._constrainedValue( value );
            this._refreshValue();
        },
    
        _setOption: function( key, value ) {
            if ( key === "max" ) {
    
                // Don't allow a max less than min
                value = Math.max( this.min, value );
            }
            this._super( key, value );
        },
    
        _setOptionDisabled: function( value ) {
            this._super( value );
    
            this.element.attr( "aria-disabled", value );
            this._toggleClass( null, "ui-state-disabled", !!value );
        },
    
        _percentage: function() {
            return this.indeterminate ?
                100 :
                100 * ( this.options.value - this.min ) / ( this.options.max - this.min );
        },
    
        _refreshValue: function() {
            var value = this.options.value,
                percentage = this._percentage();
    
            this.valueDiv
                .toggle( this.indeterminate || value > this.min )
                .width( percentage.toFixed( 0 ) + "%" );
    
            this
                ._toggleClass( this.valueDiv, "ui-progressbar-complete", null,
                    value === this.options.max )
                ._toggleClass( "ui-progressbar-indeterminate", null, this.indeterminate );
    
            if ( this.indeterminate ) {
                this.element.removeAttr( "aria-valuenow" );
                if ( !this.overlayDiv ) {
                    this.overlayDiv = $( "<div>" ).appendTo( this.valueDiv );
                    this._addClass( this.overlayDiv, "ui-progressbar-overlay" );
                }
            } else {
                this.element.attr( {
                    "aria-valuemax": this.options.max,
                    "aria-valuenow": value
                } );
                if ( this.overlayDiv ) {
                    this.overlayDiv.remove();
                    this.overlayDiv = null;
                }
            }
    
            if ( this.oldValue !== value ) {
                this.oldValue = value;
                this._trigger( "change" );
            }
            if ( value === this.options.max ) {
                this._trigger( "complete" );
            }
        }
    } );
    
    
    /*!
     * jQuery UI Selectable 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Selectable
    //>>group: Interactions
    //>>description: Allows groups of elements to be selected with the mouse.
    //>>docs: http://api.jqueryui.com/selectable/
    //>>demos: http://jqueryui.com/selectable/
    //>>css.structure: ../../themes/base/selectable.css
    
    
    
    var widgetsSelectable = $.widget( "ui.selectable", $.ui.mouse, {
        version: "1.12.1",
        options: {
            appendTo: "body",
            autoRefresh: true,
            distance: 0,
            filter: "*",
            tolerance: "touch",
    
            // Callbacks
            selected: null,
            selecting: null,
            start: null,
            stop: null,
            unselected: null,
            unselecting: null
        },
        _create: function() {
            var that = this;
    
            this._addClass( "ui-selectable" );
    
            this.dragged = false;
    
            // Cache selectee children based on filter
            this.refresh = function() {
                that.elementPos = $( that.element[ 0 ] ).offset();
                that.selectees = $( that.options.filter, that.element[ 0 ] );
                that._addClass( that.selectees, "ui-selectee" );
                that.selectees.each( function() {
                    var $this = $( this ),
                        selecteeOffset = $this.offset(),
                        pos = {
                            left: selecteeOffset.left - that.elementPos.left,
                            top: selecteeOffset.top - that.elementPos.top
                        };
                    $.data( this, "selectable-item", {
                        element: this,
                        $element: $this,
                        left: pos.left,
                        top: pos.top,
                        right: pos.left + $this.outerWidth(),
                        bottom: pos.top + $this.outerHeight(),
                        startselected: false,
                        selected: $this.hasClass( "ui-selected" ),
                        selecting: $this.hasClass( "ui-selecting" ),
                        unselecting: $this.hasClass( "ui-unselecting" )
                    } );
                } );
            };
            this.refresh();
    
            this._mouseInit();
    
            this.helper = $( "<div>" );
            this._addClass( this.helper, "ui-selectable-helper" );
        },
    
        _destroy: function() {
            this.selectees.removeData( "selectable-item" );
            this._mouseDestroy();
        },
    
        _mouseStart: function( event ) {
            var that = this,
                options = this.options;
    
            this.opos = [ event.pageX, event.pageY ];
            this.elementPos = $( this.element[ 0 ] ).offset();
    
            if ( this.options.disabled ) {
                return;
            }
    
            this.selectees = $( options.filter, this.element[ 0 ] );
    
            this._trigger( "start", event );
    
            $( options.appendTo ).append( this.helper );
    
            // position helper (lasso)
            this.helper.css( {
                "left": event.pageX,
                "top": event.pageY,
                "width": 0,
                "height": 0
            } );
    
            if ( options.autoRefresh ) {
                this.refresh();
            }
    
            this.selectees.filter( ".ui-selected" ).each( function() {
                var selectee = $.data( this, "selectable-item" );
                selectee.startselected = true;
                if ( !event.metaKey && !event.ctrlKey ) {
                    that._removeClass( selectee.$element, "ui-selected" );
                    selectee.selected = false;
                    that._addClass( selectee.$element, "ui-unselecting" );
                    selectee.unselecting = true;
    
                    // selectable UNSELECTING callback
                    that._trigger( "unselecting", event, {
                        unselecting: selectee.element
                    } );
                }
            } );
    
            $( event.target ).parents().addBack().each( function() {
                var doSelect,
                    selectee = $.data( this, "selectable-item" );
                if ( selectee ) {
                    doSelect = ( !event.metaKey && !event.ctrlKey ) ||
                        !selectee.$element.hasClass( "ui-selected" );
                    that._removeClass( selectee.$element, doSelect ? "ui-unselecting" : "ui-selected" )
                        ._addClass( selectee.$element, doSelect ? "ui-selecting" : "ui-unselecting" );
                    selectee.unselecting = !doSelect;
                    selectee.selecting = doSelect;
                    selectee.selected = doSelect;
    
                    // selectable (UN)SELECTING callback
                    if ( doSelect ) {
                        that._trigger( "selecting", event, {
                            selecting: selectee.element
                        } );
                    } else {
                        that._trigger( "unselecting", event, {
                            unselecting: selectee.element
                        } );
                    }
                    return false;
                }
            } );
    
        },
    
        _mouseDrag: function( event ) {
    
            this.dragged = true;
    
            if ( this.options.disabled ) {
                return;
            }
    
            var tmp,
                that = this,
                options = this.options,
                x1 = this.opos[ 0 ],
                y1 = this.opos[ 1 ],
                x2 = event.pageX,
                y2 = event.pageY;
    
            if ( x1 > x2 ) { tmp = x2; x2 = x1; x1 = tmp; }
            if ( y1 > y2 ) { tmp = y2; y2 = y1; y1 = tmp; }
            this.helper.css( { left: x1, top: y1, width: x2 - x1, height: y2 - y1 } );
    
            this.selectees.each( function() {
                var selectee = $.data( this, "selectable-item" ),
                    hit = false,
                    offset = {};
    
                //prevent helper from being selected if appendTo: selectable
                if ( !selectee || selectee.element === that.element[ 0 ] ) {
                    return;
                }
    
                offset.left   = selectee.left   + that.elementPos.left;
                offset.right  = selectee.right  + that.elementPos.left;
                offset.top    = selectee.top    + that.elementPos.top;
                offset.bottom = selectee.bottom + that.elementPos.top;
    
                if ( options.tolerance === "touch" ) {
                    hit = ( !( offset.left > x2 || offset.right < x1 || offset.top > y2 ||
                        offset.bottom < y1 ) );
                } else if ( options.tolerance === "fit" ) {
                    hit = ( offset.left > x1 && offset.right < x2 && offset.top > y1 &&
                        offset.bottom < y2 );
                }
    
                if ( hit ) {
    
                    // SELECT
                    if ( selectee.selected ) {
                        that._removeClass( selectee.$element, "ui-selected" );
                        selectee.selected = false;
                    }
                    if ( selectee.unselecting ) {
                        that._removeClass( selectee.$element, "ui-unselecting" );
                        selectee.unselecting = false;
                    }
                    if ( !selectee.selecting ) {
                        that._addClass( selectee.$element, "ui-selecting" );
                        selectee.selecting = true;
    
                        // selectable SELECTING callback
                        that._trigger( "selecting", event, {
                            selecting: selectee.element
                        } );
                    }
                } else {
    
                    // UNSELECT
                    if ( selectee.selecting ) {
                        if ( ( event.metaKey || event.ctrlKey ) && selectee.startselected ) {
                            that._removeClass( selectee.$element, "ui-selecting" );
                            selectee.selecting = false;
                            that._addClass( selectee.$element, "ui-selected" );
                            selectee.selected = true;
                        } else {
                            that._removeClass( selectee.$element, "ui-selecting" );
                            selectee.selecting = false;
                            if ( selectee.startselected ) {
                                that._addClass( selectee.$element, "ui-unselecting" );
                                selectee.unselecting = true;
                            }
    
                            // selectable UNSELECTING callback
                            that._trigger( "unselecting", event, {
                                unselecting: selectee.element
                            } );
                        }
                    }
                    if ( selectee.selected ) {
                        if ( !event.metaKey && !event.ctrlKey && !selectee.startselected ) {
                            that._removeClass( selectee.$element, "ui-selected" );
                            selectee.selected = false;
    
                            that._addClass( selectee.$element, "ui-unselecting" );
                            selectee.unselecting = true;
    
                            // selectable UNSELECTING callback
                            that._trigger( "unselecting", event, {
                                unselecting: selectee.element
                            } );
                        }
                    }
                }
            } );
    
            return false;
        },
    
        _mouseStop: function( event ) {
            var that = this;
    
            this.dragged = false;
    
            $( ".ui-unselecting", this.element[ 0 ] ).each( function() {
                var selectee = $.data( this, "selectable-item" );
                that._removeClass( selectee.$element, "ui-unselecting" );
                selectee.unselecting = false;
                selectee.startselected = false;
                that._trigger( "unselected", event, {
                    unselected: selectee.element
                } );
            } );
            $( ".ui-selecting", this.element[ 0 ] ).each( function() {
                var selectee = $.data( this, "selectable-item" );
                that._removeClass( selectee.$element, "ui-selecting" )
                    ._addClass( selectee.$element, "ui-selected" );
                selectee.selecting = false;
                selectee.selected = true;
                selectee.startselected = true;
                that._trigger( "selected", event, {
                    selected: selectee.element
                } );
            } );
            this._trigger( "stop", event );
    
            this.helper.remove();
    
            return false;
        }
    
    } );
    
    
    /*!
     * jQuery UI Selectmenu 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Selectmenu
    //>>group: Widgets
    // jscs:disable maximumLineLength
    //>>description: Duplicates and extends the functionality of a native HTML select element, allowing it to be customizable in behavior and appearance far beyond the limitations of a native select.
    // jscs:enable maximumLineLength
    //>>docs: http://api.jqueryui.com/selectmenu/
    //>>demos: http://jqueryui.com/selectmenu/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/selectmenu.css, ../../themes/base/button.css
    //>>css.theme: ../../themes/base/theme.css
    
    
    
    var widgetsSelectmenu = $.widget( "ui.selectmenu", [ $.ui.formResetMixin, {
        version: "1.12.1",
        defaultElement: "<select>",
        options: {
            appendTo: null,
            classes: {
                "ui-selectmenu-button-open": "ui-corner-top",
                "ui-selectmenu-button-closed": "ui-corner-all"
            },
            disabled: null,
            icons: {
                button: "ui-icon-triangle-1-s"
            },
            position: {
                my: "left top",
                at: "left bottom",
                collision: "none"
            },
            width: false,
    
            // Callbacks
            change: null,
            close: null,
            focus: null,
            open: null,
            select: null
        },
    
        _create: function() {
            var selectmenuId = this.element.uniqueId().attr( "id" );
            this.ids = {
                element: selectmenuId,
                button: selectmenuId + "-button",
                menu: selectmenuId + "-menu"
            };
    
            this._drawButton();
            this._drawMenu();
            this._bindFormResetHandler();
    
            this._rendered = false;
            this.menuItems = $();
        },
    
        _drawButton: function() {
            var icon,
                that = this,
                item = this._parseOption(
                    this.element.find( "option:selected" ),
                    this.element[ 0 ].selectedIndex
                );
    
            // Associate existing label with the new button
            this.labels = this.element.labels().attr( "for", this.ids.button );
            this._on( this.labels, {
                click: function( event ) {
                    this.button.focus();
                    event.preventDefault();
                }
            } );
    
            // Hide original select element
            this.element.hide();
    
            // Create button
            this.button = $( "<span>", {
                tabindex: this.options.disabled ? -1 : 0,
                id: this.ids.button,
                role: "combobox",
                "aria-expanded": "false",
                "aria-autocomplete": "list",
                "aria-owns": this.ids.menu,
                "aria-haspopup": "true",
                title: this.element.attr( "title" )
            } )
                .insertAfter( this.element );
    
            this._addClass( this.button, "ui-selectmenu-button ui-selectmenu-button-closed",
                "ui-button ui-widget" );
    
            icon = $( "<span>" ).appendTo( this.button );
            this._addClass( icon, "ui-selectmenu-icon", "ui-icon " + this.options.icons.button );
            this.buttonItem = this._renderButtonItem( item )
                .appendTo( this.button );
    
            if ( this.options.width !== false ) {
                this._resizeButton();
            }
    
            this._on( this.button, this._buttonEvents );
            this.button.one( "focusin", function() {
    
                // Delay rendering the menu items until the button receives focus.
                // The menu may have already been rendered via a programmatic open.
                if ( !that._rendered ) {
                    that._refreshMenu();
                }
            } );
        },
    
        _drawMenu: function() {
            var that = this;
    
            // Create menu
            this.menu = $( "<ul>", {
                "aria-hidden": "true",
                "aria-labelledby": this.ids.button,
                id: this.ids.menu
            } );
    
            // Wrap menu
            this.menuWrap = $( "<div>" ).append( this.menu );
            this._addClass( this.menuWrap, "ui-selectmenu-menu", "ui-front" );
            this.menuWrap.appendTo( this._appendTo() );
    
            // Initialize menu widget
            this.menuInstance = this.menu
                .menu( {
                    classes: {
                        "ui-menu": "ui-corner-bottom"
                    },
                    role: "listbox",
                    select: function( event, ui ) {
                        event.preventDefault();
    
                        // Support: IE8
                        // If the item was selected via a click, the text selection
                        // will be destroyed in IE
                        that._setSelection();
    
                        that._select( ui.item.data( "ui-selectmenu-item" ), event );
                    },
                    focus: function( event, ui ) {
                        var item = ui.item.data( "ui-selectmenu-item" );
    
                        // Prevent inital focus from firing and check if its a newly focused item
                        if ( that.focusIndex != null && item.index !== that.focusIndex ) {
                            that._trigger( "focus", event, { item: item } );
                            if ( !that.isOpen ) {
                                that._select( item, event );
                            }
                        }
                        that.focusIndex = item.index;
    
                        that.button.attr( "aria-activedescendant",
                            that.menuItems.eq( item.index ).attr( "id" ) );
                    }
                } )
                .menu( "instance" );
    
            // Don't close the menu on mouseleave
            this.menuInstance._off( this.menu, "mouseleave" );
    
            // Cancel the menu's collapseAll on document click
            this.menuInstance._closeOnDocumentClick = function() {
                return false;
            };
    
            // Selects often contain empty items, but never contain dividers
            this.menuInstance._isDivider = function() {
                return false;
            };
        },
    
        refresh: function() {
            this._refreshMenu();
            this.buttonItem.replaceWith(
                this.buttonItem = this._renderButtonItem(
    
                    // Fall back to an empty object in case there are no options
                    this._getSelectedItem().data( "ui-selectmenu-item" ) || {}
                )
            );
            if ( this.options.width === null ) {
                this._resizeButton();
            }
        },
    
        _refreshMenu: function() {
            var item,
                options = this.element.find( "option" );
    
            this.menu.empty();
    
            this._parseOptions( options );
            this._renderMenu( this.menu, this.items );
    
            this.menuInstance.refresh();
            this.menuItems = this.menu.find( "li" )
                .not( ".ui-selectmenu-optgroup" )
                    .find( ".ui-menu-item-wrapper" );
    
            this._rendered = true;
    
            if ( !options.length ) {
                return;
            }
    
            item = this._getSelectedItem();
    
            // Update the menu to have the correct item focused
            this.menuInstance.focus( null, item );
            this._setAria( item.data( "ui-selectmenu-item" ) );
    
            // Set disabled state
            this._setOption( "disabled", this.element.prop( "disabled" ) );
        },
    
        open: function( event ) {
            if ( this.options.disabled ) {
                return;
            }
    
            // If this is the first time the menu is being opened, render the items
            if ( !this._rendered ) {
                this._refreshMenu();
            } else {
    
                // Menu clears focus on close, reset focus to selected item
                this._removeClass( this.menu.find( ".ui-state-active" ), null, "ui-state-active" );
                this.menuInstance.focus( null, this._getSelectedItem() );
            }
    
            // If there are no options, don't open the menu
            if ( !this.menuItems.length ) {
                return;
            }
    
            this.isOpen = true;
            this._toggleAttr();
            this._resizeMenu();
            this._position();
    
            this._on( this.document, this._documentClick );
    
            this._trigger( "open", event );
        },
    
        _position: function() {
            this.menuWrap.position( $.extend( { of: this.button }, this.options.position ) );
        },
    
        close: function( event ) {
            if ( !this.isOpen ) {
                return;
            }
    
            this.isOpen = false;
            this._toggleAttr();
    
            this.range = null;
            this._off( this.document );
    
            this._trigger( "close", event );
        },
    
        widget: function() {
            return this.button;
        },
    
        menuWidget: function() {
            return this.menu;
        },
    
        _renderButtonItem: function( item ) {
            var buttonItem = $( "<span>" );
    
            this._setText( buttonItem, item.label );
            this._addClass( buttonItem, "ui-selectmenu-text" );
    
            return buttonItem;
        },
    
        _renderMenu: function( ul, items ) {
            var that = this,
                currentOptgroup = "";
    
            $.each( items, function( index, item ) {
                var li;
    
                if ( item.optgroup !== currentOptgroup ) {
                    li = $( "<li>", {
                        text: item.optgroup
                    } );
                    that._addClass( li, "ui-selectmenu-optgroup", "ui-menu-divider" +
                        ( item.element.parent( "optgroup" ).prop( "disabled" ) ?
                            " ui-state-disabled" :
                            "" ) );
    
                    li.appendTo( ul );
    
                    currentOptgroup = item.optgroup;
                }
    
                that._renderItemData( ul, item );
            } );
        },
    
        _renderItemData: function( ul, item ) {
            return this._renderItem( ul, item ).data( "ui-selectmenu-item", item );
        },
    
        _renderItem: function( ul, item ) {
            var li = $( "<li>" ),
                wrapper = $( "<div>", {
                    title: item.element.attr( "title" )
                } );
    
            if ( item.disabled ) {
                this._addClass( li, null, "ui-state-disabled" );
            }
            this._setText( wrapper, item.label );
    
            return li.append( wrapper ).appendTo( ul );
        },
    
        _setText: function( element, value ) {
            if ( value ) {
                element.text( value );
            } else {
                element.html( "&#160;" );
            }
        },
    
        _move: function( direction, event ) {
            var item, next,
                filter = ".ui-menu-item";
    
            if ( this.isOpen ) {
                item = this.menuItems.eq( this.focusIndex ).parent( "li" );
            } else {
                item = this.menuItems.eq( this.element[ 0 ].selectedIndex ).parent( "li" );
                filter += ":not(.ui-state-disabled)";
            }
    
            if ( direction === "first" || direction === "last" ) {
                next = item[ direction === "first" ? "prevAll" : "nextAll" ]( filter ).eq( -1 );
            } else {
                next = item[ direction + "All" ]( filter ).eq( 0 );
            }
    
            if ( next.length ) {
                this.menuInstance.focus( event, next );
            }
        },
    
        _getSelectedItem: function() {
            return this.menuItems.eq( this.element[ 0 ].selectedIndex ).parent( "li" );
        },
    
        _toggle: function( event ) {
            this[ this.isOpen ? "close" : "open" ]( event );
        },
    
        _setSelection: function() {
            var selection;
    
            if ( !this.range ) {
                return;
            }
    
            if ( window.getSelection ) {
                selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange( this.range );
    
            // Support: IE8
            } else {
                this.range.select();
            }
    
            // Support: IE
            // Setting the text selection kills the button focus in IE, but
            // restoring the focus doesn't kill the selection.
            this.button.focus();
        },
    
        _documentClick: {
            mousedown: function( event ) {
                if ( !this.isOpen ) {
                    return;
                }
    
                if ( !$( event.target ).closest( ".ui-selectmenu-menu, #" +
                        $.ui.escapeSelector( this.ids.button ) ).length ) {
                    this.close( event );
                }
            }
        },
    
        _buttonEvents: {
    
            // Prevent text selection from being reset when interacting with the selectmenu (#10144)
            mousedown: function() {
                var selection;
    
                if ( window.getSelection ) {
                    selection = window.getSelection();
                    if ( selection.rangeCount ) {
                        this.range = selection.getRangeAt( 0 );
                    }
    
                // Support: IE8
                } else {
                    this.range = document.selection.createRange();
                }
            },
    
            click: function( event ) {
                this._setSelection();
                this._toggle( event );
            },
    
            keydown: function( event ) {
                var preventDefault = true;
                switch ( event.keyCode ) {
                case $.ui.keyCode.TAB:
                case $.ui.keyCode.ESCAPE:
                    this.close( event );
                    preventDefault = false;
                    break;
                case $.ui.keyCode.ENTER:
                    if ( this.isOpen ) {
                        this._selectFocusedItem( event );
                    }
                    break;
                case $.ui.keyCode.UP:
                    if ( event.altKey ) {
                        this._toggle( event );
                    } else {
                        this._move( "prev", event );
                    }
                    break;
                case $.ui.keyCode.DOWN:
                    if ( event.altKey ) {
                        this._toggle( event );
                    } else {
                        this._move( "next", event );
                    }
                    break;
                case $.ui.keyCode.SPACE:
                    if ( this.isOpen ) {
                        this._selectFocusedItem( event );
                    } else {
                        this._toggle( event );
                    }
                    break;
                case $.ui.keyCode.LEFT:
                    this._move( "prev", event );
                    break;
                case $.ui.keyCode.RIGHT:
                    this._move( "next", event );
                    break;
                case $.ui.keyCode.HOME:
                case $.ui.keyCode.PAGE_UP:
                    this._move( "first", event );
                    break;
                case $.ui.keyCode.END:
                case $.ui.keyCode.PAGE_DOWN:
                    this._move( "last", event );
                    break;
                default:
                    this.menu.trigger( event );
                    preventDefault = false;
                }
    
                if ( preventDefault ) {
                    event.preventDefault();
                }
            }
        },
    
        _selectFocusedItem: function( event ) {
            var item = this.menuItems.eq( this.focusIndex ).parent( "li" );
            if ( !item.hasClass( "ui-state-disabled" ) ) {
                this._select( item.data( "ui-selectmenu-item" ), event );
            }
        },
    
        _select: function( item, event ) {
            var oldIndex = this.element[ 0 ].selectedIndex;
    
            // Change native select element
            this.element[ 0 ].selectedIndex = item.index;
            this.buttonItem.replaceWith( this.buttonItem = this._renderButtonItem( item ) );
            this._setAria( item );
            this._trigger( "select", event, { item: item } );
    
            if ( item.index !== oldIndex ) {
                this._trigger( "change", event, { item: item } );
            }
    
            this.close( event );
        },
    
        _setAria: function( item ) {
            var id = this.menuItems.eq( item.index ).attr( "id" );
    
            this.button.attr( {
                "aria-labelledby": id,
                "aria-activedescendant": id
            } );
            this.menu.attr( "aria-activedescendant", id );
        },
    
        _setOption: function( key, value ) {
            if ( key === "icons" ) {
                var icon = this.button.find( "span.ui-icon" );
                this._removeClass( icon, null, this.options.icons.button )
                    ._addClass( icon, null, value.button );
            }
    
            this._super( key, value );
    
            if ( key === "appendTo" ) {
                this.menuWrap.appendTo( this._appendTo() );
            }
    
            if ( key === "width" ) {
                this._resizeButton();
            }
        },
    
        _setOptionDisabled: function( value ) {
            this._super( value );
    
            this.menuInstance.option( "disabled", value );
            this.button.attr( "aria-disabled", value );
            this._toggleClass( this.button, null, "ui-state-disabled", value );
    
            this.element.prop( "disabled", value );
            if ( value ) {
                this.button.attr( "tabindex", -1 );
                this.close();
            } else {
                this.button.attr( "tabindex", 0 );
            }
        },
    
        _appendTo: function() {
            var element = this.options.appendTo;
    
            if ( element ) {
                element = element.jquery || element.nodeType ?
                    $( element ) :
                    this.document.find( element ).eq( 0 );
            }
    
            if ( !element || !element[ 0 ] ) {
                element = this.element.closest( ".ui-front, dialog" );
            }
    
            if ( !element.length ) {
                element = this.document[ 0 ].body;
            }
    
            return element;
        },
    
        _toggleAttr: function() {
            this.button.attr( "aria-expanded", this.isOpen );
    
            // We can't use two _toggleClass() calls here, because we need to make sure
            // we always remove classes first and add them second, otherwise if both classes have the
            // same theme class, it will be removed after we add it.
            this._removeClass( this.button, "ui-selectmenu-button-" +
                ( this.isOpen ? "closed" : "open" ) )
                ._addClass( this.button, "ui-selectmenu-button-" +
                    ( this.isOpen ? "open" : "closed" ) )
                ._toggleClass( this.menuWrap, "ui-selectmenu-open", null, this.isOpen );
    
            this.menu.attr( "aria-hidden", !this.isOpen );
        },
    
        _resizeButton: function() {
            var width = this.options.width;
    
            // For `width: false`, just remove inline style and stop
            if ( width === false ) {
                this.button.css( "width", "" );
                return;
            }
    
            // For `width: null`, match the width of the original element
            if ( width === null ) {
                width = this.element.show().outerWidth();
                this.element.hide();
            }
    
            this.button.outerWidth( width );
        },
    
        _resizeMenu: function() {
            this.menu.outerWidth( Math.max(
                this.button.outerWidth(),
    
                // Support: IE10
                // IE10 wraps long text (possibly a rounding bug)
                // so we add 1px to avoid the wrapping
                this.menu.width( "" ).outerWidth() + 1
            ) );
        },
    
        _getCreateOptions: function() {
            var options = this._super();
    
            options.disabled = this.element.prop( "disabled" );
    
            return options;
        },
    
        _parseOptions: function( options ) {
            var that = this,
                data = [];
            options.each( function( index, item ) {
                data.push( that._parseOption( $( item ), index ) );
            } );
            this.items = data;
        },
    
        _parseOption: function( option, index ) {
            var optgroup = option.parent( "optgroup" );
    
            return {
                element: option,
                index: index,
                value: option.val(),
                label: option.text(),
                optgroup: optgroup.attr( "label" ) || "",
                disabled: optgroup.prop( "disabled" ) || option.prop( "disabled" )
            };
        },
    
        _destroy: function() {
            this._unbindFormResetHandler();
            this.menuWrap.remove();
            this.button.remove();
            this.element.show();
            this.element.removeUniqueId();
            this.labels.attr( "for", this.ids.element );
        }
    } ] );
    
    
    /*!
     * jQuery UI Slider 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Slider
    //>>group: Widgets
    //>>description: Displays a flexible slider with ranges and accessibility via keyboard.
    //>>docs: http://api.jqueryui.com/slider/
    //>>demos: http://jqueryui.com/slider/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/slider.css
    //>>css.theme: ../../themes/base/theme.css
    
    
    
    var widgetsSlider = $.widget( "ui.slider", $.ui.mouse, {
        version: "1.12.1",
        widgetEventPrefix: "slide",
    
        options: {
            animate: false,
            classes: {
                "ui-slider": "ui-corner-all",
                "ui-slider-handle": "ui-corner-all",
    
                // Note: ui-widget-header isn't the most fittingly semantic framework class for this
                // element, but worked best visually with a variety of themes
                "ui-slider-range": "ui-corner-all ui-widget-header"
            },
            distance: 0,
            max: 100,
            min: 0,
            orientation: "horizontal",
            range: false,
            step: 1,
            value: 0,
            values: null,
    
            // Callbacks
            change: null,
            slide: null,
            start: null,
            stop: null
        },
    
        // Number of pages in a slider
        // (how many times can you page up/down to go through the whole range)
        numPages: 5,
    
        _create: function() {
            this._keySliding = false;
            this._mouseSliding = false;
            this._animateOff = true;
            this._handleIndex = null;
            this._detectOrientation();
            this._mouseInit();
            this._calculateNewMax();
    
            this._addClass( "ui-slider ui-slider-" + this.orientation,
                "ui-widget ui-widget-content" );
    
            this._refresh();
    
            this._animateOff = false;
        },
    
        _refresh: function() {
            this._createRange();
            this._createHandles();
            this._setupEvents();
            this._refreshValue();
        },
    
        _createHandles: function() {
            var i, handleCount,
                options = this.options,
                existingHandles = this.element.find( ".ui-slider-handle" ),
                handle = "<span tabindex='0'></span>",
                handles = [];
    
            handleCount = ( options.values && options.values.length ) || 1;
    
            if ( existingHandles.length > handleCount ) {
                existingHandles.slice( handleCount ).remove();
                existingHandles = existingHandles.slice( 0, handleCount );
            }
    
            for ( i = existingHandles.length; i < handleCount; i++ ) {
                handles.push( handle );
            }
    
            this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );
    
            this._addClass( this.handles, "ui-slider-handle", "ui-state-default" );
    
            this.handle = this.handles.eq( 0 );
    
            this.handles.each( function( i ) {
                $( this )
                    .data( "ui-slider-handle-index", i )
                    .attr( "tabIndex", 0 );
            } );
        },
    
        _createRange: function() {
            var options = this.options;
    
            if ( options.range ) {
                if ( options.range === true ) {
                    if ( !options.values ) {
                        options.values = [ this._valueMin(), this._valueMin() ];
                    } else if ( options.values.length && options.values.length !== 2 ) {
                        options.values = [ options.values[ 0 ], options.values[ 0 ] ];
                    } else if ( $.isArray( options.values ) ) {
                        options.values = options.values.slice( 0 );
                    }
                }
    
                if ( !this.range || !this.range.length ) {
                    this.range = $( "<div>" )
                        .appendTo( this.element );
    
                    this._addClass( this.range, "ui-slider-range" );
                } else {
                    this._removeClass( this.range, "ui-slider-range-min ui-slider-range-max" );
    
                    // Handle range switching from true to min/max
                    this.range.css( {
                        "left": "",
                        "bottom": ""
                    } );
                }
                if ( options.range === "min" || options.range === "max" ) {
                    this._addClass( this.range, "ui-slider-range-" + options.range );
                }
            } else {
                if ( this.range ) {
                    this.range.remove();
                }
                this.range = null;
            }
        },
    
        _setupEvents: function() {
            this._off( this.handles );
            this._on( this.handles, this._handleEvents );
            this._hoverable( this.handles );
            this._focusable( this.handles );
        },
    
        _destroy: function() {
            this.handles.remove();
            if ( this.range ) {
                this.range.remove();
            }
    
            this._mouseDestroy();
        },
    
        _mouseCapture: function( event ) {
            var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
                that = this,
                o = this.options;
    
            if ( o.disabled ) {
                return false;
            }
    
            this.elementSize = {
                width: this.element.outerWidth(),
                height: this.element.outerHeight()
            };
            this.elementOffset = this.element.offset();
    
            position = { x: event.pageX, y: event.pageY };
            normValue = this._normValueFromMouse( position );
            distance = this._valueMax() - this._valueMin() + 1;
            this.handles.each( function( i ) {
                var thisDistance = Math.abs( normValue - that.values( i ) );
                if ( ( distance > thisDistance ) ||
                    ( distance === thisDistance &&
                        ( i === that._lastChangedValue || that.values( i ) === o.min ) ) ) {
                    distance = thisDistance;
                    closestHandle = $( this );
                    index = i;
                }
            } );
    
            allowed = this._start( event, index );
            if ( allowed === false ) {
                return false;
            }
            this._mouseSliding = true;
    
            this._handleIndex = index;
    
            this._addClass( closestHandle, null, "ui-state-active" );
            closestHandle.trigger( "focus" );
    
            offset = closestHandle.offset();
            mouseOverHandle = !$( event.target ).parents().addBack().is( ".ui-slider-handle" );
            this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
                left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
                top: event.pageY - offset.top -
                    ( closestHandle.height() / 2 ) -
                    ( parseInt( closestHandle.css( "borderTopWidth" ), 10 ) || 0 ) -
                    ( parseInt( closestHandle.css( "borderBottomWidth" ), 10 ) || 0 ) +
                    ( parseInt( closestHandle.css( "marginTop" ), 10 ) || 0 )
            };
    
            if ( !this.handles.hasClass( "ui-state-hover" ) ) {
                this._slide( event, index, normValue );
            }
            this._animateOff = true;
            return true;
        },
    
        _mouseStart: function() {
            return true;
        },
    
        _mouseDrag: function( event ) {
            var position = { x: event.pageX, y: event.pageY },
                normValue = this._normValueFromMouse( position );
    
            this._slide( event, this._handleIndex, normValue );
    
            return false;
        },
    
        _mouseStop: function( event ) {
            this._removeClass( this.handles, null, "ui-state-active" );
            this._mouseSliding = false;
    
            this._stop( event, this._handleIndex );
            this._change( event, this._handleIndex );
    
            this._handleIndex = null;
            this._clickOffset = null;
            this._animateOff = false;
    
            return false;
        },
    
        _detectOrientation: function() {
            this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
        },
    
        _normValueFromMouse: function( position ) {
            var pixelTotal,
                pixelMouse,
                percentMouse,
                valueTotal,
                valueMouse;
    
            if ( this.orientation === "horizontal" ) {
                pixelTotal = this.elementSize.width;
                pixelMouse = position.x - this.elementOffset.left -
                    ( this._clickOffset ? this._clickOffset.left : 0 );
            } else {
                pixelTotal = this.elementSize.height;
                pixelMouse = position.y - this.elementOffset.top -
                    ( this._clickOffset ? this._clickOffset.top : 0 );
            }
    
            percentMouse = ( pixelMouse / pixelTotal );
            if ( percentMouse > 1 ) {
                percentMouse = 1;
            }
            if ( percentMouse < 0 ) {
                percentMouse = 0;
            }
            if ( this.orientation === "vertical" ) {
                percentMouse = 1 - percentMouse;
            }
    
            valueTotal = this._valueMax() - this._valueMin();
            valueMouse = this._valueMin() + percentMouse * valueTotal;
    
            return this._trimAlignValue( valueMouse );
        },
    
        _uiHash: function( index, value, values ) {
            var uiHash = {
                handle: this.handles[ index ],
                handleIndex: index,
                value: value !== undefined ? value : this.value()
            };
    
            if ( this._hasMultipleValues() ) {
                uiHash.value = value !== undefined ? value : this.values( index );
                uiHash.values = values || this.values();
            }
    
            return uiHash;
        },
    
        _hasMultipleValues: function() {
            return this.options.values && this.options.values.length;
        },
    
        _start: function( event, index ) {
            return this._trigger( "start", event, this._uiHash( index ) );
        },
    
        _slide: function( event, index, newVal ) {
            var allowed, otherVal,
                currentValue = this.value(),
                newValues = this.values();
    
            if ( this._hasMultipleValues() ) {
                otherVal = this.values( index ? 0 : 1 );
                currentValue = this.values( index );
    
                if ( this.options.values.length === 2 && this.options.range === true ) {
                    newVal =  index === 0 ? Math.min( otherVal, newVal ) : Math.max( otherVal, newVal );
                }
    
                newValues[ index ] = newVal;
            }
    
            if ( newVal === currentValue ) {
                return;
            }
    
            allowed = this._trigger( "slide", event, this._uiHash( index, newVal, newValues ) );
    
            // A slide can be canceled by returning false from the slide callback
            if ( allowed === false ) {
                return;
            }
    
            if ( this._hasMultipleValues() ) {
                this.values( index, newVal );
            } else {
                this.value( newVal );
            }
        },
    
        _stop: function( event, index ) {
            this._trigger( "stop", event, this._uiHash( index ) );
        },
    
        _change: function( event, index ) {
            if ( !this._keySliding && !this._mouseSliding ) {
    
                //store the last changed value index for reference when handles overlap
                this._lastChangedValue = index;
                this._trigger( "change", event, this._uiHash( index ) );
            }
        },
    
        value: function( newValue ) {
            if ( arguments.length ) {
                this.options.value = this._trimAlignValue( newValue );
                this._refreshValue();
                this._change( null, 0 );
                return;
            }
    
            return this._value();
        },
    
        values: function( index, newValue ) {
            var vals,
                newValues,
                i;
    
            if ( arguments.length > 1 ) {
                this.options.values[ index ] = this._trimAlignValue( newValue );
                this._refreshValue();
                this._change( null, index );
                return;
            }
    
            if ( arguments.length ) {
                if ( $.isArray( arguments[ 0 ] ) ) {
                    vals = this.options.values;
                    newValues = arguments[ 0 ];
                    for ( i = 0; i < vals.length; i += 1 ) {
                        vals[ i ] = this._trimAlignValue( newValues[ i ] );
                        this._change( null, i );
                    }
                    this._refreshValue();
                } else {
                    if ( this._hasMultipleValues() ) {
                        return this._values( index );
                    } else {
                        return this.value();
                    }
                }
            } else {
                return this._values();
            }
        },
    
        _setOption: function( key, value ) {
            var i,
                valsLength = 0;
    
            if ( key === "range" && this.options.range === true ) {
                if ( value === "min" ) {
                    this.options.value = this._values( 0 );
                    this.options.values = null;
                } else if ( value === "max" ) {
                    this.options.value = this._values( this.options.values.length - 1 );
                    this.options.values = null;
                }
            }
    
            if ( $.isArray( this.options.values ) ) {
                valsLength = this.options.values.length;
            }
    
            this._super( key, value );
    
            switch ( key ) {
                case "orientation":
                    this._detectOrientation();
                    this._removeClass( "ui-slider-horizontal ui-slider-vertical" )
                        ._addClass( "ui-slider-" + this.orientation );
                    this._refreshValue();
                    if ( this.options.range ) {
                        this._refreshRange( value );
                    }
    
                    // Reset positioning from previous orientation
                    this.handles.css( value === "horizontal" ? "bottom" : "left", "" );
                    break;
                case "value":
                    this._animateOff = true;
                    this._refreshValue();
                    this._change( null, 0 );
                    this._animateOff = false;
                    break;
                case "values":
                    this._animateOff = true;
                    this._refreshValue();
    
                    // Start from the last handle to prevent unreachable handles (#9046)
                    for ( i = valsLength - 1; i >= 0; i-- ) {
                        this._change( null, i );
                    }
                    this._animateOff = false;
                    break;
                case "step":
                case "min":
                case "max":
                    this._animateOff = true;
                    this._calculateNewMax();
                    this._refreshValue();
                    this._animateOff = false;
                    break;
                case "range":
                    this._animateOff = true;
                    this._refresh();
                    this._animateOff = false;
                    break;
            }
        },
    
        _setOptionDisabled: function( value ) {
            this._super( value );
    
            this._toggleClass( null, "ui-state-disabled", !!value );
        },
    
        //internal value getter
        // _value() returns value trimmed by min and max, aligned by step
        _value: function() {
            var val = this.options.value;
            val = this._trimAlignValue( val );
    
            return val;
        },
    
        //internal values getter
        // _values() returns array of values trimmed by min and max, aligned by step
        // _values( index ) returns single value trimmed by min and max, aligned by step
        _values: function( index ) {
            var val,
                vals,
                i;
    
            if ( arguments.length ) {
                val = this.options.values[ index ];
                val = this._trimAlignValue( val );
    
                return val;
            } else if ( this._hasMultipleValues() ) {
    
                // .slice() creates a copy of the array
                // this copy gets trimmed by min and max and then returned
                vals = this.options.values.slice();
                for ( i = 0; i < vals.length; i += 1 ) {
                    vals[ i ] = this._trimAlignValue( vals[ i ] );
                }
    
                return vals;
            } else {
                return [];
            }
        },
    
        // Returns the step-aligned value that val is closest to, between (inclusive) min and max
        _trimAlignValue: function( val ) {
            if ( val <= this._valueMin() ) {
                return this._valueMin();
            }
            if ( val >= this._valueMax() ) {
                return this._valueMax();
            }
            var step = ( this.options.step > 0 ) ? this.options.step : 1,
                valModStep = ( val - this._valueMin() ) % step,
                alignValue = val - valModStep;
    
            if ( Math.abs( valModStep ) * 2 >= step ) {
                alignValue += ( valModStep > 0 ) ? step : ( -step );
            }
    
            // Since JavaScript has problems with large floats, round
            // the final value to 5 digits after the decimal point (see #4124)
            return parseFloat( alignValue.toFixed( 5 ) );
        },
    
        _calculateNewMax: function() {
            var max = this.options.max,
                min = this._valueMin(),
                step = this.options.step,
                aboveMin = Math.round( ( max - min ) / step ) * step;
            max = aboveMin + min;
            if ( max > this.options.max ) {
    
                //If max is not divisible by step, rounding off may increase its value
                max -= step;
            }
            this.max = parseFloat( max.toFixed( this._precision() ) );
        },
    
        _precision: function() {
            var precision = this._precisionOf( this.options.step );
            if ( this.options.min !== null ) {
                precision = Math.max( precision, this._precisionOf( this.options.min ) );
            }
            return precision;
        },
    
        _precisionOf: function( num ) {
            var str = num.toString(),
                decimal = str.indexOf( "." );
            return decimal === -1 ? 0 : str.length - decimal - 1;
        },
    
        _valueMin: function() {
            return this.options.min;
        },
    
        _valueMax: function() {
            return this.max;
        },
    
        _refreshRange: function( orientation ) {
            if ( orientation === "vertical" ) {
                this.range.css( { "width": "", "left": "" } );
            }
            if ( orientation === "horizontal" ) {
                this.range.css( { "height": "", "bottom": "" } );
            }
        },
    
        _refreshValue: function() {
            var lastValPercent, valPercent, value, valueMin, valueMax,
                oRange = this.options.range,
                o = this.options,
                that = this,
                animate = ( !this._animateOff ) ? o.animate : false,
                _set = {};
    
            if ( this._hasMultipleValues() ) {
                this.handles.each( function( i ) {
                    valPercent = ( that.values( i ) - that._valueMin() ) / ( that._valueMax() -
                        that._valueMin() ) * 100;
                    _set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
                    $( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
                    if ( that.options.range === true ) {
                        if ( that.orientation === "horizontal" ) {
                            if ( i === 0 ) {
                                that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
                                    left: valPercent + "%"
                                }, o.animate );
                            }
                            if ( i === 1 ) {
                                that.range[ animate ? "animate" : "css" ]( {
                                    width: ( valPercent - lastValPercent ) + "%"
                                }, {
                                    queue: false,
                                    duration: o.animate
                                } );
                            }
                        } else {
                            if ( i === 0 ) {
                                that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
                                    bottom: ( valPercent ) + "%"
                                }, o.animate );
                            }
                            if ( i === 1 ) {
                                that.range[ animate ? "animate" : "css" ]( {
                                    height: ( valPercent - lastValPercent ) + "%"
                                }, {
                                    queue: false,
                                    duration: o.animate
                                } );
                            }
                        }
                    }
                    lastValPercent = valPercent;
                } );
            } else {
                value = this.value();
                valueMin = this._valueMin();
                valueMax = this._valueMax();
                valPercent = ( valueMax !== valueMin ) ?
                        ( value - valueMin ) / ( valueMax - valueMin ) * 100 :
                        0;
                _set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
                this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
    
                if ( oRange === "min" && this.orientation === "horizontal" ) {
                    this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
                        width: valPercent + "%"
                    }, o.animate );
                }
                if ( oRange === "max" && this.orientation === "horizontal" ) {
                    this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
                        width: ( 100 - valPercent ) + "%"
                    }, o.animate );
                }
                if ( oRange === "min" && this.orientation === "vertical" ) {
                    this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
                        height: valPercent + "%"
                    }, o.animate );
                }
                if ( oRange === "max" && this.orientation === "vertical" ) {
                    this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
                        height: ( 100 - valPercent ) + "%"
                    }, o.animate );
                }
            }
        },
    
        _handleEvents: {
            keydown: function( event ) {
                var allowed, curVal, newVal, step,
                    index = $( event.target ).data( "ui-slider-handle-index" );
    
                switch ( event.keyCode ) {
                    case $.ui.keyCode.HOME:
                    case $.ui.keyCode.END:
                    case $.ui.keyCode.PAGE_UP:
                    case $.ui.keyCode.PAGE_DOWN:
                    case $.ui.keyCode.UP:
                    case $.ui.keyCode.RIGHT:
                    case $.ui.keyCode.DOWN:
                    case $.ui.keyCode.LEFT:
                        event.preventDefault();
                        if ( !this._keySliding ) {
                            this._keySliding = true;
                            this._addClass( $( event.target ), null, "ui-state-active" );
                            allowed = this._start( event, index );
                            if ( allowed === false ) {
                                return;
                            }
                        }
                        break;
                }
    
                step = this.options.step;
                if ( this._hasMultipleValues() ) {
                    curVal = newVal = this.values( index );
                } else {
                    curVal = newVal = this.value();
                }
    
                switch ( event.keyCode ) {
                    case $.ui.keyCode.HOME:
                        newVal = this._valueMin();
                        break;
                    case $.ui.keyCode.END:
                        newVal = this._valueMax();
                        break;
                    case $.ui.keyCode.PAGE_UP:
                        newVal = this._trimAlignValue(
                            curVal + ( ( this._valueMax() - this._valueMin() ) / this.numPages )
                        );
                        break;
                    case $.ui.keyCode.PAGE_DOWN:
                        newVal = this._trimAlignValue(
                            curVal - ( ( this._valueMax() - this._valueMin() ) / this.numPages ) );
                        break;
                    case $.ui.keyCode.UP:
                    case $.ui.keyCode.RIGHT:
                        if ( curVal === this._valueMax() ) {
                            return;
                        }
                        newVal = this._trimAlignValue( curVal + step );
                        break;
                    case $.ui.keyCode.DOWN:
                    case $.ui.keyCode.LEFT:
                        if ( curVal === this._valueMin() ) {
                            return;
                        }
                        newVal = this._trimAlignValue( curVal - step );
                        break;
                }
    
                this._slide( event, index, newVal );
            },
            keyup: function( event ) {
                var index = $( event.target ).data( "ui-slider-handle-index" );
    
                if ( this._keySliding ) {
                    this._keySliding = false;
                    this._stop( event, index );
                    this._change( event, index );
                    this._removeClass( $( event.target ), null, "ui-state-active" );
                }
            }
        }
    } );
    
    
    /*!
     * jQuery UI Sortable 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Sortable
    //>>group: Interactions
    //>>description: Enables items in a list to be sorted using the mouse.
    //>>docs: http://api.jqueryui.com/sortable/
    //>>demos: http://jqueryui.com/sortable/
    //>>css.structure: ../../themes/base/sortable.css
    
    
    
    var widgetsSortable = $.widget( "ui.sortable", $.ui.mouse, {
        version: "1.12.1",
        widgetEventPrefix: "sort",
        ready: false,
        options: {
            appendTo: "parent",
            axis: false,
            connectWith: false,
            containment: false,
            cursor: "auto",
            cursorAt: false,
            dropOnEmpty: true,
            forcePlaceholderSize: false,
            forceHelperSize: false,
            grid: false,
            handle: false,
            helper: "original",
            items: "> *",
            opacity: false,
            placeholder: false,
            revert: false,
            scroll: true,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            scope: "default",
            tolerance: "intersect",
            zIndex: 1000,
    
            // Callbacks
            activate: null,
            beforeStop: null,
            change: null,
            deactivate: null,
            out: null,
            over: null,
            receive: null,
            remove: null,
            sort: null,
            start: null,
            stop: null,
            update: null
        },
    
        _isOverAxis: function( x, reference, size ) {
            return ( x >= reference ) && ( x < ( reference + size ) );
        },
    
        _isFloating: function( item ) {
            return ( /left|right/ ).test( item.css( "float" ) ) ||
                ( /inline|table-cell/ ).test( item.css( "display" ) );
        },
    
        _create: function() {
            this.containerCache = {};
            this._addClass( "ui-sortable" );
    
            //Get the items
            this.refresh();
    
            //Let's determine the parent's offset
            this.offset = this.element.offset();
    
            //Initialize mouse events for interaction
            this._mouseInit();
    
            this._setHandleClassName();
    
            //We're ready to go
            this.ready = true;
    
        },
    
        _setOption: function( key, value ) {
            this._super( key, value );
    
            if ( key === "handle" ) {
                this._setHandleClassName();
            }
        },
    
        _setHandleClassName: function() {
            var that = this;
            this._removeClass( this.element.find( ".ui-sortable-handle" ), "ui-sortable-handle" );
            $.each( this.items, function() {
                that._addClass(
                    this.instance.options.handle ?
                        this.item.find( this.instance.options.handle ) :
                        this.item,
                    "ui-sortable-handle"
                );
            } );
        },
    
        _destroy: function() {
            this._mouseDestroy();
    
            for ( var i = this.items.length - 1; i >= 0; i-- ) {
                this.items[ i ].item.removeData( this.widgetName + "-item" );
            }
    
            return this;
        },
    
        _mouseCapture: function( event, overrideHandle ) {
            var currentItem = null,
                validHandle = false,
                that = this;
    
            if ( this.reverting ) {
                return false;
            }
    
            if ( this.options.disabled || this.options.type === "static" ) {
                return false;
            }
    
            //We have to refresh the items data once first
            this._refreshItems( event );
    
            //Find out if the clicked node (or one of its parents) is a actual item in this.items
            $( event.target ).parents().each( function() {
                if ( $.data( this, that.widgetName + "-item" ) === that ) {
                    currentItem = $( this );
                    return false;
                }
            } );
            if ( $.data( event.target, that.widgetName + "-item" ) === that ) {
                currentItem = $( event.target );
            }
    
            if ( !currentItem ) {
                return false;
            }
            if ( this.options.handle && !overrideHandle ) {
                $( this.options.handle, currentItem ).find( "*" ).addBack().each( function() {
                    if ( this === event.target ) {
                        validHandle = true;
                    }
                } );
                if ( !validHandle ) {
                    return false;
                }
            }
    
            this.currentItem = currentItem;
            this._removeCurrentsFromItems();
            return true;
    
        },
    
        _mouseStart: function( event, overrideHandle, noActivation ) {
    
            var i, body,
                o = this.options;
    
            this.currentContainer = this;
    
            //We only need to call refreshPositions, because the refreshItems call has been moved to
            // mouseCapture
            this.refreshPositions();
    
            //Create and append the visible helper
            this.helper = this._createHelper( event );
    
            //Cache the helper size
            this._cacheHelperProportions();
    
            /*
             * - Position generation -
             * This block generates everything position related - it's the core of draggables.
             */
    
            //Cache the margins of the original element
            this._cacheMargins();
    
            //Get the next scrolling parent
            this.scrollParent = this.helper.scrollParent();
    
            //The element's absolute position on the page minus margins
            this.offset = this.currentItem.offset();
            this.offset = {
                top: this.offset.top - this.margins.top,
                left: this.offset.left - this.margins.left
            };
    
            $.extend( this.offset, {
                click: { //Where the click happened, relative to the element
                    left: event.pageX - this.offset.left,
                    top: event.pageY - this.offset.top
                },
                parent: this._getParentOffset(),
    
                // This is a relative to absolute position minus the actual position calculation -
                // only used for relative positioned helper
                relative: this._getRelativeOffset()
            } );
    
            // Only after we got the offset, we can change the helper's position to absolute
            // TODO: Still need to figure out a way to make relative sorting possible
            this.helper.css( "position", "absolute" );
            this.cssPosition = this.helper.css( "position" );
    
            //Generate the original position
            this.originalPosition = this._generatePosition( event );
            this.originalPageX = event.pageX;
            this.originalPageY = event.pageY;
    
            //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
            ( o.cursorAt && this._adjustOffsetFromHelper( o.cursorAt ) );
    
            //Cache the former DOM position
            this.domPosition = {
                prev: this.currentItem.prev()[ 0 ],
                parent: this.currentItem.parent()[ 0 ]
            };
    
            // If the helper is not the original, hide the original so it's not playing any role during
            // the drag, won't cause anything bad this way
            if ( this.helper[ 0 ] !== this.currentItem[ 0 ] ) {
                this.currentItem.hide();
            }
    
            //Create the placeholder
            this._createPlaceholder();
    
            //Set a containment if given in the options
            if ( o.containment ) {
                this._setContainment();
            }
    
            if ( o.cursor && o.cursor !== "auto" ) { // cursor option
                body = this.document.find( "body" );
    
                // Support: IE
                this.storedCursor = body.css( "cursor" );
                body.css( "cursor", o.cursor );
    
                this.storedStylesheet =
                    $( "<style>*{ cursor: " + o.cursor + " !important; }</style>" ).appendTo( body );
            }
    
            if ( o.opacity ) { // opacity option
                if ( this.helper.css( "opacity" ) ) {
                    this._storedOpacity = this.helper.css( "opacity" );
                }
                this.helper.css( "opacity", o.opacity );
            }
    
            if ( o.zIndex ) { // zIndex option
                if ( this.helper.css( "zIndex" ) ) {
                    this._storedZIndex = this.helper.css( "zIndex" );
                }
                this.helper.css( "zIndex", o.zIndex );
            }
    
            //Prepare scrolling
            if ( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
                    this.scrollParent[ 0 ].tagName !== "HTML" ) {
                this.overflowOffset = this.scrollParent.offset();
            }
    
            //Call callbacks
            this._trigger( "start", event, this._uiHash() );
    
            //Recache the helper size
            if ( !this._preserveHelperProportions ) {
                this._cacheHelperProportions();
            }
    
            //Post "activate" events to possible containers
            if ( !noActivation ) {
                for ( i = this.containers.length - 1; i >= 0; i-- ) {
                    this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );
                }
            }
    
            //Prepare possible droppables
            if ( $.ui.ddmanager ) {
                $.ui.ddmanager.current = this;
            }
    
            if ( $.ui.ddmanager && !o.dropBehaviour ) {
                $.ui.ddmanager.prepareOffsets( this, event );
            }
    
            this.dragging = true;
    
            this._addClass( this.helper, "ui-sortable-helper" );
    
            // Execute the drag once - this causes the helper not to be visiblebefore getting its
            // correct position
            this._mouseDrag( event );
            return true;
    
        },
    
        _mouseDrag: function( event ) {
            var i, item, itemElement, intersection,
                o = this.options,
                scrolled = false;
    
            //Compute the helpers position
            this.position = this._generatePosition( event );
            this.positionAbs = this._convertPositionTo( "absolute" );
    
            if ( !this.lastPositionAbs ) {
                this.lastPositionAbs = this.positionAbs;
            }
    
            //Do scrolling
            if ( this.options.scroll ) {
                if ( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
                        this.scrollParent[ 0 ].tagName !== "HTML" ) {
    
                    if ( ( this.overflowOffset.top + this.scrollParent[ 0 ].offsetHeight ) -
                            event.pageY < o.scrollSensitivity ) {
                        this.scrollParent[ 0 ].scrollTop =
                            scrolled = this.scrollParent[ 0 ].scrollTop + o.scrollSpeed;
                    } else if ( event.pageY - this.overflowOffset.top < o.scrollSensitivity ) {
                        this.scrollParent[ 0 ].scrollTop =
                            scrolled = this.scrollParent[ 0 ].scrollTop - o.scrollSpeed;
                    }
    
                    if ( ( this.overflowOffset.left + this.scrollParent[ 0 ].offsetWidth ) -
                            event.pageX < o.scrollSensitivity ) {
                        this.scrollParent[ 0 ].scrollLeft = scrolled =
                            this.scrollParent[ 0 ].scrollLeft + o.scrollSpeed;
                    } else if ( event.pageX - this.overflowOffset.left < o.scrollSensitivity ) {
                        this.scrollParent[ 0 ].scrollLeft = scrolled =
                            this.scrollParent[ 0 ].scrollLeft - o.scrollSpeed;
                    }
    
                } else {
    
                    if ( event.pageY - this.document.scrollTop() < o.scrollSensitivity ) {
                        scrolled = this.document.scrollTop( this.document.scrollTop() - o.scrollSpeed );
                    } else if ( this.window.height() - ( event.pageY - this.document.scrollTop() ) <
                            o.scrollSensitivity ) {
                        scrolled = this.document.scrollTop( this.document.scrollTop() + o.scrollSpeed );
                    }
    
                    if ( event.pageX - this.document.scrollLeft() < o.scrollSensitivity ) {
                        scrolled = this.document.scrollLeft(
                            this.document.scrollLeft() - o.scrollSpeed
                        );
                    } else if ( this.window.width() - ( event.pageX - this.document.scrollLeft() ) <
                            o.scrollSensitivity ) {
                        scrolled = this.document.scrollLeft(
                            this.document.scrollLeft() + o.scrollSpeed
                        );
                    }
    
                }
    
                if ( scrolled !== false && $.ui.ddmanager && !o.dropBehaviour ) {
                    $.ui.ddmanager.prepareOffsets( this, event );
                }
            }
    
            //Regenerate the absolute position used for position checks
            this.positionAbs = this._convertPositionTo( "absolute" );
    
            //Set the helper position
            if ( !this.options.axis || this.options.axis !== "y" ) {
                this.helper[ 0 ].style.left = this.position.left + "px";
            }
            if ( !this.options.axis || this.options.axis !== "x" ) {
                this.helper[ 0 ].style.top = this.position.top + "px";
            }
    
            //Rearrange
            for ( i = this.items.length - 1; i >= 0; i-- ) {
    
                //Cache variables and intersection, continue if no intersection
                item = this.items[ i ];
                itemElement = item.item[ 0 ];
                intersection = this._intersectsWithPointer( item );
                if ( !intersection ) {
                    continue;
                }
    
                // Only put the placeholder inside the current Container, skip all
                // items from other containers. This works because when moving
                // an item from one container to another the
                // currentContainer is switched before the placeholder is moved.
                //
                // Without this, moving items in "sub-sortables" can cause
                // the placeholder to jitter between the outer and inner container.
                if ( item.instance !== this.currentContainer ) {
                    continue;
                }
    
                // Cannot intersect with itself
                // no useless actions that have been done before
                // no action if the item moved is the parent of the item checked
                if ( itemElement !== this.currentItem[ 0 ] &&
                    this.placeholder[ intersection === 1 ? "next" : "prev" ]()[ 0 ] !== itemElement &&
                    !$.contains( this.placeholder[ 0 ], itemElement ) &&
                    ( this.options.type === "semi-dynamic" ?
                        !$.contains( this.element[ 0 ], itemElement ) :
                        true
                    )
                ) {
    
                    this.direction = intersection === 1 ? "down" : "up";
    
                    if ( this.options.tolerance === "pointer" || this._intersectsWithSides( item ) ) {
                        this._rearrange( event, item );
                    } else {
                        break;
                    }
    
                    this._trigger( "change", event, this._uiHash() );
                    break;
                }
            }
    
            //Post events to containers
            this._contactContainers( event );
    
            //Interconnect with droppables
            if ( $.ui.ddmanager ) {
                $.ui.ddmanager.drag( this, event );
            }
    
            //Call callbacks
            this._trigger( "sort", event, this._uiHash() );
    
            this.lastPositionAbs = this.positionAbs;
            return false;
    
        },
    
        _mouseStop: function( event, noPropagation ) {
    
            if ( !event ) {
                return;
            }
    
            //If we are using droppables, inform the manager about the drop
            if ( $.ui.ddmanager && !this.options.dropBehaviour ) {
                $.ui.ddmanager.drop( this, event );
            }
    
            if ( this.options.revert ) {
                var that = this,
                    cur = this.placeholder.offset(),
                    axis = this.options.axis,
                    animation = {};
    
                if ( !axis || axis === "x" ) {
                    animation.left = cur.left - this.offset.parent.left - this.margins.left +
                        ( this.offsetParent[ 0 ] === this.document[ 0 ].body ?
                            0 :
                            this.offsetParent[ 0 ].scrollLeft
                        );
                }
                if ( !axis || axis === "y" ) {
                    animation.top = cur.top - this.offset.parent.top - this.margins.top +
                        ( this.offsetParent[ 0 ] === this.document[ 0 ].body ?
                            0 :
                            this.offsetParent[ 0 ].scrollTop
                        );
                }
                this.reverting = true;
                $( this.helper ).animate(
                    animation,
                    parseInt( this.options.revert, 10 ) || 500,
                    function() {
                        that._clear( event );
                    }
                );
            } else {
                this._clear( event, noPropagation );
            }
    
            return false;
    
        },
    
        cancel: function() {
    
            if ( this.dragging ) {
    
                this._mouseUp( new $.Event( "mouseup", { target: null } ) );
    
                if ( this.options.helper === "original" ) {
                    this.currentItem.css( this._storedCSS );
                    this._removeClass( this.currentItem, "ui-sortable-helper" );
                } else {
                    this.currentItem.show();
                }
    
                //Post deactivating events to containers
                for ( var i = this.containers.length - 1; i >= 0; i-- ) {
                    this.containers[ i ]._trigger( "deactivate", null, this._uiHash( this ) );
                    if ( this.containers[ i ].containerCache.over ) {
                        this.containers[ i ]._trigger( "out", null, this._uiHash( this ) );
                        this.containers[ i ].containerCache.over = 0;
                    }
                }
    
            }
    
            if ( this.placeholder ) {
    
                //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,
                // it unbinds ALL events from the original node!
                if ( this.placeholder[ 0 ].parentNode ) {
                    this.placeholder[ 0 ].parentNode.removeChild( this.placeholder[ 0 ] );
                }
                if ( this.options.helper !== "original" && this.helper &&
                        this.helper[ 0 ].parentNode ) {
                    this.helper.remove();
                }
    
                $.extend( this, {
                    helper: null,
                    dragging: false,
                    reverting: false,
                    _noFinalSort: null
                } );
    
                if ( this.domPosition.prev ) {
                    $( this.domPosition.prev ).after( this.currentItem );
                } else {
                    $( this.domPosition.parent ).prepend( this.currentItem );
                }
            }
    
            return this;
    
        },
    
        serialize: function( o ) {
    
            var items = this._getItemsAsjQuery( o && o.connected ),
                str = [];
            o = o || {};
    
            $( items ).each( function() {
                var res = ( $( o.item || this ).attr( o.attribute || "id" ) || "" )
                    .match( o.expression || ( /(.+)[\-=_](.+)/ ) );
                if ( res ) {
                    str.push(
                        ( o.key || res[ 1 ] + "[]" ) +
                        "=" + ( o.key && o.expression ? res[ 1 ] : res[ 2 ] ) );
                }
            } );
    
            if ( !str.length && o.key ) {
                str.push( o.key + "=" );
            }
    
            return str.join( "&" );
    
        },
    
        toArray: function( o ) {
    
            var items = this._getItemsAsjQuery( o && o.connected ),
                ret = [];
    
            o = o || {};
    
            items.each( function() {
                ret.push( $( o.item || this ).attr( o.attribute || "id" ) || "" );
            } );
            return ret;
    
        },
    
        /* Be careful with the following core functions */
        _intersectsWith: function( item ) {
    
            var x1 = this.positionAbs.left,
                x2 = x1 + this.helperProportions.width,
                y1 = this.positionAbs.top,
                y2 = y1 + this.helperProportions.height,
                l = item.left,
                r = l + item.width,
                t = item.top,
                b = t + item.height,
                dyClick = this.offset.click.top,
                dxClick = this.offset.click.left,
                isOverElementHeight = ( this.options.axis === "x" ) || ( ( y1 + dyClick ) > t &&
                    ( y1 + dyClick ) < b ),
                isOverElementWidth = ( this.options.axis === "y" ) || ( ( x1 + dxClick ) > l &&
                    ( x1 + dxClick ) < r ),
                isOverElement = isOverElementHeight && isOverElementWidth;
    
            if ( this.options.tolerance === "pointer" ||
                this.options.forcePointerForContainers ||
                ( this.options.tolerance !== "pointer" &&
                    this.helperProportions[ this.floating ? "width" : "height" ] >
                    item[ this.floating ? "width" : "height" ] )
            ) {
                return isOverElement;
            } else {
    
                return ( l < x1 + ( this.helperProportions.width / 2 ) && // Right Half
                    x2 - ( this.helperProportions.width / 2 ) < r && // Left Half
                    t < y1 + ( this.helperProportions.height / 2 ) && // Bottom Half
                    y2 - ( this.helperProportions.height / 2 ) < b ); // Top Half
    
            }
        },
    
        _intersectsWithPointer: function( item ) {
            var verticalDirection, horizontalDirection,
                isOverElementHeight = ( this.options.axis === "x" ) ||
                    this._isOverAxis(
                        this.positionAbs.top + this.offset.click.top, item.top, item.height ),
                isOverElementWidth = ( this.options.axis === "y" ) ||
                    this._isOverAxis(
                        this.positionAbs.left + this.offset.click.left, item.left, item.width ),
                isOverElement = isOverElementHeight && isOverElementWidth;
    
            if ( !isOverElement ) {
                return false;
            }
    
            verticalDirection = this._getDragVerticalDirection();
            horizontalDirection = this._getDragHorizontalDirection();
    
            return this.floating ?
                ( ( horizontalDirection === "right" || verticalDirection === "down" ) ? 2 : 1 )
                : ( verticalDirection && ( verticalDirection === "down" ? 2 : 1 ) );
    
        },
    
        _intersectsWithSides: function( item ) {
    
            var isOverBottomHalf = this._isOverAxis( this.positionAbs.top +
                    this.offset.click.top, item.top + ( item.height / 2 ), item.height ),
                isOverRightHalf = this._isOverAxis( this.positionAbs.left +
                    this.offset.click.left, item.left + ( item.width / 2 ), item.width ),
                verticalDirection = this._getDragVerticalDirection(),
                horizontalDirection = this._getDragHorizontalDirection();
    
            if ( this.floating && horizontalDirection ) {
                return ( ( horizontalDirection === "right" && isOverRightHalf ) ||
                    ( horizontalDirection === "left" && !isOverRightHalf ) );
            } else {
                return verticalDirection && ( ( verticalDirection === "down" && isOverBottomHalf ) ||
                    ( verticalDirection === "up" && !isOverBottomHalf ) );
            }
    
        },
    
        _getDragVerticalDirection: function() {
            var delta = this.positionAbs.top - this.lastPositionAbs.top;
            return delta !== 0 && ( delta > 0 ? "down" : "up" );
        },
    
        _getDragHorizontalDirection: function() {
            var delta = this.positionAbs.left - this.lastPositionAbs.left;
            return delta !== 0 && ( delta > 0 ? "right" : "left" );
        },
    
        refresh: function( event ) {
            this._refreshItems( event );
            this._setHandleClassName();
            this.refreshPositions();
            return this;
        },
    
        _connectWith: function() {
            var options = this.options;
            return options.connectWith.constructor === String ?
                [ options.connectWith ] :
                options.connectWith;
        },
    
        _getItemsAsjQuery: function( connected ) {
    
            var i, j, cur, inst,
                items = [],
                queries = [],
                connectWith = this._connectWith();
    
            if ( connectWith && connected ) {
                for ( i = connectWith.length - 1; i >= 0; i-- ) {
                    cur = $( connectWith[ i ], this.document[ 0 ] );
                    for ( j = cur.length - 1; j >= 0; j-- ) {
                        inst = $.data( cur[ j ], this.widgetFullName );
                        if ( inst && inst !== this && !inst.options.disabled ) {
                            queries.push( [ $.isFunction( inst.options.items ) ?
                                inst.options.items.call( inst.element ) :
                                $( inst.options.items, inst.element )
                                    .not( ".ui-sortable-helper" )
                                    .not( ".ui-sortable-placeholder" ), inst ] );
                        }
                    }
                }
            }
    
            queries.push( [ $.isFunction( this.options.items ) ?
                this.options.items
                    .call( this.element, null, { options: this.options, item: this.currentItem } ) :
                $( this.options.items, this.element )
                    .not( ".ui-sortable-helper" )
                    .not( ".ui-sortable-placeholder" ), this ] );
    
            function addItems() {
                items.push( this );
            }
            for ( i = queries.length - 1; i >= 0; i-- ) {
                queries[ i ][ 0 ].each( addItems );
            }
    
            return $( items );
    
        },
    
        _removeCurrentsFromItems: function() {
    
            var list = this.currentItem.find( ":data(" + this.widgetName + "-item)" );
    
            this.items = $.grep( this.items, function( item ) {
                for ( var j = 0; j < list.length; j++ ) {
                    if ( list[ j ] === item.item[ 0 ] ) {
                        return false;
                    }
                }
                return true;
            } );
    
        },
    
        _refreshItems: function( event ) {
    
            this.items = [];
            this.containers = [ this ];
    
            var i, j, cur, inst, targetData, _queries, item, queriesLength,
                items = this.items,
                queries = [ [ $.isFunction( this.options.items ) ?
                    this.options.items.call( this.element[ 0 ], event, { item: this.currentItem } ) :
                    $( this.options.items, this.element ), this ] ],
                connectWith = this._connectWith();
    
            //Shouldn't be run the first time through due to massive slow-down
            if ( connectWith && this.ready ) {
                for ( i = connectWith.length - 1; i >= 0; i-- ) {
                    cur = $( connectWith[ i ], this.document[ 0 ] );
                    for ( j = cur.length - 1; j >= 0; j-- ) {
                        inst = $.data( cur[ j ], this.widgetFullName );
                        if ( inst && inst !== this && !inst.options.disabled ) {
                            queries.push( [ $.isFunction( inst.options.items ) ?
                                inst.options.items
                                    .call( inst.element[ 0 ], event, { item: this.currentItem } ) :
                                $( inst.options.items, inst.element ), inst ] );
                            this.containers.push( inst );
                        }
                    }
                }
            }
    
            for ( i = queries.length - 1; i >= 0; i-- ) {
                targetData = queries[ i ][ 1 ];
                _queries = queries[ i ][ 0 ];
    
                for ( j = 0, queriesLength = _queries.length; j < queriesLength; j++ ) {
                    item = $( _queries[ j ] );
    
                    // Data for target checking (mouse manager)
                    item.data( this.widgetName + "-item", targetData );
    
                    items.push( {
                        item: item,
                        instance: targetData,
                        width: 0, height: 0,
                        left: 0, top: 0
                    } );
                }
            }
    
        },
    
        refreshPositions: function( fast ) {
    
            // Determine whether items are being displayed horizontally
            this.floating = this.items.length ?
                this.options.axis === "x" || this._isFloating( this.items[ 0 ].item ) :
                false;
    
            //This has to be redone because due to the item being moved out/into the offsetParent,
            // the offsetParent's position will change
            if ( this.offsetParent && this.helper ) {
                this.offset.parent = this._getParentOffset();
            }
    
            var i, item, t, p;
    
            for ( i = this.items.length - 1; i >= 0; i-- ) {
                item = this.items[ i ];
    
                //We ignore calculating positions of all connected containers when we're not over them
                if ( item.instance !== this.currentContainer && this.currentContainer &&
                        item.item[ 0 ] !== this.currentItem[ 0 ] ) {
                    continue;
                }
    
                t = this.options.toleranceElement ?
                    $( this.options.toleranceElement, item.item ) :
                    item.item;
    
                if ( !fast ) {
                    item.width = t.outerWidth();
                    item.height = t.outerHeight();
                }
    
                p = t.offset();
                item.left = p.left;
                item.top = p.top;
            }
    
            if ( this.options.custom && this.options.custom.refreshContainers ) {
                this.options.custom.refreshContainers.call( this );
            } else {
                for ( i = this.containers.length - 1; i >= 0; i-- ) {
                    p = this.containers[ i ].element.offset();
                    this.containers[ i ].containerCache.left = p.left;
                    this.containers[ i ].containerCache.top = p.top;
                    this.containers[ i ].containerCache.width =
                        this.containers[ i ].element.outerWidth();
                    this.containers[ i ].containerCache.height =
                        this.containers[ i ].element.outerHeight();
                }
            }
    
            return this;
        },
    
        _createPlaceholder: function( that ) {
            that = that || this;
            var className,
                o = that.options;
    
            if ( !o.placeholder || o.placeholder.constructor === String ) {
                className = o.placeholder;
                o.placeholder = {
                    element: function() {
    
                        var nodeName = that.currentItem[ 0 ].nodeName.toLowerCase(),
                            element = $( "<" + nodeName + ">", that.document[ 0 ] );
    
                            that._addClass( element, "ui-sortable-placeholder",
                                    className || that.currentItem[ 0 ].className )
                                ._removeClass( element, "ui-sortable-helper" );
    
                        if ( nodeName === "tbody" ) {
                            that._createTrPlaceholder(
                                that.currentItem.find( "tr" ).eq( 0 ),
                                $( "<tr>", that.document[ 0 ] ).appendTo( element )
                            );
                        } else if ( nodeName === "tr" ) {
                            that._createTrPlaceholder( that.currentItem, element );
                        } else if ( nodeName === "img" ) {
                            element.attr( "src", that.currentItem.attr( "src" ) );
                        }
    
                        if ( !className ) {
                            element.css( "visibility", "hidden" );
                        }
    
                        return element;
                    },
                    update: function( container, p ) {
    
                        // 1. If a className is set as 'placeholder option, we don't force sizes -
                        // the class is responsible for that
                        // 2. The option 'forcePlaceholderSize can be enabled to force it even if a
                        // class name is specified
                        if ( className && !o.forcePlaceholderSize ) {
                            return;
                        }
    
                        //If the element doesn't have a actual height by itself (without styles coming
                        // from a stylesheet), it receives the inline height from the dragged item
                        if ( !p.height() ) {
                            p.height(
                                that.currentItem.innerHeight() -
                                parseInt( that.currentItem.css( "paddingTop" ) || 0, 10 ) -
                                parseInt( that.currentItem.css( "paddingBottom" ) || 0, 10 ) );
                        }
                        if ( !p.width() ) {
                            p.width(
                                that.currentItem.innerWidth() -
                                parseInt( that.currentItem.css( "paddingLeft" ) || 0, 10 ) -
                                parseInt( that.currentItem.css( "paddingRight" ) || 0, 10 ) );
                        }
                    }
                };
            }
    
            //Create the placeholder
            that.placeholder = $( o.placeholder.element.call( that.element, that.currentItem ) );
    
            //Append it after the actual current item
            that.currentItem.after( that.placeholder );
    
            //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
            o.placeholder.update( that, that.placeholder );
    
        },
    
        _createTrPlaceholder: function( sourceTr, targetTr ) {
            var that = this;
    
            sourceTr.children().each( function() {
                $( "<td>&#160;</td>", that.document[ 0 ] )
                    .attr( "colspan", $( this ).attr( "colspan" ) || 1 )
                    .appendTo( targetTr );
            } );
        },
    
        _contactContainers: function( event ) {
            var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom,
                floating, axis,
                innermostContainer = null,
                innermostIndex = null;
    
            // Get innermost container that intersects with item
            for ( i = this.containers.length - 1; i >= 0; i-- ) {
    
                // Never consider a container that's located within the item itself
                if ( $.contains( this.currentItem[ 0 ], this.containers[ i ].element[ 0 ] ) ) {
                    continue;
                }
    
                if ( this._intersectsWith( this.containers[ i ].containerCache ) ) {
    
                    // If we've already found a container and it's more "inner" than this, then continue
                    if ( innermostContainer &&
                            $.contains(
                                this.containers[ i ].element[ 0 ],
                                innermostContainer.element[ 0 ] ) ) {
                        continue;
                    }
    
                    innermostContainer = this.containers[ i ];
                    innermostIndex = i;
    
                } else {
    
                    // container doesn't intersect. trigger "out" event if necessary
                    if ( this.containers[ i ].containerCache.over ) {
                        this.containers[ i ]._trigger( "out", event, this._uiHash( this ) );
                        this.containers[ i ].containerCache.over = 0;
                    }
                }
    
            }
    
            // If no intersecting containers found, return
            if ( !innermostContainer ) {
                return;
            }
    
            // Move the item into the container if it's not there already
            if ( this.containers.length === 1 ) {
                if ( !this.containers[ innermostIndex ].containerCache.over ) {
                    this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash( this ) );
                    this.containers[ innermostIndex ].containerCache.over = 1;
                }
            } else {
    
                // When entering a new container, we will find the item with the least distance and
                // append our item near it
                dist = 10000;
                itemWithLeastDistance = null;
                floating = innermostContainer.floating || this._isFloating( this.currentItem );
                posProperty = floating ? "left" : "top";
                sizeProperty = floating ? "width" : "height";
                axis = floating ? "pageX" : "pageY";
    
                for ( j = this.items.length - 1; j >= 0; j-- ) {
                    if ( !$.contains(
                            this.containers[ innermostIndex ].element[ 0 ], this.items[ j ].item[ 0 ] )
                    ) {
                        continue;
                    }
                    if ( this.items[ j ].item[ 0 ] === this.currentItem[ 0 ] ) {
                        continue;
                    }
    
                    cur = this.items[ j ].item.offset()[ posProperty ];
                    nearBottom = false;
                    if ( event[ axis ] - cur > this.items[ j ][ sizeProperty ] / 2 ) {
                        nearBottom = true;
                    }
    
                    if ( Math.abs( event[ axis ] - cur ) < dist ) {
                        dist = Math.abs( event[ axis ] - cur );
                        itemWithLeastDistance = this.items[ j ];
                        this.direction = nearBottom ? "up" : "down";
                    }
                }
    
                //Check if dropOnEmpty is enabled
                if ( !itemWithLeastDistance && !this.options.dropOnEmpty ) {
                    return;
                }
    
                if ( this.currentContainer === this.containers[ innermostIndex ] ) {
                    if ( !this.currentContainer.containerCache.over ) {
                        this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash() );
                        this.currentContainer.containerCache.over = 1;
                    }
                    return;
                }
    
                itemWithLeastDistance ?
                    this._rearrange( event, itemWithLeastDistance, null, true ) :
                    this._rearrange( event, null, this.containers[ innermostIndex ].element, true );
                this._trigger( "change", event, this._uiHash() );
                this.containers[ innermostIndex ]._trigger( "change", event, this._uiHash( this ) );
                this.currentContainer = this.containers[ innermostIndex ];
    
                //Update the placeholder
                this.options.placeholder.update( this.currentContainer, this.placeholder );
    
                this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash( this ) );
                this.containers[ innermostIndex ].containerCache.over = 1;
            }
    
        },
    
        _createHelper: function( event ) {
    
            var o = this.options,
                helper = $.isFunction( o.helper ) ?
                    $( o.helper.apply( this.element[ 0 ], [ event, this.currentItem ] ) ) :
                    ( o.helper === "clone" ? this.currentItem.clone() : this.currentItem );
    
            //Add the helper to the DOM if that didn't happen already
            if ( !helper.parents( "body" ).length ) {
                $( o.appendTo !== "parent" ?
                    o.appendTo :
                    this.currentItem[ 0 ].parentNode )[ 0 ].appendChild( helper[ 0 ] );
            }
    
            if ( helper[ 0 ] === this.currentItem[ 0 ] ) {
                this._storedCSS = {
                    width: this.currentItem[ 0 ].style.width,
                    height: this.currentItem[ 0 ].style.height,
                    position: this.currentItem.css( "position" ),
                    top: this.currentItem.css( "top" ),
                    left: this.currentItem.css( "left" )
                };
            }
    
            if ( !helper[ 0 ].style.width || o.forceHelperSize ) {
                helper.width( this.currentItem.width() );
            }
            if ( !helper[ 0 ].style.height || o.forceHelperSize ) {
                helper.height( this.currentItem.height() );
            }
    
            return helper;
    
        },
    
        _adjustOffsetFromHelper: function( obj ) {
            if ( typeof obj === "string" ) {
                obj = obj.split( " " );
            }
            if ( $.isArray( obj ) ) {
                obj = { left: +obj[ 0 ], top: +obj[ 1 ] || 0 };
            }
            if ( "left" in obj ) {
                this.offset.click.left = obj.left + this.margins.left;
            }
            if ( "right" in obj ) {
                this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
            }
            if ( "top" in obj ) {
                this.offset.click.top = obj.top + this.margins.top;
            }
            if ( "bottom" in obj ) {
                this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
            }
        },
    
        _getParentOffset: function() {
    
            //Get the offsetParent and cache its position
            this.offsetParent = this.helper.offsetParent();
            var po = this.offsetParent.offset();
    
            // This is a special case where we need to modify a offset calculated on start, since the
            // following happened:
            // 1. The position of the helper is absolute, so it's position is calculated based on the
            // next positioned parent
            // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't
            // the document, which means that the scroll is included in the initial calculation of the
            // offset of the parent, and never recalculated upon drag
            if ( this.cssPosition === "absolute" && this.scrollParent[ 0 ] !== this.document[ 0 ] &&
                    $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) {
                po.left += this.scrollParent.scrollLeft();
                po.top += this.scrollParent.scrollTop();
            }
    
            // This needs to be actually done for all browsers, since pageX/pageY includes this
            // information with an ugly IE fix
            if ( this.offsetParent[ 0 ] === this.document[ 0 ].body ||
                    ( this.offsetParent[ 0 ].tagName &&
                    this.offsetParent[ 0 ].tagName.toLowerCase() === "html" && $.ui.ie ) ) {
                po = { top: 0, left: 0 };
            }
    
            return {
                top: po.top + ( parseInt( this.offsetParent.css( "borderTopWidth" ), 10 ) || 0 ),
                left: po.left + ( parseInt( this.offsetParent.css( "borderLeftWidth" ), 10 ) || 0 )
            };
    
        },
    
        _getRelativeOffset: function() {
    
            if ( this.cssPosition === "relative" ) {
                var p = this.currentItem.position();
                return {
                    top: p.top - ( parseInt( this.helper.css( "top" ), 10 ) || 0 ) +
                        this.scrollParent.scrollTop(),
                    left: p.left - ( parseInt( this.helper.css( "left" ), 10 ) || 0 ) +
                        this.scrollParent.scrollLeft()
                };
            } else {
                return { top: 0, left: 0 };
            }
    
        },
    
        _cacheMargins: function() {
            this.margins = {
                left: ( parseInt( this.currentItem.css( "marginLeft" ), 10 ) || 0 ),
                top: ( parseInt( this.currentItem.css( "marginTop" ), 10 ) || 0 )
            };
        },
    
        _cacheHelperProportions: function() {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            };
        },
    
        _setContainment: function() {
    
            var ce, co, over,
                o = this.options;
            if ( o.containment === "parent" ) {
                o.containment = this.helper[ 0 ].parentNode;
            }
            if ( o.containment === "document" || o.containment === "window" ) {
                this.containment = [
                    0 - this.offset.relative.left - this.offset.parent.left,
                    0 - this.offset.relative.top - this.offset.parent.top,
                    o.containment === "document" ?
                        this.document.width() :
                        this.window.width() - this.helperProportions.width - this.margins.left,
                    ( o.containment === "document" ?
                        ( this.document.height() || document.body.parentNode.scrollHeight ) :
                        this.window.height() || this.document[ 0 ].body.parentNode.scrollHeight
                    ) - this.helperProportions.height - this.margins.top
                ];
            }
    
            if ( !( /^(document|window|parent)$/ ).test( o.containment ) ) {
                ce = $( o.containment )[ 0 ];
                co = $( o.containment ).offset();
                over = ( $( ce ).css( "overflow" ) !== "hidden" );
    
                this.containment = [
                    co.left + ( parseInt( $( ce ).css( "borderLeftWidth" ), 10 ) || 0 ) +
                        ( parseInt( $( ce ).css( "paddingLeft" ), 10 ) || 0 ) - this.margins.left,
                    co.top + ( parseInt( $( ce ).css( "borderTopWidth" ), 10 ) || 0 ) +
                        ( parseInt( $( ce ).css( "paddingTop" ), 10 ) || 0 ) - this.margins.top,
                    co.left + ( over ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
                        ( parseInt( $( ce ).css( "borderLeftWidth" ), 10 ) || 0 ) -
                        ( parseInt( $( ce ).css( "paddingRight" ), 10 ) || 0 ) -
                        this.helperProportions.width - this.margins.left,
                    co.top + ( over ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
                        ( parseInt( $( ce ).css( "borderTopWidth" ), 10 ) || 0 ) -
                        ( parseInt( $( ce ).css( "paddingBottom" ), 10 ) || 0 ) -
                        this.helperProportions.height - this.margins.top
                ];
            }
    
        },
    
        _convertPositionTo: function( d, pos ) {
    
            if ( !pos ) {
                pos = this.position;
            }
            var mod = d === "absolute" ? 1 : -1,
                scroll = this.cssPosition === "absolute" &&
                    !( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
                    $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ?
                        this.offsetParent :
                        this.scrollParent,
                scrollIsRootNode = ( /(html|body)/i ).test( scroll[ 0 ].tagName );
    
            return {
                top: (
    
                    // The absolute mouse position
                    pos.top	+
    
                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.relative.top * mod +
    
                    // The offsetParent's offset without borders (offset + border)
                    this.offset.parent.top * mod -
                    ( ( this.cssPosition === "fixed" ?
                        -this.scrollParent.scrollTop() :
                        ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod )
                ),
                left: (
    
                    // The absolute mouse position
                    pos.left +
    
                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.relative.left * mod +
    
                    // The offsetParent's offset without borders (offset + border)
                    this.offset.parent.left * mod	-
                    ( ( this.cssPosition === "fixed" ?
                        -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 :
                        scroll.scrollLeft() ) * mod )
                )
            };
    
        },
    
        _generatePosition: function( event ) {
    
            var top, left,
                o = this.options,
                pageX = event.pageX,
                pageY = event.pageY,
                scroll = this.cssPosition === "absolute" &&
                    !( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
                    $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ?
                        this.offsetParent :
                        this.scrollParent,
                    scrollIsRootNode = ( /(html|body)/i ).test( scroll[ 0 ].tagName );
    
            // This is another very weird special case that only happens for relative elements:
            // 1. If the css position is relative
            // 2. and the scroll parent is the document or similar to the offset parent
            // we have to refresh the relative offset during the scroll so there are no jumps
            if ( this.cssPosition === "relative" && !( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
                    this.scrollParent[ 0 ] !== this.offsetParent[ 0 ] ) ) {
                this.offset.relative = this._getRelativeOffset();
            }
    
            /*
             * - Position constraining -
             * Constrain the position to a mix of grid, containment.
             */
    
            if ( this.originalPosition ) { //If we are not dragging yet, we won't check for options
    
                if ( this.containment ) {
                    if ( event.pageX - this.offset.click.left < this.containment[ 0 ] ) {
                        pageX = this.containment[ 0 ] + this.offset.click.left;
                    }
                    if ( event.pageY - this.offset.click.top < this.containment[ 1 ] ) {
                        pageY = this.containment[ 1 ] + this.offset.click.top;
                    }
                    if ( event.pageX - this.offset.click.left > this.containment[ 2 ] ) {
                        pageX = this.containment[ 2 ] + this.offset.click.left;
                    }
                    if ( event.pageY - this.offset.click.top > this.containment[ 3 ] ) {
                        pageY = this.containment[ 3 ] + this.offset.click.top;
                    }
                }
    
                if ( o.grid ) {
                    top = this.originalPageY + Math.round( ( pageY - this.originalPageY ) /
                        o.grid[ 1 ] ) * o.grid[ 1 ];
                    pageY = this.containment ?
                        ( ( top - this.offset.click.top >= this.containment[ 1 ] &&
                            top - this.offset.click.top <= this.containment[ 3 ] ) ?
                                top :
                                ( ( top - this.offset.click.top >= this.containment[ 1 ] ) ?
                                    top - o.grid[ 1 ] : top + o.grid[ 1 ] ) ) :
                                    top;
    
                    left = this.originalPageX + Math.round( ( pageX - this.originalPageX ) /
                        o.grid[ 0 ] ) * o.grid[ 0 ];
                    pageX = this.containment ?
                        ( ( left - this.offset.click.left >= this.containment[ 0 ] &&
                            left - this.offset.click.left <= this.containment[ 2 ] ) ?
                                left :
                                ( ( left - this.offset.click.left >= this.containment[ 0 ] ) ?
                                    left - o.grid[ 0 ] : left + o.grid[ 0 ] ) ) :
                                    left;
                }
    
            }
    
            return {
                top: (
    
                    // The absolute mouse position
                    pageY -
    
                    // Click offset (relative to the element)
                    this.offset.click.top -
    
                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.relative.top -
    
                    // The offsetParent's offset without borders (offset + border)
                    this.offset.parent.top +
                    ( ( this.cssPosition === "fixed" ?
                        -this.scrollParent.scrollTop() :
                        ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) )
                ),
                left: (
    
                    // The absolute mouse position
                    pageX -
    
                    // Click offset (relative to the element)
                    this.offset.click.left -
    
                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.relative.left -
    
                    // The offsetParent's offset without borders (offset + border)
                    this.offset.parent.left +
                    ( ( this.cssPosition === "fixed" ?
                        -this.scrollParent.scrollLeft() :
                        scrollIsRootNode ? 0 : scroll.scrollLeft() ) )
                )
            };
    
        },
    
        _rearrange: function( event, i, a, hardRefresh ) {
    
            a ? a[ 0 ].appendChild( this.placeholder[ 0 ] ) :
                i.item[ 0 ].parentNode.insertBefore( this.placeholder[ 0 ],
                    ( this.direction === "down" ? i.item[ 0 ] : i.item[ 0 ].nextSibling ) );
    
            //Various things done here to improve the performance:
            // 1. we create a setTimeout, that calls refreshPositions
            // 2. on the instance, we have a counter variable, that get's higher after every append
            // 3. on the local scope, we copy the counter variable, and check in the timeout,
            // if it's still the same
            // 4. this lets only the last addition to the timeout stack through
            this.counter = this.counter ? ++this.counter : 1;
            var counter = this.counter;
    
            this._delay( function() {
                if ( counter === this.counter ) {
    
                    //Precompute after each DOM insertion, NOT on mousemove
                    this.refreshPositions( !hardRefresh );
                }
            } );
    
        },
    
        _clear: function( event, noPropagation ) {
    
            this.reverting = false;
    
            // We delay all events that have to be triggered to after the point where the placeholder
            // has been removed and everything else normalized again
            var i,
                delayedTriggers = [];
    
            // We first have to update the dom position of the actual currentItem
            // Note: don't do it if the current item is already removed (by a user), or it gets
            // reappended (see #4088)
            if ( !this._noFinalSort && this.currentItem.parent().length ) {
                this.placeholder.before( this.currentItem );
            }
            this._noFinalSort = null;
    
            if ( this.helper[ 0 ] === this.currentItem[ 0 ] ) {
                for ( i in this._storedCSS ) {
                    if ( this._storedCSS[ i ] === "auto" || this._storedCSS[ i ] === "static" ) {
                        this._storedCSS[ i ] = "";
                    }
                }
                this.currentItem.css( this._storedCSS );
                this._removeClass( this.currentItem, "ui-sortable-helper" );
            } else {
                this.currentItem.show();
            }
    
            if ( this.fromOutside && !noPropagation ) {
                delayedTriggers.push( function( event ) {
                    this._trigger( "receive", event, this._uiHash( this.fromOutside ) );
                } );
            }
            if ( ( this.fromOutside ||
                    this.domPosition.prev !==
                    this.currentItem.prev().not( ".ui-sortable-helper" )[ 0 ] ||
                    this.domPosition.parent !== this.currentItem.parent()[ 0 ] ) && !noPropagation ) {
    
                // Trigger update callback if the DOM position has changed
                delayedTriggers.push( function( event ) {
                    this._trigger( "update", event, this._uiHash() );
                } );
            }
    
            // Check if the items Container has Changed and trigger appropriate
            // events.
            if ( this !== this.currentContainer ) {
                if ( !noPropagation ) {
                    delayedTriggers.push( function( event ) {
                        this._trigger( "remove", event, this._uiHash() );
                    } );
                    delayedTriggers.push( ( function( c ) {
                        return function( event ) {
                            c._trigger( "receive", event, this._uiHash( this ) );
                        };
                    } ).call( this, this.currentContainer ) );
                    delayedTriggers.push( ( function( c ) {
                        return function( event ) {
                            c._trigger( "update", event, this._uiHash( this ) );
                        };
                    } ).call( this, this.currentContainer ) );
                }
            }
    
            //Post events to containers
            function delayEvent( type, instance, container ) {
                return function( event ) {
                    container._trigger( type, event, instance._uiHash( instance ) );
                };
            }
            for ( i = this.containers.length - 1; i >= 0; i-- ) {
                if ( !noPropagation ) {
                    delayedTriggers.push( delayEvent( "deactivate", this, this.containers[ i ] ) );
                }
                if ( this.containers[ i ].containerCache.over ) {
                    delayedTriggers.push( delayEvent( "out", this, this.containers[ i ] ) );
                    this.containers[ i ].containerCache.over = 0;
                }
            }
    
            //Do what was originally in plugins
            if ( this.storedCursor ) {
                this.document.find( "body" ).css( "cursor", this.storedCursor );
                this.storedStylesheet.remove();
            }
            if ( this._storedOpacity ) {
                this.helper.css( "opacity", this._storedOpacity );
            }
            if ( this._storedZIndex ) {
                this.helper.css( "zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex );
            }
    
            this.dragging = false;
    
            if ( !noPropagation ) {
                this._trigger( "beforeStop", event, this._uiHash() );
            }
    
            //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,
            // it unbinds ALL events from the original node!
            this.placeholder[ 0 ].parentNode.removeChild( this.placeholder[ 0 ] );
    
            if ( !this.cancelHelperRemoval ) {
                if ( this.helper[ 0 ] !== this.currentItem[ 0 ] ) {
                    this.helper.remove();
                }
                this.helper = null;
            }
    
            if ( !noPropagation ) {
                for ( i = 0; i < delayedTriggers.length; i++ ) {
    
                    // Trigger all delayed events
                    delayedTriggers[ i ].call( this, event );
                }
                this._trigger( "stop", event, this._uiHash() );
            }
    
            this.fromOutside = false;
            return !this.cancelHelperRemoval;
    
        },
    
        _trigger: function() {
            if ( $.Widget.prototype._trigger.apply( this, arguments ) === false ) {
                this.cancel();
            }
        },
    
        _uiHash: function( _inst ) {
            var inst = _inst || this;
            return {
                helper: inst.helper,
                placeholder: inst.placeholder || $( [] ),
                position: inst.position,
                originalPosition: inst.originalPosition,
                offset: inst.positionAbs,
                item: inst.currentItem,
                sender: _inst ? _inst.element : null
            };
        }
    
    } );
    
    
    /*!
     * jQuery UI Spinner 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Spinner
    //>>group: Widgets
    //>>description: Displays buttons to easily input numbers via the keyboard or mouse.
    //>>docs: http://api.jqueryui.com/spinner/
    //>>demos: http://jqueryui.com/spinner/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/spinner.css
    //>>css.theme: ../../themes/base/theme.css
    
    
    
    function spinnerModifer( fn ) {
        return function() {
            var previous = this.element.val();
            fn.apply( this, arguments );
            this._refresh();
            if ( previous !== this.element.val() ) {
                this._trigger( "change" );
            }
        };
    }
    
    $.widget( "ui.spinner", {
        version: "1.12.1",
        defaultElement: "<input>",
        widgetEventPrefix: "spin",
        options: {
            classes: {
                "ui-spinner": "ui-corner-all",
                "ui-spinner-down": "ui-corner-br",
                "ui-spinner-up": "ui-corner-tr"
            },
            culture: null,
            icons: {
                down: "ui-icon-triangle-1-s",
                up: "ui-icon-triangle-1-n"
            },
            incremental: true,
            max: null,
            min: null,
            numberFormat: null,
            page: 10,
            step: 1,
    
            change: null,
            spin: null,
            start: null,
            stop: null
        },
    
        _create: function() {
    
            // handle string values that need to be parsed
            this._setOption( "max", this.options.max );
            this._setOption( "min", this.options.min );
            this._setOption( "step", this.options.step );
    
            // Only format if there is a value, prevents the field from being marked
            // as invalid in Firefox, see #9573.
            if ( this.value() !== "" ) {
    
                // Format the value, but don't constrain.
                this._value( this.element.val(), true );
            }
    
            this._draw();
            this._on( this._events );
            this._refresh();
    
            // Turning off autocomplete prevents the browser from remembering the
            // value when navigating through history, so we re-enable autocomplete
            // if the page is unloaded before the widget is destroyed. #7790
            this._on( this.window, {
                beforeunload: function() {
                    this.element.removeAttr( "autocomplete" );
                }
            } );
        },
    
        _getCreateOptions: function() {
            var options = this._super();
            var element = this.element;
    
            $.each( [ "min", "max", "step" ], function( i, option ) {
                var value = element.attr( option );
                if ( value != null && value.length ) {
                    options[ option ] = value;
                }
            } );
    
            return options;
        },
    
        _events: {
            keydown: function( event ) {
                if ( this._start( event ) && this._keydown( event ) ) {
                    event.preventDefault();
                }
            },
            keyup: "_stop",
            focus: function() {
                this.previous = this.element.val();
            },
            blur: function( event ) {
                if ( this.cancelBlur ) {
                    delete this.cancelBlur;
                    return;
                }
    
                this._stop();
                this._refresh();
                if ( this.previous !== this.element.val() ) {
                    this._trigger( "change", event );
                }
            },
            mousewheel: function( event, delta ) {
                if ( !delta ) {
                    return;
                }
                if ( !this.spinning && !this._start( event ) ) {
                    return false;
                }
    
                this._spin( ( delta > 0 ? 1 : -1 ) * this.options.step, event );
                clearTimeout( this.mousewheelTimer );
                this.mousewheelTimer = this._delay( function() {
                    if ( this.spinning ) {
                        this._stop( event );
                    }
                }, 100 );
                event.preventDefault();
            },
            "mousedown .ui-spinner-button": function( event ) {
                var previous;
    
                // We never want the buttons to have focus; whenever the user is
                // interacting with the spinner, the focus should be on the input.
                // If the input is focused then this.previous is properly set from
                // when the input first received focus. If the input is not focused
                // then we need to set this.previous based on the value before spinning.
                previous = this.element[ 0 ] === $.ui.safeActiveElement( this.document[ 0 ] ) ?
                    this.previous : this.element.val();
                function checkFocus() {
                    var isActive = this.element[ 0 ] === $.ui.safeActiveElement( this.document[ 0 ] );
                    if ( !isActive ) {
                        this.element.trigger( "focus" );
                        this.previous = previous;
    
                        // support: IE
                        // IE sets focus asynchronously, so we need to check if focus
                        // moved off of the input because the user clicked on the button.
                        this._delay( function() {
                            this.previous = previous;
                        } );
                    }
                }
    
                // Ensure focus is on (or stays on) the text field
                event.preventDefault();
                checkFocus.call( this );
    
                // Support: IE
                // IE doesn't prevent moving focus even with event.preventDefault()
                // so we set a flag to know when we should ignore the blur event
                // and check (again) if focus moved off of the input.
                this.cancelBlur = true;
                this._delay( function() {
                    delete this.cancelBlur;
                    checkFocus.call( this );
                } );
    
                if ( this._start( event ) === false ) {
                    return;
                }
    
                this._repeat( null, $( event.currentTarget )
                    .hasClass( "ui-spinner-up" ) ? 1 : -1, event );
            },
            "mouseup .ui-spinner-button": "_stop",
            "mouseenter .ui-spinner-button": function( event ) {
    
                // button will add ui-state-active if mouse was down while mouseleave and kept down
                if ( !$( event.currentTarget ).hasClass( "ui-state-active" ) ) {
                    return;
                }
    
                if ( this._start( event ) === false ) {
                    return false;
                }
                this._repeat( null, $( event.currentTarget )
                    .hasClass( "ui-spinner-up" ) ? 1 : -1, event );
            },
    
            // TODO: do we really want to consider this a stop?
            // shouldn't we just stop the repeater and wait until mouseup before
            // we trigger the stop event?
            "mouseleave .ui-spinner-button": "_stop"
        },
    
        // Support mobile enhanced option and make backcompat more sane
        _enhance: function() {
            this.uiSpinner = this.element
                .attr( "autocomplete", "off" )
                .wrap( "<span>" )
                .parent()
    
                    // Add buttons
                    .append(
                        "<a></a><a></a>"
                    );
        },
    
        _draw: function() {
            this._enhance();
    
            this._addClass( this.uiSpinner, "ui-spinner", "ui-widget ui-widget-content" );
            this._addClass( "ui-spinner-input" );
    
            this.element.attr( "role", "spinbutton" );
    
            // Button bindings
            this.buttons = this.uiSpinner.children( "a" )
                .attr( "tabIndex", -1 )
                .attr( "aria-hidden", true )
                .button( {
                    classes: {
                        "ui-button": ""
                    }
                } );
    
            // TODO: Right now button does not support classes this is already updated in button PR
            this._removeClass( this.buttons, "ui-corner-all" );
    
            this._addClass( this.buttons.first(), "ui-spinner-button ui-spinner-up" );
            this._addClass( this.buttons.last(), "ui-spinner-button ui-spinner-down" );
            this.buttons.first().button( {
                "icon": this.options.icons.up,
                "showLabel": false
            } );
            this.buttons.last().button( {
                "icon": this.options.icons.down,
                "showLabel": false
            } );
    
            // IE 6 doesn't understand height: 50% for the buttons
            // unless the wrapper has an explicit height
            if ( this.buttons.height() > Math.ceil( this.uiSpinner.height() * 0.5 ) &&
                    this.uiSpinner.height() > 0 ) {
                this.uiSpinner.height( this.uiSpinner.height() );
            }
        },
    
        _keydown: function( event ) {
            var options = this.options,
                keyCode = $.ui.keyCode;
    
            switch ( event.keyCode ) {
            case keyCode.UP:
                this._repeat( null, 1, event );
                return true;
            case keyCode.DOWN:
                this._repeat( null, -1, event );
                return true;
            case keyCode.PAGE_UP:
                this._repeat( null, options.page, event );
                return true;
            case keyCode.PAGE_DOWN:
                this._repeat( null, -options.page, event );
                return true;
            }
    
            return false;
        },
    
        _start: function( event ) {
            if ( !this.spinning && this._trigger( "start", event ) === false ) {
                return false;
            }
    
            if ( !this.counter ) {
                this.counter = 1;
            }
            this.spinning = true;
            return true;
        },
    
        _repeat: function( i, steps, event ) {
            i = i || 500;
    
            clearTimeout( this.timer );
            this.timer = this._delay( function() {
                this._repeat( 40, steps, event );
            }, i );
    
            this._spin( steps * this.options.step, event );
        },
    
        _spin: function( step, event ) {
            var value = this.value() || 0;
    
            if ( !this.counter ) {
                this.counter = 1;
            }
    
            value = this._adjustValue( value + step * this._increment( this.counter ) );
    
            if ( !this.spinning || this._trigger( "spin", event, { value: value } ) !== false ) {
                this._value( value );
                this.counter++;
            }
        },
    
        _increment: function( i ) {
            var incremental = this.options.incremental;
    
            if ( incremental ) {
                return $.isFunction( incremental ) ?
                    incremental( i ) :
                    Math.floor( i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1 );
            }
    
            return 1;
        },
    
        _precision: function() {
            var precision = this._precisionOf( this.options.step );
            if ( this.options.min !== null ) {
                precision = Math.max( precision, this._precisionOf( this.options.min ) );
            }
            return precision;
        },
    
        _precisionOf: function( num ) {
            var str = num.toString(),
                decimal = str.indexOf( "." );
            return decimal === -1 ? 0 : str.length - decimal - 1;
        },
    
        _adjustValue: function( value ) {
            var base, aboveMin,
                options = this.options;
    
            // Make sure we're at a valid step
            // - find out where we are relative to the base (min or 0)
            base = options.min !== null ? options.min : 0;
            aboveMin = value - base;
    
            // - round to the nearest step
            aboveMin = Math.round( aboveMin / options.step ) * options.step;
    
            // - rounding is based on 0, so adjust back to our base
            value = base + aboveMin;
    
            // Fix precision from bad JS floating point math
            value = parseFloat( value.toFixed( this._precision() ) );
    
            // Clamp the value
            if ( options.max !== null && value > options.max ) {
                return options.max;
            }
            if ( options.min !== null && value < options.min ) {
                return options.min;
            }
    
            return value;
        },
    
        _stop: function( event ) {
            if ( !this.spinning ) {
                return;
            }
    
            clearTimeout( this.timer );
            clearTimeout( this.mousewheelTimer );
            this.counter = 0;
            this.spinning = false;
            this._trigger( "stop", event );
        },
    
        _setOption: function( key, value ) {
            var prevValue, first, last;
    
            if ( key === "culture" || key === "numberFormat" ) {
                prevValue = this._parse( this.element.val() );
                this.options[ key ] = value;
                this.element.val( this._format( prevValue ) );
                return;
            }
    
            if ( key === "max" || key === "min" || key === "step" ) {
                if ( typeof value === "string" ) {
                    value = this._parse( value );
                }
            }
            if ( key === "icons" ) {
                first = this.buttons.first().find( ".ui-icon" );
                this._removeClass( first, null, this.options.icons.up );
                this._addClass( first, null, value.up );
                last = this.buttons.last().find( ".ui-icon" );
                this._removeClass( last, null, this.options.icons.down );
                this._addClass( last, null, value.down );
            }
    
            this._super( key, value );
        },
    
        _setOptionDisabled: function( value ) {
            this._super( value );
    
            this._toggleClass( this.uiSpinner, null, "ui-state-disabled", !!value );
            this.element.prop( "disabled", !!value );
            this.buttons.button( value ? "disable" : "enable" );
        },
    
        _setOptions: spinnerModifer( function( options ) {
            this._super( options );
        } ),
    
        _parse: function( val ) {
            if ( typeof val === "string" && val !== "" ) {
                val = window.Globalize && this.options.numberFormat ?
                    Globalize.parseFloat( val, 10, this.options.culture ) : +val;
            }
            return val === "" || isNaN( val ) ? null : val;
        },
    
        _format: function( value ) {
            if ( value === "" ) {
                return "";
            }
            return window.Globalize && this.options.numberFormat ?
                Globalize.format( value, this.options.numberFormat, this.options.culture ) :
                value;
        },
    
        _refresh: function() {
            this.element.attr( {
                "aria-valuemin": this.options.min,
                "aria-valuemax": this.options.max,
    
                // TODO: what should we do with values that can't be parsed?
                "aria-valuenow": this._parse( this.element.val() )
            } );
        },
    
        isValid: function() {
            var value = this.value();
    
            // Null is invalid
            if ( value === null ) {
                return false;
            }
    
            // If value gets adjusted, it's invalid
            return value === this._adjustValue( value );
        },
    
        // Update the value without triggering change
        _value: function( value, allowAny ) {
            var parsed;
            if ( value !== "" ) {
                parsed = this._parse( value );
                if ( parsed !== null ) {
                    if ( !allowAny ) {
                        parsed = this._adjustValue( parsed );
                    }
                    value = this._format( parsed );
                }
            }
            this.element.val( value );
            this._refresh();
        },
    
        _destroy: function() {
            this.element
                .prop( "disabled", false )
                .removeAttr( "autocomplete role aria-valuemin aria-valuemax aria-valuenow" );
    
            this.uiSpinner.replaceWith( this.element );
        },
    
        stepUp: spinnerModifer( function( steps ) {
            this._stepUp( steps );
        } ),
        _stepUp: function( steps ) {
            if ( this._start() ) {
                this._spin( ( steps || 1 ) * this.options.step );
                this._stop();
            }
        },
    
        stepDown: spinnerModifer( function( steps ) {
            this._stepDown( steps );
        } ),
        _stepDown: function( steps ) {
            if ( this._start() ) {
                this._spin( ( steps || 1 ) * -this.options.step );
                this._stop();
            }
        },
    
        pageUp: spinnerModifer( function( pages ) {
            this._stepUp( ( pages || 1 ) * this.options.page );
        } ),
    
        pageDown: spinnerModifer( function( pages ) {
            this._stepDown( ( pages || 1 ) * this.options.page );
        } ),
    
        value: function( newVal ) {
            if ( !arguments.length ) {
                return this._parse( this.element.val() );
            }
            spinnerModifer( this._value ).call( this, newVal );
        },
    
        widget: function() {
            return this.uiSpinner;
        }
    } );
    
    // DEPRECATED
    // TODO: switch return back to widget declaration at top of file when this is removed
    if ( $.uiBackCompat !== false ) {
    
        // Backcompat for spinner html extension points
        $.widget( "ui.spinner", $.ui.spinner, {
            _enhance: function() {
                this.uiSpinner = this.element
                    .attr( "autocomplete", "off" )
                    .wrap( this._uiSpinnerHtml() )
                    .parent()
    
                        // Add buttons
                        .append( this._buttonHtml() );
            },
            _uiSpinnerHtml: function() {
                return "<span>";
            },
    
            _buttonHtml: function() {
                return "<a></a><a></a>";
            }
        } );
    }
    
    var widgetsSpinner = $.ui.spinner;
    
    
    /*!
     * jQuery UI Tabs 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Tabs
    //>>group: Widgets
    //>>description: Transforms a set of container elements into a tab structure.
    //>>docs: http://api.jqueryui.com/tabs/
    //>>demos: http://jqueryui.com/tabs/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/tabs.css
    //>>css.theme: ../../themes/base/theme.css
    
    
    
    $.widget( "ui.tabs", {
        version: "1.12.1",
        delay: 300,
        options: {
            active: null,
            classes: {
                "ui-tabs": "ui-corner-all",
                "ui-tabs-nav": "ui-corner-all",
                "ui-tabs-panel": "ui-corner-bottom",
                "ui-tabs-tab": "ui-corner-top"
            },
            collapsible: false,
            event: "click",
            heightStyle: "content",
            hide: null,
            show: null,
    
            // Callbacks
            activate: null,
            beforeActivate: null,
            beforeLoad: null,
            load: null
        },
    
        _isLocal: ( function() {
            var rhash = /#.*$/;
    
            return function( anchor ) {
                var anchorUrl, locationUrl;
    
                anchorUrl = anchor.href.replace( rhash, "" );
                locationUrl = location.href.replace( rhash, "" );
    
                // Decoding may throw an error if the URL isn't UTF-8 (#9518)
                try {
                    anchorUrl = decodeURIComponent( anchorUrl );
                } catch ( error ) {}
                try {
                    locationUrl = decodeURIComponent( locationUrl );
                } catch ( error ) {}
    
                return anchor.hash.length > 1 && anchorUrl === locationUrl;
            };
        } )(),
    
        _create: function() {
            var that = this,
                options = this.options;
    
            this.running = false;
    
            this._addClass( "ui-tabs", "ui-widget ui-widget-content" );
            this._toggleClass( "ui-tabs-collapsible", null, options.collapsible );
    
            this._processTabs();
            options.active = this._initialActive();
    
            // Take disabling tabs via class attribute from HTML
            // into account and update option properly.
            if ( $.isArray( options.disabled ) ) {
                options.disabled = $.unique( options.disabled.concat(
                    $.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {
                        return that.tabs.index( li );
                    } )
                ) ).sort();
            }
    
            // Check for length avoids error when initializing empty list
            if ( this.options.active !== false && this.anchors.length ) {
                this.active = this._findActive( options.active );
            } else {
                this.active = $();
            }
    
            this._refresh();
    
            if ( this.active.length ) {
                this.load( options.active );
            }
        },
    
        _initialActive: function() {
            var active = this.options.active,
                collapsible = this.options.collapsible,
                locationHash = location.hash.substring( 1 );
    
            if ( active === null ) {
    
                // check the fragment identifier in the URL
                if ( locationHash ) {
                    this.tabs.each( function( i, tab ) {
                        if ( $( tab ).attr( "aria-controls" ) === locationHash ) {
                            active = i;
                            return false;
                        }
                    } );
                }
    
                // Check for a tab marked active via a class
                if ( active === null ) {
                    active = this.tabs.index( this.tabs.filter( ".ui-tabs-active" ) );
                }
    
                // No active tab, set to false
                if ( active === null || active === -1 ) {
                    active = this.tabs.length ? 0 : false;
                }
            }
    
            // Handle numbers: negative, out of range
            if ( active !== false ) {
                active = this.tabs.index( this.tabs.eq( active ) );
                if ( active === -1 ) {
                    active = collapsible ? false : 0;
                }
            }
    
            // Don't allow collapsible: false and active: false
            if ( !collapsible && active === false && this.anchors.length ) {
                active = 0;
            }
    
            return active;
        },
    
        _getCreateEventData: function() {
            return {
                tab: this.active,
                panel: !this.active.length ? $() : this._getPanelForTab( this.active )
            };
        },
    
        _tabKeydown: function( event ) {
            var focusedTab = $( $.ui.safeActiveElement( this.document[ 0 ] ) ).closest( "li" ),
                selectedIndex = this.tabs.index( focusedTab ),
                goingForward = true;
    
            if ( this._handlePageNav( event ) ) {
                return;
            }
    
            switch ( event.keyCode ) {
            case $.ui.keyCode.RIGHT:
            case $.ui.keyCode.DOWN:
                selectedIndex++;
                break;
            case $.ui.keyCode.UP:
            case $.ui.keyCode.LEFT:
                goingForward = false;
                selectedIndex--;
                break;
            case $.ui.keyCode.END:
                selectedIndex = this.anchors.length - 1;
                break;
            case $.ui.keyCode.HOME:
                selectedIndex = 0;
                break;
            case $.ui.keyCode.SPACE:
    
                // Activate only, no collapsing
                event.preventDefault();
                clearTimeout( this.activating );
                this._activate( selectedIndex );
                return;
            case $.ui.keyCode.ENTER:
    
                // Toggle (cancel delayed activation, allow collapsing)
                event.preventDefault();
                clearTimeout( this.activating );
    
                // Determine if we should collapse or activate
                this._activate( selectedIndex === this.options.active ? false : selectedIndex );
                return;
            default:
                return;
            }
    
            // Focus the appropriate tab, based on which key was pressed
            event.preventDefault();
            clearTimeout( this.activating );
            selectedIndex = this._focusNextTab( selectedIndex, goingForward );
    
            // Navigating with control/command key will prevent automatic activation
            if ( !event.ctrlKey && !event.metaKey ) {
    
                // Update aria-selected immediately so that AT think the tab is already selected.
                // Otherwise AT may confuse the user by stating that they need to activate the tab,
                // but the tab will already be activated by the time the announcement finishes.
                focusedTab.attr( "aria-selected", "false" );
                this.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );
    
                this.activating = this._delay( function() {
                    this.option( "active", selectedIndex );
                }, this.delay );
            }
        },
    
        _panelKeydown: function( event ) {
            if ( this._handlePageNav( event ) ) {
                return;
            }
    
            // Ctrl+up moves focus to the current tab
            if ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {
                event.preventDefault();
                this.active.trigger( "focus" );
            }
        },
    
        // Alt+page up/down moves focus to the previous/next tab (and activates)
        _handlePageNav: function( event ) {
            if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {
                this._activate( this._focusNextTab( this.options.active - 1, false ) );
                return true;
            }
            if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {
                this._activate( this._focusNextTab( this.options.active + 1, true ) );
                return true;
            }
        },
    
        _findNextTab: function( index, goingForward ) {
            var lastTabIndex = this.tabs.length - 1;
    
            function constrain() {
                if ( index > lastTabIndex ) {
                    index = 0;
                }
                if ( index < 0 ) {
                    index = lastTabIndex;
                }
                return index;
            }
    
            while ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {
                index = goingForward ? index + 1 : index - 1;
            }
    
            return index;
        },
    
        _focusNextTab: function( index, goingForward ) {
            index = this._findNextTab( index, goingForward );
            this.tabs.eq( index ).trigger( "focus" );
            return index;
        },
    
        _setOption: function( key, value ) {
            if ( key === "active" ) {
    
                // _activate() will handle invalid values and update this.options
                this._activate( value );
                return;
            }
    
            this._super( key, value );
    
            if ( key === "collapsible" ) {
                this._toggleClass( "ui-tabs-collapsible", null, value );
    
                // Setting collapsible: false while collapsed; open first panel
                if ( !value && this.options.active === false ) {
                    this._activate( 0 );
                }
            }
    
            if ( key === "event" ) {
                this._setupEvents( value );
            }
    
            if ( key === "heightStyle" ) {
                this._setupHeightStyle( value );
            }
        },
    
        _sanitizeSelector: function( hash ) {
            return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
        },
    
        refresh: function() {
            var options = this.options,
                lis = this.tablist.children( ":has(a[href])" );
    
            // Get disabled tabs from class attribute from HTML
            // this will get converted to a boolean if needed in _refresh()
            options.disabled = $.map( lis.filter( ".ui-state-disabled" ), function( tab ) {
                return lis.index( tab );
            } );
    
            this._processTabs();
    
            // Was collapsed or no tabs
            if ( options.active === false || !this.anchors.length ) {
                options.active = false;
                this.active = $();
    
            // was active, but active tab is gone
            } else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {
    
                // all remaining tabs are disabled
                if ( this.tabs.length === options.disabled.length ) {
                    options.active = false;
                    this.active = $();
    
                // activate previous tab
                } else {
                    this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );
                }
    
            // was active, active tab still exists
            } else {
    
                // make sure active index is correct
                options.active = this.tabs.index( this.active );
            }
    
            this._refresh();
        },
    
        _refresh: function() {
            this._setOptionDisabled( this.options.disabled );
            this._setupEvents( this.options.event );
            this._setupHeightStyle( this.options.heightStyle );
    
            this.tabs.not( this.active ).attr( {
                "aria-selected": "false",
                "aria-expanded": "false",
                tabIndex: -1
            } );
            this.panels.not( this._getPanelForTab( this.active ) )
                .hide()
                .attr( {
                    "aria-hidden": "true"
                } );
    
            // Make sure one tab is in the tab order
            if ( !this.active.length ) {
                this.tabs.eq( 0 ).attr( "tabIndex", 0 );
            } else {
                this.active
                    .attr( {
                        "aria-selected": "true",
                        "aria-expanded": "true",
                        tabIndex: 0
                    } );
                this._addClass( this.active, "ui-tabs-active", "ui-state-active" );
                this._getPanelForTab( this.active )
                    .show()
                    .attr( {
                        "aria-hidden": "false"
                    } );
            }
        },
    
        _processTabs: function() {
            var that = this,
                prevTabs = this.tabs,
                prevAnchors = this.anchors,
                prevPanels = this.panels;
    
            this.tablist = this._getList().attr( "role", "tablist" );
            this._addClass( this.tablist, "ui-tabs-nav",
                "ui-helper-reset ui-helper-clearfix ui-widget-header" );
    
            // Prevent users from focusing disabled tabs via click
            this.tablist
                .on( "mousedown" + this.eventNamespace, "> li", function( event ) {
                    if ( $( this ).is( ".ui-state-disabled" ) ) {
                        event.preventDefault();
                    }
                } )
    
                // Support: IE <9
                // Preventing the default action in mousedown doesn't prevent IE
                // from focusing the element, so if the anchor gets focused, blur.
                // We don't have to worry about focusing the previously focused
                // element since clicking on a non-focusable element should focus
                // the body anyway.
                .on( "focus" + this.eventNamespace, ".ui-tabs-anchor", function() {
                    if ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {
                        this.blur();
                    }
                } );
    
            this.tabs = this.tablist.find( "> li:has(a[href])" )
                .attr( {
                    role: "tab",
                    tabIndex: -1
                } );
            this._addClass( this.tabs, "ui-tabs-tab", "ui-state-default" );
    
            this.anchors = this.tabs.map( function() {
                return $( "a", this )[ 0 ];
            } )
                .attr( {
                    role: "presentation",
                    tabIndex: -1
                } );
            this._addClass( this.anchors, "ui-tabs-anchor" );
    
            this.panels = $();
    
            this.anchors.each( function( i, anchor ) {
                var selector, panel, panelId,
                    anchorId = $( anchor ).uniqueId().attr( "id" ),
                    tab = $( anchor ).closest( "li" ),
                    originalAriaControls = tab.attr( "aria-controls" );
    
                // Inline tab
                if ( that._isLocal( anchor ) ) {
                    selector = anchor.hash;
                    panelId = selector.substring( 1 );
                    panel = that.element.find( that._sanitizeSelector( selector ) );
    
                // remote tab
                } else {
    
                    // If the tab doesn't already have aria-controls,
                    // generate an id by using a throw-away element
                    panelId = tab.attr( "aria-controls" ) || $( {} ).uniqueId()[ 0 ].id;
                    selector = "#" + panelId;
                    panel = that.element.find( selector );
                    if ( !panel.length ) {
                        panel = that._createPanel( panelId );
                        panel.insertAfter( that.panels[ i - 1 ] || that.tablist );
                    }
                    panel.attr( "aria-live", "polite" );
                }
    
                if ( panel.length ) {
                    that.panels = that.panels.add( panel );
                }
                if ( originalAriaControls ) {
                    tab.data( "ui-tabs-aria-controls", originalAriaControls );
                }
                tab.attr( {
                    "aria-controls": panelId,
                    "aria-labelledby": anchorId
                } );
                panel.attr( "aria-labelledby", anchorId );
            } );
    
            this.panels.attr( "role", "tabpanel" );
            this._addClass( this.panels, "ui-tabs-panel", "ui-widget-content" );
    
            // Avoid memory leaks (#10056)
            if ( prevTabs ) {
                this._off( prevTabs.not( this.tabs ) );
                this._off( prevAnchors.not( this.anchors ) );
                this._off( prevPanels.not( this.panels ) );
            }
        },
    
        // Allow overriding how to find the list for rare usage scenarios (#7715)
        _getList: function() {
            return this.tablist || this.element.find( "ol, ul" ).eq( 0 );
        },
    
        _createPanel: function( id ) {
            return $( "<div>" )
                .attr( "id", id )
                .data( "ui-tabs-destroy", true );
        },
    
        _setOptionDisabled: function( disabled ) {
            var currentItem, li, i;
    
            if ( $.isArray( disabled ) ) {
                if ( !disabled.length ) {
                    disabled = false;
                } else if ( disabled.length === this.anchors.length ) {
                    disabled = true;
                }
            }
    
            // Disable tabs
            for ( i = 0; ( li = this.tabs[ i ] ); i++ ) {
                currentItem = $( li );
                if ( disabled === true || $.inArray( i, disabled ) !== -1 ) {
                    currentItem.attr( "aria-disabled", "true" );
                    this._addClass( currentItem, null, "ui-state-disabled" );
                } else {
                    currentItem.removeAttr( "aria-disabled" );
                    this._removeClass( currentItem, null, "ui-state-disabled" );
                }
            }
    
            this.options.disabled = disabled;
    
            this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null,
                disabled === true );
        },
    
        _setupEvents: function( event ) {
            var events = {};
            if ( event ) {
                $.each( event.split( " " ), function( index, eventName ) {
                    events[ eventName ] = "_eventHandler";
                } );
            }
    
            this._off( this.anchors.add( this.tabs ).add( this.panels ) );
    
            // Always prevent the default action, even when disabled
            this._on( true, this.anchors, {
                click: function( event ) {
                    event.preventDefault();
                }
            } );
            this._on( this.anchors, events );
            this._on( this.tabs, { keydown: "_tabKeydown" } );
            this._on( this.panels, { keydown: "_panelKeydown" } );
    
            this._focusable( this.tabs );
            this._hoverable( this.tabs );
        },
    
        _setupHeightStyle: function( heightStyle ) {
            var maxHeight,
                parent = this.element.parent();
    
            if ( heightStyle === "fill" ) {
                maxHeight = parent.height();
                maxHeight -= this.element.outerHeight() - this.element.height();
    
                this.element.siblings( ":visible" ).each( function() {
                    var elem = $( this ),
                        position = elem.css( "position" );
    
                    if ( position === "absolute" || position === "fixed" ) {
                        return;
                    }
                    maxHeight -= elem.outerHeight( true );
                } );
    
                this.element.children().not( this.panels ).each( function() {
                    maxHeight -= $( this ).outerHeight( true );
                } );
    
                this.panels.each( function() {
                    $( this ).height( Math.max( 0, maxHeight -
                        $( this ).innerHeight() + $( this ).height() ) );
                } )
                    .css( "overflow", "auto" );
            } else if ( heightStyle === "auto" ) {
                maxHeight = 0;
                this.panels.each( function() {
                    maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
                } ).height( maxHeight );
            }
        },
    
        _eventHandler: function( event ) {
            var options = this.options,
                active = this.active,
                anchor = $( event.currentTarget ),
                tab = anchor.closest( "li" ),
                clickedIsActive = tab[ 0 ] === active[ 0 ],
                collapsing = clickedIsActive && options.collapsible,
                toShow = collapsing ? $() : this._getPanelForTab( tab ),
                toHide = !active.length ? $() : this._getPanelForTab( active ),
                eventData = {
                    oldTab: active,
                    oldPanel: toHide,
                    newTab: collapsing ? $() : tab,
                    newPanel: toShow
                };
    
            event.preventDefault();
    
            if ( tab.hasClass( "ui-state-disabled" ) ||
    
                    // tab is already loading
                    tab.hasClass( "ui-tabs-loading" ) ||
    
                    // can't switch durning an animation
                    this.running ||
    
                    // click on active header, but not collapsible
                    ( clickedIsActive && !options.collapsible ) ||
    
                    // allow canceling activation
                    ( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
                return;
            }
    
            options.active = collapsing ? false : this.tabs.index( tab );
    
            this.active = clickedIsActive ? $() : tab;
            if ( this.xhr ) {
                this.xhr.abort();
            }
    
            if ( !toHide.length && !toShow.length ) {
                $.error( "jQuery UI Tabs: Mismatching fragment identifier." );
            }
    
            if ( toShow.length ) {
                this.load( this.tabs.index( tab ), event );
            }
            this._toggle( event, eventData );
        },
    
        // Handles show/hide for selecting tabs
        _toggle: function( event, eventData ) {
            var that = this,
                toShow = eventData.newPanel,
                toHide = eventData.oldPanel;
    
            this.running = true;
    
            function complete() {
                that.running = false;
                that._trigger( "activate", event, eventData );
            }
    
            function show() {
                that._addClass( eventData.newTab.closest( "li" ), "ui-tabs-active", "ui-state-active" );
    
                if ( toShow.length && that.options.show ) {
                    that._show( toShow, that.options.show, complete );
                } else {
                    toShow.show();
                    complete();
                }
            }
    
            // Start out by hiding, then showing, then completing
            if ( toHide.length && this.options.hide ) {
                this._hide( toHide, this.options.hide, function() {
                    that._removeClass( eventData.oldTab.closest( "li" ),
                        "ui-tabs-active", "ui-state-active" );
                    show();
                } );
            } else {
                this._removeClass( eventData.oldTab.closest( "li" ),
                    "ui-tabs-active", "ui-state-active" );
                toHide.hide();
                show();
            }
    
            toHide.attr( "aria-hidden", "true" );
            eventData.oldTab.attr( {
                "aria-selected": "false",
                "aria-expanded": "false"
            } );
    
            // If we're switching tabs, remove the old tab from the tab order.
            // If we're opening from collapsed state, remove the previous tab from the tab order.
            // If we're collapsing, then keep the collapsing tab in the tab order.
            if ( toShow.length && toHide.length ) {
                eventData.oldTab.attr( "tabIndex", -1 );
            } else if ( toShow.length ) {
                this.tabs.filter( function() {
                    return $( this ).attr( "tabIndex" ) === 0;
                } )
                    .attr( "tabIndex", -1 );
            }
    
            toShow.attr( "aria-hidden", "false" );
            eventData.newTab.attr( {
                "aria-selected": "true",
                "aria-expanded": "true",
                tabIndex: 0
            } );
        },
    
        _activate: function( index ) {
            var anchor,
                active = this._findActive( index );
    
            // Trying to activate the already active panel
            if ( active[ 0 ] === this.active[ 0 ] ) {
                return;
            }
    
            // Trying to collapse, simulate a click on the current active header
            if ( !active.length ) {
                active = this.active;
            }
    
            anchor = active.find( ".ui-tabs-anchor" )[ 0 ];
            this._eventHandler( {
                target: anchor,
                currentTarget: anchor,
                preventDefault: $.noop
            } );
        },
    
        _findActive: function( index ) {
            return index === false ? $() : this.tabs.eq( index );
        },
    
        _getIndex: function( index ) {
    
            // meta-function to give users option to provide a href string instead of a numerical index.
            if ( typeof index === "string" ) {
                index = this.anchors.index( this.anchors.filter( "[href$='" +
                    $.ui.escapeSelector( index ) + "']" ) );
            }
    
            return index;
        },
    
        _destroy: function() {
            if ( this.xhr ) {
                this.xhr.abort();
            }
    
            this.tablist
                .removeAttr( "role" )
                .off( this.eventNamespace );
    
            this.anchors
                .removeAttr( "role tabIndex" )
                .removeUniqueId();
    
            this.tabs.add( this.panels ).each( function() {
                if ( $.data( this, "ui-tabs-destroy" ) ) {
                    $( this ).remove();
                } else {
                    $( this ).removeAttr( "role tabIndex " +
                        "aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded" );
                }
            } );
    
            this.tabs.each( function() {
                var li = $( this ),
                    prev = li.data( "ui-tabs-aria-controls" );
                if ( prev ) {
                    li
                        .attr( "aria-controls", prev )
                        .removeData( "ui-tabs-aria-controls" );
                } else {
                    li.removeAttr( "aria-controls" );
                }
            } );
    
            this.panels.show();
    
            if ( this.options.heightStyle !== "content" ) {
                this.panels.css( "height", "" );
            }
        },
    
        enable: function( index ) {
            var disabled = this.options.disabled;
            if ( disabled === false ) {
                return;
            }
    
            if ( index === undefined ) {
                disabled = false;
            } else {
                index = this._getIndex( index );
                if ( $.isArray( disabled ) ) {
                    disabled = $.map( disabled, function( num ) {
                        return num !== index ? num : null;
                    } );
                } else {
                    disabled = $.map( this.tabs, function( li, num ) {
                        return num !== index ? num : null;
                    } );
                }
            }
            this._setOptionDisabled( disabled );
        },
    
        disable: function( index ) {
            var disabled = this.options.disabled;
            if ( disabled === true ) {
                return;
            }
    
            if ( index === undefined ) {
                disabled = true;
            } else {
                index = this._getIndex( index );
                if ( $.inArray( index, disabled ) !== -1 ) {
                    return;
                }
                if ( $.isArray( disabled ) ) {
                    disabled = $.merge( [ index ], disabled ).sort();
                } else {
                    disabled = [ index ];
                }
            }
            this._setOptionDisabled( disabled );
        },
    
        load: function( index, event ) {
            index = this._getIndex( index );
            var that = this,
                tab = this.tabs.eq( index ),
                anchor = tab.find( ".ui-tabs-anchor" ),
                panel = this._getPanelForTab( tab ),
                eventData = {
                    tab: tab,
                    panel: panel
                },
                complete = function( jqXHR, status ) {
                    if ( status === "abort" ) {
                        that.panels.stop( false, true );
                    }
    
                    that._removeClass( tab, "ui-tabs-loading" );
                    panel.removeAttr( "aria-busy" );
    
                    if ( jqXHR === that.xhr ) {
                        delete that.xhr;
                    }
                };
    
            // Not remote
            if ( this._isLocal( anchor[ 0 ] ) ) {
                return;
            }
    
            this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );
    
            // Support: jQuery <1.8
            // jQuery <1.8 returns false if the request is canceled in beforeSend,
            // but as of 1.8, $.ajax() always returns a jqXHR object.
            if ( this.xhr && this.xhr.statusText !== "canceled" ) {
                this._addClass( tab, "ui-tabs-loading" );
                panel.attr( "aria-busy", "true" );
    
                this.xhr
                    .done( function( response, status, jqXHR ) {
    
                        // support: jQuery <1.8
                        // http://bugs.jquery.com/ticket/11778
                        setTimeout( function() {
                            panel.html( response );
                            that._trigger( "load", event, eventData );
    
                            complete( jqXHR, status );
                        }, 1 );
                    } )
                    .fail( function( jqXHR, status ) {
    
                        // support: jQuery <1.8
                        // http://bugs.jquery.com/ticket/11778
                        setTimeout( function() {
                            complete( jqXHR, status );
                        }, 1 );
                    } );
            }
        },
    
        _ajaxSettings: function( anchor, event, eventData ) {
            var that = this;
            return {
    
                // Support: IE <11 only
                // Strip any hash that exists to prevent errors with the Ajax request
                url: anchor.attr( "href" ).replace( /#.*$/, "" ),
                beforeSend: function( jqXHR, settings ) {
                    return that._trigger( "beforeLoad", event,
                        $.extend( { jqXHR: jqXHR, ajaxSettings: settings }, eventData ) );
                }
            };
        },
    
        _getPanelForTab: function( tab ) {
            var id = $( tab ).attr( "aria-controls" );
            return this.element.find( this._sanitizeSelector( "#" + id ) );
        }
    } );
    
    // DEPRECATED
    // TODO: Switch return back to widget declaration at top of file when this is removed
    if ( $.uiBackCompat !== false ) {
    
        // Backcompat for ui-tab class (now ui-tabs-tab)
        $.widget( "ui.tabs", $.ui.tabs, {
            _processTabs: function() {
                this._superApply( arguments );
                this._addClass( this.tabs, "ui-tab" );
            }
        } );
    }
    
    var widgetsTabs = $.ui.tabs;
    
    
    /*!
     * jQuery UI Tooltip 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Tooltip
    //>>group: Widgets
    //>>description: Shows additional information for any element on hover or focus.
    //>>docs: http://api.jqueryui.com/tooltip/
    //>>demos: http://jqueryui.com/tooltip/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/tooltip.css
    //>>css.theme: ../../themes/base/theme.css
    
    
    
    $.widget( "ui.tooltip", {
        version: "1.12.1",
        options: {
            classes: {
                "ui-tooltip": "ui-corner-all ui-widget-shadow"
            },
            content: function() {
    
                // support: IE<9, Opera in jQuery <1.7
                // .text() can't accept undefined, so coerce to a string
                var title = $( this ).attr( "title" ) || "";
    
                // Escape title, since we're going from an attribute to raw HTML
                return $( "<a>" ).text( title ).html();
            },
            hide: true,
    
            // Disabled elements have inconsistent behavior across browsers (#8661)
            items: "[title]:not([disabled])",
            position: {
                my: "left top+15",
                at: "left bottom",
                collision: "flipfit flip"
            },
            show: true,
            track: false,
    
            // Callbacks
            close: null,
            open: null
        },
    
        _addDescribedBy: function( elem, id ) {
            var describedby = ( elem.attr( "aria-describedby" ) || "" ).split( /\s+/ );
            describedby.push( id );
            elem
                .data( "ui-tooltip-id", id )
                .attr( "aria-describedby", $.trim( describedby.join( " " ) ) );
        },
    
        _removeDescribedBy: function( elem ) {
            var id = elem.data( "ui-tooltip-id" ),
                describedby = ( elem.attr( "aria-describedby" ) || "" ).split( /\s+/ ),
                index = $.inArray( id, describedby );
    
            if ( index !== -1 ) {
                describedby.splice( index, 1 );
            }
    
            elem.removeData( "ui-tooltip-id" );
            describedby = $.trim( describedby.join( " " ) );
            if ( describedby ) {
                elem.attr( "aria-describedby", describedby );
            } else {
                elem.removeAttr( "aria-describedby" );
            }
        },
    
        _create: function() {
            this._on( {
                mouseover: "open",
                focusin: "open"
            } );
    
            // IDs of generated tooltips, needed for destroy
            this.tooltips = {};
    
            // IDs of parent tooltips where we removed the title attribute
            this.parents = {};
    
            // Append the aria-live region so tooltips announce correctly
            this.liveRegion = $( "<div>" )
                .attr( {
                    role: "log",
                    "aria-live": "assertive",
                    "aria-relevant": "additions"
                } )
                .appendTo( this.document[ 0 ].body );
            this._addClass( this.liveRegion, null, "ui-helper-hidden-accessible" );
    
            this.disabledTitles = $( [] );
        },
    
        _setOption: function( key, value ) {
            var that = this;
    
            this._super( key, value );
    
            if ( key === "content" ) {
                $.each( this.tooltips, function( id, tooltipData ) {
                    that._updateContent( tooltipData.element );
                } );
            }
        },
    
        _setOptionDisabled: function( value ) {
            this[ value ? "_disable" : "_enable" ]();
        },
    
        _disable: function() {
            var that = this;
    
            // Close open tooltips
            $.each( this.tooltips, function( id, tooltipData ) {
                var event = $.Event( "blur" );
                event.target = event.currentTarget = tooltipData.element[ 0 ];
                that.close( event, true );
            } );
    
            // Remove title attributes to prevent native tooltips
            this.disabledTitles = this.disabledTitles.add(
                this.element.find( this.options.items ).addBack()
                    .filter( function() {
                        var element = $( this );
                        if ( element.is( "[title]" ) ) {
                            return element
                                .data( "ui-tooltip-title", element.attr( "title" ) )
                                .removeAttr( "title" );
                        }
                    } )
            );
        },
    
        _enable: function() {
    
            // restore title attributes
            this.disabledTitles.each( function() {
                var element = $( this );
                if ( element.data( "ui-tooltip-title" ) ) {
                    element.attr( "title", element.data( "ui-tooltip-title" ) );
                }
            } );
            this.disabledTitles = $( [] );
        },
    
        open: function( event ) {
            var that = this,
                target = $( event ? event.target : this.element )
    
                    // we need closest here due to mouseover bubbling,
                    // but always pointing at the same event target
                    .closest( this.options.items );
    
            // No element to show a tooltip for or the tooltip is already open
            if ( !target.length || target.data( "ui-tooltip-id" ) ) {
                return;
            }
    
            if ( target.attr( "title" ) ) {
                target.data( "ui-tooltip-title", target.attr( "title" ) );
            }
    
            target.data( "ui-tooltip-open", true );
    
            // Kill parent tooltips, custom or native, for hover
            if ( event && event.type === "mouseover" ) {
                target.parents().each( function() {
                    var parent = $( this ),
                        blurEvent;
                    if ( parent.data( "ui-tooltip-open" ) ) {
                        blurEvent = $.Event( "blur" );
                        blurEvent.target = blurEvent.currentTarget = this;
                        that.close( blurEvent, true );
                    }
                    if ( parent.attr( "title" ) ) {
                        parent.uniqueId();
                        that.parents[ this.id ] = {
                            element: this,
                            title: parent.attr( "title" )
                        };
                        parent.attr( "title", "" );
                    }
                } );
            }
    
            this._registerCloseHandlers( event, target );
            this._updateContent( target, event );
        },
    
        _updateContent: function( target, event ) {
            var content,
                contentOption = this.options.content,
                that = this,
                eventType = event ? event.type : null;
    
            if ( typeof contentOption === "string" || contentOption.nodeType ||
                    contentOption.jquery ) {
                return this._open( event, target, contentOption );
            }
    
            content = contentOption.call( target[ 0 ], function( response ) {
    
                // IE may instantly serve a cached response for ajax requests
                // delay this call to _open so the other call to _open runs first
                that._delay( function() {
    
                    // Ignore async response if tooltip was closed already
                    if ( !target.data( "ui-tooltip-open" ) ) {
                        return;
                    }
    
                    // JQuery creates a special event for focusin when it doesn't
                    // exist natively. To improve performance, the native event
                    // object is reused and the type is changed. Therefore, we can't
                    // rely on the type being correct after the event finished
                    // bubbling, so we set it back to the previous value. (#8740)
                    if ( event ) {
                        event.type = eventType;
                    }
                    this._open( event, target, response );
                } );
            } );
            if ( content ) {
                this._open( event, target, content );
            }
        },
    
        _open: function( event, target, content ) {
            var tooltipData, tooltip, delayedShow, a11yContent,
                positionOption = $.extend( {}, this.options.position );
    
            if ( !content ) {
                return;
            }
    
            // Content can be updated multiple times. If the tooltip already
            // exists, then just update the content and bail.
            tooltipData = this._find( target );
            if ( tooltipData ) {
                tooltipData.tooltip.find( ".ui-tooltip-content" ).html( content );
                return;
            }
    
            // If we have a title, clear it to prevent the native tooltip
            // we have to check first to avoid defining a title if none exists
            // (we don't want to cause an element to start matching [title])
            //
            // We use removeAttr only for key events, to allow IE to export the correct
            // accessible attributes. For mouse events, set to empty string to avoid
            // native tooltip showing up (happens only when removing inside mouseover).
            if ( target.is( "[title]" ) ) {
                if ( event && event.type === "mouseover" ) {
                    target.attr( "title", "" );
                } else {
                    target.removeAttr( "title" );
                }
            }
    
            tooltipData = this._tooltip( target );
            tooltip = tooltipData.tooltip;
            this._addDescribedBy( target, tooltip.attr( "id" ) );
            tooltip.find( ".ui-tooltip-content" ).html( content );
    
            // Support: Voiceover on OS X, JAWS on IE <= 9
            // JAWS announces deletions even when aria-relevant="additions"
            // Voiceover will sometimes re-read the entire log region's contents from the beginning
            this.liveRegion.children().hide();
            a11yContent = $( "<div>" ).html( tooltip.find( ".ui-tooltip-content" ).html() );
            a11yContent.removeAttr( "name" ).find( "[name]" ).removeAttr( "name" );
            a11yContent.removeAttr( "id" ).find( "[id]" ).removeAttr( "id" );
            a11yContent.appendTo( this.liveRegion );
    
            function position( event ) {
                positionOption.of = event;
                if ( tooltip.is( ":hidden" ) ) {
                    return;
                }
                tooltip.position( positionOption );
            }
            if ( this.options.track && event && /^mouse/.test( event.type ) ) {
                this._on( this.document, {
                    mousemove: position
                } );
    
                // trigger once to override element-relative positioning
                position( event );
            } else {
                tooltip.position( $.extend( {
                    of: target
                }, this.options.position ) );
            }
    
            tooltip.hide();
    
            this._show( tooltip, this.options.show );
    
            // Handle tracking tooltips that are shown with a delay (#8644). As soon
            // as the tooltip is visible, position the tooltip using the most recent
            // event.
            // Adds the check to add the timers only when both delay and track options are set (#14682)
            if ( this.options.track && this.options.show && this.options.show.delay ) {
                delayedShow = this.delayedShow = setInterval( function() {
                    if ( tooltip.is( ":visible" ) ) {
                        position( positionOption.of );
                        clearInterval( delayedShow );
                    }
                }, $.fx.interval );
            }
    
            this._trigger( "open", event, { tooltip: tooltip } );
        },
    
        _registerCloseHandlers: function( event, target ) {
            var events = {
                keyup: function( event ) {
                    if ( event.keyCode === $.ui.keyCode.ESCAPE ) {
                        var fakeEvent = $.Event( event );
                        fakeEvent.currentTarget = target[ 0 ];
                        this.close( fakeEvent, true );
                    }
                }
            };
    
            // Only bind remove handler for delegated targets. Non-delegated
            // tooltips will handle this in destroy.
            if ( target[ 0 ] !== this.element[ 0 ] ) {
                events.remove = function() {
                    this._removeTooltip( this._find( target ).tooltip );
                };
            }
    
            if ( !event || event.type === "mouseover" ) {
                events.mouseleave = "close";
            }
            if ( !event || event.type === "focusin" ) {
                events.focusout = "close";
            }
            this._on( true, target, events );
        },
    
        close: function( event ) {
            var tooltip,
                that = this,
                target = $( event ? event.currentTarget : this.element ),
                tooltipData = this._find( target );
    
            // The tooltip may already be closed
            if ( !tooltipData ) {
    
                // We set ui-tooltip-open immediately upon open (in open()), but only set the
                // additional data once there's actually content to show (in _open()). So even if the
                // tooltip doesn't have full data, we always remove ui-tooltip-open in case we're in
                // the period between open() and _open().
                target.removeData( "ui-tooltip-open" );
                return;
            }
    
            tooltip = tooltipData.tooltip;
    
            // Disabling closes the tooltip, so we need to track when we're closing
            // to avoid an infinite loop in case the tooltip becomes disabled on close
            if ( tooltipData.closing ) {
                return;
            }
    
            // Clear the interval for delayed tracking tooltips
            clearInterval( this.delayedShow );
    
            // Only set title if we had one before (see comment in _open())
            // If the title attribute has changed since open(), don't restore
            if ( target.data( "ui-tooltip-title" ) && !target.attr( "title" ) ) {
                target.attr( "title", target.data( "ui-tooltip-title" ) );
            }
    
            this._removeDescribedBy( target );
    
            tooltipData.hiding = true;
            tooltip.stop( true );
            this._hide( tooltip, this.options.hide, function() {
                that._removeTooltip( $( this ) );
            } );
    
            target.removeData( "ui-tooltip-open" );
            this._off( target, "mouseleave focusout keyup" );
    
            // Remove 'remove' binding only on delegated targets
            if ( target[ 0 ] !== this.element[ 0 ] ) {
                this._off( target, "remove" );
            }
            this._off( this.document, "mousemove" );
    
            if ( event && event.type === "mouseleave" ) {
                $.each( this.parents, function( id, parent ) {
                    $( parent.element ).attr( "title", parent.title );
                    delete that.parents[ id ];
                } );
            }
    
            tooltipData.closing = true;
            this._trigger( "close", event, { tooltip: tooltip } );
            if ( !tooltipData.hiding ) {
                tooltipData.closing = false;
            }
        },
    
        _tooltip: function( element ) {
            var tooltip = $( "<div>" ).attr( "role", "tooltip" ),
                content = $( "<div>" ).appendTo( tooltip ),
                id = tooltip.uniqueId().attr( "id" );
    
            this._addClass( content, "ui-tooltip-content" );
            this._addClass( tooltip, "ui-tooltip", "ui-widget ui-widget-content" );
    
            tooltip.appendTo( this._appendTo( element ) );
    
            return this.tooltips[ id ] = {
                element: element,
                tooltip: tooltip
            };
        },
    
        _find: function( target ) {
            var id = target.data( "ui-tooltip-id" );
            return id ? this.tooltips[ id ] : null;
        },
    
        _removeTooltip: function( tooltip ) {
            tooltip.remove();
            delete this.tooltips[ tooltip.attr( "id" ) ];
        },
    
        _appendTo: function( target ) {
            var element = target.closest( ".ui-front, dialog" );
    
            if ( !element.length ) {
                element = this.document[ 0 ].body;
            }
    
            return element;
        },
    
        _destroy: function() {
            var that = this;
    
            // Close open tooltips
            $.each( this.tooltips, function( id, tooltipData ) {
    
                // Delegate to close method to handle common cleanup
                var event = $.Event( "blur" ),
                    element = tooltipData.element;
                event.target = event.currentTarget = element[ 0 ];
                that.close( event, true );
    
                // Remove immediately; destroying an open tooltip doesn't use the
                // hide animation
                $( "#" + id ).remove();
    
                // Restore the title
                if ( element.data( "ui-tooltip-title" ) ) {
    
                    // If the title attribute has changed since open(), don't restore
                    if ( !element.attr( "title" ) ) {
                        element.attr( "title", element.data( "ui-tooltip-title" ) );
                    }
                    element.removeData( "ui-tooltip-title" );
                }
            } );
            this.liveRegion.remove();
        }
    } );
    
    // DEPRECATED
    // TODO: Switch return back to widget declaration at top of file when this is removed
    if ( $.uiBackCompat !== false ) {
    
        // Backcompat for tooltipClass option
        $.widget( "ui.tooltip", $.ui.tooltip, {
            options: {
                tooltipClass: null
            },
            _tooltip: function() {
                var tooltipData = this._superApply( arguments );
                if ( this.options.tooltipClass ) {
                    tooltipData.tooltip.addClass( this.options.tooltipClass );
                }
                return tooltipData;
            }
        } );
    }
    
    var widgetsTooltip = $.ui.tooltip;
    
    
    
    
    }));
    /*!
      * Bootstrap v4.1.1 (https://getbootstrap.com/)
      * Copyright 2011-2018 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
      * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
      */
    !function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("jquery"),require("popper.js")):"function"==typeof define&&define.amd?define(["exports","jquery","popper.js"],e):e(t.bootstrap={},t.jQuery,t.Popper)}(this,function(t,e,c){"use strict";function i(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}function o(t,e,n){return e&&i(t.prototype,e),n&&i(t,n),t}function h(r){for(var t=1;t<arguments.length;t++){var s=null!=arguments[t]?arguments[t]:{},e=Object.keys(s);"function"==typeof Object.getOwnPropertySymbols&&(e=e.concat(Object.getOwnPropertySymbols(s).filter(function(t){return Object.getOwnPropertyDescriptor(s,t).enumerable}))),e.forEach(function(t){var e,n,i;e=r,i=s[n=t],n in e?Object.defineProperty(e,n,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[n]=i})}return r}e=e&&e.hasOwnProperty("default")?e.default:e,c=c&&c.hasOwnProperty("default")?c.default:c;var r,n,s,a,l,u,f,d,_,g,m,p,v,E,y,T,C,I,A,D,b,S,w,N,O,k,P,L,j,R,H,W,M,x,U,K,F,V,Q,B,Y,G,q,z,X,J,Z,$,tt,et,nt,it,rt,st,ot,at,lt,ht,ct,ut,ft,dt,_t,gt,mt,pt,vt,Et,yt,Tt,Ct,It,At,Dt,bt,St,wt,Nt,Ot,kt,Pt,Lt,jt,Rt,Ht,Wt,Mt,xt,Ut,Kt,Ft,Vt,Qt,Bt,Yt,Gt,qt,zt,Xt,Jt,Zt,$t,te,ee,ne,ie,re,se,oe,ae,le,he,ce,ue,fe,de,_e,ge,me,pe,ve,Ee,ye,Te,Ce,Ie,Ae,De,be,Se,we,Ne,Oe,ke,Pe,Le,je,Re,He,We,Me,xe,Ue,Ke,Fe,Ve,Qe,Be,Ye,Ge,qe,ze,Xe,Je,Ze,$e,tn,en,nn,rn,sn,on,an,ln,hn,cn,un,fn,dn,_n,gn,mn,pn,vn,En,yn,Tn,Cn=function(i){var e="transitionend";function t(t){var e=this,n=!1;return i(this).one(l.TRANSITION_END,function(){n=!0}),setTimeout(function(){n||l.triggerTransitionEnd(e)},t),this}var l={TRANSITION_END:"bsTransitionEnd",getUID:function(t){for(;t+=~~(1e6*Math.random()),document.getElementById(t););return t},getSelectorFromElement:function(t){var e=t.getAttribute("data-target");e&&"#"!==e||(e=t.getAttribute("href")||"");try{return 0<i(document).find(e).length?e:null}catch(t){return null}},getTransitionDurationFromElement:function(t){if(!t)return 0;var e=i(t).css("transition-duration");return parseFloat(e)?(e=e.split(",")[0],1e3*parseFloat(e)):0},reflow:function(t){return t.offsetHeight},triggerTransitionEnd:function(t){i(t).trigger(e)},supportsTransitionEnd:function(){return Boolean(e)},isElement:function(t){return(t[0]||t).nodeType},typeCheckConfig:function(t,e,n){for(var i in n)if(Object.prototype.hasOwnProperty.call(n,i)){var r=n[i],s=e[i],o=s&&l.isElement(s)?"element":(a=s,{}.toString.call(a).match(/\s([a-z]+)/i)[1].toLowerCase());if(!new RegExp(r).test(o))throw new Error(t.toUpperCase()+': Option "'+i+'" provided type "'+o+'" but expected type "'+r+'".')}var a}};return i.fn.emulateTransitionEnd=t,i.event.special[l.TRANSITION_END]={bindType:e,delegateType:e,handle:function(t){if(i(t.target).is(this))return t.handleObj.handler.apply(this,arguments)}},l}(e),In=(n="alert",a="."+(s="bs.alert"),l=(r=e).fn[n],u={CLOSE:"close"+a,CLOSED:"closed"+a,CLICK_DATA_API:"click"+a+".data-api"},f="alert",d="fade",_="show",g=function(){function i(t){this._element=t}var t=i.prototype;return t.close=function(t){var e=this._element;t&&(e=this._getRootElement(t)),this._triggerCloseEvent(e).isDefaultPrevented()||this._removeElement(e)},t.dispose=function(){r.removeData(this._element,s),this._element=null},t._getRootElement=function(t){var e=Cn.getSelectorFromElement(t),n=!1;return e&&(n=r(e)[0]),n||(n=r(t).closest("."+f)[0]),n},t._triggerCloseEvent=function(t){var e=r.Event(u.CLOSE);return r(t).trigger(e),e},t._removeElement=function(e){var n=this;if(r(e).removeClass(_),r(e).hasClass(d)){var t=Cn.getTransitionDurationFromElement(e);r(e).one(Cn.TRANSITION_END,function(t){return n._destroyElement(e,t)}).emulateTransitionEnd(t)}else this._destroyElement(e)},t._destroyElement=function(t){r(t).detach().trigger(u.CLOSED).remove()},i._jQueryInterface=function(n){return this.each(function(){var t=r(this),e=t.data(s);e||(e=new i(this),t.data(s,e)),"close"===n&&e[n](this)})},i._handleDismiss=function(e){return function(t){t&&t.preventDefault(),e.close(this)}},o(i,null,[{key:"VERSION",get:function(){return"4.1.1"}}]),i}(),r(document).on(u.CLICK_DATA_API,'[data-dismiss="alert"]',g._handleDismiss(new g)),r.fn[n]=g._jQueryInterface,r.fn[n].Constructor=g,r.fn[n].noConflict=function(){return r.fn[n]=l,g._jQueryInterface},g),An=(p="button",E="."+(v="bs.button"),y=".data-api",T=(m=e).fn[p],C="active",I="btn",D='[data-toggle^="button"]',b='[data-toggle="buttons"]',S="input",w=".active",N=".btn",O={CLICK_DATA_API:"click"+E+y,FOCUS_BLUR_DATA_API:(A="focus")+E+y+" blur"+E+y},k=function(){function n(t){this._element=t}var t=n.prototype;return t.toggle=function(){var t=!0,e=!0,n=m(this._element).closest(b)[0];if(n){var i=m(this._element).find(S)[0];if(i){if("radio"===i.type)if(i.checked&&m(this._element).hasClass(C))t=!1;else{var r=m(n).find(w)[0];r&&m(r).removeClass(C)}if(t){if(i.hasAttribute("disabled")||n.hasAttribute("disabled")||i.classList.contains("disabled")||n.classList.contains("disabled"))return;i.checked=!m(this._element).hasClass(C),m(i).trigger("change")}i.focus(),e=!1}}e&&this._element.setAttribute("aria-pressed",!m(this._element).hasClass(C)),t&&m(this._element).toggleClass(C)},t.dispose=function(){m.removeData(this._element,v),this._element=null},n._jQueryInterface=function(e){return this.each(function(){var t=m(this).data(v);t||(t=new n(this),m(this).data(v,t)),"toggle"===e&&t[e]()})},o(n,null,[{key:"VERSION",get:function(){return"4.1.1"}}]),n}(),m(document).on(O.CLICK_DATA_API,D,function(t){t.preventDefault();var e=t.target;m(e).hasClass(I)||(e=m(e).closest(N)),k._jQueryInterface.call(m(e),"toggle")}).on(O.FOCUS_BLUR_DATA_API,D,function(t){var e=m(t.target).closest(N)[0];m(e).toggleClass(A,/^focus(in)?$/.test(t.type))}),m.fn[p]=k._jQueryInterface,m.fn[p].Constructor=k,m.fn[p].noConflict=function(){return m.fn[p]=T,k._jQueryInterface},k),Dn=(L="carousel",R="."+(j="bs.carousel"),H=".data-api",W=(P=e).fn[L],M={interval:5e3,keyboard:!0,slide:!1,pause:"hover",wrap:!0},x={interval:"(number|boolean)",keyboard:"boolean",slide:"(boolean|string)",pause:"(string|boolean)",wrap:"boolean"},U="next",K="prev",F="left",V="right",Q={SLIDE:"slide"+R,SLID:"slid"+R,KEYDOWN:"keydown"+R,MOUSEENTER:"mouseenter"+R,MOUSELEAVE:"mouseleave"+R,TOUCHEND:"touchend"+R,LOAD_DATA_API:"load"+R+H,CLICK_DATA_API:"click"+R+H},B="carousel",Y="active",G="slide",q="carousel-item-right",z="carousel-item-left",X="carousel-item-next",J="carousel-item-prev",Z={ACTIVE:".active",ACTIVE_ITEM:".active.carousel-item",ITEM:".carousel-item",NEXT_PREV:".carousel-item-next, .carousel-item-prev",INDICATORS:".carousel-indicators",DATA_SLIDE:"[data-slide], [data-slide-to]",DATA_RIDE:'[data-ride="carousel"]'},$=function(){function s(t,e){this._items=null,this._interval=null,this._activeElement=null,this._isPaused=!1,this._isSliding=!1,this.touchTimeout=null,this._config=this._getConfig(e),this._element=P(t)[0],this._indicatorsElement=P(this._element).find(Z.INDICATORS)[0],this._addEventListeners()}var t=s.prototype;return t.next=function(){this._isSliding||this._slide(U)},t.nextWhenVisible=function(){!document.hidden&&P(this._element).is(":visible")&&"hidden"!==P(this._element).css("visibility")&&this.next()},t.prev=function(){this._isSliding||this._slide(K)},t.pause=function(t){t||(this._isPaused=!0),P(this._element).find(Z.NEXT_PREV)[0]&&(Cn.triggerTransitionEnd(this._element),this.cycle(!0)),clearInterval(this._interval),this._interval=null},t.cycle=function(t){t||(this._isPaused=!1),this._interval&&(clearInterval(this._interval),this._interval=null),this._config.interval&&!this._isPaused&&(this._interval=setInterval((document.visibilityState?this.nextWhenVisible:this.next).bind(this),this._config.interval))},t.to=function(t){var e=this;this._activeElement=P(this._element).find(Z.ACTIVE_ITEM)[0];var n=this._getItemIndex(this._activeElement);if(!(t>this._items.length-1||t<0))if(this._isSliding)P(this._element).one(Q.SLID,function(){return e.to(t)});else{if(n===t)return this.pause(),void this.cycle();var i=n<t?U:K;this._slide(i,this._items[t])}},t.dispose=function(){P(this._element).off(R),P.removeData(this._element,j),this._items=null,this._config=null,this._element=null,this._interval=null,this._isPaused=null,this._isSliding=null,this._activeElement=null,this._indicatorsElement=null},t._getConfig=function(t){return t=h({},M,t),Cn.typeCheckConfig(L,t,x),t},t._addEventListeners=function(){var e=this;this._config.keyboard&&P(this._element).on(Q.KEYDOWN,function(t){return e._keydown(t)}),"hover"===this._config.pause&&(P(this._element).on(Q.MOUSEENTER,function(t){return e.pause(t)}).on(Q.MOUSELEAVE,function(t){return e.cycle(t)}),"ontouchstart"in document.documentElement&&P(this._element).on(Q.TOUCHEND,function(){e.pause(),e.touchTimeout&&clearTimeout(e.touchTimeout),e.touchTimeout=setTimeout(function(t){return e.cycle(t)},500+e._config.interval)}))},t._keydown=function(t){if(!/input|textarea/i.test(t.target.tagName))switch(t.which){case 37:t.preventDefault(),this.prev();break;case 39:t.preventDefault(),this.next()}},t._getItemIndex=function(t){return this._items=P.makeArray(P(t).parent().find(Z.ITEM)),this._items.indexOf(t)},t._getItemByDirection=function(t,e){var n=t===U,i=t===K,r=this._getItemIndex(e),s=this._items.length-1;if((i&&0===r||n&&r===s)&&!this._config.wrap)return e;var o=(r+(t===K?-1:1))%this._items.length;return-1===o?this._items[this._items.length-1]:this._items[o]},t._triggerSlideEvent=function(t,e){var n=this._getItemIndex(t),i=this._getItemIndex(P(this._element).find(Z.ACTIVE_ITEM)[0]),r=P.Event(Q.SLIDE,{relatedTarget:t,direction:e,from:i,to:n});return P(this._element).trigger(r),r},t._setActiveIndicatorElement=function(t){if(this._indicatorsElement){P(this._indicatorsElement).find(Z.ACTIVE).removeClass(Y);var e=this._indicatorsElement.children[this._getItemIndex(t)];e&&P(e).addClass(Y)}},t._slide=function(t,e){var n,i,r,s=this,o=P(this._element).find(Z.ACTIVE_ITEM)[0],a=this._getItemIndex(o),l=e||o&&this._getItemByDirection(t,o),h=this._getItemIndex(l),c=Boolean(this._interval);if(t===U?(n=z,i=X,r=F):(n=q,i=J,r=V),l&&P(l).hasClass(Y))this._isSliding=!1;else if(!this._triggerSlideEvent(l,r).isDefaultPrevented()&&o&&l){this._isSliding=!0,c&&this.pause(),this._setActiveIndicatorElement(l);var u=P.Event(Q.SLID,{relatedTarget:l,direction:r,from:a,to:h});if(P(this._element).hasClass(G)){P(l).addClass(i),Cn.reflow(l),P(o).addClass(n),P(l).addClass(n);var f=Cn.getTransitionDurationFromElement(o);P(o).one(Cn.TRANSITION_END,function(){P(l).removeClass(n+" "+i).addClass(Y),P(o).removeClass(Y+" "+i+" "+n),s._isSliding=!1,setTimeout(function(){return P(s._element).trigger(u)},0)}).emulateTransitionEnd(f)}else P(o).removeClass(Y),P(l).addClass(Y),this._isSliding=!1,P(this._element).trigger(u);c&&this.cycle()}},s._jQueryInterface=function(i){return this.each(function(){var t=P(this).data(j),e=h({},M,P(this).data());"object"==typeof i&&(e=h({},e,i));var n="string"==typeof i?i:e.slide;if(t||(t=new s(this,e),P(this).data(j,t)),"number"==typeof i)t.to(i);else if("string"==typeof n){if("undefined"==typeof t[n])throw new TypeError('No method named "'+n+'"');t[n]()}else e.interval&&(t.pause(),t.cycle())})},s._dataApiClickHandler=function(t){var e=Cn.getSelectorFromElement(this);if(e){var n=P(e)[0];if(n&&P(n).hasClass(B)){var i=h({},P(n).data(),P(this).data()),r=this.getAttribute("data-slide-to");r&&(i.interval=!1),s._jQueryInterface.call(P(n),i),r&&P(n).data(j).to(r),t.preventDefault()}}},o(s,null,[{key:"VERSION",get:function(){return"4.1.1"}},{key:"Default",get:function(){return M}}]),s}(),P(document).on(Q.CLICK_DATA_API,Z.DATA_SLIDE,$._dataApiClickHandler),P(window).on(Q.LOAD_DATA_API,function(){P(Z.DATA_RIDE).each(function(){var t=P(this);$._jQueryInterface.call(t,t.data())})}),P.fn[L]=$._jQueryInterface,P.fn[L].Constructor=$,P.fn[L].noConflict=function(){return P.fn[L]=W,$._jQueryInterface},$),bn=(et="collapse",it="."+(nt="bs.collapse"),rt=(tt=e).fn[et],st={toggle:!0,parent:""},ot={toggle:"boolean",parent:"(string|element)"},at={SHOW:"show"+it,SHOWN:"shown"+it,HIDE:"hide"+it,HIDDEN:"hidden"+it,CLICK_DATA_API:"click"+it+".data-api"},lt="show",ht="collapse",ct="collapsing",ut="collapsed",ft="width",dt="height",_t={ACTIVES:".show, .collapsing",DATA_TOGGLE:'[data-toggle="collapse"]'},gt=function(){function a(t,e){this._isTransitioning=!1,this._element=t,this._config=this._getConfig(e),this._triggerArray=tt.makeArray(tt('[data-toggle="collapse"][href="#'+t.id+'"],[data-toggle="collapse"][data-target="#'+t.id+'"]'));for(var n=tt(_t.DATA_TOGGLE),i=0;i<n.length;i++){var r=n[i],s=Cn.getSelectorFromElement(r);null!==s&&0<tt(s).filter(t).length&&(this._selector=s,this._triggerArray.push(r))}this._parent=this._config.parent?this._getParent():null,this._config.parent||this._addAriaAndCollapsedClass(this._element,this._triggerArray),this._config.toggle&&this.toggle()}var t=a.prototype;return t.toggle=function(){tt(this._element).hasClass(lt)?this.hide():this.show()},t.show=function(){var t,e,n=this;if(!this._isTransitioning&&!tt(this._element).hasClass(lt)&&(this._parent&&0===(t=tt.makeArray(tt(this._parent).find(_t.ACTIVES).filter('[data-parent="'+this._config.parent+'"]'))).length&&(t=null),!(t&&(e=tt(t).not(this._selector).data(nt))&&e._isTransitioning))){var i=tt.Event(at.SHOW);if(tt(this._element).trigger(i),!i.isDefaultPrevented()){t&&(a._jQueryInterface.call(tt(t).not(this._selector),"hide"),e||tt(t).data(nt,null));var r=this._getDimension();tt(this._element).removeClass(ht).addClass(ct),(this._element.style[r]=0)<this._triggerArray.length&&tt(this._triggerArray).removeClass(ut).attr("aria-expanded",!0),this.setTransitioning(!0);var s="scroll"+(r[0].toUpperCase()+r.slice(1)),o=Cn.getTransitionDurationFromElement(this._element);tt(this._element).one(Cn.TRANSITION_END,function(){tt(n._element).removeClass(ct).addClass(ht).addClass(lt),n._element.style[r]="",n.setTransitioning(!1),tt(n._element).trigger(at.SHOWN)}).emulateTransitionEnd(o),this._element.style[r]=this._element[s]+"px"}}},t.hide=function(){var t=this;if(!this._isTransitioning&&tt(this._element).hasClass(lt)){var e=tt.Event(at.HIDE);if(tt(this._element).trigger(e),!e.isDefaultPrevented()){var n=this._getDimension();if(this._element.style[n]=this._element.getBoundingClientRect()[n]+"px",Cn.reflow(this._element),tt(this._element).addClass(ct).removeClass(ht).removeClass(lt),0<this._triggerArray.length)for(var i=0;i<this._triggerArray.length;i++){var r=this._triggerArray[i],s=Cn.getSelectorFromElement(r);if(null!==s)tt(s).hasClass(lt)||tt(r).addClass(ut).attr("aria-expanded",!1)}this.setTransitioning(!0);this._element.style[n]="";var o=Cn.getTransitionDurationFromElement(this._element);tt(this._element).one(Cn.TRANSITION_END,function(){t.setTransitioning(!1),tt(t._element).removeClass(ct).addClass(ht).trigger(at.HIDDEN)}).emulateTransitionEnd(o)}}},t.setTransitioning=function(t){this._isTransitioning=t},t.dispose=function(){tt.removeData(this._element,nt),this._config=null,this._parent=null,this._element=null,this._triggerArray=null,this._isTransitioning=null},t._getConfig=function(t){return(t=h({},st,t)).toggle=Boolean(t.toggle),Cn.typeCheckConfig(et,t,ot),t},t._getDimension=function(){return tt(this._element).hasClass(ft)?ft:dt},t._getParent=function(){var n=this,t=null;Cn.isElement(this._config.parent)?(t=this._config.parent,"undefined"!=typeof this._config.parent.jquery&&(t=this._config.parent[0])):t=tt(this._config.parent)[0];var e='[data-toggle="collapse"][data-parent="'+this._config.parent+'"]';return tt(t).find(e).each(function(t,e){n._addAriaAndCollapsedClass(a._getTargetFromElement(e),[e])}),t},t._addAriaAndCollapsedClass=function(t,e){if(t){var n=tt(t).hasClass(lt);0<e.length&&tt(e).toggleClass(ut,!n).attr("aria-expanded",n)}},a._getTargetFromElement=function(t){var e=Cn.getSelectorFromElement(t);return e?tt(e)[0]:null},a._jQueryInterface=function(i){return this.each(function(){var t=tt(this),e=t.data(nt),n=h({},st,t.data(),"object"==typeof i&&i?i:{});if(!e&&n.toggle&&/show|hide/.test(i)&&(n.toggle=!1),e||(e=new a(this,n),t.data(nt,e)),"string"==typeof i){if("undefined"==typeof e[i])throw new TypeError('No method named "'+i+'"');e[i]()}})},o(a,null,[{key:"VERSION",get:function(){return"4.1.1"}},{key:"Default",get:function(){return st}}]),a}(),tt(document).on(at.CLICK_DATA_API,_t.DATA_TOGGLE,function(t){"A"===t.currentTarget.tagName&&t.preventDefault();var n=tt(this),e=Cn.getSelectorFromElement(this);tt(e).each(function(){var t=tt(this),e=t.data(nt)?"toggle":n.data();gt._jQueryInterface.call(t,e)})}),tt.fn[et]=gt._jQueryInterface,tt.fn[et].Constructor=gt,tt.fn[et].noConflict=function(){return tt.fn[et]=rt,gt._jQueryInterface},gt),Sn=(pt="dropdown",Et="."+(vt="bs.dropdown"),yt=".data-api",Tt=(mt=e).fn[pt],Ct=new RegExp("38|40|27"),It={HIDE:"hide"+Et,HIDDEN:"hidden"+Et,SHOW:"show"+Et,SHOWN:"shown"+Et,CLICK:"click"+Et,CLICK_DATA_API:"click"+Et+yt,KEYDOWN_DATA_API:"keydown"+Et+yt,KEYUP_DATA_API:"keyup"+Et+yt},At="disabled",Dt="show",bt="dropup",St="dropright",wt="dropleft",Nt="dropdown-menu-right",Ot="position-static",kt='[data-toggle="dropdown"]',Pt=".dropdown form",Lt=".dropdown-menu",jt=".navbar-nav",Rt=".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)",Ht="top-start",Wt="top-end",Mt="bottom-start",xt="bottom-end",Ut="right-start",Kt="left-start",Ft={offset:0,flip:!0,boundary:"scrollParent",reference:"toggle",display:"dynamic"},Vt={offset:"(number|string|function)",flip:"boolean",boundary:"(string|element)",reference:"(string|element)",display:"string"},Qt=function(){function l(t,e){this._element=t,this._popper=null,this._config=this._getConfig(e),this._menu=this._getMenuElement(),this._inNavbar=this._detectNavbar(),this._addEventListeners()}var t=l.prototype;return t.toggle=function(){if(!this._element.disabled&&!mt(this._element).hasClass(At)){var t=l._getParentFromElement(this._element),e=mt(this._menu).hasClass(Dt);if(l._clearMenus(),!e){var n={relatedTarget:this._element},i=mt.Event(It.SHOW,n);if(mt(t).trigger(i),!i.isDefaultPrevented()){if(!this._inNavbar){if("undefined"==typeof c)throw new TypeError("Bootstrap dropdown require Popper.js (https://popper.js.org)");var r=this._element;"parent"===this._config.reference?r=t:Cn.isElement(this._config.reference)&&(r=this._config.reference,"undefined"!=typeof this._config.reference.jquery&&(r=this._config.reference[0])),"scrollParent"!==this._config.boundary&&mt(t).addClass(Ot),this._popper=new c(r,this._menu,this._getPopperConfig())}"ontouchstart"in document.documentElement&&0===mt(t).closest(jt).length&&mt(document.body).children().on("mouseover",null,mt.noop),this._element.focus(),this._element.setAttribute("aria-expanded",!0),mt(this._menu).toggleClass(Dt),mt(t).toggleClass(Dt).trigger(mt.Event(It.SHOWN,n))}}}},t.dispose=function(){mt.removeData(this._element,vt),mt(this._element).off(Et),this._element=null,(this._menu=null)!==this._popper&&(this._popper.destroy(),this._popper=null)},t.update=function(){this._inNavbar=this._detectNavbar(),null!==this._popper&&this._popper.scheduleUpdate()},t._addEventListeners=function(){var e=this;mt(this._element).on(It.CLICK,function(t){t.preventDefault(),t.stopPropagation(),e.toggle()})},t._getConfig=function(t){return t=h({},this.constructor.Default,mt(this._element).data(),t),Cn.typeCheckConfig(pt,t,this.constructor.DefaultType),t},t._getMenuElement=function(){if(!this._menu){var t=l._getParentFromElement(this._element);this._menu=mt(t).find(Lt)[0]}return this._menu},t._getPlacement=function(){var t=mt(this._element).parent(),e=Mt;return t.hasClass(bt)?(e=Ht,mt(this._menu).hasClass(Nt)&&(e=Wt)):t.hasClass(St)?e=Ut:t.hasClass(wt)?e=Kt:mt(this._menu).hasClass(Nt)&&(e=xt),e},t._detectNavbar=function(){return 0<mt(this._element).closest(".navbar").length},t._getPopperConfig=function(){var e=this,t={};"function"==typeof this._config.offset?t.fn=function(t){return t.offsets=h({},t.offsets,e._config.offset(t.offsets)||{}),t}:t.offset=this._config.offset;var n={placement:this._getPlacement(),modifiers:{offset:t,flip:{enabled:this._config.flip},preventOverflow:{boundariesElement:this._config.boundary}}};return"static"===this._config.display&&(n.modifiers.applyStyle={enabled:!1}),n},l._jQueryInterface=function(e){return this.each(function(){var t=mt(this).data(vt);if(t||(t=new l(this,"object"==typeof e?e:null),mt(this).data(vt,t)),"string"==typeof e){if("undefined"==typeof t[e])throw new TypeError('No method named "'+e+'"');t[e]()}})},l._clearMenus=function(t){if(!t||3!==t.which&&("keyup"!==t.type||9===t.which))for(var e=mt.makeArray(mt(kt)),n=0;n<e.length;n++){var i=l._getParentFromElement(e[n]),r=mt(e[n]).data(vt),s={relatedTarget:e[n]};if(r){var o=r._menu;if(mt(i).hasClass(Dt)&&!(t&&("click"===t.type&&/input|textarea/i.test(t.target.tagName)||"keyup"===t.type&&9===t.which)&&mt.contains(i,t.target))){var a=mt.Event(It.HIDE,s);mt(i).trigger(a),a.isDefaultPrevented()||("ontouchstart"in document.documentElement&&mt(document.body).children().off("mouseover",null,mt.noop),e[n].setAttribute("aria-expanded","false"),mt(o).removeClass(Dt),mt(i).removeClass(Dt).trigger(mt.Event(It.HIDDEN,s)))}}}},l._getParentFromElement=function(t){var e,n=Cn.getSelectorFromElement(t);return n&&(e=mt(n)[0]),e||t.parentNode},l._dataApiKeydownHandler=function(t){if((/input|textarea/i.test(t.target.tagName)?!(32===t.which||27!==t.which&&(40!==t.which&&38!==t.which||mt(t.target).closest(Lt).length)):Ct.test(t.which))&&(t.preventDefault(),t.stopPropagation(),!this.disabled&&!mt(this).hasClass(At))){var e=l._getParentFromElement(this),n=mt(e).hasClass(Dt);if((n||27===t.which&&32===t.which)&&(!n||27!==t.which&&32!==t.which)){var i=mt(e).find(Rt).get();if(0!==i.length){var r=i.indexOf(t.target);38===t.which&&0<r&&r--,40===t.which&&r<i.length-1&&r++,r<0&&(r=0),i[r].focus()}}else{if(27===t.which){var s=mt(e).find(kt)[0];mt(s).trigger("focus")}mt(this).trigger("click")}}},o(l,null,[{key:"VERSION",get:function(){return"4.1.1"}},{key:"Default",get:function(){return Ft}},{key:"DefaultType",get:function(){return Vt}}]),l}(),mt(document).on(It.KEYDOWN_DATA_API,kt,Qt._dataApiKeydownHandler).on(It.KEYDOWN_DATA_API,Lt,Qt._dataApiKeydownHandler).on(It.CLICK_DATA_API+" "+It.KEYUP_DATA_API,Qt._clearMenus).on(It.CLICK_DATA_API,kt,function(t){t.preventDefault(),t.stopPropagation(),Qt._jQueryInterface.call(mt(this),"toggle")}).on(It.CLICK_DATA_API,Pt,function(t){t.stopPropagation()}),mt.fn[pt]=Qt._jQueryInterface,mt.fn[pt].Constructor=Qt,mt.fn[pt].noConflict=function(){return mt.fn[pt]=Tt,Qt._jQueryInterface},Qt),wn=(Yt="modal",qt="."+(Gt="bs.modal"),zt=(Bt=e).fn[Yt],Xt={backdrop:!0,keyboard:!0,focus:!0,show:!0},Jt={backdrop:"(boolean|string)",keyboard:"boolean",focus:"boolean",show:"boolean"},Zt={HIDE:"hide"+qt,HIDDEN:"hidden"+qt,SHOW:"show"+qt,SHOWN:"shown"+qt,FOCUSIN:"focusin"+qt,RESIZE:"resize"+qt,CLICK_DISMISS:"click.dismiss"+qt,KEYDOWN_DISMISS:"keydown.dismiss"+qt,MOUSEUP_DISMISS:"mouseup.dismiss"+qt,MOUSEDOWN_DISMISS:"mousedown.dismiss"+qt,CLICK_DATA_API:"click"+qt+".data-api"},$t="modal-scrollbar-measure",te="modal-backdrop",ee="modal-open",ne="fade",ie="show",re={DIALOG:".modal-dialog",DATA_TOGGLE:'[data-toggle="modal"]',DATA_DISMISS:'[data-dismiss="modal"]',FIXED_CONTENT:".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",STICKY_CONTENT:".sticky-top",NAVBAR_TOGGLER:".navbar-toggler"},se=function(){function r(t,e){this._config=this._getConfig(e),this._element=t,this._dialog=Bt(t).find(re.DIALOG)[0],this._backdrop=null,this._isShown=!1,this._isBodyOverflowing=!1,this._ignoreBackdropClick=!1,this._scrollbarWidth=0}var t=r.prototype;return t.toggle=function(t){return this._isShown?this.hide():this.show(t)},t.show=function(t){var e=this;if(!this._isTransitioning&&!this._isShown){Bt(this._element).hasClass(ne)&&(this._isTransitioning=!0);var n=Bt.Event(Zt.SHOW,{relatedTarget:t});Bt(this._element).trigger(n),this._isShown||n.isDefaultPrevented()||(this._isShown=!0,this._checkScrollbar(),this._setScrollbar(),this._adjustDialog(),Bt(document.body).addClass(ee),this._setEscapeEvent(),this._setResizeEvent(),Bt(this._element).on(Zt.CLICK_DISMISS,re.DATA_DISMISS,function(t){return e.hide(t)}),Bt(this._dialog).on(Zt.MOUSEDOWN_DISMISS,function(){Bt(e._element).one(Zt.MOUSEUP_DISMISS,function(t){Bt(t.target).is(e._element)&&(e._ignoreBackdropClick=!0)})}),this._showBackdrop(function(){return e._showElement(t)}))}},t.hide=function(t){var e=this;if(t&&t.preventDefault(),!this._isTransitioning&&this._isShown){var n=Bt.Event(Zt.HIDE);if(Bt(this._element).trigger(n),this._isShown&&!n.isDefaultPrevented()){this._isShown=!1;var i=Bt(this._element).hasClass(ne);if(i&&(this._isTransitioning=!0),this._setEscapeEvent(),this._setResizeEvent(),Bt(document).off(Zt.FOCUSIN),Bt(this._element).removeClass(ie),Bt(this._element).off(Zt.CLICK_DISMISS),Bt(this._dialog).off(Zt.MOUSEDOWN_DISMISS),i){var r=Cn.getTransitionDurationFromElement(this._element);Bt(this._element).one(Cn.TRANSITION_END,function(t){return e._hideModal(t)}).emulateTransitionEnd(r)}else this._hideModal()}}},t.dispose=function(){Bt.removeData(this._element,Gt),Bt(window,document,this._element,this._backdrop).off(qt),this._config=null,this._element=null,this._dialog=null,this._backdrop=null,this._isShown=null,this._isBodyOverflowing=null,this._ignoreBackdropClick=null,this._scrollbarWidth=null},t.handleUpdate=function(){this._adjustDialog()},t._getConfig=function(t){return t=h({},Xt,t),Cn.typeCheckConfig(Yt,t,Jt),t},t._showElement=function(t){var e=this,n=Bt(this._element).hasClass(ne);this._element.parentNode&&this._element.parentNode.nodeType===Node.ELEMENT_NODE||document.body.appendChild(this._element),this._element.style.display="block",this._element.removeAttribute("aria-hidden"),this._element.scrollTop=0,n&&Cn.reflow(this._element),Bt(this._element).addClass(ie),this._config.focus&&this._enforceFocus();var i=Bt.Event(Zt.SHOWN,{relatedTarget:t}),r=function(){e._config.focus&&e._element.focus(),e._isTransitioning=!1,Bt(e._element).trigger(i)};if(n){var s=Cn.getTransitionDurationFromElement(this._element);Bt(this._dialog).one(Cn.TRANSITION_END,r).emulateTransitionEnd(s)}else r()},t._enforceFocus=function(){var e=this;Bt(document).off(Zt.FOCUSIN).on(Zt.FOCUSIN,function(t){document!==t.target&&e._element!==t.target&&0===Bt(e._element).has(t.target).length&&e._element.focus()})},t._setEscapeEvent=function(){var e=this;this._isShown&&this._config.keyboard?Bt(this._element).on(Zt.KEYDOWN_DISMISS,function(t){27===t.which&&(t.preventDefault(),e.hide())}):this._isShown||Bt(this._element).off(Zt.KEYDOWN_DISMISS)},t._setResizeEvent=function(){var e=this;this._isShown?Bt(window).on(Zt.RESIZE,function(t){return e.handleUpdate(t)}):Bt(window).off(Zt.RESIZE)},t._hideModal=function(){var t=this;this._element.style.display="none",this._element.setAttribute("aria-hidden",!0),this._isTransitioning=!1,this._showBackdrop(function(){Bt(document.body).removeClass(ee),t._resetAdjustments(),t._resetScrollbar(),Bt(t._element).trigger(Zt.HIDDEN)})},t._removeBackdrop=function(){this._backdrop&&(Bt(this._backdrop).remove(),this._backdrop=null)},t._showBackdrop=function(t){var e=this,n=Bt(this._element).hasClass(ne)?ne:"";if(this._isShown&&this._config.backdrop){if(this._backdrop=document.createElement("div"),this._backdrop.className=te,n&&Bt(this._backdrop).addClass(n),Bt(this._backdrop).appendTo(document.body),Bt(this._element).on(Zt.CLICK_DISMISS,function(t){e._ignoreBackdropClick?e._ignoreBackdropClick=!1:t.target===t.currentTarget&&("static"===e._config.backdrop?e._element.focus():e.hide())}),n&&Cn.reflow(this._backdrop),Bt(this._backdrop).addClass(ie),!t)return;if(!n)return void t();var i=Cn.getTransitionDurationFromElement(this._backdrop);Bt(this._backdrop).one(Cn.TRANSITION_END,t).emulateTransitionEnd(i)}else if(!this._isShown&&this._backdrop){Bt(this._backdrop).removeClass(ie);var r=function(){e._removeBackdrop(),t&&t()};if(Bt(this._element).hasClass(ne)){var s=Cn.getTransitionDurationFromElement(this._backdrop);Bt(this._backdrop).one(Cn.TRANSITION_END,r).emulateTransitionEnd(s)}else r()}else t&&t()},t._adjustDialog=function(){var t=this._element.scrollHeight>document.documentElement.clientHeight;!this._isBodyOverflowing&&t&&(this._element.style.paddingLeft=this._scrollbarWidth+"px"),this._isBodyOverflowing&&!t&&(this._element.style.paddingRight=this._scrollbarWidth+"px")},t._resetAdjustments=function(){this._element.style.paddingLeft="",this._element.style.paddingRight=""},t._checkScrollbar=function(){var t=document.body.getBoundingClientRect();this._isBodyOverflowing=t.left+t.right<window.innerWidth,this._scrollbarWidth=this._getScrollbarWidth()},t._setScrollbar=function(){var r=this;if(this._isBodyOverflowing){Bt(re.FIXED_CONTENT).each(function(t,e){var n=Bt(e)[0].style.paddingRight,i=Bt(e).css("padding-right");Bt(e).data("padding-right",n).css("padding-right",parseFloat(i)+r._scrollbarWidth+"px")}),Bt(re.STICKY_CONTENT).each(function(t,e){var n=Bt(e)[0].style.marginRight,i=Bt(e).css("margin-right");Bt(e).data("margin-right",n).css("margin-right",parseFloat(i)-r._scrollbarWidth+"px")}),Bt(re.NAVBAR_TOGGLER).each(function(t,e){var n=Bt(e)[0].style.marginRight,i=Bt(e).css("margin-right");Bt(e).data("margin-right",n).css("margin-right",parseFloat(i)+r._scrollbarWidth+"px")});var t=document.body.style.paddingRight,e=Bt(document.body).css("padding-right");Bt(document.body).data("padding-right",t).css("padding-right",parseFloat(e)+this._scrollbarWidth+"px")}},t._resetScrollbar=function(){Bt(re.FIXED_CONTENT).each(function(t,e){var n=Bt(e).data("padding-right");"undefined"!=typeof n&&Bt(e).css("padding-right",n).removeData("padding-right")}),Bt(re.STICKY_CONTENT+", "+re.NAVBAR_TOGGLER).each(function(t,e){var n=Bt(e).data("margin-right");"undefined"!=typeof n&&Bt(e).css("margin-right",n).removeData("margin-right")});var t=Bt(document.body).data("padding-right");"undefined"!=typeof t&&Bt(document.body).css("padding-right",t).removeData("padding-right")},t._getScrollbarWidth=function(){var t=document.createElement("div");t.className=$t,document.body.appendChild(t);var e=t.getBoundingClientRect().width-t.clientWidth;return document.body.removeChild(t),e},r._jQueryInterface=function(n,i){return this.each(function(){var t=Bt(this).data(Gt),e=h({},Xt,Bt(this).data(),"object"==typeof n&&n?n:{});if(t||(t=new r(this,e),Bt(this).data(Gt,t)),"string"==typeof n){if("undefined"==typeof t[n])throw new TypeError('No method named "'+n+'"');t[n](i)}else e.show&&t.show(i)})},o(r,null,[{key:"VERSION",get:function(){return"4.1.1"}},{key:"Default",get:function(){return Xt}}]),r}(),Bt(document).on(Zt.CLICK_DATA_API,re.DATA_TOGGLE,function(t){var e,n=this,i=Cn.getSelectorFromElement(this);i&&(e=Bt(i)[0]);var r=Bt(e).data(Gt)?"toggle":h({},Bt(e).data(),Bt(this).data());"A"!==this.tagName&&"AREA"!==this.tagName||t.preventDefault();var s=Bt(e).one(Zt.SHOW,function(t){t.isDefaultPrevented()||s.one(Zt.HIDDEN,function(){Bt(n).is(":visible")&&n.focus()})});se._jQueryInterface.call(Bt(e),r,this)}),Bt.fn[Yt]=se._jQueryInterface,Bt.fn[Yt].Constructor=se,Bt.fn[Yt].noConflict=function(){return Bt.fn[Yt]=zt,se._jQueryInterface},se),Nn=(ae="tooltip",he="."+(le="bs.tooltip"),ce=(oe=e).fn[ae],ue="bs-tooltip",fe=new RegExp("(^|\\s)"+ue+"\\S+","g"),ge={animation:!0,template:'<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!(_e={AUTO:"auto",TOP:"top",RIGHT:"right",BOTTOM:"bottom",LEFT:"left"}),selector:!(de={animation:"boolean",template:"string",title:"(string|element|function)",trigger:"string",delay:"(number|object)",html:"boolean",selector:"(string|boolean)",placement:"(string|function)",offset:"(number|string)",container:"(string|element|boolean)",fallbackPlacement:"(string|array)",boundary:"(string|element)"}),placement:"top",offset:0,container:!1,fallbackPlacement:"flip",boundary:"scrollParent"},pe="out",ve={HIDE:"hide"+he,HIDDEN:"hidden"+he,SHOW:(me="show")+he,SHOWN:"shown"+he,INSERTED:"inserted"+he,CLICK:"click"+he,FOCUSIN:"focusin"+he,FOCUSOUT:"focusout"+he,MOUSEENTER:"mouseenter"+he,MOUSELEAVE:"mouseleave"+he},Ee="fade",ye="show",Te=".tooltip-inner",Ce=".arrow",Ie="hover",Ae="focus",De="click",be="manual",Se=function(){function i(t,e){if("undefined"==typeof c)throw new TypeError("Bootstrap tooltips require Popper.js (https://popper.js.org)");this._isEnabled=!0,this._timeout=0,this._hoverState="",this._activeTrigger={},this._popper=null,this.element=t,this.config=this._getConfig(e),this.tip=null,this._setListeners()}var t=i.prototype;return t.enable=function(){this._isEnabled=!0},t.disable=function(){this._isEnabled=!1},t.toggleEnabled=function(){this._isEnabled=!this._isEnabled},t.toggle=function(t){if(this._isEnabled)if(t){var e=this.constructor.DATA_KEY,n=oe(t.currentTarget).data(e);n||(n=new this.constructor(t.currentTarget,this._getDelegateConfig()),oe(t.currentTarget).data(e,n)),n._activeTrigger.click=!n._activeTrigger.click,n._isWithActiveTrigger()?n._enter(null,n):n._leave(null,n)}else{if(oe(this.getTipElement()).hasClass(ye))return void this._leave(null,this);this._enter(null,this)}},t.dispose=function(){clearTimeout(this._timeout),oe.removeData(this.element,this.constructor.DATA_KEY),oe(this.element).off(this.constructor.EVENT_KEY),oe(this.element).closest(".modal").off("hide.bs.modal"),this.tip&&oe(this.tip).remove(),this._isEnabled=null,this._timeout=null,this._hoverState=null,(this._activeTrigger=null)!==this._popper&&this._popper.destroy(),this._popper=null,this.element=null,this.config=null,this.tip=null},t.show=function(){var e=this;if("none"===oe(this.element).css("display"))throw new Error("Please use show on visible elements");var t=oe.Event(this.constructor.Event.SHOW);if(this.isWithContent()&&this._isEnabled){oe(this.element).trigger(t);var n=oe.contains(this.element.ownerDocument.documentElement,this.element);if(t.isDefaultPrevented()||!n)return;var i=this.getTipElement(),r=Cn.getUID(this.constructor.NAME);i.setAttribute("id",r),this.element.setAttribute("aria-describedby",r),this.setContent(),this.config.animation&&oe(i).addClass(Ee);var s="function"==typeof this.config.placement?this.config.placement.call(this,i,this.element):this.config.placement,o=this._getAttachment(s);this.addAttachmentClass(o);var a=!1===this.config.container?document.body:oe(this.config.container);oe(i).data(this.constructor.DATA_KEY,this),oe.contains(this.element.ownerDocument.documentElement,this.tip)||oe(i).appendTo(a),oe(this.element).trigger(this.constructor.Event.INSERTED),this._popper=new c(this.element,i,{placement:o,modifiers:{offset:{offset:this.config.offset},flip:{behavior:this.config.fallbackPlacement},arrow:{element:Ce},preventOverflow:{boundariesElement:this.config.boundary}},onCreate:function(t){t.originalPlacement!==t.placement&&e._handlePopperPlacementChange(t)},onUpdate:function(t){e._handlePopperPlacementChange(t)}}),oe(i).addClass(ye),"ontouchstart"in document.documentElement&&oe(document.body).children().on("mouseover",null,oe.noop);var l=function(){e.config.animation&&e._fixTransition();var t=e._hoverState;e._hoverState=null,oe(e.element).trigger(e.constructor.Event.SHOWN),t===pe&&e._leave(null,e)};if(oe(this.tip).hasClass(Ee)){var h=Cn.getTransitionDurationFromElement(this.tip);oe(this.tip).one(Cn.TRANSITION_END,l).emulateTransitionEnd(h)}else l()}},t.hide=function(t){var e=this,n=this.getTipElement(),i=oe.Event(this.constructor.Event.HIDE),r=function(){e._hoverState!==me&&n.parentNode&&n.parentNode.removeChild(n),e._cleanTipClass(),e.element.removeAttribute("aria-describedby"),oe(e.element).trigger(e.constructor.Event.HIDDEN),null!==e._popper&&e._popper.destroy(),t&&t()};if(oe(this.element).trigger(i),!i.isDefaultPrevented()){if(oe(n).removeClass(ye),"ontouchstart"in document.documentElement&&oe(document.body).children().off("mouseover",null,oe.noop),this._activeTrigger[De]=!1,this._activeTrigger[Ae]=!1,this._activeTrigger[Ie]=!1,oe(this.tip).hasClass(Ee)){var s=Cn.getTransitionDurationFromElement(n);oe(n).one(Cn.TRANSITION_END,r).emulateTransitionEnd(s)}else r();this._hoverState=""}},t.update=function(){null!==this._popper&&this._popper.scheduleUpdate()},t.isWithContent=function(){return Boolean(this.getTitle())},t.addAttachmentClass=function(t){oe(this.getTipElement()).addClass(ue+"-"+t)},t.getTipElement=function(){return this.tip=this.tip||oe(this.config.template)[0],this.tip},t.setContent=function(){var t=oe(this.getTipElement());this.setElementContent(t.find(Te),this.getTitle()),t.removeClass(Ee+" "+ye)},t.setElementContent=function(t,e){var n=this.config.html;"object"==typeof e&&(e.nodeType||e.jquery)?n?oe(e).parent().is(t)||t.empty().append(e):t.text(oe(e).text()):t[n?"html":"text"](e)},t.getTitle=function(){var t=this.element.getAttribute("data-original-title");return t||(t="function"==typeof this.config.title?this.config.title.call(this.element):this.config.title),t},t._getAttachment=function(t){return _e[t.toUpperCase()]},t._setListeners=function(){var i=this;this.config.trigger.split(" ").forEach(function(t){if("click"===t)oe(i.element).on(i.constructor.Event.CLICK,i.config.selector,function(t){return i.toggle(t)});else if(t!==be){var e=t===Ie?i.constructor.Event.MOUSEENTER:i.constructor.Event.FOCUSIN,n=t===Ie?i.constructor.Event.MOUSELEAVE:i.constructor.Event.FOCUSOUT;oe(i.element).on(e,i.config.selector,function(t){return i._enter(t)}).on(n,i.config.selector,function(t){return i._leave(t)})}oe(i.element).closest(".modal").on("hide.bs.modal",function(){return i.hide()})}),this.config.selector?this.config=h({},this.config,{trigger:"manual",selector:""}):this._fixTitle()},t._fixTitle=function(){var t=typeof this.element.getAttribute("data-original-title");(this.element.getAttribute("title")||"string"!==t)&&(this.element.setAttribute("data-original-title",this.element.getAttribute("title")||""),this.element.setAttribute("title",""))},t._enter=function(t,e){var n=this.constructor.DATA_KEY;(e=e||oe(t.currentTarget).data(n))||(e=new this.constructor(t.currentTarget,this._getDelegateConfig()),oe(t.currentTarget).data(n,e)),t&&(e._activeTrigger["focusin"===t.type?Ae:Ie]=!0),oe(e.getTipElement()).hasClass(ye)||e._hoverState===me?e._hoverState=me:(clearTimeout(e._timeout),e._hoverState=me,e.config.delay&&e.config.delay.show?e._timeout=setTimeout(function(){e._hoverState===me&&e.show()},e.config.delay.show):e.show())},t._leave=function(t,e){var n=this.constructor.DATA_KEY;(e=e||oe(t.currentTarget).data(n))||(e=new this.constructor(t.currentTarget,this._getDelegateConfig()),oe(t.currentTarget).data(n,e)),t&&(e._activeTrigger["focusout"===t.type?Ae:Ie]=!1),e._isWithActiveTrigger()||(clearTimeout(e._timeout),e._hoverState=pe,e.config.delay&&e.config.delay.hide?e._timeout=setTimeout(function(){e._hoverState===pe&&e.hide()},e.config.delay.hide):e.hide())},t._isWithActiveTrigger=function(){for(var t in this._activeTrigger)if(this._activeTrigger[t])return!0;return!1},t._getConfig=function(t){return"number"==typeof(t=h({},this.constructor.Default,oe(this.element).data(),"object"==typeof t&&t?t:{})).delay&&(t.delay={show:t.delay,hide:t.delay}),"number"==typeof t.title&&(t.title=t.title.toString()),"number"==typeof t.content&&(t.content=t.content.toString()),Cn.typeCheckConfig(ae,t,this.constructor.DefaultType),t},t._getDelegateConfig=function(){var t={};if(this.config)for(var e in this.config)this.constructor.Default[e]!==this.config[e]&&(t[e]=this.config[e]);return t},t._cleanTipClass=function(){var t=oe(this.getTipElement()),e=t.attr("class").match(fe);null!==e&&0<e.length&&t.removeClass(e.join(""))},t._handlePopperPlacementChange=function(t){this._cleanTipClass(),this.addAttachmentClass(this._getAttachment(t.placement))},t._fixTransition=function(){var t=this.getTipElement(),e=this.config.animation;null===t.getAttribute("x-placement")&&(oe(t).removeClass(Ee),this.config.animation=!1,this.hide(),this.show(),this.config.animation=e)},i._jQueryInterface=function(n){return this.each(function(){var t=oe(this).data(le),e="object"==typeof n&&n;if((t||!/dispose|hide/.test(n))&&(t||(t=new i(this,e),oe(this).data(le,t)),"string"==typeof n)){if("undefined"==typeof t[n])throw new TypeError('No method named "'+n+'"');t[n]()}})},o(i,null,[{key:"VERSION",get:function(){return"4.1.1"}},{key:"Default",get:function(){return ge}},{key:"NAME",get:function(){return ae}},{key:"DATA_KEY",get:function(){return le}},{key:"Event",get:function(){return ve}},{key:"EVENT_KEY",get:function(){return he}},{key:"DefaultType",get:function(){return de}}]),i}(),oe.fn[ae]=Se._jQueryInterface,oe.fn[ae].Constructor=Se,oe.fn[ae].noConflict=function(){return oe.fn[ae]=ce,Se._jQueryInterface},Se),On=(Ne="popover",ke="."+(Oe="bs.popover"),Pe=(we=e).fn[Ne],Le="bs-popover",je=new RegExp("(^|\\s)"+Le+"\\S+","g"),Re=h({},Nn.Default,{placement:"right",trigger:"click",content:"",template:'<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'}),He=h({},Nn.DefaultType,{content:"(string|element|function)"}),We="fade",xe=".popover-header",Ue=".popover-body",Ke={HIDE:"hide"+ke,HIDDEN:"hidden"+ke,SHOW:(Me="show")+ke,SHOWN:"shown"+ke,INSERTED:"inserted"+ke,CLICK:"click"+ke,FOCUSIN:"focusin"+ke,FOCUSOUT:"focusout"+ke,MOUSEENTER:"mouseenter"+ke,MOUSELEAVE:"mouseleave"+ke},Fe=function(t){var e,n;function i(){return t.apply(this,arguments)||this}n=t,(e=i).prototype=Object.create(n.prototype),(e.prototype.constructor=e).__proto__=n;var r=i.prototype;return r.isWithContent=function(){return this.getTitle()||this._getContent()},r.addAttachmentClass=function(t){we(this.getTipElement()).addClass(Le+"-"+t)},r.getTipElement=function(){return this.tip=this.tip||we(this.config.template)[0],this.tip},r.setContent=function(){var t=we(this.getTipElement());this.setElementContent(t.find(xe),this.getTitle());var e=this._getContent();"function"==typeof e&&(e=e.call(this.element)),this.setElementContent(t.find(Ue),e),t.removeClass(We+" "+Me)},r._getContent=function(){return this.element.getAttribute("data-content")||this.config.content},r._cleanTipClass=function(){var t=we(this.getTipElement()),e=t.attr("class").match(je);null!==e&&0<e.length&&t.removeClass(e.join(""))},i._jQueryInterface=function(n){return this.each(function(){var t=we(this).data(Oe),e="object"==typeof n?n:null;if((t||!/destroy|hide/.test(n))&&(t||(t=new i(this,e),we(this).data(Oe,t)),"string"==typeof n)){if("undefined"==typeof t[n])throw new TypeError('No method named "'+n+'"');t[n]()}})},o(i,null,[{key:"VERSION",get:function(){return"4.1.1"}},{key:"Default",get:function(){return Re}},{key:"NAME",get:function(){return Ne}},{key:"DATA_KEY",get:function(){return Oe}},{key:"Event",get:function(){return Ke}},{key:"EVENT_KEY",get:function(){return ke}},{key:"DefaultType",get:function(){return He}}]),i}(Nn),we.fn[Ne]=Fe._jQueryInterface,we.fn[Ne].Constructor=Fe,we.fn[Ne].noConflict=function(){return we.fn[Ne]=Pe,Fe._jQueryInterface},Fe),kn=(Qe="scrollspy",Ye="."+(Be="bs.scrollspy"),Ge=(Ve=e).fn[Qe],qe={offset:10,method:"auto",target:""},ze={offset:"number",method:"string",target:"(string|element)"},Xe={ACTIVATE:"activate"+Ye,SCROLL:"scroll"+Ye,LOAD_DATA_API:"load"+Ye+".data-api"},Je="dropdown-item",Ze="active",$e={DATA_SPY:'[data-spy="scroll"]',ACTIVE:".active",NAV_LIST_GROUP:".nav, .list-group",NAV_LINKS:".nav-link",NAV_ITEMS:".nav-item",LIST_ITEMS:".list-group-item",DROPDOWN:".dropdown",DROPDOWN_ITEMS:".dropdown-item",DROPDOWN_TOGGLE:".dropdown-toggle"},tn="offset",en="position",nn=function(){function n(t,e){var n=this;this._element=t,this._scrollElement="BODY"===t.tagName?window:t,this._config=this._getConfig(e),this._selector=this._config.target+" "+$e.NAV_LINKS+","+this._config.target+" "+$e.LIST_ITEMS+","+this._config.target+" "+$e.DROPDOWN_ITEMS,this._offsets=[],this._targets=[],this._activeTarget=null,this._scrollHeight=0,Ve(this._scrollElement).on(Xe.SCROLL,function(t){return n._process(t)}),this.refresh(),this._process()}var t=n.prototype;return t.refresh=function(){var e=this,t=this._scrollElement===this._scrollElement.window?tn:en,r="auto"===this._config.method?t:this._config.method,s=r===en?this._getScrollTop():0;this._offsets=[],this._targets=[],this._scrollHeight=this._getScrollHeight(),Ve.makeArray(Ve(this._selector)).map(function(t){var e,n=Cn.getSelectorFromElement(t);if(n&&(e=Ve(n)[0]),e){var i=e.getBoundingClientRect();if(i.width||i.height)return[Ve(e)[r]().top+s,n]}return null}).filter(function(t){return t}).sort(function(t,e){return t[0]-e[0]}).forEach(function(t){e._offsets.push(t[0]),e._targets.push(t[1])})},t.dispose=function(){Ve.removeData(this._element,Be),Ve(this._scrollElement).off(Ye),this._element=null,this._scrollElement=null,this._config=null,this._selector=null,this._offsets=null,this._targets=null,this._activeTarget=null,this._scrollHeight=null},t._getConfig=function(t){if("string"!=typeof(t=h({},qe,"object"==typeof t&&t?t:{})).target){var e=Ve(t.target).attr("id");e||(e=Cn.getUID(Qe),Ve(t.target).attr("id",e)),t.target="#"+e}return Cn.typeCheckConfig(Qe,t,ze),t},t._getScrollTop=function(){return this._scrollElement===window?this._scrollElement.pageYOffset:this._scrollElement.scrollTop},t._getScrollHeight=function(){return this._scrollElement.scrollHeight||Math.max(document.body.scrollHeight,document.documentElement.scrollHeight)},t._getOffsetHeight=function(){return this._scrollElement===window?window.innerHeight:this._scrollElement.getBoundingClientRect().height},t._process=function(){var t=this._getScrollTop()+this._config.offset,e=this._getScrollHeight(),n=this._config.offset+e-this._getOffsetHeight();if(this._scrollHeight!==e&&this.refresh(),n<=t){var i=this._targets[this._targets.length-1];this._activeTarget!==i&&this._activate(i)}else{if(this._activeTarget&&t<this._offsets[0]&&0<this._offsets[0])return this._activeTarget=null,void this._clear();for(var r=this._offsets.length;r--;){this._activeTarget!==this._targets[r]&&t>=this._offsets[r]&&("undefined"==typeof this._offsets[r+1]||t<this._offsets[r+1])&&this._activate(this._targets[r])}}},t._activate=function(e){this._activeTarget=e,this._clear();var t=this._selector.split(",");t=t.map(function(t){return t+'[data-target="'+e+'"],'+t+'[href="'+e+'"]'});var n=Ve(t.join(","));n.hasClass(Je)?(n.closest($e.DROPDOWN).find($e.DROPDOWN_TOGGLE).addClass(Ze),n.addClass(Ze)):(n.addClass(Ze),n.parents($e.NAV_LIST_GROUP).prev($e.NAV_LINKS+", "+$e.LIST_ITEMS).addClass(Ze),n.parents($e.NAV_LIST_GROUP).prev($e.NAV_ITEMS).children($e.NAV_LINKS).addClass(Ze)),Ve(this._scrollElement).trigger(Xe.ACTIVATE,{relatedTarget:e})},t._clear=function(){Ve(this._selector).filter($e.ACTIVE).removeClass(Ze)},n._jQueryInterface=function(e){return this.each(function(){var t=Ve(this).data(Be);if(t||(t=new n(this,"object"==typeof e&&e),Ve(this).data(Be,t)),"string"==typeof e){if("undefined"==typeof t[e])throw new TypeError('No method named "'+e+'"');t[e]()}})},o(n,null,[{key:"VERSION",get:function(){return"4.1.1"}},{key:"Default",get:function(){return qe}}]),n}(),Ve(window).on(Xe.LOAD_DATA_API,function(){for(var t=Ve.makeArray(Ve($e.DATA_SPY)),e=t.length;e--;){var n=Ve(t[e]);nn._jQueryInterface.call(n,n.data())}}),Ve.fn[Qe]=nn._jQueryInterface,Ve.fn[Qe].Constructor=nn,Ve.fn[Qe].noConflict=function(){return Ve.fn[Qe]=Ge,nn._jQueryInterface},nn),Pn=(on="."+(sn="bs.tab"),an=(rn=e).fn.tab,ln={HIDE:"hide"+on,HIDDEN:"hidden"+on,SHOW:"show"+on,SHOWN:"shown"+on,CLICK_DATA_API:"click"+on+".data-api"},hn="dropdown-menu",cn="active",un="disabled",fn="fade",dn="show",_n=".dropdown",gn=".nav, .list-group",mn=".active",pn="> li > .active",vn='[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',En=".dropdown-toggle",yn="> .dropdown-menu .active",Tn=function(){function i(t){this._element=t}var t=i.prototype;return t.show=function(){var n=this;if(!(this._element.parentNode&&this._element.parentNode.nodeType===Node.ELEMENT_NODE&&rn(this._element).hasClass(cn)||rn(this._element).hasClass(un))){var t,i,e=rn(this._element).closest(gn)[0],r=Cn.getSelectorFromElement(this._element);if(e){var s="UL"===e.nodeName?pn:mn;i=(i=rn.makeArray(rn(e).find(s)))[i.length-1]}var o=rn.Event(ln.HIDE,{relatedTarget:this._element}),a=rn.Event(ln.SHOW,{relatedTarget:i});if(i&&rn(i).trigger(o),rn(this._element).trigger(a),!a.isDefaultPrevented()&&!o.isDefaultPrevented()){r&&(t=rn(r)[0]),this._activate(this._element,e);var l=function(){var t=rn.Event(ln.HIDDEN,{relatedTarget:n._element}),e=rn.Event(ln.SHOWN,{relatedTarget:i});rn(i).trigger(t),rn(n._element).trigger(e)};t?this._activate(t,t.parentNode,l):l()}}},t.dispose=function(){rn.removeData(this._element,sn),this._element=null},t._activate=function(t,e,n){var i=this,r=("UL"===e.nodeName?rn(e).find(pn):rn(e).children(mn))[0],s=n&&r&&rn(r).hasClass(fn),o=function(){return i._transitionComplete(t,r,n)};if(r&&s){var a=Cn.getTransitionDurationFromElement(r);rn(r).one(Cn.TRANSITION_END,o).emulateTransitionEnd(a)}else o()},t._transitionComplete=function(t,e,n){if(e){rn(e).removeClass(dn+" "+cn);var i=rn(e.parentNode).find(yn)[0];i&&rn(i).removeClass(cn),"tab"===e.getAttribute("role")&&e.setAttribute("aria-selected",!1)}if(rn(t).addClass(cn),"tab"===t.getAttribute("role")&&t.setAttribute("aria-selected",!0),Cn.reflow(t),rn(t).addClass(dn),t.parentNode&&rn(t.parentNode).hasClass(hn)){var r=rn(t).closest(_n)[0];r&&rn(r).find(En).addClass(cn),t.setAttribute("aria-expanded",!0)}n&&n()},i._jQueryInterface=function(n){return this.each(function(){var t=rn(this),e=t.data(sn);if(e||(e=new i(this),t.data(sn,e)),"string"==typeof n){if("undefined"==typeof e[n])throw new TypeError('No method named "'+n+'"');e[n]()}})},o(i,null,[{key:"VERSION",get:function(){return"4.1.1"}}]),i}(),rn(document).on(ln.CLICK_DATA_API,vn,function(t){t.preventDefault(),Tn._jQueryInterface.call(rn(this),"show")}),rn.fn.tab=Tn._jQueryInterface,rn.fn.tab.Constructor=Tn,rn.fn.tab.noConflict=function(){return rn.fn.tab=an,Tn._jQueryInterface},Tn);!function(t){if("undefined"==typeof t)throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript.");var e=t.fn.jquery.split(" ")[0].split(".");if(e[0]<2&&e[1]<9||1===e[0]&&9===e[1]&&e[2]<1||4<=e[0])throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0")}(e),t.Util=Cn,t.Alert=In,t.Button=An,t.Carousel=Dn,t.Collapse=bn,t.Dropdown=Sn,t.Modal=wn,t.Popover=On,t.Scrollspy=kn,t.Tab=Pn,t.Tooltip=Nn,Object.defineProperty(t,"__esModule",{value:!0})});
    //# sourceMappingURL=bootstrap.js.map
    /*
     Copyright (C) Federico Zivolo 2018
     Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).
     */(function(e,t){'object'==typeof exports&&'undefined'!=typeof module?module.exports=t():'function'==typeof define&&define.amd?define(t):e.Popper=t()})(this,function(){'use strict';function e(e){return e&&'[object Function]'==={}.toString.call(e)}function t(e,t){if(1!==e.nodeType)return[];var o=getComputedStyle(e,null);return t?o[t]:o}function o(e){return'HTML'===e.nodeName?e:e.parentNode||e.host}function n(e){if(!e)return document.body;switch(e.nodeName){case'HTML':case'BODY':return e.ownerDocument.body;case'#document':return e.body;}var i=t(e),r=i.overflow,p=i.overflowX,s=i.overflowY;return /(auto|scroll|overlay)/.test(r+s+p)?e:n(o(e))}function r(e){return 11===e?re:10===e?pe:re||pe}function p(e){if(!e)return document.documentElement;for(var o=r(10)?document.body:null,n=e.offsetParent;n===o&&e.nextElementSibling;)n=(e=e.nextElementSibling).offsetParent;var i=n&&n.nodeName;return i&&'BODY'!==i&&'HTML'!==i?-1!==['TD','TABLE'].indexOf(n.nodeName)&&'static'===t(n,'position')?p(n):n:e?e.ownerDocument.documentElement:document.documentElement}function s(e){var t=e.nodeName;return'BODY'!==t&&('HTML'===t||p(e.firstElementChild)===e)}function d(e){return null===e.parentNode?e:d(e.parentNode)}function a(e,t){if(!e||!e.nodeType||!t||!t.nodeType)return document.documentElement;var o=e.compareDocumentPosition(t)&Node.DOCUMENT_POSITION_FOLLOWING,n=o?e:t,i=o?t:e,r=document.createRange();r.setStart(n,0),r.setEnd(i,0);var l=r.commonAncestorContainer;if(e!==l&&t!==l||n.contains(i))return s(l)?l:p(l);var f=d(e);return f.host?a(f.host,t):a(e,d(t).host)}function l(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:'top',o='top'===t?'scrollTop':'scrollLeft',n=e.nodeName;if('BODY'===n||'HTML'===n){var i=e.ownerDocument.documentElement,r=e.ownerDocument.scrollingElement||i;return r[o]}return e[o]}function f(e,t){var o=2<arguments.length&&void 0!==arguments[2]&&arguments[2],n=l(t,'top'),i=l(t,'left'),r=o?-1:1;return e.top+=n*r,e.bottom+=n*r,e.left+=i*r,e.right+=i*r,e}function m(e,t){var o='x'===t?'Left':'Top',n='Left'==o?'Right':'Bottom';return parseFloat(e['border'+o+'Width'],10)+parseFloat(e['border'+n+'Width'],10)}function h(e,t,o,n){return $(t['offset'+e],t['scroll'+e],o['client'+e],o['offset'+e],o['scroll'+e],r(10)?o['offset'+e]+n['margin'+('Height'===e?'Top':'Left')]+n['margin'+('Height'===e?'Bottom':'Right')]:0)}function c(){var e=document.body,t=document.documentElement,o=r(10)&&getComputedStyle(t);return{height:h('Height',e,t,o),width:h('Width',e,t,o)}}function g(e){return le({},e,{right:e.left+e.width,bottom:e.top+e.height})}function u(e){var o={};try{if(r(10)){o=e.getBoundingClientRect();var n=l(e,'top'),i=l(e,'left');o.top+=n,o.left+=i,o.bottom+=n,o.right+=i}else o=e.getBoundingClientRect()}catch(t){}var p={left:o.left,top:o.top,width:o.right-o.left,height:o.bottom-o.top},s='HTML'===e.nodeName?c():{},d=s.width||e.clientWidth||p.right-p.left,a=s.height||e.clientHeight||p.bottom-p.top,f=e.offsetWidth-d,h=e.offsetHeight-a;if(f||h){var u=t(e);f-=m(u,'x'),h-=m(u,'y'),p.width-=f,p.height-=h}return g(p)}function b(e,o){var i=2<arguments.length&&void 0!==arguments[2]&&arguments[2],p=r(10),s='HTML'===o.nodeName,d=u(e),a=u(o),l=n(e),m=t(o),h=parseFloat(m.borderTopWidth,10),c=parseFloat(m.borderLeftWidth,10);i&&'HTML'===o.nodeName&&(a.top=$(a.top,0),a.left=$(a.left,0));var b=g({top:d.top-a.top-h,left:d.left-a.left-c,width:d.width,height:d.height});if(b.marginTop=0,b.marginLeft=0,!p&&s){var y=parseFloat(m.marginTop,10),w=parseFloat(m.marginLeft,10);b.top-=h-y,b.bottom-=h-y,b.left-=c-w,b.right-=c-w,b.marginTop=y,b.marginLeft=w}return(p&&!i?o.contains(l):o===l&&'BODY'!==l.nodeName)&&(b=f(b,o)),b}function y(e){var t=1<arguments.length&&void 0!==arguments[1]&&arguments[1],o=e.ownerDocument.documentElement,n=b(e,o),i=$(o.clientWidth,window.innerWidth||0),r=$(o.clientHeight,window.innerHeight||0),p=t?0:l(o),s=t?0:l(o,'left'),d={top:p-n.top+n.marginTop,left:s-n.left+n.marginLeft,width:i,height:r};return g(d)}function w(e){var n=e.nodeName;return'BODY'===n||'HTML'===n?!1:'fixed'===t(e,'position')||w(o(e))}function E(e){if(!e||!e.parentElement||r())return document.documentElement;for(var o=e.parentElement;o&&'none'===t(o,'transform');)o=o.parentElement;return o||document.documentElement}function v(e,t,i,r){var p=4<arguments.length&&void 0!==arguments[4]&&arguments[4],s={top:0,left:0},d=p?E(e):a(e,t);if('viewport'===r)s=y(d,p);else{var l;'scrollParent'===r?(l=n(o(t)),'BODY'===l.nodeName&&(l=e.ownerDocument.documentElement)):'window'===r?l=e.ownerDocument.documentElement:l=r;var f=b(l,d,p);if('HTML'===l.nodeName&&!w(d)){var m=c(),h=m.height,g=m.width;s.top+=f.top-f.marginTop,s.bottom=h+f.top,s.left+=f.left-f.marginLeft,s.right=g+f.left}else s=f}return s.left+=i,s.top+=i,s.right-=i,s.bottom-=i,s}function x(e){var t=e.width,o=e.height;return t*o}function O(e,t,o,n,i){var r=5<arguments.length&&void 0!==arguments[5]?arguments[5]:0;if(-1===e.indexOf('auto'))return e;var p=v(o,n,r,i),s={top:{width:p.width,height:t.top-p.top},right:{width:p.right-t.right,height:p.height},bottom:{width:p.width,height:p.bottom-t.bottom},left:{width:t.left-p.left,height:p.height}},d=Object.keys(s).map(function(e){return le({key:e},s[e],{area:x(s[e])})}).sort(function(e,t){return t.area-e.area}),a=d.filter(function(e){var t=e.width,n=e.height;return t>=o.clientWidth&&n>=o.clientHeight}),l=0<a.length?a[0].key:d[0].key,f=e.split('-')[1];return l+(f?'-'+f:'')}function L(e,t,o){var n=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null,i=n?E(t):a(t,o);return b(o,i,n)}function S(e){var t=getComputedStyle(e),o=parseFloat(t.marginTop)+parseFloat(t.marginBottom),n=parseFloat(t.marginLeft)+parseFloat(t.marginRight),i={width:e.offsetWidth+n,height:e.offsetHeight+o};return i}function T(e){var t={left:'right',right:'left',bottom:'top',top:'bottom'};return e.replace(/left|right|bottom|top/g,function(e){return t[e]})}function C(e,t,o){o=o.split('-')[0];var n=S(e),i={width:n.width,height:n.height},r=-1!==['right','left'].indexOf(o),p=r?'top':'left',s=r?'left':'top',d=r?'height':'width',a=r?'width':'height';return i[p]=t[p]+t[d]/2-n[d]/2,i[s]=o===s?t[s]-n[a]:t[T(s)],i}function D(e,t){return Array.prototype.find?e.find(t):e.filter(t)[0]}function N(e,t,o){if(Array.prototype.findIndex)return e.findIndex(function(e){return e[t]===o});var n=D(e,function(e){return e[t]===o});return e.indexOf(n)}function P(t,o,n){var i=void 0===n?t:t.slice(0,N(t,'name',n));return i.forEach(function(t){t['function']&&console.warn('`modifier.function` is deprecated, use `modifier.fn`!');var n=t['function']||t.fn;t.enabled&&e(n)&&(o.offsets.popper=g(o.offsets.popper),o.offsets.reference=g(o.offsets.reference),o=n(o,t))}),o}function k(){if(!this.state.isDestroyed){var e={instance:this,styles:{},arrowStyles:{},attributes:{},flipped:!1,offsets:{}};e.offsets.reference=L(this.state,this.popper,this.reference,this.options.positionFixed),e.placement=O(this.options.placement,e.offsets.reference,this.popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding),e.originalPlacement=e.placement,e.positionFixed=this.options.positionFixed,e.offsets.popper=C(this.popper,e.offsets.reference,e.placement),e.offsets.popper.position=this.options.positionFixed?'fixed':'absolute',e=P(this.modifiers,e),this.state.isCreated?this.options.onUpdate(e):(this.state.isCreated=!0,this.options.onCreate(e))}}function W(e,t){return e.some(function(e){var o=e.name,n=e.enabled;return n&&o===t})}function B(e){for(var t=[!1,'ms','Webkit','Moz','O'],o=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<t.length;n++){var i=t[n],r=i?''+i+o:e;if('undefined'!=typeof document.body.style[r])return r}return null}function H(){return this.state.isDestroyed=!0,W(this.modifiers,'applyStyle')&&(this.popper.removeAttribute('x-placement'),this.popper.style.position='',this.popper.style.top='',this.popper.style.left='',this.popper.style.right='',this.popper.style.bottom='',this.popper.style.willChange='',this.popper.style[B('transform')]=''),this.disableEventListeners(),this.options.removeOnDestroy&&this.popper.parentNode.removeChild(this.popper),this}function A(e){var t=e.ownerDocument;return t?t.defaultView:window}function M(e,t,o,i){var r='BODY'===e.nodeName,p=r?e.ownerDocument.defaultView:e;p.addEventListener(t,o,{passive:!0}),r||M(n(p.parentNode),t,o,i),i.push(p)}function I(e,t,o,i){o.updateBound=i,A(e).addEventListener('resize',o.updateBound,{passive:!0});var r=n(e);return M(r,'scroll',o.updateBound,o.scrollParents),o.scrollElement=r,o.eventsEnabled=!0,o}function F(){this.state.eventsEnabled||(this.state=I(this.reference,this.options,this.state,this.scheduleUpdate))}function R(e,t){return A(e).removeEventListener('resize',t.updateBound),t.scrollParents.forEach(function(e){e.removeEventListener('scroll',t.updateBound)}),t.updateBound=null,t.scrollParents=[],t.scrollElement=null,t.eventsEnabled=!1,t}function U(){this.state.eventsEnabled&&(cancelAnimationFrame(this.scheduleUpdate),this.state=R(this.reference,this.state))}function Y(e){return''!==e&&!isNaN(parseFloat(e))&&isFinite(e)}function j(e,t){Object.keys(t).forEach(function(o){var n='';-1!==['width','height','top','right','bottom','left'].indexOf(o)&&Y(t[o])&&(n='px'),e.style[o]=t[o]+n})}function K(e,t){Object.keys(t).forEach(function(o){var n=t[o];!1===n?e.removeAttribute(o):e.setAttribute(o,t[o])})}function q(e,t,o){var n=D(e,function(e){var o=e.name;return o===t}),i=!!n&&e.some(function(e){return e.name===o&&e.enabled&&e.order<n.order});if(!i){var r='`'+t+'`';console.warn('`'+o+'`'+' modifier is required by '+r+' modifier in order to work, be sure to include it before '+r+'!')}return i}function G(e){return'end'===e?'start':'start'===e?'end':e}function z(e){var t=1<arguments.length&&void 0!==arguments[1]&&arguments[1],o=me.indexOf(e),n=me.slice(o+1).concat(me.slice(0,o));return t?n.reverse():n}function V(e,t,o,n){var i=e.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),r=+i[1],p=i[2];if(!r)return e;if(0===p.indexOf('%')){var s;switch(p){case'%p':s=o;break;case'%':case'%r':default:s=n;}var d=g(s);return d[t]/100*r}if('vh'===p||'vw'===p){var a;return a='vh'===p?$(document.documentElement.clientHeight,window.innerHeight||0):$(document.documentElement.clientWidth,window.innerWidth||0),a/100*r}return r}function _(e,t,o,n){var i=[0,0],r=-1!==['right','left'].indexOf(n),p=e.split(/(\+|\-)/).map(function(e){return e.trim()}),s=p.indexOf(D(p,function(e){return-1!==e.search(/,|\s/)}));p[s]&&-1===p[s].indexOf(',')&&console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');var d=/\s*,\s*|\s+/,a=-1===s?[p]:[p.slice(0,s).concat([p[s].split(d)[0]]),[p[s].split(d)[1]].concat(p.slice(s+1))];return a=a.map(function(e,n){var i=(1===n?!r:r)?'height':'width',p=!1;return e.reduce(function(e,t){return''===e[e.length-1]&&-1!==['+','-'].indexOf(t)?(e[e.length-1]=t,p=!0,e):p?(e[e.length-1]+=t,p=!1,e):e.concat(t)},[]).map(function(e){return V(e,i,t,o)})}),a.forEach(function(e,t){e.forEach(function(o,n){Y(o)&&(i[t]+=o*('-'===e[n-1]?-1:1))})}),i}function X(e,t){var o,n=t.offset,i=e.placement,r=e.offsets,p=r.popper,s=r.reference,d=i.split('-')[0];return o=Y(+n)?[+n,0]:_(n,p,s,d),'left'===d?(p.top+=o[0],p.left-=o[1]):'right'===d?(p.top+=o[0],p.left+=o[1]):'top'===d?(p.left+=o[0],p.top-=o[1]):'bottom'===d&&(p.left+=o[0],p.top+=o[1]),e.popper=p,e}for(var J=Math.min,Q=Math.round,Z=Math.floor,$=Math.max,ee='undefined'!=typeof window&&'undefined'!=typeof document,te=['Edge','Trident','Firefox'],oe=0,ne=0;ne<te.length;ne+=1)if(ee&&0<=navigator.userAgent.indexOf(te[ne])){oe=1;break}var i=ee&&window.Promise,ie=i?function(e){var t=!1;return function(){t||(t=!0,window.Promise.resolve().then(function(){t=!1,e()}))}}:function(e){var t=!1;return function(){t||(t=!0,setTimeout(function(){t=!1,e()},oe))}},re=ee&&!!(window.MSInputMethodContext&&document.documentMode),pe=ee&&/MSIE 10/.test(navigator.userAgent),se=function(e,t){if(!(e instanceof t))throw new TypeError('Cannot call a class as a function')},de=function(){function e(e,t){for(var o,n=0;n<t.length;n++)o=t[n],o.enumerable=o.enumerable||!1,o.configurable=!0,'value'in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}return function(t,o,n){return o&&e(t.prototype,o),n&&e(t,n),t}}(),ae=function(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e},le=Object.assign||function(e){for(var t,o=1;o<arguments.length;o++)for(var n in t=arguments[o],t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e},fe=['auto-start','auto','auto-end','top-start','top','top-end','right-start','right','right-end','bottom-end','bottom','bottom-start','left-end','left','left-start'],me=fe.slice(3),he={FLIP:'flip',CLOCKWISE:'clockwise',COUNTERCLOCKWISE:'counterclockwise'},ce=function(){function t(o,n){var i=this,r=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};se(this,t),this.scheduleUpdate=function(){return requestAnimationFrame(i.update)},this.update=ie(this.update.bind(this)),this.options=le({},t.Defaults,r),this.state={isDestroyed:!1,isCreated:!1,scrollParents:[]},this.reference=o&&o.jquery?o[0]:o,this.popper=n&&n.jquery?n[0]:n,this.options.modifiers={},Object.keys(le({},t.Defaults.modifiers,r.modifiers)).forEach(function(e){i.options.modifiers[e]=le({},t.Defaults.modifiers[e]||{},r.modifiers?r.modifiers[e]:{})}),this.modifiers=Object.keys(this.options.modifiers).map(function(e){return le({name:e},i.options.modifiers[e])}).sort(function(e,t){return e.order-t.order}),this.modifiers.forEach(function(t){t.enabled&&e(t.onLoad)&&t.onLoad(i.reference,i.popper,i.options,t,i.state)}),this.update();var p=this.options.eventsEnabled;p&&this.enableEventListeners(),this.state.eventsEnabled=p}return de(t,[{key:'update',value:function(){return k.call(this)}},{key:'destroy',value:function(){return H.call(this)}},{key:'enableEventListeners',value:function(){return F.call(this)}},{key:'disableEventListeners',value:function(){return U.call(this)}}]),t}();return ce.Utils=('undefined'==typeof window?global:window).PopperUtils,ce.placements=fe,ce.Defaults={placement:'bottom',positionFixed:!1,eventsEnabled:!0,removeOnDestroy:!1,onCreate:function(){},onUpdate:function(){},modifiers:{shift:{order:100,enabled:!0,fn:function(e){var t=e.placement,o=t.split('-')[0],n=t.split('-')[1];if(n){var i=e.offsets,r=i.reference,p=i.popper,s=-1!==['bottom','top'].indexOf(o),d=s?'left':'top',a=s?'width':'height',l={start:ae({},d,r[d]),end:ae({},d,r[d]+r[a]-p[a])};e.offsets.popper=le({},p,l[n])}return e}},offset:{order:200,enabled:!0,fn:X,offset:0},preventOverflow:{order:300,enabled:!0,fn:function(e,t){var o=t.boundariesElement||p(e.instance.popper);e.instance.reference===o&&(o=p(o));var n=B('transform'),i=e.instance.popper.style,r=i.top,s=i.left,d=i[n];i.top='',i.left='',i[n]='';var a=v(e.instance.popper,e.instance.reference,t.padding,o,e.positionFixed);i.top=r,i.left=s,i[n]=d,t.boundaries=a;var l=t.priority,f=e.offsets.popper,m={primary:function(e){var o=f[e];return f[e]<a[e]&&!t.escapeWithReference&&(o=$(f[e],a[e])),ae({},e,o)},secondary:function(e){var o='right'===e?'left':'top',n=f[o];return f[e]>a[e]&&!t.escapeWithReference&&(n=J(f[o],a[e]-('right'===e?f.width:f.height))),ae({},o,n)}};return l.forEach(function(e){var t=-1===['left','top'].indexOf(e)?'secondary':'primary';f=le({},f,m[t](e))}),e.offsets.popper=f,e},priority:['left','right','top','bottom'],padding:5,boundariesElement:'scrollParent'},keepTogether:{order:400,enabled:!0,fn:function(e){var t=e.offsets,o=t.popper,n=t.reference,i=e.placement.split('-')[0],r=Z,p=-1!==['top','bottom'].indexOf(i),s=p?'right':'bottom',d=p?'left':'top',a=p?'width':'height';return o[s]<r(n[d])&&(e.offsets.popper[d]=r(n[d])-o[a]),o[d]>r(n[s])&&(e.offsets.popper[d]=r(n[s])),e}},arrow:{order:500,enabled:!0,fn:function(e,o){var n;if(!q(e.instance.modifiers,'arrow','keepTogether'))return e;var i=o.element;if('string'==typeof i){if(i=e.instance.popper.querySelector(i),!i)return e;}else if(!e.instance.popper.contains(i))return console.warn('WARNING: `arrow.element` must be child of its popper element!'),e;var r=e.placement.split('-')[0],p=e.offsets,s=p.popper,d=p.reference,a=-1!==['left','right'].indexOf(r),l=a?'height':'width',f=a?'Top':'Left',m=f.toLowerCase(),h=a?'left':'top',c=a?'bottom':'right',u=S(i)[l];d[c]-u<s[m]&&(e.offsets.popper[m]-=s[m]-(d[c]-u)),d[m]+u>s[c]&&(e.offsets.popper[m]+=d[m]+u-s[c]),e.offsets.popper=g(e.offsets.popper);var b=d[m]+d[l]/2-u/2,y=t(e.instance.popper),w=parseFloat(y['margin'+f],10),E=parseFloat(y['border'+f+'Width'],10),v=b-e.offsets.popper[m]-w-E;return v=$(J(s[l]-u,v),0),e.arrowElement=i,e.offsets.arrow=(n={},ae(n,m,Q(v)),ae(n,h,''),n),e},element:'[x-arrow]'},flip:{order:600,enabled:!0,fn:function(e,t){if(W(e.instance.modifiers,'inner'))return e;if(e.flipped&&e.placement===e.originalPlacement)return e;var o=v(e.instance.popper,e.instance.reference,t.padding,t.boundariesElement,e.positionFixed),n=e.placement.split('-')[0],i=T(n),r=e.placement.split('-')[1]||'',p=[];switch(t.behavior){case he.FLIP:p=[n,i];break;case he.CLOCKWISE:p=z(n);break;case he.COUNTERCLOCKWISE:p=z(n,!0);break;default:p=t.behavior;}return p.forEach(function(s,d){if(n!==s||p.length===d+1)return e;n=e.placement.split('-')[0],i=T(n);var a=e.offsets.popper,l=e.offsets.reference,f=Z,m='left'===n&&f(a.right)>f(l.left)||'right'===n&&f(a.left)<f(l.right)||'top'===n&&f(a.bottom)>f(l.top)||'bottom'===n&&f(a.top)<f(l.bottom),h=f(a.left)<f(o.left),c=f(a.right)>f(o.right),g=f(a.top)<f(o.top),u=f(a.bottom)>f(o.bottom),b='left'===n&&h||'right'===n&&c||'top'===n&&g||'bottom'===n&&u,y=-1!==['top','bottom'].indexOf(n),w=!!t.flipVariations&&(y&&'start'===r&&h||y&&'end'===r&&c||!y&&'start'===r&&g||!y&&'end'===r&&u);(m||b||w)&&(e.flipped=!0,(m||b)&&(n=p[d+1]),w&&(r=G(r)),e.placement=n+(r?'-'+r:''),e.offsets.popper=le({},e.offsets.popper,C(e.instance.popper,e.offsets.reference,e.placement)),e=P(e.instance.modifiers,e,'flip'))}),e},behavior:'flip',padding:5,boundariesElement:'viewport'},inner:{order:700,enabled:!1,fn:function(e){var t=e.placement,o=t.split('-')[0],n=e.offsets,i=n.popper,r=n.reference,p=-1!==['left','right'].indexOf(o),s=-1===['top','left'].indexOf(o);return i[p?'left':'top']=r[o]-(s?i[p?'width':'height']:0),e.placement=T(t),e.offsets.popper=g(i),e}},hide:{order:800,enabled:!0,fn:function(e){if(!q(e.instance.modifiers,'hide','preventOverflow'))return e;var t=e.offsets.reference,o=D(e.instance.modifiers,function(e){return'preventOverflow'===e.name}).boundaries;if(t.bottom<o.top||t.left>o.right||t.top>o.bottom||t.right<o.left){if(!0===e.hide)return e;e.hide=!0,e.attributes['x-out-of-boundaries']=''}else{if(!1===e.hide)return e;e.hide=!1,e.attributes['x-out-of-boundaries']=!1}return e}},computeStyle:{order:850,enabled:!0,fn:function(e,t){var o=t.x,n=t.y,i=e.offsets.popper,r=D(e.instance.modifiers,function(e){return'applyStyle'===e.name}).gpuAcceleration;void 0!==r&&console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');var s,d,a=void 0===r?t.gpuAcceleration:r,l=p(e.instance.popper),f=u(l),m={position:i.position},h={left:Z(i.left),top:Q(i.top),bottom:Q(i.bottom),right:Z(i.right)},c='bottom'===o?'top':'bottom',g='right'===n?'left':'right',b=B('transform');if(d='bottom'==c?-f.height+h.bottom:h.top,s='right'==g?-f.width+h.right:h.left,a&&b)m[b]='translate3d('+s+'px, '+d+'px, 0)',m[c]=0,m[g]=0,m.willChange='transform';else{var y='bottom'==c?-1:1,w='right'==g?-1:1;m[c]=d*y,m[g]=s*w,m.willChange=c+', '+g}var E={"x-placement":e.placement};return e.attributes=le({},E,e.attributes),e.styles=le({},m,e.styles),e.arrowStyles=le({},e.offsets.arrow,e.arrowStyles),e},gpuAcceleration:!0,x:'bottom',y:'right'},applyStyle:{order:900,enabled:!0,fn:function(e){return j(e.instance.popper,e.styles),K(e.instance.popper,e.attributes),e.arrowElement&&Object.keys(e.arrowStyles).length&&j(e.arrowElement,e.arrowStyles),e},onLoad:function(e,t,o,n,i){var r=L(i,t,e,o.positionFixed),p=O(o.placement,r,t,e,o.modifiers.flip.boundariesElement,o.modifiers.flip.padding);return t.setAttribute('x-placement',p),j(t,{position:o.positionFixed?'fixed':'absolute'}),o},gpuAcceleration:void 0}}},ce});
    //# sourceMappingURL=popper.js.map
    /**
     * Owl Carousel v2.2.1
     * Copyright 2013-2017 David Deutsch
     * Licensed under  ()
     */
    !function(a,b,c,d){function e(b,c){this.settings=null,this.options=a.extend({},e.Defaults,c),this.$element=a(b),this._handlers={},this._plugins={},this._supress={},this._current=null,this._speed=null,this._coordinates=[],this._breakpoint=null,this._width=null,this._items=[],this._clones=[],this._mergers=[],this._widths=[],this._invalidated={},this._pipe=[],this._drag={time:null,target:null,pointer:null,stage:{start:null,current:null},direction:null},this._states={current:{},tags:{initializing:["busy"],animating:["busy"],dragging:["interacting"]}},a.each(["onResize","onThrottledResize"],a.proxy(function(b,c){this._handlers[c]=a.proxy(this[c],this)},this)),a.each(e.Plugins,a.proxy(function(a,b){this._plugins[a.charAt(0).toLowerCase()+a.slice(1)]=new b(this)},this)),a.each(e.Workers,a.proxy(function(b,c){this._pipe.push({filter:c.filter,run:a.proxy(c.run,this)})},this)),this.setup(),this.initialize()}e.Defaults={items:3,loop:!1,center:!1,rewind:!1,mouseDrag:!0,touchDrag:!0,pullDrag:!0,freeDrag:!1,margin:0,stagePadding:0,merge:!1,mergeFit:!0,autoWidth:!1,startPosition:0,rtl:!1,smartSpeed:250,fluidSpeed:!1,dragEndSpeed:!1,responsive:{},responsiveRefreshRate:200,responsiveBaseElement:b,fallbackEasing:"swing",info:!1,nestedItemSelector:!1,itemElement:"div",stageElement:"div",refreshClass:"owl-refresh",loadedClass:"owl-loaded",loadingClass:"owl-loading",rtlClass:"owl-rtl",responsiveClass:"owl-responsive",dragClass:"owl-drag",itemClass:"owl-item",stageClass:"owl-stage",stageOuterClass:"owl-stage-outer",grabClass:"owl-grab"},e.Width={Default:"default",Inner:"inner",Outer:"outer"},e.Type={Event:"event",State:"state"},e.Plugins={},e.Workers=[{filter:["width","settings"],run:function(){this._width=this.$element.width()}},{filter:["width","items","settings"],run:function(a){a.current=this._items&&this._items[this.relative(this._current)]}},{filter:["items","settings"],run:function(){this.$stage.children(".cloned").remove()}},{filter:["width","items","settings"],run:function(a){var b=this.settings.margin||"",c=!this.settings.autoWidth,d=this.settings.rtl,e={width:"auto","margin-left":d?b:"","margin-right":d?"":b};!c&&this.$stage.children().css(e),a.css=e}},{filter:["width","items","settings"],run:function(a){var b=(this.width()/this.settings.items).toFixed(3)-this.settings.margin,c=null,d=this._items.length,e=!this.settings.autoWidth,f=[];for(a.items={merge:!1,width:b};d--;)c=this._mergers[d],c=this.settings.mergeFit&&Math.min(c,this.settings.items)||c,a.items.merge=c>1||a.items.merge,f[d]=e?b*c:this._items[d].width();this._widths=f}},{filter:["items","settings"],run:function(){var b=[],c=this._items,d=this.settings,e=Math.max(2*d.items,4),f=2*Math.ceil(c.length/2),g=d.loop&&c.length?d.rewind?e:Math.max(e,f):0,h="",i="";for(g/=2;g--;)b.push(this.normalize(b.length/2,!0)),h+=c[b[b.length-1]][0].outerHTML,b.push(this.normalize(c.length-1-(b.length-1)/2,!0)),i=c[b[b.length-1]][0].outerHTML+i;this._clones=b,a(h).addClass("cloned").appendTo(this.$stage),a(i).addClass("cloned").prependTo(this.$stage)}},{filter:["width","items","settings"],run:function(){for(var a=this.settings.rtl?1:-1,b=this._clones.length+this._items.length,c=-1,d=0,e=0,f=[];++c<b;)d=f[c-1]||0,e=this._widths[this.relative(c)]+this.settings.margin,f.push(d+e*a);this._coordinates=f}},{filter:["width","items","settings"],run:function(){var a=this.settings.stagePadding,b=this._coordinates,c={width:Math.ceil(Math.abs(b[b.length-1]))+2*a,"padding-left":a||"","padding-right":a||""};this.$stage.css(c)}},{filter:["width","items","settings"],run:function(a){var b=this._coordinates.length,c=!this.settings.autoWidth,d=this.$stage.children();if(c&&a.items.merge)for(;b--;)a.css.width=this._widths[this.relative(b)],d.eq(b).css(a.css);else c&&(a.css.width=a.items.width,d.css(a.css))}},{filter:["items"],run:function(){this._coordinates.length<1&&this.$stage.removeAttr("style")}},{filter:["width","items","settings"],run:function(a){a.current=a.current?this.$stage.children().index(a.current):0,a.current=Math.max(this.minimum(),Math.min(this.maximum(),a.current)),this.reset(a.current)}},{filter:["position"],run:function(){this.animate(this.coordinates(this._current))}},{filter:["width","position","items","settings"],run:function(){var a,b,c,d,e=this.settings.rtl?1:-1,f=2*this.settings.stagePadding,g=this.coordinates(this.current())+f,h=g+this.width()*e,i=[];for(c=0,d=this._coordinates.length;c<d;c++)a=this._coordinates[c-1]||0,b=Math.abs(this._coordinates[c])+f*e,(this.op(a,"<=",g)&&this.op(a,">",h)||this.op(b,"<",g)&&this.op(b,">",h))&&i.push(c);this.$stage.children(".active").removeClass("active"),this.$stage.children(":eq("+i.join("), :eq(")+")").addClass("active"),this.settings.center&&(this.$stage.children(".center").removeClass("center"),this.$stage.children().eq(this.current()).addClass("center"))}}],e.prototype.initialize=function(){if(this.enter("initializing"),this.trigger("initialize"),this.$element.toggleClass(this.settings.rtlClass,this.settings.rtl),this.settings.autoWidth&&!this.is("pre-loading")){var b,c,e;b=this.$element.find("img"),c=this.settings.nestedItemSelector?"."+this.settings.nestedItemSelector:d,e=this.$element.children(c).width(),b.length&&e<=0&&this.preloadAutoWidthImages(b)}this.$element.addClass(this.options.loadingClass),this.$stage=a("<"+this.settings.stageElement+' class="'+this.settings.stageClass+'"/>').wrap('<div class="'+this.settings.stageOuterClass+'"/>'),this.$element.append(this.$stage.parent()),this.replace(this.$element.children().not(this.$stage.parent())),this.$element.is(":visible")?this.refresh():this.invalidate("width"),this.$element.removeClass(this.options.loadingClass).addClass(this.options.loadedClass),this.registerEventHandlers(),this.leave("initializing"),this.trigger("initialized")},e.prototype.setup=function(){var b=this.viewport(),c=this.options.responsive,d=-1,e=null;c?(a.each(c,function(a){a<=b&&a>d&&(d=Number(a))}),e=a.extend({},this.options,c[d]),"function"==typeof e.stagePadding&&(e.stagePadding=e.stagePadding()),delete e.responsive,e.responsiveClass&&this.$element.attr("class",this.$element.attr("class").replace(new RegExp("("+this.options.responsiveClass+"-)\\S+\\s","g"),"$1"+d))):e=a.extend({},this.options),this.trigger("change",{property:{name:"settings",value:e}}),this._breakpoint=d,this.settings=e,this.invalidate("settings"),this.trigger("changed",{property:{name:"settings",value:this.settings}})},e.prototype.optionsLogic=function(){this.settings.autoWidth&&(this.settings.stagePadding=!1,this.settings.merge=!1)},e.prototype.prepare=function(b){var c=this.trigger("prepare",{content:b});return c.data||(c.data=a("<"+this.settings.itemElement+"/>").addClass(this.options.itemClass).append(b)),this.trigger("prepared",{content:c.data}),c.data},e.prototype.update=function(){for(var b=0,c=this._pipe.length,d=a.proxy(function(a){return this[a]},this._invalidated),e={};b<c;)(this._invalidated.all||a.grep(this._pipe[b].filter,d).length>0)&&this._pipe[b].run(e),b++;this._invalidated={},!this.is("valid")&&this.enter("valid")},e.prototype.width=function(a){switch(a=a||e.Width.Default){case e.Width.Inner:case e.Width.Outer:return this._width;default:return this._width-2*this.settings.stagePadding+this.settings.margin}},e.prototype.refresh=function(){this.enter("refreshing"),this.trigger("refresh"),this.setup(),this.optionsLogic(),this.$element.addClass(this.options.refreshClass),this.update(),this.$element.removeClass(this.options.refreshClass),this.leave("refreshing"),this.trigger("refreshed")},e.prototype.onThrottledResize=function(){b.clearTimeout(this.resizeTimer),this.resizeTimer=b.setTimeout(this._handlers.onResize,this.settings.responsiveRefreshRate)},e.prototype.onResize=function(){return!!this._items.length&&(this._width!==this.$element.width()&&(!!this.$element.is(":visible")&&(this.enter("resizing"),this.trigger("resize").isDefaultPrevented()?(this.leave("resizing"),!1):(this.invalidate("width"),this.refresh(),this.leave("resizing"),void this.trigger("resized")))))},e.prototype.registerEventHandlers=function(){a.support.transition&&this.$stage.on(a.support.transition.end+".owl.core",a.proxy(this.onTransitionEnd,this)),this.settings.responsive!==!1&&this.on(b,"resize",this._handlers.onThrottledResize),this.settings.mouseDrag&&(this.$element.addClass(this.options.dragClass),this.$stage.on("mousedown.owl.core",a.proxy(this.onDragStart,this)),this.$stage.on("dragstart.owl.core selectstart.owl.core",function(){return!1})),this.settings.touchDrag&&(this.$stage.on("touchstart.owl.core",a.proxy(this.onDragStart,this)),this.$stage.on("touchcancel.owl.core",a.proxy(this.onDragEnd,this)))},e.prototype.onDragStart=function(b){var d=null;3!==b.which&&(a.support.transform?(d=this.$stage.css("transform").replace(/.*\(|\)| /g,"").split(","),d={x:d[16===d.length?12:4],y:d[16===d.length?13:5]}):(d=this.$stage.position(),d={x:this.settings.rtl?d.left+this.$stage.width()-this.width()+this.settings.margin:d.left,y:d.top}),this.is("animating")&&(a.support.transform?this.animate(d.x):this.$stage.stop(),this.invalidate("position")),this.$element.toggleClass(this.options.grabClass,"mousedown"===b.type),this.speed(0),this._drag.time=(new Date).getTime(),this._drag.target=a(b.target),this._drag.stage.start=d,this._drag.stage.current=d,this._drag.pointer=this.pointer(b),a(c).on("mouseup.owl.core touchend.owl.core",a.proxy(this.onDragEnd,this)),a(c).one("mousemove.owl.core touchmove.owl.core",a.proxy(function(b){var d=this.difference(this._drag.pointer,this.pointer(b));a(c).on("mousemove.owl.core touchmove.owl.core",a.proxy(this.onDragMove,this)),Math.abs(d.x)<Math.abs(d.y)&&this.is("valid")||(b.preventDefault(),this.enter("dragging"),this.trigger("drag"))},this)))},e.prototype.onDragMove=function(a){var b=null,c=null,d=null,e=this.difference(this._drag.pointer,this.pointer(a)),f=this.difference(this._drag.stage.start,e);this.is("dragging")&&(a.preventDefault(),this.settings.loop?(b=this.coordinates(this.minimum()),c=this.coordinates(this.maximum()+1)-b,f.x=((f.x-b)%c+c)%c+b):(b=this.settings.rtl?this.coordinates(this.maximum()):this.coordinates(this.minimum()),c=this.settings.rtl?this.coordinates(this.minimum()):this.coordinates(this.maximum()),d=this.settings.pullDrag?-1*e.x/5:0,f.x=Math.max(Math.min(f.x,b+d),c+d)),this._drag.stage.current=f,this.animate(f.x))},e.prototype.onDragEnd=function(b){var d=this.difference(this._drag.pointer,this.pointer(b)),e=this._drag.stage.current,f=d.x>0^this.settings.rtl?"left":"right";a(c).off(".owl.core"),this.$element.removeClass(this.options.grabClass),(0!==d.x&&this.is("dragging")||!this.is("valid"))&&(this.speed(this.settings.dragEndSpeed||this.settings.smartSpeed),this.current(this.closest(e.x,0!==d.x?f:this._drag.direction)),this.invalidate("position"),this.update(),this._drag.direction=f,(Math.abs(d.x)>3||(new Date).getTime()-this._drag.time>300)&&this._drag.target.one("click.owl.core",function(){return!1})),this.is("dragging")&&(this.leave("dragging"),this.trigger("dragged"))},e.prototype.closest=function(b,c){var d=-1,e=30,f=this.width(),g=this.coordinates();return this.settings.freeDrag||a.each(g,a.proxy(function(a,h){return"left"===c&&b>h-e&&b<h+e?d=a:"right"===c&&b>h-f-e&&b<h-f+e?d=a+1:this.op(b,"<",h)&&this.op(b,">",g[a+1]||h-f)&&(d="left"===c?a+1:a),d===-1},this)),this.settings.loop||(this.op(b,">",g[this.minimum()])?d=b=this.minimum():this.op(b,"<",g[this.maximum()])&&(d=b=this.maximum())),d},e.prototype.animate=function(b){var c=this.speed()>0;this.is("animating")&&this.onTransitionEnd(),c&&(this.enter("animating"),this.trigger("translate")),a.support.transform3d&&a.support.transition?this.$stage.css({transform:"translate3d("+b+"px,0px,0px)",transition:this.speed()/1e3+"s"}):c?this.$stage.animate({left:b+"px"},this.speed(),this.settings.fallbackEasing,a.proxy(this.onTransitionEnd,this)):this.$stage.css({left:b+"px"})},e.prototype.is=function(a){return this._states.current[a]&&this._states.current[a]>0},e.prototype.current=function(a){if(a===d)return this._current;if(0===this._items.length)return d;if(a=this.normalize(a),this._current!==a){var b=this.trigger("change",{property:{name:"position",value:a}});b.data!==d&&(a=this.normalize(b.data)),this._current=a,this.invalidate("position"),this.trigger("changed",{property:{name:"position",value:this._current}})}return this._current},e.prototype.invalidate=function(b){return"string"===a.type(b)&&(this._invalidated[b]=!0,this.is("valid")&&this.leave("valid")),a.map(this._invalidated,function(a,b){return b})},e.prototype.reset=function(a){a=this.normalize(a),a!==d&&(this._speed=0,this._current=a,this.suppress(["translate","translated"]),this.animate(this.coordinates(a)),this.release(["translate","translated"]))},e.prototype.normalize=function(a,b){var c=this._items.length,e=b?0:this._clones.length;return!this.isNumeric(a)||c<1?a=d:(a<0||a>=c+e)&&(a=((a-e/2)%c+c)%c+e/2),a},e.prototype.relative=function(a){return a-=this._clones.length/2,this.normalize(a,!0)},e.prototype.maximum=function(a){var b,c,d,e=this.settings,f=this._coordinates.length;if(e.loop)f=this._clones.length/2+this._items.length-1;else if(e.autoWidth||e.merge){for(b=this._items.length,c=this._items[--b].width(),d=this.$element.width();b--&&(c+=this._items[b].width()+this.settings.margin,!(c>d)););f=b+1}else f=e.center?this._items.length-1:this._items.length-e.items;return a&&(f-=this._clones.length/2),Math.max(f,0)},e.prototype.minimum=function(a){return a?0:this._clones.length/2},e.prototype.items=function(a){return a===d?this._items.slice():(a=this.normalize(a,!0),this._items[a])},e.prototype.mergers=function(a){return a===d?this._mergers.slice():(a=this.normalize(a,!0),this._mergers[a])},e.prototype.clones=function(b){var c=this._clones.length/2,e=c+this._items.length,f=function(a){return a%2===0?e+a/2:c-(a+1)/2};return b===d?a.map(this._clones,function(a,b){return f(b)}):a.map(this._clones,function(a,c){return a===b?f(c):null})},e.prototype.speed=function(a){return a!==d&&(this._speed=a),this._speed},e.prototype.coordinates=function(b){var c,e=1,f=b-1;return b===d?a.map(this._coordinates,a.proxy(function(a,b){return this.coordinates(b)},this)):(this.settings.center?(this.settings.rtl&&(e=-1,f=b+1),c=this._coordinates[b],c+=(this.width()-c+(this._coordinates[f]||0))/2*e):c=this._coordinates[f]||0,c=Math.ceil(c))},e.prototype.duration=function(a,b,c){return 0===c?0:Math.min(Math.max(Math.abs(b-a),1),6)*Math.abs(c||this.settings.smartSpeed)},e.prototype.to=function(a,b){var c=this.current(),d=null,e=a-this.relative(c),f=(e>0)-(e<0),g=this._items.length,h=this.minimum(),i=this.maximum();this.settings.loop?(!this.settings.rewind&&Math.abs(e)>g/2&&(e+=f*-1*g),a=c+e,d=((a-h)%g+g)%g+h,d!==a&&d-e<=i&&d-e>0&&(c=d-e,a=d,this.reset(c))):this.settings.rewind?(i+=1,a=(a%i+i)%i):a=Math.max(h,Math.min(i,a)),this.speed(this.duration(c,a,b)),this.current(a),this.$element.is(":visible")&&this.update()},e.prototype.next=function(a){a=a||!1,this.to(this.relative(this.current())+1,a)},e.prototype.prev=function(a){a=a||!1,this.to(this.relative(this.current())-1,a)},e.prototype.onTransitionEnd=function(a){if(a!==d&&(a.stopPropagation(),(a.target||a.srcElement||a.originalTarget)!==this.$stage.get(0)))return!1;this.leave("animating"),this.trigger("translated")},e.prototype.viewport=function(){var d;return this.options.responsiveBaseElement!==b?d=a(this.options.responsiveBaseElement).width():b.innerWidth?d=b.innerWidth:c.documentElement&&c.documentElement.clientWidth?d=c.documentElement.clientWidth:console.warn("Can not detect viewport width."),d},e.prototype.replace=function(b){this.$stage.empty(),this._items=[],b&&(b=b instanceof jQuery?b:a(b)),this.settings.nestedItemSelector&&(b=b.find("."+this.settings.nestedItemSelector)),b.filter(function(){return 1===this.nodeType}).each(a.proxy(function(a,b){b=this.prepare(b),this.$stage.append(b),this._items.push(b),this._mergers.push(1*b.find("[data-merge]").addBack("[data-merge]").attr("data-merge")||1)},this)),this.reset(this.isNumeric(this.settings.startPosition)?this.settings.startPosition:0),this.invalidate("items")},e.prototype.add=function(b,c){var e=this.relative(this._current);c=c===d?this._items.length:this.normalize(c,!0),b=b instanceof jQuery?b:a(b),this.trigger("add",{content:b,position:c}),b=this.prepare(b),0===this._items.length||c===this._items.length?(0===this._items.length&&this.$stage.append(b),0!==this._items.length&&this._items[c-1].after(b),this._items.push(b),this._mergers.push(1*b.find("[data-merge]").addBack("[data-merge]").attr("data-merge")||1)):(this._items[c].before(b),this._items.splice(c,0,b),this._mergers.splice(c,0,1*b.find("[data-merge]").addBack("[data-merge]").attr("data-merge")||1)),this._items[e]&&this.reset(this._items[e].index()),this.invalidate("items"),this.trigger("added",{content:b,position:c})},e.prototype.remove=function(a){a=this.normalize(a,!0),a!==d&&(this.trigger("remove",{content:this._items[a],position:a}),this._items[a].remove(),this._items.splice(a,1),this._mergers.splice(a,1),this.invalidate("items"),this.trigger("removed",{content:null,position:a}))},e.prototype.preloadAutoWidthImages=function(b){b.each(a.proxy(function(b,c){this.enter("pre-loading"),c=a(c),a(new Image).one("load",a.proxy(function(a){c.attr("src",a.target.src),c.css("opacity",1),this.leave("pre-loading"),!this.is("pre-loading")&&!this.is("initializing")&&this.refresh()},this)).attr("src",c.attr("src")||c.attr("data-src")||c.attr("data-src-retina"))},this))},e.prototype.destroy=function(){this.$element.off(".owl.core"),this.$stage.off(".owl.core"),a(c).off(".owl.core"),this.settings.responsive!==!1&&(b.clearTimeout(this.resizeTimer),this.off(b,"resize",this._handlers.onThrottledResize));for(var d in this._plugins)this._plugins[d].destroy();this.$stage.children(".cloned").remove(),this.$stage.unwrap(),this.$stage.children().contents().unwrap(),this.$stage.children().unwrap(),this.$element.removeClass(this.options.refreshClass).removeClass(this.options.loadingClass).removeClass(this.options.loadedClass).removeClass(this.options.rtlClass).removeClass(this.options.dragClass).removeClass(this.options.grabClass).attr("class",this.$element.attr("class").replace(new RegExp(this.options.responsiveClass+"-\\S+\\s","g"),"")).removeData("owl.carousel")},e.prototype.op=function(a,b,c){var d=this.settings.rtl;switch(b){case"<":return d?a>c:a<c;case">":return d?a<c:a>c;case">=":return d?a<=c:a>=c;case"<=":return d?a>=c:a<=c}},e.prototype.on=function(a,b,c,d){a.addEventListener?a.addEventListener(b,c,d):a.attachEvent&&a.attachEvent("on"+b,c)},e.prototype.off=function(a,b,c,d){a.removeEventListener?a.removeEventListener(b,c,d):a.detachEvent&&a.detachEvent("on"+b,c)},e.prototype.trigger=function(b,c,d,f,g){var h={item:{count:this._items.length,index:this.current()}},i=a.camelCase(a.grep(["on",b,d],function(a){return a}).join("-").toLowerCase()),j=a.Event([b,"owl",d||"carousel"].join(".").toLowerCase(),a.extend({relatedTarget:this},h,c));return this._supress[b]||(a.each(this._plugins,function(a,b){b.onTrigger&&b.onTrigger(j)}),this.register({type:e.Type.Event,name:b}),this.$element.trigger(j),this.settings&&"function"==typeof this.settings[i]&&this.settings[i].call(this,j)),j},e.prototype.enter=function(b){a.each([b].concat(this._states.tags[b]||[]),a.proxy(function(a,b){this._states.current[b]===d&&(this._states.current[b]=0),this._states.current[b]++},this))},e.prototype.leave=function(b){a.each([b].concat(this._states.tags[b]||[]),a.proxy(function(a,b){this._states.current[b]--},this))},e.prototype.register=function(b){if(b.type===e.Type.Event){if(a.event.special[b.name]||(a.event.special[b.name]={}),!a.event.special[b.name].owl){var c=a.event.special[b.name]._default;a.event.special[b.name]._default=function(a){return!c||!c.apply||a.namespace&&a.namespace.indexOf("owl")!==-1?a.namespace&&a.namespace.indexOf("owl")>-1:c.apply(this,arguments)},a.event.special[b.name].owl=!0}}else b.type===e.Type.State&&(this._states.tags[b.name]?this._states.tags[b.name]=this._states.tags[b.name].concat(b.tags):this._states.tags[b.name]=b.tags,this._states.tags[b.name]=a.grep(this._states.tags[b.name],a.proxy(function(c,d){return a.inArray(c,this._states.tags[b.name])===d},this)))},e.prototype.suppress=function(b){a.each(b,a.proxy(function(a,b){this._supress[b]=!0},this))},e.prototype.release=function(b){a.each(b,a.proxy(function(a,b){delete this._supress[b]},this))},e.prototype.pointer=function(a){var c={x:null,y:null};return a=a.originalEvent||a||b.event,a=a.touches&&a.touches.length?a.touches[0]:a.changedTouches&&a.changedTouches.length?a.changedTouches[0]:a,a.pageX?(c.x=a.pageX,c.y=a.pageY):(c.x=a.clientX,c.y=a.clientY),c},e.prototype.isNumeric=function(a){return!isNaN(parseFloat(a))},e.prototype.difference=function(a,b){return{x:a.x-b.x,y:a.y-b.y}},a.fn.owlCarousel=function(b){var c=Array.prototype.slice.call(arguments,1);return this.each(function(){var d=a(this),f=d.data("owl.carousel");f||(f=new e(this,"object"==typeof b&&b),d.data("owl.carousel",f),a.each(["next","prev","to","destroy","refresh","replace","add","remove"],function(b,c){f.register({type:e.Type.Event,name:c}),f.$element.on(c+".owl.carousel.core",a.proxy(function(a){a.namespace&&a.relatedTarget!==this&&(this.suppress([c]),f[c].apply(this,[].slice.call(arguments,1)),this.release([c]))},f))})),"string"==typeof b&&"_"!==b.charAt(0)&&f[b].apply(f,c)})},a.fn.owlCarousel.Constructor=e}(window.Zepto||window.jQuery,window,document),function(a,b,c,d){var e=function(b){this._core=b,this._interval=null,this._visible=null,this._handlers={"initialized.owl.carousel":a.proxy(function(a){a.namespace&&this._core.settings.autoRefresh&&this.watch()},this)},this._core.options=a.extend({},e.Defaults,this._core.options),this._core.$element.on(this._handlers)};e.Defaults={autoRefresh:!0,autoRefreshInterval:500},e.prototype.watch=function(){this._interval||(this._visible=this._core.$element.is(":visible"),this._interval=b.setInterval(a.proxy(this.refresh,this),this._core.settings.autoRefreshInterval))},e.prototype.refresh=function(){this._core.$element.is(":visible")!==this._visible&&(this._visible=!this._visible,this._core.$element.toggleClass("owl-hidden",!this._visible),this._visible&&this._core.invalidate("width")&&this._core.refresh())},e.prototype.destroy=function(){var a,c;b.clearInterval(this._interval);for(a in this._handlers)this._core.$element.off(a,this._handlers[a]);for(c in Object.getOwnPropertyNames(this))"function"!=typeof this[c]&&(this[c]=null)},a.fn.owlCarousel.Constructor.Plugins.AutoRefresh=e}(window.Zepto||window.jQuery,window,document),function(a,b,c,d){var e=function(b){this._core=b,this._loaded=[],this._handlers={"initialized.owl.carousel change.owl.carousel resized.owl.carousel":a.proxy(function(b){if(b.namespace&&this._core.settings&&this._core.settings.lazyLoad&&(b.property&&"position"==b.property.name||"initialized"==b.type))for(var c=this._core.settings,e=c.center&&Math.ceil(c.items/2)||c.items,f=c.center&&e*-1||0,g=(b.property&&b.property.value!==d?b.property.value:this._core.current())+f,h=this._core.clones().length,i=a.proxy(function(a,b){this.load(b)},this);f++<e;)this.load(h/2+this._core.relative(g)),h&&a.each(this._core.clones(this._core.relative(g)),i),g++},this)},this._core.options=a.extend({},e.Defaults,this._core.options),this._core.$element.on(this._handlers)};e.Defaults={lazyLoad:!1},e.prototype.load=function(c){var d=this._core.$stage.children().eq(c),e=d&&d.find(".owl-lazy");!e||a.inArray(d.get(0),this._loaded)>-1||(e.each(a.proxy(function(c,d){var e,f=a(d),g=b.devicePixelRatio>1&&f.attr("data-src-retina")||f.attr("data-src");this._core.trigger("load",{element:f,url:g},"lazy"),f.is("img")?f.one("load.owl.lazy",a.proxy(function(){f.css("opacity",1),this._core.trigger("loaded",{element:f,url:g},"lazy")},this)).attr("src",g):(e=new Image,e.onload=a.proxy(function(){f.css({"background-image":'url("'+g+'")',opacity:"1"}),this._core.trigger("loaded",{element:f,url:g},"lazy")},this),e.src=g)},this)),this._loaded.push(d.get(0)))},e.prototype.destroy=function(){var a,b;for(a in this.handlers)this._core.$element.off(a,this.handlers[a]);for(b in Object.getOwnPropertyNames(this))"function"!=typeof this[b]&&(this[b]=null)},a.fn.owlCarousel.Constructor.Plugins.Lazy=e}(window.Zepto||window.jQuery,window,document),function(a,b,c,d){var e=function(b){this._core=b,this._handlers={"initialized.owl.carousel refreshed.owl.carousel":a.proxy(function(a){a.namespace&&this._core.settings.autoHeight&&this.update()},this),"changed.owl.carousel":a.proxy(function(a){a.namespace&&this._core.settings.autoHeight&&"position"==a.property.name&&this.update()},this),"loaded.owl.lazy":a.proxy(function(a){a.namespace&&this._core.settings.autoHeight&&a.element.closest("."+this._core.settings.itemClass).index()===this._core.current()&&this.update()},this)},this._core.options=a.extend({},e.Defaults,this._core.options),this._core.$element.on(this._handlers)};e.Defaults={autoHeight:!1,autoHeightClass:"owl-height"},e.prototype.update=function(){var b=this._core._current,c=b+this._core.settings.items,d=this._core.$stage.children().toArray().slice(b,c),e=[],f=0;a.each(d,function(b,c){e.push(a(c).height())}),f=Math.max.apply(null,e),this._core.$stage.parent().height(f).addClass(this._core.settings.autoHeightClass)},e.prototype.destroy=function(){var a,b;for(a in this._handlers)this._core.$element.off(a,this._handlers[a]);for(b in Object.getOwnPropertyNames(this))"function"!=typeof this[b]&&(this[b]=null)},a.fn.owlCarousel.Constructor.Plugins.AutoHeight=e}(window.Zepto||window.jQuery,window,document),function(a,b,c,d){var e=function(b){this._core=b,this._videos={},this._playing=null,this._handlers={"initialized.owl.carousel":a.proxy(function(a){a.namespace&&this._core.register({type:"state",name:"playing",tags:["interacting"]})},this),"resize.owl.carousel":a.proxy(function(a){a.namespace&&this._core.settings.video&&this.isInFullScreen()&&a.preventDefault()},this),"refreshed.owl.carousel":a.proxy(function(a){a.namespace&&this._core.is("resizing")&&this._core.$stage.find(".cloned .owl-video-frame").remove()},this),"changed.owl.carousel":a.proxy(function(a){a.namespace&&"position"===a.property.name&&this._playing&&this.stop()},this),"prepared.owl.carousel":a.proxy(function(b){if(b.namespace){var c=a(b.content).find(".owl-video");c.length&&(c.css("display","none"),this.fetch(c,a(b.content)))}},this)},this._core.options=a.extend({},e.Defaults,this._core.options),this._core.$element.on(this._handlers),this._core.$element.on("click.owl.video",".owl-video-play-icon",a.proxy(function(a){this.play(a)},this))};e.Defaults={video:!1,videoHeight:!1,videoWidth:!1},e.prototype.fetch=function(a,b){var c=function(){return a.attr("data-vimeo-id")?"vimeo":a.attr("data-vzaar-id")?"vzaar":"youtube"}(),d=a.attr("data-vimeo-id")||a.attr("data-youtube-id")||a.attr("data-vzaar-id"),e=a.attr("data-width")||this._core.settings.videoWidth,f=a.attr("data-height")||this._core.settings.videoHeight,g=a.attr("href");if(!g)throw new Error("Missing video URL.");if(d=g.match(/(http:|https:|)\/\/(player.|www.|app.)?(vimeo\.com|youtu(be\.com|\.be|be\.googleapis\.com)|vzaar\.com)\/(video\/|videos\/|embed\/|channels\/.+\/|groups\/.+\/|watch\?v=|v\/)?([A-Za-z0-9._%-]*)(\&\S+)?/),d[3].indexOf("youtu")>-1)c="youtube";else if(d[3].indexOf("vimeo")>-1)c="vimeo";else{if(!(d[3].indexOf("vzaar")>-1))throw new Error("Video URL not supported.");c="vzaar"}d=d[6],this._videos[g]={type:c,id:d,width:e,height:f},b.attr("data-video",g),this.thumbnail(a,this._videos[g])},e.prototype.thumbnail=function(b,c){var d,e,f,g=c.width&&c.height?'style="width:'+c.width+"px;height:"+c.height+'px;"':"",h=b.find("img"),i="src",j="",k=this._core.settings,l=function(a){e='<div class="owl-video-play-icon"></div>',d=k.lazyLoad?'<div class="owl-video-tn '+j+'" '+i+'="'+a+'"></div>':'<div class="owl-video-tn" style="opacity:1;background-image:url('+a+')"></div>',b.after(d),b.after(e)};if(b.wrap('<div class="owl-video-wrapper"'+g+"></div>"),this._core.settings.lazyLoad&&(i="data-src",j="owl-lazy"),h.length)return l(h.attr(i)),h.remove(),!1;"youtube"===c.type?(f="//img.youtube.com/vi/"+c.id+"/hqdefault.jpg",l(f)):"vimeo"===c.type?a.ajax({type:"GET",url:"//vimeo.com/api/v2/video/"+c.id+".json",jsonp:"callback",dataType:"jsonp",success:function(a){f=a[0].thumbnail_large,l(f)}}):"vzaar"===c.type&&a.ajax({type:"GET",url:"//vzaar.com/api/videos/"+c.id+".json",jsonp:"callback",dataType:"jsonp",success:function(a){f=a.framegrab_url,l(f)}})},e.prototype.stop=function(){this._core.trigger("stop",null,"video"),this._playing.find(".owl-video-frame").remove(),this._playing.removeClass("owl-video-playing"),this._playing=null,this._core.leave("playing"),this._core.trigger("stopped",null,"video")},e.prototype.play=function(b){var c,d=a(b.target),e=d.closest("."+this._core.settings.itemClass),f=this._videos[e.attr("data-video")],g=f.width||"100%",h=f.height||this._core.$stage.height();this._playing||(this._core.enter("playing"),this._core.trigger("play",null,"video"),e=this._core.items(this._core.relative(e.index())),this._core.reset(e.index()),"youtube"===f.type?c='<iframe width="'+g+'" height="'+h+'" src="//www.youtube.com/embed/'+f.id+"?autoplay=1&rel=0&v="+f.id+'" frameborder="0" allowfullscreen></iframe>':"vimeo"===f.type?c='<iframe src="//player.vimeo.com/video/'+f.id+'?autoplay=1" width="'+g+'" height="'+h+'" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>':"vzaar"===f.type&&(c='<iframe frameborder="0"height="'+h+'"width="'+g+'" allowfullscreen mozallowfullscreen webkitAllowFullScreen src="//view.vzaar.com/'+f.id+'/player?autoplay=true"></iframe>'),a('<div class="owl-video-frame">'+c+"</div>").insertAfter(e.find(".owl-video")),this._playing=e.addClass("owl-video-playing"))},e.prototype.isInFullScreen=function(){var b=c.fullscreenElement||c.mozFullScreenElement||c.webkitFullscreenElement;return b&&a(b).parent().hasClass("owl-video-frame")},e.prototype.destroy=function(){var a,b;this._core.$element.off("click.owl.video");for(a in this._handlers)this._core.$element.off(a,this._handlers[a]);for(b in Object.getOwnPropertyNames(this))"function"!=typeof this[b]&&(this[b]=null)},a.fn.owlCarousel.Constructor.Plugins.Video=e}(window.Zepto||window.jQuery,window,document),function(a,b,c,d){var e=function(b){this.core=b,this.core.options=a.extend({},e.Defaults,this.core.options),this.swapping=!0,this.previous=d,this.next=d,this.handlers={"change.owl.carousel":a.proxy(function(a){a.namespace&&"position"==a.property.name&&(this.previous=this.core.current(),this.next=a.property.value)},this),"drag.owl.carousel dragged.owl.carousel translated.owl.carousel":a.proxy(function(a){a.namespace&&(this.swapping="translated"==a.type)},this),"translate.owl.carousel":a.proxy(function(a){a.namespace&&this.swapping&&(this.core.options.animateOut||this.core.options.animateIn)&&this.swap()},this)},this.core.$element.on(this.handlers)};e.Defaults={animateOut:!1,animateIn:!1},e.prototype.swap=function(){if(1===this.core.settings.items&&a.support.animation&&a.support.transition){this.core.speed(0);var b,c=a.proxy(this.clear,this),d=this.core.$stage.children().eq(this.previous),e=this.core.$stage.children().eq(this.next),f=this.core.settings.animateIn,g=this.core.settings.animateOut;this.core.current()!==this.previous&&(g&&(b=this.core.coordinates(this.previous)-this.core.coordinates(this.next),d.one(a.support.animation.end,c).css({left:b+"px"}).addClass("animated owl-animated-out").addClass(g)),f&&e.one(a.support.animation.end,c).addClass("animated owl-animated-in").addClass(f))}},e.prototype.clear=function(b){a(b.target).css({left:""}).removeClass("animated owl-animated-out owl-animated-in").removeClass(this.core.settings.animateIn).removeClass(this.core.settings.animateOut),this.core.onTransitionEnd()},e.prototype.destroy=function(){var a,b;for(a in this.handlers)this.core.$element.off(a,this.handlers[a]);for(b in Object.getOwnPropertyNames(this))"function"!=typeof this[b]&&(this[b]=null)},
    a.fn.owlCarousel.Constructor.Plugins.Animate=e}(window.Zepto||window.jQuery,window,document),function(a,b,c,d){var e=function(b){this._core=b,this._timeout=null,this._paused=!1,this._handlers={"changed.owl.carousel":a.proxy(function(a){a.namespace&&"settings"===a.property.name?this._core.settings.autoplay?this.play():this.stop():a.namespace&&"position"===a.property.name&&this._core.settings.autoplay&&this._setAutoPlayInterval()},this),"initialized.owl.carousel":a.proxy(function(a){a.namespace&&this._core.settings.autoplay&&this.play()},this),"play.owl.autoplay":a.proxy(function(a,b,c){a.namespace&&this.play(b,c)},this),"stop.owl.autoplay":a.proxy(function(a){a.namespace&&this.stop()},this),"mouseover.owl.autoplay":a.proxy(function(){this._core.settings.autoplayHoverPause&&this._core.is("rotating")&&this.pause()},this),"mouseleave.owl.autoplay":a.proxy(function(){this._core.settings.autoplayHoverPause&&this._core.is("rotating")&&this.play()},this),"touchstart.owl.core":a.proxy(function(){this._core.settings.autoplayHoverPause&&this._core.is("rotating")&&this.pause()},this),"touchend.owl.core":a.proxy(function(){this._core.settings.autoplayHoverPause&&this.play()},this)},this._core.$element.on(this._handlers),this._core.options=a.extend({},e.Defaults,this._core.options)};e.Defaults={autoplay:!1,autoplayTimeout:5e3,autoplayHoverPause:!1,autoplaySpeed:!1},e.prototype.play=function(a,b){this._paused=!1,this._core.is("rotating")||(this._core.enter("rotating"),this._setAutoPlayInterval())},e.prototype._getNextTimeout=function(d,e){return this._timeout&&b.clearTimeout(this._timeout),b.setTimeout(a.proxy(function(){this._paused||this._core.is("busy")||this._core.is("interacting")||c.hidden||this._core.next(e||this._core.settings.autoplaySpeed)},this),d||this._core.settings.autoplayTimeout)},e.prototype._setAutoPlayInterval=function(){this._timeout=this._getNextTimeout()},e.prototype.stop=function(){this._core.is("rotating")&&(b.clearTimeout(this._timeout),this._core.leave("rotating"))},e.prototype.pause=function(){this._core.is("rotating")&&(this._paused=!0)},e.prototype.destroy=function(){var a,b;this.stop();for(a in this._handlers)this._core.$element.off(a,this._handlers[a]);for(b in Object.getOwnPropertyNames(this))"function"!=typeof this[b]&&(this[b]=null)},a.fn.owlCarousel.Constructor.Plugins.autoplay=e}(window.Zepto||window.jQuery,window,document),function(a,b,c,d){"use strict";var e=function(b){this._core=b,this._initialized=!1,this._pages=[],this._controls={},this._templates=[],this.$element=this._core.$element,this._overrides={next:this._core.next,prev:this._core.prev,to:this._core.to},this._handlers={"prepared.owl.carousel":a.proxy(function(b){b.namespace&&this._core.settings.dotsData&&this._templates.push('<div class="'+this._core.settings.dotClass+'">'+a(b.content).find("[data-dot]").addBack("[data-dot]").attr("data-dot")+"</div>")},this),"added.owl.carousel":a.proxy(function(a){a.namespace&&this._core.settings.dotsData&&this._templates.splice(a.position,0,this._templates.pop())},this),"remove.owl.carousel":a.proxy(function(a){a.namespace&&this._core.settings.dotsData&&this._templates.splice(a.position,1)},this),"changed.owl.carousel":a.proxy(function(a){a.namespace&&"position"==a.property.name&&this.draw()},this),"initialized.owl.carousel":a.proxy(function(a){a.namespace&&!this._initialized&&(this._core.trigger("initialize",null,"navigation"),this.initialize(),this.update(),this.draw(),this._initialized=!0,this._core.trigger("initialized",null,"navigation"))},this),"refreshed.owl.carousel":a.proxy(function(a){a.namespace&&this._initialized&&(this._core.trigger("refresh",null,"navigation"),this.update(),this.draw(),this._core.trigger("refreshed",null,"navigation"))},this)},this._core.options=a.extend({},e.Defaults,this._core.options),this.$element.on(this._handlers)};e.Defaults={nav:!1,navText:["prev","next"],navSpeed:!1,navElement:"div",navContainer:!1,navContainerClass:"owl-nav",navClass:["owl-prev","owl-next"],slideBy:1,dotClass:"owl-dot",dotsClass:"owl-dots",dots:!0,dotsEach:!1,dotsData:!1,dotsSpeed:!1,dotsContainer:!1},e.prototype.initialize=function(){var b,c=this._core.settings;this._controls.$relative=(c.navContainer?a(c.navContainer):a("<div>").addClass(c.navContainerClass).appendTo(this.$element)).addClass("disabled"),this._controls.$previous=a("<"+c.navElement+">").addClass(c.navClass[0]).html(c.navText[0]).prependTo(this._controls.$relative).on("click",a.proxy(function(a){this.prev(c.navSpeed)},this)),this._controls.$next=a("<"+c.navElement+">").addClass(c.navClass[1]).html(c.navText[1]).appendTo(this._controls.$relative).on("click",a.proxy(function(a){this.next(c.navSpeed)},this)),c.dotsData||(this._templates=[a("<div>").addClass(c.dotClass).append(a("<span>")).prop("outerHTML")]),this._controls.$absolute=(c.dotsContainer?a(c.dotsContainer):a("<div>").addClass(c.dotsClass).appendTo(this.$element)).addClass("disabled"),this._controls.$absolute.on("click","div",a.proxy(function(b){var d=a(b.target).parent().is(this._controls.$absolute)?a(b.target).index():a(b.target).parent().index();b.preventDefault(),this.to(d,c.dotsSpeed)},this));for(b in this._overrides)this._core[b]=a.proxy(this[b],this)},e.prototype.destroy=function(){var a,b,c,d;for(a in this._handlers)this.$element.off(a,this._handlers[a]);for(b in this._controls)this._controls[b].remove();for(d in this.overides)this._core[d]=this._overrides[d];for(c in Object.getOwnPropertyNames(this))"function"!=typeof this[c]&&(this[c]=null)},e.prototype.update=function(){var a,b,c,d=this._core.clones().length/2,e=d+this._core.items().length,f=this._core.maximum(!0),g=this._core.settings,h=g.center||g.autoWidth||g.dotsData?1:g.dotsEach||g.items;if("page"!==g.slideBy&&(g.slideBy=Math.min(g.slideBy,g.items)),g.dots||"page"==g.slideBy)for(this._pages=[],a=d,b=0,c=0;a<e;a++){if(b>=h||0===b){if(this._pages.push({start:Math.min(f,a-d),end:a-d+h-1}),Math.min(f,a-d)===f)break;b=0,++c}b+=this._core.mergers(this._core.relative(a))}},e.prototype.draw=function(){var b,c=this._core.settings,d=this._core.items().length<=c.items,e=this._core.relative(this._core.current()),f=c.loop||c.rewind;this._controls.$relative.toggleClass("disabled",!c.nav||d),c.nav&&(this._controls.$previous.toggleClass("disabled",!f&&e<=this._core.minimum(!0)),this._controls.$next.toggleClass("disabled",!f&&e>=this._core.maximum(!0))),this._controls.$absolute.toggleClass("disabled",!c.dots||d),c.dots&&(b=this._pages.length-this._controls.$absolute.children().length,c.dotsData&&0!==b?this._controls.$absolute.html(this._templates.join("")):b>0?this._controls.$absolute.append(new Array(b+1).join(this._templates[0])):b<0&&this._controls.$absolute.children().slice(b).remove(),this._controls.$absolute.find(".active").removeClass("active"),this._controls.$absolute.children().eq(a.inArray(this.current(),this._pages)).addClass("active"))},e.prototype.onTrigger=function(b){var c=this._core.settings;b.page={index:a.inArray(this.current(),this._pages),count:this._pages.length,size:c&&(c.center||c.autoWidth||c.dotsData?1:c.dotsEach||c.items)}},e.prototype.current=function(){var b=this._core.relative(this._core.current());return a.grep(this._pages,a.proxy(function(a,c){return a.start<=b&&a.end>=b},this)).pop()},e.prototype.getPosition=function(b){var c,d,e=this._core.settings;return"page"==e.slideBy?(c=a.inArray(this.current(),this._pages),d=this._pages.length,b?++c:--c,c=this._pages[(c%d+d)%d].start):(c=this._core.relative(this._core.current()),d=this._core.items().length,b?c+=e.slideBy:c-=e.slideBy),c},e.prototype.next=function(b){a.proxy(this._overrides.to,this._core)(this.getPosition(!0),b)},e.prototype.prev=function(b){a.proxy(this._overrides.to,this._core)(this.getPosition(!1),b)},e.prototype.to=function(b,c,d){var e;!d&&this._pages.length?(e=this._pages.length,a.proxy(this._overrides.to,this._core)(this._pages[(b%e+e)%e].start,c)):a.proxy(this._overrides.to,this._core)(b,c)},a.fn.owlCarousel.Constructor.Plugins.Navigation=e}(window.Zepto||window.jQuery,window,document),function(a,b,c,d){"use strict";var e=function(c){this._core=c,this._hashes={},this.$element=this._core.$element,this._handlers={"initialized.owl.carousel":a.proxy(function(c){c.namespace&&"URLHash"===this._core.settings.startPosition&&a(b).trigger("hashchange.owl.navigation")},this),"prepared.owl.carousel":a.proxy(function(b){if(b.namespace){var c=a(b.content).find("[data-hash]").addBack("[data-hash]").attr("data-hash");if(!c)return;this._hashes[c]=b.content}},this),"changed.owl.carousel":a.proxy(function(c){if(c.namespace&&"position"===c.property.name){var d=this._core.items(this._core.relative(this._core.current())),e=a.map(this._hashes,function(a,b){return a===d?b:null}).join();if(!e||b.location.hash.slice(1)===e)return;b.location.hash=e}},this)},this._core.options=a.extend({},e.Defaults,this._core.options),this.$element.on(this._handlers),a(b).on("hashchange.owl.navigation",a.proxy(function(a){var c=b.location.hash.substring(1),e=this._core.$stage.children(),f=this._hashes[c]&&e.index(this._hashes[c]);f!==d&&f!==this._core.current()&&this._core.to(this._core.relative(f),!1,!0)},this))};e.Defaults={URLhashListener:!1},e.prototype.destroy=function(){var c,d;a(b).off("hashchange.owl.navigation");for(c in this._handlers)this._core.$element.off(c,this._handlers[c]);for(d in Object.getOwnPropertyNames(this))"function"!=typeof this[d]&&(this[d]=null)},a.fn.owlCarousel.Constructor.Plugins.Hash=e}(window.Zepto||window.jQuery,window,document),function(a,b,c,d){function e(b,c){var e=!1,f=b.charAt(0).toUpperCase()+b.slice(1);return a.each((b+" "+h.join(f+" ")+f).split(" "),function(a,b){if(g[b]!==d)return e=!c||b,!1}),e}function f(a){return e(a,!0)}var g=a("<support>").get(0).style,h="Webkit Moz O ms".split(" "),i={transition:{end:{WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd",transition:"transitionend"}},animation:{end:{WebkitAnimation:"webkitAnimationEnd",MozAnimation:"animationend",OAnimation:"oAnimationEnd",animation:"animationend"}}},j={csstransforms:function(){return!!e("transform")},csstransforms3d:function(){return!!e("perspective")},csstransitions:function(){return!!e("transition")},cssanimations:function(){return!!e("animation")}};j.csstransitions()&&(a.support.transition=new String(f("transition")),a.support.transition.end=i.transition.end[a.support.transition]),j.cssanimations()&&(a.support.animation=new String(f("animation")),a.support.animation.end=i.animation.end[a.support.animation]),j.csstransforms()&&(a.support.transform=new String(f("transform")),a.support.transform3d=j.csstransforms3d())}(window.Zepto||window.jQuery,window,document);
    /*! WOW - v1.1.3 - 2016-05-06
    * Copyright (c) 2016 Matthieu Aussaguel;*/(function(){var a,b,c,d,e,f=function(a,b){return function(){return a.apply(b,arguments)}},g=[].indexOf||function(a){for(var b=0,c=this.length;c>b;b++)if(b in this&&this[b]===a)return b;return-1};b=function(){function a(){}return a.prototype.extend=function(a,b){var c,d;for(c in b)d=b[c],null==a[c]&&(a[c]=d);return a},a.prototype.isMobile=function(a){return/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(a)},a.prototype.createEvent=function(a,b,c,d){var e;return null==b&&(b=!1),null==c&&(c=!1),null==d&&(d=null),null!=document.createEvent?(e=document.createEvent("CustomEvent"),e.initCustomEvent(a,b,c,d)):null!=document.createEventObject?(e=document.createEventObject(),e.eventType=a):e.eventName=a,e},a.prototype.emitEvent=function(a,b){return null!=a.dispatchEvent?a.dispatchEvent(b):b in(null!=a)?a[b]():"on"+b in(null!=a)?a["on"+b]():void 0},a.prototype.addEvent=function(a,b,c){return null!=a.addEventListener?a.addEventListener(b,c,!1):null!=a.attachEvent?a.attachEvent("on"+b,c):a[b]=c},a.prototype.removeEvent=function(a,b,c){return null!=a.removeEventListener?a.removeEventListener(b,c,!1):null!=a.detachEvent?a.detachEvent("on"+b,c):delete a[b]},a.prototype.innerHeight=function(){return"innerHeight"in window?window.innerHeight:document.documentElement.clientHeight},a}(),c=this.WeakMap||this.MozWeakMap||(c=function(){function a(){this.keys=[],this.values=[]}return a.prototype.get=function(a){var b,c,d,e,f;for(f=this.keys,b=d=0,e=f.length;e>d;b=++d)if(c=f[b],c===a)return this.values[b]},a.prototype.set=function(a,b){var c,d,e,f,g;for(g=this.keys,c=e=0,f=g.length;f>e;c=++e)if(d=g[c],d===a)return void(this.values[c]=b);return this.keys.push(a),this.values.push(b)},a}()),a=this.MutationObserver||this.WebkitMutationObserver||this.MozMutationObserver||(a=function(){function a(){"undefined"!=typeof console&&null!==console&&console.warn("MutationObserver is not supported by your browser."),"undefined"!=typeof console&&null!==console&&console.warn("WOW.js cannot detect dom mutations, please call .sync() after loading new content.")}return a.notSupported=!0,a.prototype.observe=function(){},a}()),d=this.getComputedStyle||function(a,b){return this.getPropertyValue=function(b){var c;return"float"===b&&(b="styleFloat"),e.test(b)&&b.replace(e,function(a,b){return b.toUpperCase()}),(null!=(c=a.currentStyle)?c[b]:void 0)||null},this},e=/(\-([a-z]){1})/g,this.WOW=function(){function e(a){null==a&&(a={}),this.scrollCallback=f(this.scrollCallback,this),this.scrollHandler=f(this.scrollHandler,this),this.resetAnimation=f(this.resetAnimation,this),this.start=f(this.start,this),this.scrolled=!0,this.config=this.util().extend(a,this.defaults),null!=a.scrollContainer&&(this.config.scrollContainer=document.querySelector(a.scrollContainer)),this.animationNameCache=new c,this.wowEvent=this.util().createEvent(this.config.boxClass)}return e.prototype.defaults={boxClass:"wow",animateClass:"animated",offset:0,mobile:!0,live:!0,callback:null,scrollContainer:null},e.prototype.init=function(){var a;return this.element=window.document.documentElement,"interactive"===(a=document.readyState)||"complete"===a?this.start():this.util().addEvent(document,"DOMContentLoaded",this.start),this.finished=[]},e.prototype.start=function(){var b,c,d,e;if(this.stopped=!1,this.boxes=function(){var a,c,d,e;for(d=this.element.querySelectorAll("."+this.config.boxClass),e=[],a=0,c=d.length;c>a;a++)b=d[a],e.push(b);return e}.call(this),this.all=function(){var a,c,d,e;for(d=this.boxes,e=[],a=0,c=d.length;c>a;a++)b=d[a],e.push(b);return e}.call(this),this.boxes.length)if(this.disabled())this.resetStyle();else for(e=this.boxes,c=0,d=e.length;d>c;c++)b=e[c],this.applyStyle(b,!0);return this.disabled()||(this.util().addEvent(this.config.scrollContainer||window,"scroll",this.scrollHandler),this.util().addEvent(window,"resize",this.scrollHandler),this.interval=setInterval(this.scrollCallback,50)),this.config.live?new a(function(a){return function(b){var c,d,e,f,g;for(g=[],c=0,d=b.length;d>c;c++)f=b[c],g.push(function(){var a,b,c,d;for(c=f.addedNodes||[],d=[],a=0,b=c.length;b>a;a++)e=c[a],d.push(this.doSync(e));return d}.call(a));return g}}(this)).observe(document.body,{childList:!0,subtree:!0}):void 0},e.prototype.stop=function(){return this.stopped=!0,this.util().removeEvent(this.config.scrollContainer||window,"scroll",this.scrollHandler),this.util().removeEvent(window,"resize",this.scrollHandler),null!=this.interval?clearInterval(this.interval):void 0},e.prototype.sync=function(b){return a.notSupported?this.doSync(this.element):void 0},e.prototype.doSync=function(a){var b,c,d,e,f;if(null==a&&(a=this.element),1===a.nodeType){for(a=a.parentNode||a,e=a.querySelectorAll("."+this.config.boxClass),f=[],c=0,d=e.length;d>c;c++)b=e[c],g.call(this.all,b)<0?(this.boxes.push(b),this.all.push(b),this.stopped||this.disabled()?this.resetStyle():this.applyStyle(b,!0),f.push(this.scrolled=!0)):f.push(void 0);return f}},e.prototype.show=function(a){return this.applyStyle(a),a.className=a.className+" "+this.config.animateClass,null!=this.config.callback&&this.config.callback(a),this.util().emitEvent(a,this.wowEvent),this.util().addEvent(a,"animationend",this.resetAnimation),this.util().addEvent(a,"oanimationend",this.resetAnimation),this.util().addEvent(a,"webkitAnimationEnd",this.resetAnimation),this.util().addEvent(a,"MSAnimationEnd",this.resetAnimation),a},e.prototype.applyStyle=function(a,b){var c,d,e;return d=a.getAttribute("data-wow-duration"),c=a.getAttribute("data-wow-delay"),e=a.getAttribute("data-wow-iteration"),this.animate(function(f){return function(){return f.customStyle(a,b,d,c,e)}}(this))},e.prototype.animate=function(){return"requestAnimationFrame"in window?function(a){return window.requestAnimationFrame(a)}:function(a){return a()}}(),e.prototype.resetStyle=function(){var a,b,c,d,e;for(d=this.boxes,e=[],b=0,c=d.length;c>b;b++)a=d[b],e.push(a.style.visibility="visible");return e},e.prototype.resetAnimation=function(a){var b;return a.type.toLowerCase().indexOf("animationend")>=0?(b=a.target||a.srcElement,b.className=b.className.replace(this.config.animateClass,"").trim()):void 0},e.prototype.customStyle=function(a,b,c,d,e){return b&&this.cacheAnimationName(a),a.style.visibility=b?"hidden":"visible",c&&this.vendorSet(a.style,{animationDuration:c}),d&&this.vendorSet(a.style,{animationDelay:d}),e&&this.vendorSet(a.style,{animationIterationCount:e}),this.vendorSet(a.style,{animationName:b?"none":this.cachedAnimationName(a)}),a},e.prototype.vendors=["moz","webkit"],e.prototype.vendorSet=function(a,b){var c,d,e,f;d=[];for(c in b)e=b[c],a[""+c]=e,d.push(function(){var b,d,g,h;for(g=this.vendors,h=[],b=0,d=g.length;d>b;b++)f=g[b],h.push(a[""+f+c.charAt(0).toUpperCase()+c.substr(1)]=e);return h}.call(this));return d},e.prototype.vendorCSS=function(a,b){var c,e,f,g,h,i;for(h=d(a),g=h.getPropertyCSSValue(b),f=this.vendors,c=0,e=f.length;e>c;c++)i=f[c],g=g||h.getPropertyCSSValue("-"+i+"-"+b);return g},e.prototype.animationName=function(a){var b;try{b=this.vendorCSS(a,"animation-name").cssText}catch(c){b=d(a).getPropertyValue("animation-name")}return"none"===b?"":b},e.prototype.cacheAnimationName=function(a){return this.animationNameCache.set(a,this.animationName(a))},e.prototype.cachedAnimationName=function(a){return this.animationNameCache.get(a)},e.prototype.scrollHandler=function(){return this.scrolled=!0},e.prototype.scrollCallback=function(){var a;return!this.scrolled||(this.scrolled=!1,this.boxes=function(){var b,c,d,e;for(d=this.boxes,e=[],b=0,c=d.length;c>b;b++)a=d[b],a&&(this.isVisible(a)?this.show(a):e.push(a));return e}.call(this),this.boxes.length||this.config.live)?void 0:this.stop()},e.prototype.offsetTop=function(a){for(var b;void 0===a.offsetTop;)a=a.parentNode;for(b=a.offsetTop;a=a.offsetParent;)b+=a.offsetTop;return b},e.prototype.isVisible=function(a){var b,c,d,e,f;return c=a.getAttribute("data-wow-offset")||this.config.offset,f=this.config.scrollContainer&&this.config.scrollContainer.scrollTop||window.pageYOffset,e=f+Math.min(this.element.clientHeight,this.util().innerHeight())-c,d=this.offsetTop(a),b=d+a.clientHeight,e>=d&&b>=f},e.prototype.util=function(){return null!=this._util?this._util:this._util=new b},e.prototype.disabled=function(){return!this.config.mobile&&this.util().isMobile(navigator.userAgent)},e}()}).call(this);
    /**
     * Extend jquery with a scrollspy plugin.
     * This watches the window scroll and fires events when elements are scrolled into viewport.
     *
     * throttle() and getTime() taken from Underscore.js
     * https://github.com/jashkenas/underscore
     *
     * @author Copyright 2013 John Smart
     * @license https://raw.github.com/thesmart/jquery-scrollspy/master/LICENSE
     * @see https://github.com/thesmart
     * @version 0.1.2
     */
    (function($) {
    
        var jWindow = $(window);
        var elements = [];
        var elementsInView = [];
        var isSpying = false;
        var ticks = 0;
        var offset = {
            top : 0,
            right : 0,
            bottom : 0,
            left : 0,
        }
    
        /**
         * Find elements that are within the boundary
         * @param {number} top
         * @param {number} right
         * @param {number} bottom
         * @param {number} left
         * @return {jQuery}		A collection of elements
         */
        function findElements(top, right, bottom, left) {
            var hits = $();
            $.each(elements, function(i, element) {
                var elTop = element.offset().top,
                    elLeft = element.offset().left,
                    elRight = elLeft + element.width(),
                    elBottom = elTop + element.height();
    
                var isIntersect = !(elLeft > right ||
                    elRight < left ||
                    elTop > bottom ||
                    elBottom < top);
    
                if (isIntersect) {
                    hits.push(element);
                }
            });
    
            return hits;
        }
    
        /**
         * Called when the user scrolls the window
         */
        function onScroll() {
            // unique tick id
            ++ticks;
    
            // viewport rectangle
            var top = jWindow.scrollTop(),
                left = jWindow.scrollLeft(),
                right = left + jWindow.width(),
                bottom = top + jWindow.height();
    
            // determine which elements are in view
            var intersections = findElements(top+offset.top, right+offset.right, bottom+offset.bottom, left+offset.left);
            $.each(intersections, function(i, element) {
                var lastTick = element.data('scrollSpy:ticks');
                if (typeof lastTick != 'number') {
                    // entered into view
                    element.triggerHandler('scrollSpy:enter');
                }
    
                // update tick id
                element.data('scrollSpy:ticks', ticks);
            });
    
            // determine which elements are no longer in view
            $.each(elementsInView, function(i, element) {
                var lastTick = element.data('scrollSpy:ticks');
                if (typeof lastTick == 'number' && lastTick !== ticks) {
                    // exited from view
                    element.triggerHandler('scrollSpy:exit');
                    element.data('scrollSpy:ticks', null);
                }
            });
    
            // remember elements in view for next tick
            elementsInView = intersections;
        }
    
        /**
         * Called when window is resized
        */
        function onWinSize() {
            jWindow.trigger('scrollSpy:winSize');
        }
    
        /**
         * Get time in ms
       * @license https://raw.github.com/jashkenas/underscore/master/LICENSE
         * @type {function}
         * @return {number}
         */
        var getTime = (Date.now || function () {
            return new Date().getTime();
        });
    
        /**
         * Returns a function, that, when invoked, will only be triggered at most once
         * during a given window of time. Normally, the throttled function will run
         * as much as it can, without ever going more than once per `wait` duration;
         * but if you'd like to disable the execution on the leading edge, pass
         * `{leading: false}`. To disable execution on the trailing edge, ditto.
         * @license https://raw.github.com/jashkenas/underscore/master/LICENSE
         * @param {function} func
         * @param {number} wait
         * @param {Object=} options
         * @returns {Function}
         */
        function throttle(func, wait, options) {
            var context, args, result;
            var timeout = null;
            var previous = 0;
            options || (options = {});
            var later = function () {
                previous = options.leading === false ? 0 : getTime();
                timeout = null;
                result = func.apply(context, args);
                context = args = null;
            };
            return function () {
                var now = getTime();
                if (!previous && options.leading === false) previous = now;
                var remaining = wait - (now - previous);
                context = this;
                args = arguments;
                if (remaining <= 0) {
                    clearTimeout(timeout);
                    timeout = null;
                    previous = now;
                    result = func.apply(context, args);
                    context = args = null;
                } else if (!timeout && options.trailing !== false) {
                    timeout = setTimeout(later, remaining);
                }
                return result;
            };
        };
    
        /**
         * Enables ScrollSpy using a selector
         * @param {jQuery|string} selector  The elements collection, or a selector
         * @param {Object=} options	Optional.
                                                throttle : number -> scrollspy throttling. Default: 100 ms
                                                offsetTop : number -> offset from top. Default: 0
                                                offsetRight : number -> offset from right. Default: 0
                                                offsetBottom : number -> offset from bottom. Default: 0
                                                offsetLeft : number -> offset from left. Default: 0
         * @returns {jQuery}
         */
        $.scrollSpy = function(selector, options) {
            selector = $(selector);
            selector.each(function(i, element) {
                elements.push($(element));
            });
            options = options || {
                throttle: 100
            };
    
            offset.top = options.offsetTop || 0;
            offset.right = options.offsetRight || 0;
            offset.bottom = options.offsetBottom || 0;
            offset.left = options.offsetLeft || 0;
    
            var throttledScroll = throttle(onScroll, options.throttle || 100);
            var readyScroll = function(){
                $(document).ready(throttledScroll);
            };
    
            if (!isSpying) {
                jWindow.on('scroll', readyScroll);
                jWindow.on('resize', readyScroll);
                isSpying = true;
            }
    
            // perform a scan once, after current execution context, and after dom is ready
            setTimeout(readyScroll, 0);
    
            return selector;
        };
    
        /**
         * Listen for window resize events
         * @param {Object=} options						Optional. Set { throttle: number } to change throttling. Default: 100 ms
         * @returns {jQuery}		$(window)
         */
        $.winSizeSpy = function(options) {
            $.winSizeSpy = function() { return jWindow; }; // lock from multiple calls
            options = options || {
                throttle: 100
            };
            return jWindow.on('resize', throttle(onWinSize, options.throttle || 100));
        };
    
        /**
         * Enables ScrollSpy on a collection of elements
         * e.g. $('.scrollSpy').scrollSpy()
         * @param {Object=} options	Optional.
                                                throttle : number -> scrollspy throttling. Default: 100 ms
                                                offsetTop : number -> offset from top. Default: 0
                                                offsetRight : number -> offset from right. Default: 0
                                                offsetBottom : number -> offset from bottom. Default: 0
                                                offsetLeft : number -> offset from left. Default: 0
         * @returns {jQuery}
         */
        $.fn.scrollSpy = function(options) {
            return $.scrollSpy($(this), options);
        };
    
    })(jQuery);
    /*
         _ _      _       _
     ___| (_) ___| | __  (_)___
    / __| | |/ __| |/ /  | / __|
    \__ \ | | (__|   < _ | \__ \
    |___/_|_|\___|_|\_(_)/ |___/
                       |__/
    
     Version: 1.5.8
      Author: Ken Wheeler
     Website: http://kenwheeler.github.io
        Docs: http://kenwheeler.github.io/slick
        Repo: http://github.com/kenwheeler/slick
      Issues: http://github.com/kenwheeler/slick/issues
    
     */
    !function(a){"use strict";"function"==typeof define&&define.amd?define(["jquery"],a):"undefined"!=typeof exports?module.exports=a(require("jquery")):a(jQuery)}(function(a){"use strict";var b=window.Slick||{};b=function(){function c(c,d){var f,e=this;e.defaults={accessibility:!0,adaptiveHeight:!1,appendArrows:a(c),appendDots:a(c),arrows:!0,asNavFor:null,prevArrow:'<button type="button" data-role="none" class="slick-prev" aria-label="Previous" tabindex="0" role="button">Previous</button>',nextArrow:'<button type="button" data-role="none" class="slick-next" aria-label="Next" tabindex="0" role="button">Next</button>',autoplay:!1,autoplaySpeed:3e3,centerMode:!1,centerPadding:"50px",cssEase:"ease",customPaging:function(a,b){return'<button type="button" data-role="none" role="button" aria-required="false" tabindex="0">'+(b+1)+"</button>"},dots:!1,dotsClass:"slick-dots",draggable:!0,easing:"linear",edgeFriction:.35,fade:!1,focusOnSelect:!1,infinite:!0,initialSlide:0,lazyLoad:"ondemand",mobileFirst:!1,pauseOnHover:!0,pauseOnDotsHover:!1,respondTo:"window",responsive:null,rows:1,rtl:!1,slide:"",slidesPerRow:1,slidesToShow:1,slidesToScroll:1,speed:500,swipe:!0,swipeToSlide:!1,touchMove:!0,touchThreshold:5,useCSS:!0,variableWidth:!1,vertical:!1,verticalSwiping:!1,waitForAnimate:!0,zIndex:1e3},e.initials={animating:!1,dragging:!1,autoPlayTimer:null,currentDirection:0,currentLeft:null,currentSlide:0,direction:1,$dots:null,listWidth:null,listHeight:null,loadIndex:0,$nextArrow:null,$prevArrow:null,slideCount:null,slideWidth:null,$slideTrack:null,$slides:null,sliding:!1,slideOffset:0,swipeLeft:null,$list:null,touchObject:{},transformsEnabled:!1,unslicked:!1},a.extend(e,e.initials),e.activeBreakpoint=null,e.animType=null,e.animProp=null,e.breakpoints=[],e.breakpointSettings=[],e.cssTransitions=!1,e.hidden="hidden",e.paused=!1,e.positionProp=null,e.respondTo=null,e.rowCount=1,e.shouldClick=!0,e.$slider=a(c),e.$slidesCache=null,e.transformType=null,e.transitionType=null,e.visibilityChange="visibilitychange",e.windowWidth=0,e.windowTimer=null,f=a(c).data("slick")||{},e.options=a.extend({},e.defaults,f,d),e.currentSlide=e.options.initialSlide,e.originalSettings=e.options,"undefined"!=typeof document.mozHidden?(e.hidden="mozHidden",e.visibilityChange="mozvisibilitychange"):"undefined"!=typeof document.webkitHidden&&(e.hidden="webkitHidden",e.visibilityChange="webkitvisibilitychange"),e.autoPlay=a.proxy(e.autoPlay,e),e.autoPlayClear=a.proxy(e.autoPlayClear,e),e.changeSlide=a.proxy(e.changeSlide,e),e.clickHandler=a.proxy(e.clickHandler,e),e.selectHandler=a.proxy(e.selectHandler,e),e.setPosition=a.proxy(e.setPosition,e),e.swipeHandler=a.proxy(e.swipeHandler,e),e.dragHandler=a.proxy(e.dragHandler,e),e.keyHandler=a.proxy(e.keyHandler,e),e.autoPlayIterator=a.proxy(e.autoPlayIterator,e),e.instanceUid=b++,e.htmlExpr=/^(?:\s*(<[\w\W]+>)[^>]*)$/,e.registerBreakpoints(),e.init(!0),e.checkResponsive(!0)}var b=0;return c}(),b.prototype.addSlide=b.prototype.slickAdd=function(b,c,d){var e=this;if("boolean"==typeof c)d=c,c=null;else if(0>c||c>=e.slideCount)return!1;e.unload(),"number"==typeof c?0===c&&0===e.$slides.length?a(b).appendTo(e.$slideTrack):d?a(b).insertBefore(e.$slides.eq(c)):a(b).insertAfter(e.$slides.eq(c)):d===!0?a(b).prependTo(e.$slideTrack):a(b).appendTo(e.$slideTrack),e.$slides=e.$slideTrack.children(this.options.slide),e.$slideTrack.children(this.options.slide).detach(),e.$slideTrack.append(e.$slides),e.$slides.each(function(b,c){a(c).attr("data-slick-index",b)}),e.$slidesCache=e.$slides,e.reinit()},b.prototype.animateHeight=function(){var a=this;if(1===a.options.slidesToShow&&a.options.adaptiveHeight===!0&&a.options.vertical===!1){var b=a.$slides.eq(a.currentSlide).outerHeight(!0);a.$list.animate({height:b},a.options.speed)}},b.prototype.animateSlide=function(b,c){var d={},e=this;e.animateHeight(),e.options.rtl===!0&&e.options.vertical===!1&&(b=-b),e.transformsEnabled===!1?e.options.vertical===!1?e.$slideTrack.animate({left:b},e.options.speed,e.options.easing,c):e.$slideTrack.animate({top:b},e.options.speed,e.options.easing,c):e.cssTransitions===!1?(e.options.rtl===!0&&(e.currentLeft=-e.currentLeft),a({animStart:e.currentLeft}).animate({animStart:b},{duration:e.options.speed,easing:e.options.easing,step:function(a){a=Math.ceil(a),e.options.vertical===!1?(d[e.animType]="translate("+a+"px, 0px)",e.$slideTrack.css(d)):(d[e.animType]="translate(0px,"+a+"px)",e.$slideTrack.css(d))},complete:function(){c&&c.call()}})):(e.applyTransition(),b=Math.ceil(b),d[e.animType]=e.options.vertical===!1?"translate3d("+b+"px, 0px, 0px)":"translate3d(0px,"+b+"px, 0px)",e.$slideTrack.css(d),c&&setTimeout(function(){e.disableTransition(),c.call()},e.options.speed))},b.prototype.asNavFor=function(b){var c=this,d=c.options.asNavFor;d&&null!==d&&(d=a(d).not(c.$slider)),null!==d&&"object"==typeof d&&d.each(function(){var c=a(this).slick("getSlick");c.unslicked||c.slideHandler(b,!0)})},b.prototype.applyTransition=function(a){var b=this,c={};c[b.transitionType]=b.options.fade===!1?b.transformType+" "+b.options.speed+"ms "+b.options.cssEase:"opacity "+b.options.speed+"ms "+b.options.cssEase,b.options.fade===!1?b.$slideTrack.css(c):b.$slides.eq(a).css(c)},b.prototype.autoPlay=function(){var a=this;a.autoPlayTimer&&clearInterval(a.autoPlayTimer),a.slideCount>a.options.slidesToShow&&a.paused!==!0&&(a.autoPlayTimer=setInterval(a.autoPlayIterator,a.options.autoplaySpeed))},b.prototype.autoPlayClear=function(){var a=this;a.autoPlayTimer&&clearInterval(a.autoPlayTimer)},b.prototype.autoPlayIterator=function(){var a=this;a.options.infinite===!1?1===a.direction?(a.currentSlide+1===a.slideCount-1&&(a.direction=0),a.slideHandler(a.currentSlide+a.options.slidesToScroll)):(0===a.currentSlide-1&&(a.direction=1),a.slideHandler(a.currentSlide-a.options.slidesToScroll)):a.slideHandler(a.currentSlide+a.options.slidesToScroll)},b.prototype.buildArrows=function(){var b=this;b.options.arrows===!0&&(b.$prevArrow=a(b.options.prevArrow).addClass("slick-arrow"),b.$nextArrow=a(b.options.nextArrow).addClass("slick-arrow"),b.slideCount>b.options.slidesToShow?(b.$prevArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"),b.$nextArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"),b.htmlExpr.test(b.options.prevArrow)&&b.$prevArrow.prependTo(b.options.appendArrows),b.htmlExpr.test(b.options.nextArrow)&&b.$nextArrow.appendTo(b.options.appendArrows),b.options.infinite!==!0&&b.$prevArrow.addClass("slick-disabled").attr("aria-disabled","true")):b.$prevArrow.add(b.$nextArrow).addClass("slick-hidden").attr({"aria-disabled":"true",tabindex:"-1"}))},b.prototype.buildDots=function(){var c,d,b=this;if(b.options.dots===!0&&b.slideCount>b.options.slidesToShow){for(d='<ul class="'+b.options.dotsClass+'">',c=0;c<=b.getDotCount();c+=1)d+="<li>"+b.options.customPaging.call(this,b,c)+"</li>";d+="</ul>",b.$dots=a(d).appendTo(b.options.appendDots),b.$dots.find("li").first().addClass("slick-active").attr("aria-hidden","false")}},b.prototype.buildOut=function(){var b=this;b.$slides=b.$slider.children(b.options.slide+":not(.slick-cloned)").addClass("slick-slide"),b.slideCount=b.$slides.length,b.$slides.each(function(b,c){a(c).attr("data-slick-index",b).data("originalStyling",a(c).attr("style")||"")}),b.$slidesCache=b.$slides,b.$slider.addClass("slick-slider"),b.$slideTrack=0===b.slideCount?a('<div class="slick-track"/>').appendTo(b.$slider):b.$slides.wrapAll('<div class="slick-track"/>').parent(),b.$list=b.$slideTrack.wrap('<div aria-live="polite" class="slick-list"/>').parent(),b.$slideTrack.css("opacity",0),(b.options.centerMode===!0||b.options.swipeToSlide===!0)&&(b.options.slidesToScroll=1),a("img[data-lazy]",b.$slider).not("[src]").addClass("slick-loading"),b.setupInfinite(),b.buildArrows(),b.buildDots(),b.updateDots(),b.setSlideClasses("number"==typeof b.currentSlide?b.currentSlide:0),b.options.draggable===!0&&b.$list.addClass("draggable")},b.prototype.buildRows=function(){var b,c,d,e,f,g,h,a=this;if(e=document.createDocumentFragment(),g=a.$slider.children(),a.options.rows>1){for(h=a.options.slidesPerRow*a.options.rows,f=Math.ceil(g.length/h),b=0;f>b;b++){var i=document.createElement("div");for(c=0;c<a.options.rows;c++){var j=document.createElement("div");for(d=0;d<a.options.slidesPerRow;d++){var k=b*h+(c*a.options.slidesPerRow+d);g.get(k)&&j.appendChild(g.get(k))}i.appendChild(j)}e.appendChild(i)}a.$slider.html(e),a.$slider.children().children().children().css({width:100/a.options.slidesPerRow+"%",display:"inline-block"})}},b.prototype.checkResponsive=function(b,c){var e,f,g,d=this,h=!1,i=d.$slider.width(),j=window.innerWidth||a(window).width();if("window"===d.respondTo?g=j:"slider"===d.respondTo?g=i:"min"===d.respondTo&&(g=Math.min(j,i)),d.options.responsive&&d.options.responsive.length&&null!==d.options.responsive){f=null;for(e in d.breakpoints)d.breakpoints.hasOwnProperty(e)&&(d.originalSettings.mobileFirst===!1?g<d.breakpoints[e]&&(f=d.breakpoints[e]):g>d.breakpoints[e]&&(f=d.breakpoints[e]));null!==f?null!==d.activeBreakpoint?(f!==d.activeBreakpoint||c)&&(d.activeBreakpoint=f,"unslick"===d.breakpointSettings[f]?d.unslick(f):(d.options=a.extend({},d.originalSettings,d.breakpointSettings[f]),b===!0&&(d.currentSlide=d.options.initialSlide),d.refresh(b)),h=f):(d.activeBreakpoint=f,"unslick"===d.breakpointSettings[f]?d.unslick(f):(d.options=a.extend({},d.originalSettings,d.breakpointSettings[f]),b===!0&&(d.currentSlide=d.options.initialSlide),d.refresh(b)),h=f):null!==d.activeBreakpoint&&(d.activeBreakpoint=null,d.options=d.originalSettings,b===!0&&(d.currentSlide=d.options.initialSlide),d.refresh(b),h=f),b||h===!1||d.$slider.trigger("breakpoint",[d,h])}},b.prototype.changeSlide=function(b,c){var f,g,h,d=this,e=a(b.target);switch(e.is("a")&&b.preventDefault(),e.is("li")||(e=e.closest("li")),h=0!==d.slideCount%d.options.slidesToScroll,f=h?0:(d.slideCount-d.currentSlide)%d.options.slidesToScroll,b.data.message){case"previous":g=0===f?d.options.slidesToScroll:d.options.slidesToShow-f,d.slideCount>d.options.slidesToShow&&d.slideHandler(d.currentSlide-g,!1,c);break;case"next":g=0===f?d.options.slidesToScroll:f,d.slideCount>d.options.slidesToShow&&d.slideHandler(d.currentSlide+g,!1,c);break;case"index":var i=0===b.data.index?0:b.data.index||e.index()*d.options.slidesToScroll;d.slideHandler(d.checkNavigable(i),!1,c),e.children().trigger("focus");break;default:return}},b.prototype.checkNavigable=function(a){var c,d,b=this;if(c=b.getNavigableIndexes(),d=0,a>c[c.length-1])a=c[c.length-1];else for(var e in c){if(a<c[e]){a=d;break}d=c[e]}return a},b.prototype.cleanUpEvents=function(){var b=this;b.options.dots&&null!==b.$dots&&(a("li",b.$dots).off("click.slick",b.changeSlide),b.options.pauseOnDotsHover===!0&&b.options.autoplay===!0&&a("li",b.$dots).off("mouseenter.slick",a.proxy(b.setPaused,b,!0)).off("mouseleave.slick",a.proxy(b.setPaused,b,!1))),b.options.arrows===!0&&b.slideCount>b.options.slidesToShow&&(b.$prevArrow&&b.$prevArrow.off("click.slick",b.changeSlide),b.$nextArrow&&b.$nextArrow.off("click.slick",b.changeSlide)),b.$list.off("touchstart.slick mousedown.slick",b.swipeHandler),b.$list.off("touchmove.slick mousemove.slick",b.swipeHandler),b.$list.off("touchend.slick mouseup.slick",b.swipeHandler),b.$list.off("touchcancel.slick mouseleave.slick",b.swipeHandler),b.$list.off("click.slick",b.clickHandler),a(document).off(b.visibilityChange,b.visibility),b.$list.off("mouseenter.slick",a.proxy(b.setPaused,b,!0)),b.$list.off("mouseleave.slick",a.proxy(b.setPaused,b,!1)),b.options.accessibility===!0&&b.$list.off("keydown.slick",b.keyHandler),b.options.focusOnSelect===!0&&a(b.$slideTrack).children().off("click.slick",b.selectHandler),a(window).off("orientationchange.slick.slick-"+b.instanceUid,b.orientationChange),a(window).off("resize.slick.slick-"+b.instanceUid,b.resize),a("[draggable!=true]",b.$slideTrack).off("dragstart",b.preventDefault),a(window).off("load.slick.slick-"+b.instanceUid,b.setPosition),a(document).off("ready.slick.slick-"+b.instanceUid,b.setPosition)},b.prototype.cleanUpRows=function(){var b,a=this;a.options.rows>1&&(b=a.$slides.children().children(),b.removeAttr("style"),a.$slider.html(b))},b.prototype.clickHandler=function(a){var b=this;b.shouldClick===!1&&(a.stopImmediatePropagation(),a.stopPropagation(),a.preventDefault())},b.prototype.destroy=function(b){var c=this;c.autoPlayClear(),c.touchObject={},c.cleanUpEvents(),a(".slick-cloned",c.$slider).detach(),c.$dots&&c.$dots.remove(),c.$prevArrow&&c.$prevArrow.length&&(c.$prevArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display",""),c.htmlExpr.test(c.options.prevArrow)&&c.$prevArrow.remove()),c.$nextArrow&&c.$nextArrow.length&&(c.$nextArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display",""),c.htmlExpr.test(c.options.nextArrow)&&c.$nextArrow.remove()),c.$slides&&(c.$slides.removeClass("slick-slide slick-active slick-center slick-visible slick-current").removeAttr("aria-hidden").removeAttr("data-slick-index").each(function(){a(this).attr("style",a(this).data("originalStyling"))}),c.$slideTrack.children(this.options.slide).detach(),c.$slideTrack.detach(),c.$list.detach(),c.$slider.append(c.$slides)),c.cleanUpRows(),c.$slider.removeClass("slick-slider"),c.$slider.removeClass("slick-initialized"),c.unslicked=!0,b||c.$slider.trigger("destroy",[c])},b.prototype.disableTransition=function(a){var b=this,c={};c[b.transitionType]="",b.options.fade===!1?b.$slideTrack.css(c):b.$slides.eq(a).css(c)},b.prototype.fadeSlide=function(a,b){var c=this;c.cssTransitions===!1?(c.$slides.eq(a).css({zIndex:c.options.zIndex}),c.$slides.eq(a).animate({opacity:1},c.options.speed,c.options.easing,b)):(c.applyTransition(a),c.$slides.eq(a).css({opacity:1,zIndex:c.options.zIndex}),b&&setTimeout(function(){c.disableTransition(a),b.call()},c.options.speed))},b.prototype.fadeSlideOut=function(a){var b=this;b.cssTransitions===!1?b.$slides.eq(a).animate({opacity:0,zIndex:b.options.zIndex-2},b.options.speed,b.options.easing):(b.applyTransition(a),b.$slides.eq(a).css({opacity:0,zIndex:b.options.zIndex-2}))},b.prototype.filterSlides=b.prototype.slickFilter=function(a){var b=this;null!==a&&(b.unload(),b.$slideTrack.children(this.options.slide).detach(),b.$slidesCache.filter(a).appendTo(b.$slideTrack),b.reinit())},b.prototype.getCurrent=b.prototype.slickCurrentSlide=function(){var a=this;return a.currentSlide},b.prototype.getDotCount=function(){var a=this,b=0,c=0,d=0;if(a.options.infinite===!0)for(;b<a.slideCount;)++d,b=c+a.options.slidesToShow,c+=a.options.slidesToScroll<=a.options.slidesToShow?a.options.slidesToScroll:a.options.slidesToShow;else if(a.options.centerMode===!0)d=a.slideCount;else for(;b<a.slideCount;)++d,b=c+a.options.slidesToShow,c+=a.options.slidesToScroll<=a.options.slidesToShow?a.options.slidesToScroll:a.options.slidesToShow;return d-1},b.prototype.getLeft=function(a){var c,d,f,b=this,e=0;return b.slideOffset=0,d=b.$slides.first().outerHeight(!0),b.options.infinite===!0?(b.slideCount>b.options.slidesToShow&&(b.slideOffset=-1*b.slideWidth*b.options.slidesToShow,e=-1*d*b.options.slidesToShow),0!==b.slideCount%b.options.slidesToScroll&&a+b.options.slidesToScroll>b.slideCount&&b.slideCount>b.options.slidesToShow&&(a>b.slideCount?(b.slideOffset=-1*(b.options.slidesToShow-(a-b.slideCount))*b.slideWidth,e=-1*(b.options.slidesToShow-(a-b.slideCount))*d):(b.slideOffset=-1*b.slideCount%b.options.slidesToScroll*b.slideWidth,e=-1*b.slideCount%b.options.slidesToScroll*d))):a+b.options.slidesToShow>b.slideCount&&(b.slideOffset=(a+b.options.slidesToShow-b.slideCount)*b.slideWidth,e=(a+b.options.slidesToShow-b.slideCount)*d),b.slideCount<=b.options.slidesToShow&&(b.slideOffset=0,e=0),b.options.centerMode===!0&&b.options.infinite===!0?b.slideOffset+=b.slideWidth*Math.floor(b.options.slidesToShow/2)-b.slideWidth:b.options.centerMode===!0&&(b.slideOffset=0,b.slideOffset+=b.slideWidth*Math.floor(b.options.slidesToShow/2)),c=b.options.vertical===!1?-1*a*b.slideWidth+b.slideOffset:-1*a*d+e,b.options.variableWidth===!0&&(f=b.slideCount<=b.options.slidesToShow||b.options.infinite===!1?b.$slideTrack.children(".slick-slide").eq(a):b.$slideTrack.children(".slick-slide").eq(a+b.options.slidesToShow),c=f[0]?-1*f[0].offsetLeft:0,b.options.centerMode===!0&&(f=b.options.infinite===!1?b.$slideTrack.children(".slick-slide").eq(a):b.$slideTrack.children(".slick-slide").eq(a+b.options.slidesToShow+1),c=f[0]?-1*f[0].offsetLeft:0,c+=(b.$list.width()-f.outerWidth())/2)),c},b.prototype.getOption=b.prototype.slickGetOption=function(a){var b=this;return b.options[a]},b.prototype.getNavigableIndexes=function(){var e,a=this,b=0,c=0,d=[];for(a.options.infinite===!1?e=a.slideCount:(b=-1*a.options.slidesToScroll,c=-1*a.options.slidesToScroll,e=2*a.slideCount);e>b;)d.push(b),b=c+a.options.slidesToScroll,c+=a.options.slidesToScroll<=a.options.slidesToShow?a.options.slidesToScroll:a.options.slidesToShow;return d},b.prototype.getSlick=function(){return this},b.prototype.getSlideCount=function(){var c,d,e,b=this;return e=b.options.centerMode===!0?b.slideWidth*Math.floor(b.options.slidesToShow/2):0,b.options.swipeToSlide===!0?(b.$slideTrack.find(".slick-slide").each(function(c,f){return f.offsetLeft-e+a(f).outerWidth()/2>-1*b.swipeLeft?(d=f,!1):void 0}),c=Math.abs(a(d).attr("data-slick-index")-b.currentSlide)||1):b.options.slidesToScroll},b.prototype.goTo=b.prototype.slickGoTo=function(a,b){var c=this;c.changeSlide({data:{message:"index",index:parseInt(a)}},b)},b.prototype.init=function(b){var c=this;a(c.$slider).hasClass("slick-initialized")||(a(c.$slider).addClass("slick-initialized"),c.buildRows(),c.buildOut(),c.setProps(),c.startLoad(),c.loadSlider(),c.initializeEvents(),c.updateArrows(),c.updateDots()),b&&c.$slider.trigger("init",[c]),c.options.accessibility===!0&&c.initADA()},b.prototype.initArrowEvents=function(){var a=this;a.options.arrows===!0&&a.slideCount>a.options.slidesToShow&&(a.$prevArrow.on("click.slick",{message:"previous"},a.changeSlide),a.$nextArrow.on("click.slick",{message:"next"},a.changeSlide))},b.prototype.initDotEvents=function(){var b=this;b.options.dots===!0&&b.slideCount>b.options.slidesToShow&&a("li",b.$dots).on("click.slick",{message:"index"},b.changeSlide),b.options.dots===!0&&b.options.pauseOnDotsHover===!0&&b.options.autoplay===!0&&a("li",b.$dots).on("mouseenter.slick",a.proxy(b.setPaused,b,!0)).on("mouseleave.slick",a.proxy(b.setPaused,b,!1))},b.prototype.initializeEvents=function(){var b=this;b.initArrowEvents(),b.initDotEvents(),b.$list.on("touchstart.slick mousedown.slick",{action:"start"},b.swipeHandler),b.$list.on("touchmove.slick mousemove.slick",{action:"move"},b.swipeHandler),b.$list.on("touchend.slick mouseup.slick",{action:"end"},b.swipeHandler),b.$list.on("touchcancel.slick mouseleave.slick",{action:"end"},b.swipeHandler),b.$list.on("click.slick",b.clickHandler),a(document).on(b.visibilityChange,a.proxy(b.visibility,b)),b.$list.on("mouseenter.slick",a.proxy(b.setPaused,b,!0)),b.$list.on("mouseleave.slick",a.proxy(b.setPaused,b,!1)),b.options.accessibility===!0&&b.$list.on("keydown.slick",b.keyHandler),b.options.focusOnSelect===!0&&a(b.$slideTrack).children().on("click.slick",b.selectHandler),a(window).on("orientationchange.slick.slick-"+b.instanceUid,a.proxy(b.orientationChange,b)),a(window).on("resize.slick.slick-"+b.instanceUid,a.proxy(b.resize,b)),a("[draggable!=true]",b.$slideTrack).on("dragstart",b.preventDefault),a(window).on("load.slick.slick-"+b.instanceUid,b.setPosition),a(document).on("ready.slick.slick-"+b.instanceUid,b.setPosition)},b.prototype.initUI=function(){var a=this;a.options.arrows===!0&&a.slideCount>a.options.slidesToShow&&(a.$prevArrow.show(),a.$nextArrow.show()),a.options.dots===!0&&a.slideCount>a.options.slidesToShow&&a.$dots.show(),a.options.autoplay===!0&&a.autoPlay()},b.prototype.keyHandler=function(a){var b=this;a.target.tagName.match("TEXTAREA|INPUT|SELECT")||(37===a.keyCode&&b.options.accessibility===!0?b.changeSlide({data:{message:"previous"}}):39===a.keyCode&&b.options.accessibility===!0&&b.changeSlide({data:{message:"next"}}))},b.prototype.lazyLoad=function(){function g(b){a("img[data-lazy]",b).each(function(){var b=a(this),c=a(this).attr("data-lazy"),d=document.createElement("img");d.onload=function(){b.animate({opacity:0},100,function(){b.attr("src",c).animate({opacity:1},200,function(){b.removeAttr("data-lazy").removeClass("slick-loading")})})},d.src=c})}var c,d,e,f,b=this;b.options.centerMode===!0?b.options.infinite===!0?(e=b.currentSlide+(b.options.slidesToShow/2+1),f=e+b.options.slidesToShow+2):(e=Math.max(0,b.currentSlide-(b.options.slidesToShow/2+1)),f=2+(b.options.slidesToShow/2+1)+b.currentSlide):(e=b.options.infinite?b.options.slidesToShow+b.currentSlide:b.currentSlide,f=e+b.options.slidesToShow,b.options.fade===!0&&(e>0&&e--,f<=b.slideCount&&f++)),c=b.$slider.find(".slick-slide").slice(e,f),g(c),b.slideCount<=b.options.slidesToShow?(d=b.$slider.find(".slick-slide"),g(d)):b.currentSlide>=b.slideCount-b.options.slidesToShow?(d=b.$slider.find(".slick-cloned").slice(0,b.options.slidesToShow),g(d)):0===b.currentSlide&&(d=b.$slider.find(".slick-cloned").slice(-1*b.options.slidesToShow),g(d))},b.prototype.loadSlider=function(){var a=this;a.setPosition(),a.$slideTrack.css({opacity:1}),a.$slider.removeClass("slick-loading"),a.initUI(),"progressive"===a.options.lazyLoad&&a.progressiveLazyLoad()},b.prototype.next=b.prototype.slickNext=function(){var a=this;a.changeSlide({data:{message:"next"}})},b.prototype.orientationChange=function(){var a=this;a.checkResponsive(),a.setPosition()},b.prototype.pause=b.prototype.slickPause=function(){var a=this;a.autoPlayClear(),a.paused=!0},b.prototype.play=b.prototype.slickPlay=function(){var a=this;a.paused=!1,a.autoPlay()},b.prototype.postSlide=function(a){var b=this;b.$slider.trigger("afterChange",[b,a]),b.animating=!1,b.setPosition(),b.swipeLeft=null,b.options.autoplay===!0&&b.paused===!1&&b.autoPlay(),b.options.accessibility===!0&&b.initADA()},b.prototype.prev=b.prototype.slickPrev=function(){var a=this;a.changeSlide({data:{message:"previous"}})},b.prototype.preventDefault=function(a){a.preventDefault()},b.prototype.progressiveLazyLoad=function(){var c,d,b=this;c=a("img[data-lazy]",b.$slider).length,c>0&&(d=a("img[data-lazy]",b.$slider).first(),d.attr("src",d.attr("data-lazy")).removeClass("slick-loading").load(function(){d.removeAttr("data-lazy"),b.progressiveLazyLoad(),b.options.adaptiveHeight===!0&&b.setPosition()}).error(function(){d.removeAttr("data-lazy"),b.progressiveLazyLoad()}))},b.prototype.refresh=function(b){var c=this,d=c.currentSlide;c.destroy(!0),a.extend(c,c.initials,{currentSlide:d}),c.init(),b||c.changeSlide({data:{message:"index",index:d}},!1)},b.prototype.registerBreakpoints=function(){var c,d,e,b=this,f=b.options.responsive||null;if("array"===a.type(f)&&f.length){b.respondTo=b.options.respondTo||"window";for(c in f)if(e=b.breakpoints.length-1,d=f[c].breakpoint,f.hasOwnProperty(c)){for(;e>=0;)b.breakpoints[e]&&b.breakpoints[e]===d&&b.breakpoints.splice(e,1),e--;b.breakpoints.push(d),b.breakpointSettings[d]=f[c].settings}b.breakpoints.sort(function(a,c){return b.options.mobileFirst?a-c:c-a})}},b.prototype.reinit=function(){var b=this;b.$slides=b.$slideTrack.children(b.options.slide).addClass("slick-slide"),b.slideCount=b.$slides.length,b.currentSlide>=b.slideCount&&0!==b.currentSlide&&(b.currentSlide=b.currentSlide-b.options.slidesToScroll),b.slideCount<=b.options.slidesToShow&&(b.currentSlide=0),b.registerBreakpoints(),b.setProps(),b.setupInfinite(),b.buildArrows(),b.updateArrows(),b.initArrowEvents(),b.buildDots(),b.updateDots(),b.initDotEvents(),b.checkResponsive(!1,!0),b.options.focusOnSelect===!0&&a(b.$slideTrack).children().on("click.slick",b.selectHandler),b.setSlideClasses(0),b.setPosition(),b.$slider.trigger("reInit",[b]),b.options.autoplay===!0&&b.focusHandler()},b.prototype.resize=function(){var b=this;a(window).width()!==b.windowWidth&&(clearTimeout(b.windowDelay),b.windowDelay=window.setTimeout(function(){b.windowWidth=a(window).width(),b.checkResponsive(),b.unslicked||b.setPosition()},50))},b.prototype.removeSlide=b.prototype.slickRemove=function(a,b,c){var d=this;return"boolean"==typeof a?(b=a,a=b===!0?0:d.slideCount-1):a=b===!0?--a:a,d.slideCount<1||0>a||a>d.slideCount-1?!1:(d.unload(),c===!0?d.$slideTrack.children().remove():d.$slideTrack.children(this.options.slide).eq(a).remove(),d.$slides=d.$slideTrack.children(this.options.slide),d.$slideTrack.children(this.options.slide).detach(),d.$slideTrack.append(d.$slides),d.$slidesCache=d.$slides,d.reinit(),void 0)},b.prototype.setCSS=function(a){var d,e,b=this,c={};b.options.rtl===!0&&(a=-a),d="left"==b.positionProp?Math.ceil(a)+"px":"0px",e="top"==b.positionProp?Math.ceil(a)+"px":"0px",c[b.positionProp]=a,b.transformsEnabled===!1?b.$slideTrack.css(c):(c={},b.cssTransitions===!1?(c[b.animType]="translate("+d+", "+e+")",b.$slideTrack.css(c)):(c[b.animType]="translate3d("+d+", "+e+", 0px)",b.$slideTrack.css(c)))},b.prototype.setDimensions=function(){var a=this;a.options.vertical===!1?a.options.centerMode===!0&&a.$list.css({padding:"0px "+a.options.centerPadding}):(a.$list.height(a.$slides.first().outerHeight(!0)*a.options.slidesToShow),a.options.centerMode===!0&&a.$list.css({padding:a.options.centerPadding+" 0px"})),a.listWidth=a.$list.width(),a.listHeight=a.$list.height(),a.options.vertical===!1&&a.options.variableWidth===!1?(a.slideWidth=Math.ceil(a.listWidth/a.options.slidesToShow),a.$slideTrack.width(Math.ceil(a.slideWidth*a.$slideTrack.children(".slick-slide").length))):a.options.variableWidth===!0?a.$slideTrack.width(5e3*a.slideCount):(a.slideWidth=Math.ceil(a.listWidth),a.$slideTrack.height(Math.ceil(a.$slides.first().outerHeight(!0)*a.$slideTrack.children(".slick-slide").length)));var b=a.$slides.first().outerWidth(!0)-a.$slides.first().width();a.options.variableWidth===!1&&a.$slideTrack.children(".slick-slide").width(a.slideWidth-b)},b.prototype.setFade=function(){var c,b=this;b.$slides.each(function(d,e){c=-1*b.slideWidth*d,b.options.rtl===!0?a(e).css({position:"relative",right:c,top:0,zIndex:b.options.zIndex-2,opacity:0}):a(e).css({position:"relative",left:c,top:0,zIndex:b.options.zIndex-2,opacity:0})}),b.$slides.eq(b.currentSlide).css({zIndex:b.options.zIndex-1,opacity:1})},b.prototype.setHeight=function(){var a=this;if(1===a.options.slidesToShow&&a.options.adaptiveHeight===!0&&a.options.vertical===!1){var b=a.$slides.eq(a.currentSlide).outerHeight(!0);a.$list.css("height",b)}},b.prototype.setOption=b.prototype.slickSetOption=function(b,c,d){var f,g,e=this;if("responsive"===b&&"array"===a.type(c))for(g in c)if("array"!==a.type(e.options.responsive))e.options.responsive=[c[g]];else{for(f=e.options.responsive.length-1;f>=0;)e.options.responsive[f].breakpoint===c[g].breakpoint&&e.options.responsive.splice(f,1),f--;e.options.responsive.push(c[g])}else e.options[b]=c;d===!0&&(e.unload(),e.reinit())},b.prototype.setPosition=function(){var a=this;a.setDimensions(),a.setHeight(),a.options.fade===!1?a.setCSS(a.getLeft(a.currentSlide)):a.setFade(),a.$slider.trigger("setPosition",[a])},b.prototype.setProps=function(){var a=this,b=document.body.style;a.positionProp=a.options.vertical===!0?"top":"left","top"===a.positionProp?a.$slider.addClass("slick-vertical"):a.$slider.removeClass("slick-vertical"),(void 0!==b.WebkitTransition||void 0!==b.MozTransition||void 0!==b.msTransition)&&a.options.useCSS===!0&&(a.cssTransitions=!0),a.options.fade&&("number"==typeof a.options.zIndex?a.options.zIndex<3&&(a.options.zIndex=3):a.options.zIndex=a.defaults.zIndex),void 0!==b.OTransform&&(a.animType="OTransform",a.transformType="-o-transform",a.transitionType="OTransition",void 0===b.perspectiveProperty&&void 0===b.webkitPerspective&&(a.animType=!1)),void 0!==b.MozTransform&&(a.animType="MozTransform",a.transformType="-moz-transform",a.transitionType="MozTransition",void 0===b.perspectiveProperty&&void 0===b.MozPerspective&&(a.animType=!1)),void 0!==b.webkitTransform&&(a.animType="webkitTransform",a.transformType="-webkit-transform",a.transitionType="webkitTransition",void 0===b.perspectiveProperty&&void 0===b.webkitPerspective&&(a.animType=!1)),void 0!==b.msTransform&&(a.animType="msTransform",a.transformType="-ms-transform",a.transitionType="msTransition",void 0===b.msTransform&&(a.animType=!1)),void 0!==b.transform&&a.animType!==!1&&(a.animType="transform",a.transformType="transform",a.transitionType="transition"),a.transformsEnabled=null!==a.animType&&a.animType!==!1},b.prototype.setSlideClasses=function(a){var c,d,e,f,b=this;d=b.$slider.find(".slick-slide").removeClass("slick-active slick-center slick-current").attr("aria-hidden","true"),b.$slides.eq(a).addClass("slick-current"),b.options.centerMode===!0?(c=Math.floor(b.options.slidesToShow/2),b.options.infinite===!0&&(a>=c&&a<=b.slideCount-1-c?b.$slides.slice(a-c,a+c+1).addClass("slick-active").attr("aria-hidden","false"):(e=b.options.slidesToShow+a,d.slice(e-c+1,e+c+2).addClass("slick-active").attr("aria-hidden","false")),0===a?d.eq(d.length-1-b.options.slidesToShow).addClass("slick-center"):a===b.slideCount-1&&d.eq(b.options.slidesToShow).addClass("slick-center")),b.$slides.eq(a).addClass("slick-center")):a>=0&&a<=b.slideCount-b.options.slidesToShow?b.$slides.slice(a,a+b.options.slidesToShow).addClass("slick-active").attr("aria-hidden","false"):d.length<=b.options.slidesToShow?d.addClass("slick-active").attr("aria-hidden","false"):(f=b.slideCount%b.options.slidesToShow,e=b.options.infinite===!0?b.options.slidesToShow+a:a,b.options.slidesToShow==b.options.slidesToScroll&&b.slideCount-a<b.options.slidesToShow?d.slice(e-(b.options.slidesToShow-f),e+f).addClass("slick-active").attr("aria-hidden","false"):d.slice(e,e+b.options.slidesToShow).addClass("slick-active").attr("aria-hidden","false")),"ondemand"===b.options.lazyLoad&&b.lazyLoad()},b.prototype.setupInfinite=function(){var c,d,e,b=this;if(b.options.fade===!0&&(b.options.centerMode=!1),b.options.infinite===!0&&b.options.fade===!1&&(d=null,b.slideCount>b.options.slidesToShow)){for(e=b.options.centerMode===!0?b.options.slidesToShow+1:b.options.slidesToShow,c=b.slideCount;c>b.slideCount-e;c-=1)d=c-1,a(b.$slides[d]).clone(!0).attr("id","").attr("data-slick-index",d-b.slideCount).prependTo(b.$slideTrack).addClass("slick-cloned");for(c=0;e>c;c+=1)d=c,a(b.$slides[d]).clone(!0).attr("id","").attr("data-slick-index",d+b.slideCount).appendTo(b.$slideTrack).addClass("slick-cloned");b.$slideTrack.find(".slick-cloned").find("[id]").each(function(){a(this).attr("id","")})}},b.prototype.setPaused=function(a){var b=this;b.options.autoplay===!0&&b.options.pauseOnHover===!0&&(b.paused=a,a?b.autoPlayClear():b.autoPlay())},b.prototype.selectHandler=function(b){var c=this,d=a(b.target).is(".slick-slide")?a(b.target):a(b.target).parents(".slick-slide"),e=parseInt(d.attr("data-slick-index"));return e||(e=0),c.slideCount<=c.options.slidesToShow?(c.setSlideClasses(e),c.asNavFor(e),void 0):(c.slideHandler(e),void 0)},b.prototype.slideHandler=function(a,b,c){var d,e,f,g,h=null,i=this;return b=b||!1,i.animating===!0&&i.options.waitForAnimate===!0||i.options.fade===!0&&i.currentSlide===a||i.slideCount<=i.options.slidesToShow?void 0:(b===!1&&i.asNavFor(a),d=a,h=i.getLeft(d),g=i.getLeft(i.currentSlide),i.currentLeft=null===i.swipeLeft?g:i.swipeLeft,i.options.infinite===!1&&i.options.centerMode===!1&&(0>a||a>i.getDotCount()*i.options.slidesToScroll)?(i.options.fade===!1&&(d=i.currentSlide,c!==!0?i.animateSlide(g,function(){i.postSlide(d)}):i.postSlide(d)),void 0):i.options.infinite===!1&&i.options.centerMode===!0&&(0>a||a>i.slideCount-i.options.slidesToScroll)?(i.options.fade===!1&&(d=i.currentSlide,c!==!0?i.animateSlide(g,function(){i.postSlide(d)}):i.postSlide(d)),void 0):(i.options.autoplay===!0&&clearInterval(i.autoPlayTimer),e=0>d?0!==i.slideCount%i.options.slidesToScroll?i.slideCount-i.slideCount%i.options.slidesToScroll:i.slideCount+d:d>=i.slideCount?0!==i.slideCount%i.options.slidesToScroll?0:d-i.slideCount:d,i.animating=!0,i.$slider.trigger("beforeChange",[i,i.currentSlide,e]),f=i.currentSlide,i.currentSlide=e,i.setSlideClasses(i.currentSlide),i.updateDots(),i.updateArrows(),i.options.fade===!0?(c!==!0?(i.fadeSlideOut(f),i.fadeSlide(e,function(){i.postSlide(e)
    })):i.postSlide(e),i.animateHeight(),void 0):(c!==!0?i.animateSlide(h,function(){i.postSlide(e)}):i.postSlide(e),void 0)))},b.prototype.startLoad=function(){var a=this;a.options.arrows===!0&&a.slideCount>a.options.slidesToShow&&(a.$prevArrow.hide(),a.$nextArrow.hide()),a.options.dots===!0&&a.slideCount>a.options.slidesToShow&&a.$dots.hide(),a.$slider.addClass("slick-loading")},b.prototype.swipeDirection=function(){var a,b,c,d,e=this;return a=e.touchObject.startX-e.touchObject.curX,b=e.touchObject.startY-e.touchObject.curY,c=Math.atan2(b,a),d=Math.round(180*c/Math.PI),0>d&&(d=360-Math.abs(d)),45>=d&&d>=0?e.options.rtl===!1?"left":"right":360>=d&&d>=315?e.options.rtl===!1?"left":"right":d>=135&&225>=d?e.options.rtl===!1?"right":"left":e.options.verticalSwiping===!0?d>=35&&135>=d?"left":"right":"vertical"},b.prototype.swipeEnd=function(){var c,b=this;if(b.dragging=!1,b.shouldClick=b.touchObject.swipeLength>10?!1:!0,void 0===b.touchObject.curX)return!1;if(b.touchObject.edgeHit===!0&&b.$slider.trigger("edge",[b,b.swipeDirection()]),b.touchObject.swipeLength>=b.touchObject.minSwipe)switch(b.swipeDirection()){case"left":c=b.options.swipeToSlide?b.checkNavigable(b.currentSlide+b.getSlideCount()):b.currentSlide+b.getSlideCount(),b.slideHandler(c),b.currentDirection=0,b.touchObject={},b.$slider.trigger("swipe",[b,"left"]);break;case"right":c=b.options.swipeToSlide?b.checkNavigable(b.currentSlide-b.getSlideCount()):b.currentSlide-b.getSlideCount(),b.slideHandler(c),b.currentDirection=1,b.touchObject={},b.$slider.trigger("swipe",[b,"right"])}else b.touchObject.startX!==b.touchObject.curX&&(b.slideHandler(b.currentSlide),b.touchObject={})},b.prototype.swipeHandler=function(a){var b=this;if(!(b.options.swipe===!1||"ontouchend"in document&&b.options.swipe===!1||b.options.draggable===!1&&-1!==a.type.indexOf("mouse")))switch(b.touchObject.fingerCount=a.originalEvent&&void 0!==a.originalEvent.touches?a.originalEvent.touches.length:1,b.touchObject.minSwipe=b.listWidth/b.options.touchThreshold,b.options.verticalSwiping===!0&&(b.touchObject.minSwipe=b.listHeight/b.options.touchThreshold),a.data.action){case"start":b.swipeStart(a);break;case"move":b.swipeMove(a);break;case"end":b.swipeEnd(a)}},b.prototype.swipeMove=function(a){var d,e,f,g,h,b=this;return h=void 0!==a.originalEvent?a.originalEvent.touches:null,!b.dragging||h&&1!==h.length?!1:(d=b.getLeft(b.currentSlide),b.touchObject.curX=void 0!==h?h[0].pageX:a.clientX,b.touchObject.curY=void 0!==h?h[0].pageY:a.clientY,b.touchObject.swipeLength=Math.round(Math.sqrt(Math.pow(b.touchObject.curX-b.touchObject.startX,2))),b.options.verticalSwiping===!0&&(b.touchObject.swipeLength=Math.round(Math.sqrt(Math.pow(b.touchObject.curY-b.touchObject.startY,2)))),e=b.swipeDirection(),"vertical"!==e?(void 0!==a.originalEvent&&b.touchObject.swipeLength>4&&a.preventDefault(),g=(b.options.rtl===!1?1:-1)*(b.touchObject.curX>b.touchObject.startX?1:-1),b.options.verticalSwiping===!0&&(g=b.touchObject.curY>b.touchObject.startY?1:-1),f=b.touchObject.swipeLength,b.touchObject.edgeHit=!1,b.options.infinite===!1&&(0===b.currentSlide&&"right"===e||b.currentSlide>=b.getDotCount()&&"left"===e)&&(f=b.touchObject.swipeLength*b.options.edgeFriction,b.touchObject.edgeHit=!0),b.swipeLeft=b.options.vertical===!1?d+f*g:d+f*(b.$list.height()/b.listWidth)*g,b.options.verticalSwiping===!0&&(b.swipeLeft=d+f*g),b.options.fade===!0||b.options.touchMove===!1?!1:b.animating===!0?(b.swipeLeft=null,!1):(b.setCSS(b.swipeLeft),void 0)):void 0)},b.prototype.swipeStart=function(a){var c,b=this;return 1!==b.touchObject.fingerCount||b.slideCount<=b.options.slidesToShow?(b.touchObject={},!1):(void 0!==a.originalEvent&&void 0!==a.originalEvent.touches&&(c=a.originalEvent.touches[0]),b.touchObject.startX=b.touchObject.curX=void 0!==c?c.pageX:a.clientX,b.touchObject.startY=b.touchObject.curY=void 0!==c?c.pageY:a.clientY,b.dragging=!0,void 0)},b.prototype.unfilterSlides=b.prototype.slickUnfilter=function(){var a=this;null!==a.$slidesCache&&(a.unload(),a.$slideTrack.children(this.options.slide).detach(),a.$slidesCache.appendTo(a.$slideTrack),a.reinit())},b.prototype.unload=function(){var b=this;a(".slick-cloned",b.$slider).remove(),b.$dots&&b.$dots.remove(),b.$prevArrow&&b.htmlExpr.test(b.options.prevArrow)&&b.$prevArrow.remove(),b.$nextArrow&&b.htmlExpr.test(b.options.nextArrow)&&b.$nextArrow.remove(),b.$slides.removeClass("slick-slide slick-active slick-visible slick-current").attr("aria-hidden","true").css("width","")},b.prototype.unslick=function(a){var b=this;b.$slider.trigger("unslick",[b,a]),b.destroy()},b.prototype.updateArrows=function(){var b,a=this;b=Math.floor(a.options.slidesToShow/2),a.options.arrows===!0&&a.slideCount>a.options.slidesToShow&&!a.options.infinite&&(a.$prevArrow.removeClass("slick-disabled").attr("aria-disabled","false"),a.$nextArrow.removeClass("slick-disabled").attr("aria-disabled","false"),0===a.currentSlide?(a.$prevArrow.addClass("slick-disabled").attr("aria-disabled","true"),a.$nextArrow.removeClass("slick-disabled").attr("aria-disabled","false")):a.currentSlide>=a.slideCount-a.options.slidesToShow&&a.options.centerMode===!1?(a.$nextArrow.addClass("slick-disabled").attr("aria-disabled","true"),a.$prevArrow.removeClass("slick-disabled").attr("aria-disabled","false")):a.currentSlide>=a.slideCount-1&&a.options.centerMode===!0&&(a.$nextArrow.addClass("slick-disabled").attr("aria-disabled","true"),a.$prevArrow.removeClass("slick-disabled").attr("aria-disabled","false")))},b.prototype.updateDots=function(){var a=this;null!==a.$dots&&(a.$dots.find("li").removeClass("slick-active").attr("aria-hidden","true"),a.$dots.find("li").eq(Math.floor(a.currentSlide/a.options.slidesToScroll)).addClass("slick-active").attr("aria-hidden","false"))},b.prototype.visibility=function(){var a=this;document[a.hidden]?(a.paused=!0,a.autoPlayClear()):a.options.autoplay===!0&&(a.paused=!1,a.autoPlay())},b.prototype.initADA=function(){var b=this;b.$slides.add(b.$slideTrack.find(".slick-cloned")).attr({"aria-hidden":"true",tabindex:"-1"}).find("a, input, button, select").attr({tabindex:"-1"}),b.$slideTrack.attr("role","listbox"),b.$slides.not(b.$slideTrack.find(".slick-cloned")).each(function(c){a(this).attr({role:"option","aria-describedby":"slick-slide"+b.instanceUid+c})}),null!==b.$dots&&b.$dots.attr("role","tablist").find("li").each(function(c){a(this).attr({role:"presentation","aria-selected":"false","aria-controls":"navigation"+b.instanceUid+c,id:"slick-slide"+b.instanceUid+c})}).first().attr("aria-selected","true").end().find("button").attr("role","button").end().closest("div").attr("role","toolbar"),b.activateADA()},b.prototype.activateADA=function(){var a=this,b=a.$slider.find("*").is(":focus");a.$slideTrack.find(".slick-active").attr({"aria-hidden":"false",tabindex:"0"}).find("a, input, button, select").attr({tabindex:"0"}),b&&a.$slideTrack.find(".slick-active").focus()},b.prototype.focusHandler=function(){var b=this;b.$slider.on("focus.slick blur.slick","*",function(c){c.stopImmediatePropagation();var d=a(this);setTimeout(function(){b.isPlay&&(d.is(":focus")?(b.autoPlayClear(),b.paused=!0):(b.paused=!1,b.autoPlay()))},0)})},a.fn.slick=function(){var g,a=this,c=arguments[0],d=Array.prototype.slice.call(arguments,1),e=a.length,f=0;for(f;e>f;f++)if("object"==typeof c||"undefined"==typeof c?a[f].slick=new b(a[f],c):g=a[f].slick[c].apply(a[f].slick,d),"undefined"!=typeof g)return g;return a}});
    /**
     * Swiper 5.4.5
     * Most modern mobile touch slider and framework with hardware accelerated transitions
     * http://swiperjs.com
     *
     * Copyright 2014-2020 Vladimir Kharlampidi
     *
     * Released under the MIT License
     *
     * Released on: June 16, 2020
     */
    
    (function (global, factory) {
        typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
        typeof define === 'function' && define.amd ? define(factory) :
        (global = global || self, global.Swiper = factory());
    }(this, (function () { 'use strict';
    
        /**
         * SSR Window 2.0.0
         * Better handling for window object in SSR environment
         * https://github.com/nolimits4web/ssr-window
         *
         * Copyright 2020, Vladimir Kharlampidi
         *
         * Licensed under MIT
         *
         * Released on: May 12, 2020
         */
        /* eslint-disable no-param-reassign */
        function isObject(obj) {
            return (obj !== null &&
                typeof obj === 'object' &&
                'constructor' in obj &&
                obj.constructor === Object);
        }
        function extend(target, src) {
            if (target === void 0) { target = {}; }
            if (src === void 0) { src = {}; }
            Object.keys(src).forEach(function (key) {
                if (typeof target[key] === 'undefined')
                    { target[key] = src[key]; }
                else if (isObject(src[key]) &&
                    isObject(target[key]) &&
                    Object.keys(src[key]).length > 0) {
                    extend(target[key], src[key]);
                }
            });
        }
    
        var doc = typeof document !== 'undefined' ? document : {};
        var ssrDocument = {
            body: {},
            addEventListener: function () { },
            removeEventListener: function () { },
            activeElement: {
                blur: function () { },
                nodeName: '',
            },
            querySelector: function () {
                return null;
            },
            querySelectorAll: function () {
                return [];
            },
            getElementById: function () {
                return null;
            },
            createEvent: function () {
                return {
                    initEvent: function () { },
                };
            },
            createElement: function () {
                return {
                    children: [],
                    childNodes: [],
                    style: {},
                    setAttribute: function () { },
                    getElementsByTagName: function () {
                        return [];
                    },
                };
            },
            createElementNS: function () {
                return {};
            },
            importNode: function () {
                return null;
            },
            location: {
                hash: '',
                host: '',
                hostname: '',
                href: '',
                origin: '',
                pathname: '',
                protocol: '',
                search: '',
            },
        };
        extend(doc, ssrDocument);
    
        var win = typeof window !== 'undefined' ? window : {};
        var ssrWindow = {
            document: ssrDocument,
            navigator: {
                userAgent: '',
            },
            location: {
                hash: '',
                host: '',
                hostname: '',
                href: '',
                origin: '',
                pathname: '',
                protocol: '',
                search: '',
            },
            history: {
                replaceState: function () { },
                pushState: function () { },
                go: function () { },
                back: function () { },
            },
            CustomEvent: function CustomEvent() {
                return this;
            },
            addEventListener: function () { },
            removeEventListener: function () { },
            getComputedStyle: function () {
                return {
                    getPropertyValue: function () {
                        return '';
                    },
                };
            },
            Image: function () { },
            Date: function () { },
            screen: {},
            setTimeout: function () { },
            clearTimeout: function () { },
            matchMedia: function () {
                return {};
            },
        };
        extend(win, ssrWindow);
    
        /**
         * Dom7 2.1.5
         * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
         * http://framework7.io/docs/dom.html
         *
         * Copyright 2020, Vladimir Kharlampidi
         * The iDangero.us
         * http://www.idangero.us/
         *
         * Licensed under MIT
         *
         * Released on: May 15, 2020
         */
    
        var Dom7 = function Dom7(arr) {
          var self = this;
          // Create array-like object
          for (var i = 0; i < arr.length; i += 1) {
            self[i] = arr[i];
          }
          self.length = arr.length;
          // Return collection with methods
          return this;
        };
    
        function $(selector, context) {
          var arr = [];
          var i = 0;
          if (selector && !context) {
            if (selector instanceof Dom7) {
              return selector;
            }
          }
          if (selector) {
              // String
            if (typeof selector === 'string') {
              var els;
              var tempParent;
              var html = selector.trim();
              if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
                var toCreate = 'div';
                if (html.indexOf('<li') === 0) { toCreate = 'ul'; }
                if (html.indexOf('<tr') === 0) { toCreate = 'tbody'; }
                if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) { toCreate = 'tr'; }
                if (html.indexOf('<tbody') === 0) { toCreate = 'table'; }
                if (html.indexOf('<option') === 0) { toCreate = 'select'; }
                tempParent = doc.createElement(toCreate);
                tempParent.innerHTML = html;
                for (i = 0; i < tempParent.childNodes.length; i += 1) {
                  arr.push(tempParent.childNodes[i]);
                }
              } else {
                if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
                  // Pure ID selector
                  els = [doc.getElementById(selector.trim().split('#')[1])];
                } else {
                  // Other selectors
                  els = (context || doc).querySelectorAll(selector.trim());
                }
                for (i = 0; i < els.length; i += 1) {
                  if (els[i]) { arr.push(els[i]); }
                }
              }
            } else if (selector.nodeType || selector === win || selector === doc) {
              // Node/element
              arr.push(selector);
            } else if (selector.length > 0 && selector[0].nodeType) {
              // Array of elements or instance of Dom
              for (i = 0; i < selector.length; i += 1) {
                arr.push(selector[i]);
              }
            }
          }
          return new Dom7(arr);
        }
    
        $.fn = Dom7.prototype;
        $.Class = Dom7;
        $.Dom7 = Dom7;
    
        function unique(arr) {
          var uniqueArray = [];
          for (var i = 0; i < arr.length; i += 1) {
            if (uniqueArray.indexOf(arr[i]) === -1) { uniqueArray.push(arr[i]); }
          }
          return uniqueArray;
        }
    
        // Classes and attributes
        function addClass(className) {
          if (typeof className === 'undefined') {
            return this;
          }
          var classes = className.split(' ');
          for (var i = 0; i < classes.length; i += 1) {
            for (var j = 0; j < this.length; j += 1) {
              if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') { this[j].classList.add(classes[i]); }
            }
          }
          return this;
        }
        function removeClass(className) {
          var classes = className.split(' ');
          for (var i = 0; i < classes.length; i += 1) {
            for (var j = 0; j < this.length; j += 1) {
              if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') { this[j].classList.remove(classes[i]); }
            }
          }
          return this;
        }
        function hasClass(className) {
          if (!this[0]) { return false; }
          return this[0].classList.contains(className);
        }
        function toggleClass(className) {
          var classes = className.split(' ');
          for (var i = 0; i < classes.length; i += 1) {
            for (var j = 0; j < this.length; j += 1) {
              if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') { this[j].classList.toggle(classes[i]); }
            }
          }
          return this;
        }
        function attr(attrs, value) {
          var arguments$1 = arguments;
    
          if (arguments.length === 1 && typeof attrs === 'string') {
            // Get attr
            if (this[0]) { return this[0].getAttribute(attrs); }
            return undefined;
          }
    
          // Set attrs
          for (var i = 0; i < this.length; i += 1) {
            if (arguments$1.length === 2) {
              // String
              this[i].setAttribute(attrs, value);
            } else {
              // Object
              // eslint-disable-next-line
              for (var attrName in attrs) {
                this[i][attrName] = attrs[attrName];
                this[i].setAttribute(attrName, attrs[attrName]);
              }
            }
          }
          return this;
        }
        // eslint-disable-next-line
        function removeAttr(attr) {
          for (var i = 0; i < this.length; i += 1) {
            this[i].removeAttribute(attr);
          }
          return this;
        }
        function data(key, value) {
          var el;
          if (typeof value === 'undefined') {
            el = this[0];
            // Get value
            if (el) {
              if (el.dom7ElementDataStorage && (key in el.dom7ElementDataStorage)) {
                return el.dom7ElementDataStorage[key];
              }
    
              var dataKey = el.getAttribute(("data-" + key));
              if (dataKey) {
                return dataKey;
              }
              return undefined;
            }
            return undefined;
          }
    
          // Set value
          for (var i = 0; i < this.length; i += 1) {
            el = this[i];
            if (!el.dom7ElementDataStorage) { el.dom7ElementDataStorage = {}; }
            el.dom7ElementDataStorage[key] = value;
          }
          return this;
        }
        // Transforms
        // eslint-disable-next-line
        function transform(transform) {
          for (var i = 0; i < this.length; i += 1) {
            var elStyle = this[i].style;
            elStyle.webkitTransform = transform;
            elStyle.transform = transform;
          }
          return this;
        }
        function transition(duration) {
          if (typeof duration !== 'string') {
            duration = duration + "ms"; // eslint-disable-line
          }
          for (var i = 0; i < this.length; i += 1) {
            var elStyle = this[i].style;
            elStyle.webkitTransitionDuration = duration;
            elStyle.transitionDuration = duration;
          }
          return this;
        }
        // Events
        function on() {
          var assign;
    
          var args = [], len = arguments.length;
          while ( len-- ) args[ len ] = arguments[ len ];
          var eventType = args[0];
          var targetSelector = args[1];
          var listener = args[2];
          var capture = args[3];
          if (typeof args[1] === 'function') {
            (assign = args, eventType = assign[0], listener = assign[1], capture = assign[2]);
            targetSelector = undefined;
          }
          if (!capture) { capture = false; }
    
          function handleLiveEvent(e) {
            var target = e.target;
            if (!target) { return; }
            var eventData = e.target.dom7EventData || [];
            if (eventData.indexOf(e) < 0) {
              eventData.unshift(e);
            }
            if ($(target).is(targetSelector)) { listener.apply(target, eventData); }
            else {
              var parents = $(target).parents(); // eslint-disable-line
              for (var k = 0; k < parents.length; k += 1) {
                if ($(parents[k]).is(targetSelector)) { listener.apply(parents[k], eventData); }
              }
            }
          }
          function handleEvent(e) {
            var eventData = e && e.target ? e.target.dom7EventData || [] : [];
            if (eventData.indexOf(e) < 0) {
              eventData.unshift(e);
            }
            listener.apply(this, eventData);
          }
          var events = eventType.split(' ');
          var j;
          for (var i = 0; i < this.length; i += 1) {
            var el = this[i];
            if (!targetSelector) {
              for (j = 0; j < events.length; j += 1) {
                var event = events[j];
                if (!el.dom7Listeners) { el.dom7Listeners = {}; }
                if (!el.dom7Listeners[event]) { el.dom7Listeners[event] = []; }
                el.dom7Listeners[event].push({
                  listener: listener,
                  proxyListener: handleEvent,
                });
                el.addEventListener(event, handleEvent, capture);
              }
            } else {
              // Live events
              for (j = 0; j < events.length; j += 1) {
                var event$1 = events[j];
                if (!el.dom7LiveListeners) { el.dom7LiveListeners = {}; }
                if (!el.dom7LiveListeners[event$1]) { el.dom7LiveListeners[event$1] = []; }
                el.dom7LiveListeners[event$1].push({
                  listener: listener,
                  proxyListener: handleLiveEvent,
                });
                el.addEventListener(event$1, handleLiveEvent, capture);
              }
            }
          }
          return this;
        }
        function off() {
          var assign;
    
          var args = [], len = arguments.length;
          while ( len-- ) args[ len ] = arguments[ len ];
          var eventType = args[0];
          var targetSelector = args[1];
          var listener = args[2];
          var capture = args[3];
          if (typeof args[1] === 'function') {
            (assign = args, eventType = assign[0], listener = assign[1], capture = assign[2]);
            targetSelector = undefined;
          }
          if (!capture) { capture = false; }
    
          var events = eventType.split(' ');
          for (var i = 0; i < events.length; i += 1) {
            var event = events[i];
            for (var j = 0; j < this.length; j += 1) {
              var el = this[j];
              var handlers = (void 0);
              if (!targetSelector && el.dom7Listeners) {
                handlers = el.dom7Listeners[event];
              } else if (targetSelector && el.dom7LiveListeners) {
                handlers = el.dom7LiveListeners[event];
              }
              if (handlers && handlers.length) {
                for (var k = handlers.length - 1; k >= 0; k -= 1) {
                  var handler = handlers[k];
                  if (listener && handler.listener === listener) {
                    el.removeEventListener(event, handler.proxyListener, capture);
                    handlers.splice(k, 1);
                  } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
                    el.removeEventListener(event, handler.proxyListener, capture);
                    handlers.splice(k, 1);
                  } else if (!listener) {
                    el.removeEventListener(event, handler.proxyListener, capture);
                    handlers.splice(k, 1);
                  }
                }
              }
            }
          }
          return this;
        }
        function trigger() {
          var args = [], len = arguments.length;
          while ( len-- ) args[ len ] = arguments[ len ];
    
          var events = args[0].split(' ');
          var eventData = args[1];
          for (var i = 0; i < events.length; i += 1) {
            var event = events[i];
            for (var j = 0; j < this.length; j += 1) {
              var el = this[j];
              var evt = (void 0);
              try {
                evt = new win.CustomEvent(event, {
                  detail: eventData,
                  bubbles: true,
                  cancelable: true,
                });
              } catch (e) {
                evt = doc.createEvent('Event');
                evt.initEvent(event, true, true);
                evt.detail = eventData;
              }
              // eslint-disable-next-line
              el.dom7EventData = args.filter(function (data, dataIndex) { return dataIndex > 0; });
              el.dispatchEvent(evt);
              el.dom7EventData = [];
              delete el.dom7EventData;
            }
          }
          return this;
        }
        function transitionEnd(callback) {
          var events = ['webkitTransitionEnd', 'transitionend'];
          var dom = this;
          var i;
          function fireCallBack(e) {
            /* jshint validthis:true */
            if (e.target !== this) { return; }
            callback.call(this, e);
            for (i = 0; i < events.length; i += 1) {
              dom.off(events[i], fireCallBack);
            }
          }
          if (callback) {
            for (i = 0; i < events.length; i += 1) {
              dom.on(events[i], fireCallBack);
            }
          }
          return this;
        }
        function outerWidth(includeMargins) {
          if (this.length > 0) {
            if (includeMargins) {
              // eslint-disable-next-line
              var styles = this.styles();
              return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
            }
            return this[0].offsetWidth;
          }
          return null;
        }
        function outerHeight(includeMargins) {
          if (this.length > 0) {
            if (includeMargins) {
              // eslint-disable-next-line
              var styles = this.styles();
              return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
            }
            return this[0].offsetHeight;
          }
          return null;
        }
        function offset() {
          if (this.length > 0) {
            var el = this[0];
            var box = el.getBoundingClientRect();
            var body = doc.body;
            var clientTop = el.clientTop || body.clientTop || 0;
            var clientLeft = el.clientLeft || body.clientLeft || 0;
            var scrollTop = el === win ? win.scrollY : el.scrollTop;
            var scrollLeft = el === win ? win.scrollX : el.scrollLeft;
            return {
              top: (box.top + scrollTop) - clientTop,
              left: (box.left + scrollLeft) - clientLeft,
            };
          }
    
          return null;
        }
        function styles() {
          if (this[0]) { return win.getComputedStyle(this[0], null); }
          return {};
        }
        function css(props, value) {
          var i;
          if (arguments.length === 1) {
            if (typeof props === 'string') {
              if (this[0]) { return win.getComputedStyle(this[0], null).getPropertyValue(props); }
            } else {
              for (i = 0; i < this.length; i += 1) {
                // eslint-disable-next-line
                for (var prop in props) {
                  this[i].style[prop] = props[prop];
                }
              }
              return this;
            }
          }
          if (arguments.length === 2 && typeof props === 'string') {
            for (i = 0; i < this.length; i += 1) {
              this[i].style[props] = value;
            }
            return this;
          }
          return this;
        }
        // Iterate over the collection passing elements to `callback`
        function each(callback) {
          // Don't bother continuing without a callback
          if (!callback) { return this; }
          // Iterate over the current collection
          for (var i = 0; i < this.length; i += 1) {
            // If the callback returns false
            if (callback.call(this[i], i, this[i]) === false) {
              // End the loop early
              return this;
            }
          }
          // Return `this` to allow chained DOM operations
          return this;
        }
        function filter(callback) {
          var matchedItems = [];
          var dom = this;
          for (var i = 0; i < dom.length; i += 1) {
            if (callback.call(dom[i], i, dom[i])) { matchedItems.push(dom[i]); }
          }
          return new Dom7(matchedItems);
        }
        // eslint-disable-next-line
        function html(html) {
          if (typeof html === 'undefined') {
            return this[0] ? this[0].innerHTML : undefined;
          }
    
          for (var i = 0; i < this.length; i += 1) {
            this[i].innerHTML = html;
          }
          return this;
        }
        // eslint-disable-next-line
        function text(text) {
          if (typeof text === 'undefined') {
            if (this[0]) {
              return this[0].textContent.trim();
            }
            return null;
          }
    
          for (var i = 0; i < this.length; i += 1) {
            this[i].textContent = text;
          }
          return this;
        }
        function is(selector) {
          var el = this[0];
          var compareWith;
          var i;
          if (!el || typeof selector === 'undefined') { return false; }
          if (typeof selector === 'string') {
            if (el.matches) { return el.matches(selector); }
            else if (el.webkitMatchesSelector) { return el.webkitMatchesSelector(selector); }
            else if (el.msMatchesSelector) { return el.msMatchesSelector(selector); }
    
            compareWith = $(selector);
            for (i = 0; i < compareWith.length; i += 1) {
              if (compareWith[i] === el) { return true; }
            }
            return false;
          } else if (selector === doc) { return el === doc; }
          else if (selector === win) { return el === win; }
    
          if (selector.nodeType || selector instanceof Dom7) {
            compareWith = selector.nodeType ? [selector] : selector;
            for (i = 0; i < compareWith.length; i += 1) {
              if (compareWith[i] === el) { return true; }
            }
            return false;
          }
          return false;
        }
        function index() {
          var child = this[0];
          var i;
          if (child) {
            i = 0;
            // eslint-disable-next-line
            while ((child = child.previousSibling) !== null) {
              if (child.nodeType === 1) { i += 1; }
            }
            return i;
          }
          return undefined;
        }
        // eslint-disable-next-line
        function eq(index) {
          if (typeof index === 'undefined') { return this; }
          var length = this.length;
          var returnIndex;
          if (index > length - 1) {
            return new Dom7([]);
          }
          if (index < 0) {
            returnIndex = length + index;
            if (returnIndex < 0) { return new Dom7([]); }
            return new Dom7([this[returnIndex]]);
          }
          return new Dom7([this[index]]);
        }
        function append() {
          var args = [], len = arguments.length;
          while ( len-- ) args[ len ] = arguments[ len ];
    
          var newChild;
    
          for (var k = 0; k < args.length; k += 1) {
            newChild = args[k];
            for (var i = 0; i < this.length; i += 1) {
              if (typeof newChild === 'string') {
                var tempDiv = doc.createElement('div');
                tempDiv.innerHTML = newChild;
                while (tempDiv.firstChild) {
                  this[i].appendChild(tempDiv.firstChild);
                }
              } else if (newChild instanceof Dom7) {
                for (var j = 0; j < newChild.length; j += 1) {
                  this[i].appendChild(newChild[j]);
                }
              } else {
                this[i].appendChild(newChild);
              }
            }
          }
    
          return this;
        }
        function prepend(newChild) {
          var i;
          var j;
          for (i = 0; i < this.length; i += 1) {
            if (typeof newChild === 'string') {
              var tempDiv = doc.createElement('div');
              tempDiv.innerHTML = newChild;
              for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
                this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
              }
            } else if (newChild instanceof Dom7) {
              for (j = 0; j < newChild.length; j += 1) {
                this[i].insertBefore(newChild[j], this[i].childNodes[0]);
              }
            } else {
              this[i].insertBefore(newChild, this[i].childNodes[0]);
            }
          }
          return this;
        }
        function next(selector) {
          if (this.length > 0) {
            if (selector) {
              if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
                return new Dom7([this[0].nextElementSibling]);
              }
              return new Dom7([]);
            }
    
            if (this[0].nextElementSibling) { return new Dom7([this[0].nextElementSibling]); }
            return new Dom7([]);
          }
          return new Dom7([]);
        }
        function nextAll(selector) {
          var nextEls = [];
          var el = this[0];
          if (!el) { return new Dom7([]); }
          while (el.nextElementSibling) {
            var next = el.nextElementSibling; // eslint-disable-line
            if (selector) {
              if ($(next).is(selector)) { nextEls.push(next); }
            } else { nextEls.push(next); }
            el = next;
          }
          return new Dom7(nextEls);
        }
        function prev(selector) {
          if (this.length > 0) {
            var el = this[0];
            if (selector) {
              if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
                return new Dom7([el.previousElementSibling]);
              }
              return new Dom7([]);
            }
    
            if (el.previousElementSibling) { return new Dom7([el.previousElementSibling]); }
            return new Dom7([]);
          }
          return new Dom7([]);
        }
        function prevAll(selector) {
          var prevEls = [];
          var el = this[0];
          if (!el) { return new Dom7([]); }
          while (el.previousElementSibling) {
            var prev = el.previousElementSibling; // eslint-disable-line
            if (selector) {
              if ($(prev).is(selector)) { prevEls.push(prev); }
            } else { prevEls.push(prev); }
            el = prev;
          }
          return new Dom7(prevEls);
        }
        function parent(selector) {
          var parents = []; // eslint-disable-line
          for (var i = 0; i < this.length; i += 1) {
            if (this[i].parentNode !== null) {
              if (selector) {
                if ($(this[i].parentNode).is(selector)) { parents.push(this[i].parentNode); }
              } else {
                parents.push(this[i].parentNode);
              }
            }
          }
          return $(unique(parents));
        }
        function parents(selector) {
          var parents = []; // eslint-disable-line
          for (var i = 0; i < this.length; i += 1) {
            var parent = this[i].parentNode; // eslint-disable-line
            while (parent) {
              if (selector) {
                if ($(parent).is(selector)) { parents.push(parent); }
              } else {
                parents.push(parent);
              }
              parent = parent.parentNode;
            }
          }
          return $(unique(parents));
        }
        function closest(selector) {
          var closest = this; // eslint-disable-line
          if (typeof selector === 'undefined') {
            return new Dom7([]);
          }
          if (!closest.is(selector)) {
            closest = closest.parents(selector).eq(0);
          }
          return closest;
        }
        function find(selector) {
          var foundElements = [];
          for (var i = 0; i < this.length; i += 1) {
            var found = this[i].querySelectorAll(selector);
            for (var j = 0; j < found.length; j += 1) {
              foundElements.push(found[j]);
            }
          }
          return new Dom7(foundElements);
        }
        function children(selector) {
          var children = []; // eslint-disable-line
          for (var i = 0; i < this.length; i += 1) {
            var childNodes = this[i].childNodes;
    
            for (var j = 0; j < childNodes.length; j += 1) {
              if (!selector) {
                if (childNodes[j].nodeType === 1) { children.push(childNodes[j]); }
              } else if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
                children.push(childNodes[j]);
              }
            }
          }
          return new Dom7(unique(children));
        }
        function remove() {
          for (var i = 0; i < this.length; i += 1) {
            if (this[i].parentNode) { this[i].parentNode.removeChild(this[i]); }
          }
          return this;
        }
        function add() {
          var args = [], len = arguments.length;
          while ( len-- ) args[ len ] = arguments[ len ];
    
          var dom = this;
          var i;
          var j;
          for (i = 0; i < args.length; i += 1) {
            var toAdd = $(args[i]);
            for (j = 0; j < toAdd.length; j += 1) {
              dom[dom.length] = toAdd[j];
              dom.length += 1;
            }
          }
          return dom;
        }
    
        var Methods = {
          addClass: addClass,
          removeClass: removeClass,
          hasClass: hasClass,
          toggleClass: toggleClass,
          attr: attr,
          removeAttr: removeAttr,
          data: data,
          transform: transform,
          transition: transition,
          on: on,
          off: off,
          trigger: trigger,
          transitionEnd: transitionEnd,
          outerWidth: outerWidth,
          outerHeight: outerHeight,
          offset: offset,
          css: css,
          each: each,
          html: html,
          text: text,
          is: is,
          index: index,
          eq: eq,
          append: append,
          prepend: prepend,
          next: next,
          nextAll: nextAll,
          prev: prev,
          prevAll: prevAll,
          parent: parent,
          parents: parents,
          closest: closest,
          find: find,
          children: children,
          filter: filter,
          remove: remove,
          add: add,
          styles: styles,
        };
    
        Object.keys(Methods).forEach(function (methodName) {
          $.fn[methodName] = $.fn[methodName] || Methods[methodName];
        });
    
        var Utils = {
          deleteProps: function deleteProps(obj) {
            var object = obj;
            Object.keys(object).forEach(function (key) {
              try {
                object[key] = null;
              } catch (e) {
                // no getter for object
              }
              try {
                delete object[key];
              } catch (e) {
                // something got wrong
              }
            });
          },
          nextTick: function nextTick(callback, delay) {
            if ( delay === void 0 ) delay = 0;
    
            return setTimeout(callback, delay);
          },
          now: function now() {
            return Date.now();
          },
          getTranslate: function getTranslate(el, axis) {
            if ( axis === void 0 ) axis = 'x';
    
            var matrix;
            var curTransform;
            var transformMatrix;
    
            var curStyle = win.getComputedStyle(el, null);
    
            if (win.WebKitCSSMatrix) {
              curTransform = curStyle.transform || curStyle.webkitTransform;
              if (curTransform.split(',').length > 6) {
                curTransform = curTransform.split(', ').map(function (a) { return a.replace(',', '.'); }).join(', ');
              }
              // Some old versions of Webkit choke when 'none' is passed; pass
              // empty string instead in this case
              transformMatrix = new win.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
            } else {
              transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
              matrix = transformMatrix.toString().split(',');
            }
    
            if (axis === 'x') {
              // Latest Chrome and webkits Fix
              if (win.WebKitCSSMatrix) { curTransform = transformMatrix.m41; }
              // Crazy IE10 Matrix
              else if (matrix.length === 16) { curTransform = parseFloat(matrix[12]); }
              // Normal Browsers
              else { curTransform = parseFloat(matrix[4]); }
            }
            if (axis === 'y') {
              // Latest Chrome and webkits Fix
              if (win.WebKitCSSMatrix) { curTransform = transformMatrix.m42; }
              // Crazy IE10 Matrix
              else if (matrix.length === 16) { curTransform = parseFloat(matrix[13]); }
              // Normal Browsers
              else { curTransform = parseFloat(matrix[5]); }
            }
            return curTransform || 0;
          },
          parseUrlQuery: function parseUrlQuery(url) {
            var query = {};
            var urlToParse = url || win.location.href;
            var i;
            var params;
            var param;
            var length;
            if (typeof urlToParse === 'string' && urlToParse.length) {
              urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\S*\?/, '') : '';
              params = urlToParse.split('&').filter(function (paramsPart) { return paramsPart !== ''; });
              length = params.length;
    
              for (i = 0; i < length; i += 1) {
                param = params[i].replace(/#\S+/g, '').split('=');
                query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param[1]) || '';
              }
            }
            return query;
          },
          isObject: function isObject(o) {
            return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
          },
          extend: function extend() {
            var args = [], len$1 = arguments.length;
            while ( len$1-- ) args[ len$1 ] = arguments[ len$1 ];
    
            var to = Object(args[0]);
            for (var i = 1; i < args.length; i += 1) {
              var nextSource = args[i];
              if (nextSource !== undefined && nextSource !== null) {
                var keysArray = Object.keys(Object(nextSource));
                for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
                  var nextKey = keysArray[nextIndex];
                  var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                  if (desc !== undefined && desc.enumerable) {
                    if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
                      Utils.extend(to[nextKey], nextSource[nextKey]);
                    } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
                      to[nextKey] = {};
                      Utils.extend(to[nextKey], nextSource[nextKey]);
                    } else {
                      to[nextKey] = nextSource[nextKey];
                    }
                  }
                }
              }
            }
            return to;
          },
        };
    
        var Support = (function Support() {
          return {
            touch: !!(('ontouchstart' in win) || (win.DocumentTouch && doc instanceof win.DocumentTouch)),
    
            pointerEvents: !!win.PointerEvent && ('maxTouchPoints' in win.navigator) && win.navigator.maxTouchPoints >= 0,
    
            observer: (function checkObserver() {
              return ('MutationObserver' in win || 'WebkitMutationObserver' in win);
            }()),
    
            passiveListener: (function checkPassiveListener() {
              var supportsPassive = false;
              try {
                var opts = Object.defineProperty({}, 'passive', {
                  // eslint-disable-next-line
                  get: function get() {
                    supportsPassive = true;
                  },
                });
                win.addEventListener('testPassiveListener', null, opts);
              } catch (e) {
                // No support
              }
              return supportsPassive;
            }()),
    
            gestures: (function checkGestures() {
              return 'ongesturestart' in win;
            }()),
          };
        }());
    
        var SwiperClass = function SwiperClass(params) {
          if ( params === void 0 ) params = {};
    
          var self = this;
          self.params = params;
    
          // Events
          self.eventsListeners = {};
    
          if (self.params && self.params.on) {
            Object.keys(self.params.on).forEach(function (eventName) {
              self.on(eventName, self.params.on[eventName]);
            });
          }
        };
    
        var staticAccessors = { components: { configurable: true } };
    
        SwiperClass.prototype.on = function on (events, handler, priority) {
          var self = this;
          if (typeof handler !== 'function') { return self; }
          var method = priority ? 'unshift' : 'push';
          events.split(' ').forEach(function (event) {
            if (!self.eventsListeners[event]) { self.eventsListeners[event] = []; }
            self.eventsListeners[event][method](handler);
          });
          return self;
        };
    
        SwiperClass.prototype.once = function once (events, handler, priority) {
          var self = this;
          if (typeof handler !== 'function') { return self; }
          function onceHandler() {
              var args = [], len = arguments.length;
              while ( len-- ) args[ len ] = arguments[ len ];
    
            self.off(events, onceHandler);
            if (onceHandler.f7proxy) {
              delete onceHandler.f7proxy;
            }
            handler.apply(self, args);
          }
          onceHandler.f7proxy = handler;
          return self.on(events, onceHandler, priority);
        };
    
        SwiperClass.prototype.off = function off (events, handler) {
          var self = this;
          if (!self.eventsListeners) { return self; }
          events.split(' ').forEach(function (event) {
            if (typeof handler === 'undefined') {
              self.eventsListeners[event] = [];
            } else if (self.eventsListeners[event] && self.eventsListeners[event].length) {
              self.eventsListeners[event].forEach(function (eventHandler, index) {
                if (eventHandler === handler || (eventHandler.f7proxy && eventHandler.f7proxy === handler)) {
                  self.eventsListeners[event].splice(index, 1);
                }
              });
            }
          });
          return self;
        };
    
        SwiperClass.prototype.emit = function emit () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];
    
          var self = this;
          if (!self.eventsListeners) { return self; }
          var events;
          var data;
          var context;
          if (typeof args[0] === 'string' || Array.isArray(args[0])) {
            events = args[0];
            data = args.slice(1, args.length);
            context = self;
          } else {
            events = args[0].events;
            data = args[0].data;
            context = args[0].context || self;
          }
          var eventsArray = Array.isArray(events) ? events : events.split(' ');
          eventsArray.forEach(function (event) {
            if (self.eventsListeners && self.eventsListeners[event]) {
              var handlers = [];
              self.eventsListeners[event].forEach(function (eventHandler) {
                handlers.push(eventHandler);
              });
              handlers.forEach(function (eventHandler) {
                eventHandler.apply(context, data);
              });
            }
          });
          return self;
        };
    
        SwiperClass.prototype.useModulesParams = function useModulesParams (instanceParams) {
          var instance = this;
          if (!instance.modules) { return; }
          Object.keys(instance.modules).forEach(function (moduleName) {
            var module = instance.modules[moduleName];
            // Extend params
            if (module.params) {
              Utils.extend(instanceParams, module.params);
            }
          });
        };
    
        SwiperClass.prototype.useModules = function useModules (modulesParams) {
            if ( modulesParams === void 0 ) modulesParams = {};
    
          var instance = this;
          if (!instance.modules) { return; }
          Object.keys(instance.modules).forEach(function (moduleName) {
            var module = instance.modules[moduleName];
            var moduleParams = modulesParams[moduleName] || {};
            // Extend instance methods and props
            if (module.instance) {
              Object.keys(module.instance).forEach(function (modulePropName) {
                var moduleProp = module.instance[modulePropName];
                if (typeof moduleProp === 'function') {
                  instance[modulePropName] = moduleProp.bind(instance);
                } else {
                  instance[modulePropName] = moduleProp;
                }
              });
            }
            // Add event listeners
            if (module.on && instance.on) {
              Object.keys(module.on).forEach(function (moduleEventName) {
                instance.on(moduleEventName, module.on[moduleEventName]);
              });
            }
    
            // Module create callback
            if (module.create) {
              module.create.bind(instance)(moduleParams);
            }
          });
        };
    
        staticAccessors.components.set = function (components) {
          var Class = this;
          if (!Class.use) { return; }
          Class.use(components);
        };
    
        SwiperClass.installModule = function installModule (module) {
            var params = [], len = arguments.length - 1;
            while ( len-- > 0 ) params[ len ] = arguments[ len + 1 ];
    
          var Class = this;
          if (!Class.prototype.modules) { Class.prototype.modules = {}; }
          var name = module.name || (((Object.keys(Class.prototype.modules).length) + "_" + (Utils.now())));
          Class.prototype.modules[name] = module;
          // Prototype
          if (module.proto) {
            Object.keys(module.proto).forEach(function (key) {
              Class.prototype[key] = module.proto[key];
            });
          }
          // Class
          if (module.static) {
            Object.keys(module.static).forEach(function (key) {
              Class[key] = module.static[key];
            });
          }
          // Callback
          if (module.install) {
            module.install.apply(Class, params);
          }
          return Class;
        };
    
        SwiperClass.use = function use (module) {
            var params = [], len = arguments.length - 1;
            while ( len-- > 0 ) params[ len ] = arguments[ len + 1 ];
    
          var Class = this;
          if (Array.isArray(module)) {
            module.forEach(function (m) { return Class.installModule(m); });
            return Class;
          }
          return Class.installModule.apply(Class, [ module ].concat( params ));
        };
    
        Object.defineProperties( SwiperClass, staticAccessors );
    
        function updateSize () {
          var swiper = this;
          var width;
          var height;
          var $el = swiper.$el;
          if (typeof swiper.params.width !== 'undefined') {
            width = swiper.params.width;
          } else {
            width = $el[0].clientWidth;
          }
          if (typeof swiper.params.height !== 'undefined') {
            height = swiper.params.height;
          } else {
            height = $el[0].clientHeight;
          }
          if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {
            return;
          }
    
          // Subtract paddings
          width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);
          height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);
    
          Utils.extend(swiper, {
            width: width,
            height: height,
            size: swiper.isHorizontal() ? width : height,
          });
        }
    
        function updateSlides () {
          var swiper = this;
          var params = swiper.params;
    
          var $wrapperEl = swiper.$wrapperEl;
          var swiperSize = swiper.size;
          var rtl = swiper.rtlTranslate;
          var wrongRTL = swiper.wrongRTL;
          var isVirtual = swiper.virtual && params.virtual.enabled;
          var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
          var slides = $wrapperEl.children(("." + (swiper.params.slideClass)));
          var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
          var snapGrid = [];
          var slidesGrid = [];
          var slidesSizesGrid = [];
    
          function slidesForMargin(slideIndex) {
            if (!params.cssMode) { return true; }
            if (slideIndex === slides.length - 1) {
              return false;
            }
            return true;
          }
    
          var offsetBefore = params.slidesOffsetBefore;
          if (typeof offsetBefore === 'function') {
            offsetBefore = params.slidesOffsetBefore.call(swiper);
          }
    
          var offsetAfter = params.slidesOffsetAfter;
          if (typeof offsetAfter === 'function') {
            offsetAfter = params.slidesOffsetAfter.call(swiper);
          }
    
          var previousSnapGridLength = swiper.snapGrid.length;
          var previousSlidesGridLength = swiper.snapGrid.length;
    
          var spaceBetween = params.spaceBetween;
          var slidePosition = -offsetBefore;
          var prevSlideSize = 0;
          var index = 0;
          if (typeof swiperSize === 'undefined') {
            return;
          }
          if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
            spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;
          }
    
          swiper.virtualSize = -spaceBetween;
    
          // reset margins
          if (rtl) { slides.css({ marginLeft: '', marginTop: '' }); }
          else { slides.css({ marginRight: '', marginBottom: '' }); }
    
          var slidesNumberEvenToRows;
          if (params.slidesPerColumn > 1) {
            if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
              slidesNumberEvenToRows = slidesLength;
            } else {
              slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
            }
            if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
              slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
            }
          }
    
          // Calc slides
          var slideSize;
          var slidesPerColumn = params.slidesPerColumn;
          var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
          var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);
          for (var i = 0; i < slidesLength; i += 1) {
            slideSize = 0;
            var slide = slides.eq(i);
            if (params.slidesPerColumn > 1) {
              // Set slides order
              var newSlideOrderIndex = (void 0);
              var column = (void 0);
              var row = (void 0);
              if (params.slidesPerColumnFill === 'row' && params.slidesPerGroup > 1) {
                var groupIndex = Math.floor(i / (params.slidesPerGroup * params.slidesPerColumn));
                var slideIndexInGroup = i - params.slidesPerColumn * params.slidesPerGroup * groupIndex;
                var columnsInGroup = groupIndex === 0
                  ? params.slidesPerGroup
                  : Math.min(Math.ceil((slidesLength - groupIndex * slidesPerColumn * params.slidesPerGroup) / slidesPerColumn), params.slidesPerGroup);
                row = Math.floor(slideIndexInGroup / columnsInGroup);
                column = (slideIndexInGroup - row * columnsInGroup) + groupIndex * params.slidesPerGroup;
    
                newSlideOrderIndex = column + ((row * slidesNumberEvenToRows) / slidesPerColumn);
                slide
                  .css({
                    '-webkit-box-ordinal-group': newSlideOrderIndex,
                    '-moz-box-ordinal-group': newSlideOrderIndex,
                    '-ms-flex-order': newSlideOrderIndex,
                    '-webkit-order': newSlideOrderIndex,
                    order: newSlideOrderIndex,
                  });
              } else if (params.slidesPerColumnFill === 'column') {
                column = Math.floor(i / slidesPerColumn);
                row = i - (column * slidesPerColumn);
                if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {
                  row += 1;
                  if (row >= slidesPerColumn) {
                    row = 0;
                    column += 1;
                  }
                }
              } else {
                row = Math.floor(i / slidesPerRow);
                column = i - (row * slidesPerRow);
              }
              slide.css(
                ("margin-" + (swiper.isHorizontal() ? 'top' : 'left')),
                (row !== 0 && params.spaceBetween) && (((params.spaceBetween) + "px"))
              );
            }
            if (slide.css('display') === 'none') { continue; } // eslint-disable-line
    
            if (params.slidesPerView === 'auto') {
              var slideStyles = win.getComputedStyle(slide[0], null);
              var currentTransform = slide[0].style.transform;
              var currentWebKitTransform = slide[0].style.webkitTransform;
              if (currentTransform) {
                slide[0].style.transform = 'none';
              }
              if (currentWebKitTransform) {
                slide[0].style.webkitTransform = 'none';
              }
              if (params.roundLengths) {
                slideSize = swiper.isHorizontal()
                  ? slide.outerWidth(true)
                  : slide.outerHeight(true);
              } else {
                // eslint-disable-next-line
                if (swiper.isHorizontal()) {
                  var width = parseFloat(slideStyles.getPropertyValue('width'));
                  var paddingLeft = parseFloat(slideStyles.getPropertyValue('padding-left'));
                  var paddingRight = parseFloat(slideStyles.getPropertyValue('padding-right'));
                  var marginLeft = parseFloat(slideStyles.getPropertyValue('margin-left'));
                  var marginRight = parseFloat(slideStyles.getPropertyValue('margin-right'));
                  var boxSizing = slideStyles.getPropertyValue('box-sizing');
                  if (boxSizing && boxSizing === 'border-box') {
                    slideSize = width + marginLeft + marginRight;
                  } else {
                    slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight;
                  }
                } else {
                  var height = parseFloat(slideStyles.getPropertyValue('height'));
                  var paddingTop = parseFloat(slideStyles.getPropertyValue('padding-top'));
                  var paddingBottom = parseFloat(slideStyles.getPropertyValue('padding-bottom'));
                  var marginTop = parseFloat(slideStyles.getPropertyValue('margin-top'));
                  var marginBottom = parseFloat(slideStyles.getPropertyValue('margin-bottom'));
                  var boxSizing$1 = slideStyles.getPropertyValue('box-sizing');
                  if (boxSizing$1 && boxSizing$1 === 'border-box') {
                    slideSize = height + marginTop + marginBottom;
                  } else {
                    slideSize = height + paddingTop + paddingBottom + marginTop + marginBottom;
                  }
                }
              }
              if (currentTransform) {
                slide[0].style.transform = currentTransform;
              }
              if (currentWebKitTransform) {
                slide[0].style.webkitTransform = currentWebKitTransform;
              }
              if (params.roundLengths) { slideSize = Math.floor(slideSize); }
            } else {
              slideSize = (swiperSize - ((params.slidesPerView - 1) * spaceBetween)) / params.slidesPerView;
              if (params.roundLengths) { slideSize = Math.floor(slideSize); }
    
              if (slides[i]) {
                if (swiper.isHorizontal()) {
                  slides[i].style.width = slideSize + "px";
                } else {
                  slides[i].style.height = slideSize + "px";
                }
              }
            }
            if (slides[i]) {
              slides[i].swiperSlideSize = slideSize;
            }
            slidesSizesGrid.push(slideSize);
    
    
            if (params.centeredSlides) {
              slidePosition = slidePosition + (slideSize / 2) + (prevSlideSize / 2) + spaceBetween;
              if (prevSlideSize === 0 && i !== 0) { slidePosition = slidePosition - (swiperSize / 2) - spaceBetween; }
              if (i === 0) { slidePosition = slidePosition - (swiperSize / 2) - spaceBetween; }
              if (Math.abs(slidePosition) < 1 / 1000) { slidePosition = 0; }
              if (params.roundLengths) { slidePosition = Math.floor(slidePosition); }
              if ((index) % params.slidesPerGroup === 0) { snapGrid.push(slidePosition); }
              slidesGrid.push(slidePosition);
            } else {
              if (params.roundLengths) { slidePosition = Math.floor(slidePosition); }
              if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) { snapGrid.push(slidePosition); }
              slidesGrid.push(slidePosition);
              slidePosition = slidePosition + slideSize + spaceBetween;
            }
    
            swiper.virtualSize += slideSize + spaceBetween;
    
            prevSlideSize = slideSize;
    
            index += 1;
          }
          swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
          var newSlidesGrid;
    
          if (
            rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
            $wrapperEl.css({ width: ((swiper.virtualSize + params.spaceBetween) + "px") });
          }
          if (params.setWrapperSize) {
            if (swiper.isHorizontal()) { $wrapperEl.css({ width: ((swiper.virtualSize + params.spaceBetween) + "px") }); }
            else { $wrapperEl.css({ height: ((swiper.virtualSize + params.spaceBetween) + "px") }); }
          }
    
          if (params.slidesPerColumn > 1) {
            swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
            swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
            if (swiper.isHorizontal()) { $wrapperEl.css({ width: ((swiper.virtualSize + params.spaceBetween) + "px") }); }
            else { $wrapperEl.css({ height: ((swiper.virtualSize + params.spaceBetween) + "px") }); }
            if (params.centeredSlides) {
              newSlidesGrid = [];
              for (var i$1 = 0; i$1 < snapGrid.length; i$1 += 1) {
                var slidesGridItem = snapGrid[i$1];
                if (params.roundLengths) { slidesGridItem = Math.floor(slidesGridItem); }
                if (snapGrid[i$1] < swiper.virtualSize + snapGrid[0]) { newSlidesGrid.push(slidesGridItem); }
              }
              snapGrid = newSlidesGrid;
            }
          }
    
          // Remove last grid elements depending on width
          if (!params.centeredSlides) {
            newSlidesGrid = [];
            for (var i$2 = 0; i$2 < snapGrid.length; i$2 += 1) {
              var slidesGridItem$1 = snapGrid[i$2];
              if (params.roundLengths) { slidesGridItem$1 = Math.floor(slidesGridItem$1); }
              if (snapGrid[i$2] <= swiper.virtualSize - swiperSize) {
                newSlidesGrid.push(slidesGridItem$1);
              }
            }
            snapGrid = newSlidesGrid;
            if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
              snapGrid.push(swiper.virtualSize - swiperSize);
            }
          }
          if (snapGrid.length === 0) { snapGrid = [0]; }
    
          if (params.spaceBetween !== 0) {
            if (swiper.isHorizontal()) {
              if (rtl) { slides.filter(slidesForMargin).css({ marginLeft: (spaceBetween + "px") }); }
              else { slides.filter(slidesForMargin).css({ marginRight: (spaceBetween + "px") }); }
            } else { slides.filter(slidesForMargin).css({ marginBottom: (spaceBetween + "px") }); }
          }
    
          if (params.centeredSlides && params.centeredSlidesBounds) {
            var allSlidesSize = 0;
            slidesSizesGrid.forEach(function (slideSizeValue) {
              allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
            });
            allSlidesSize -= params.spaceBetween;
            var maxSnap = allSlidesSize - swiperSize;
            snapGrid = snapGrid.map(function (snap) {
              if (snap < 0) { return -offsetBefore; }
              if (snap > maxSnap) { return maxSnap + offsetAfter; }
              return snap;
            });
          }
    
          if (params.centerInsufficientSlides) {
            var allSlidesSize$1 = 0;
            slidesSizesGrid.forEach(function (slideSizeValue) {
              allSlidesSize$1 += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
            });
            allSlidesSize$1 -= params.spaceBetween;
            if (allSlidesSize$1 < swiperSize) {
              var allSlidesOffset = (swiperSize - allSlidesSize$1) / 2;
              snapGrid.forEach(function (snap, snapIndex) {
                snapGrid[snapIndex] = snap - allSlidesOffset;
              });
              slidesGrid.forEach(function (snap, snapIndex) {
                slidesGrid[snapIndex] = snap + allSlidesOffset;
              });
            }
          }
    
          Utils.extend(swiper, {
            slides: slides,
            snapGrid: snapGrid,
            slidesGrid: slidesGrid,
            slidesSizesGrid: slidesSizesGrid,
          });
    
          if (slidesLength !== previousSlidesLength) {
            swiper.emit('slidesLengthChange');
          }
          if (snapGrid.length !== previousSnapGridLength) {
            if (swiper.params.watchOverflow) { swiper.checkOverflow(); }
            swiper.emit('snapGridLengthChange');
          }
          if (slidesGrid.length !== previousSlidesGridLength) {
            swiper.emit('slidesGridLengthChange');
          }
    
          if (params.watchSlidesProgress || params.watchSlidesVisibility) {
            swiper.updateSlidesOffset();
          }
        }
    
        function updateAutoHeight (speed) {
          var swiper = this;
          var activeSlides = [];
          var newHeight = 0;
          var i;
          if (typeof speed === 'number') {
            swiper.setTransition(speed);
          } else if (speed === true) {
            swiper.setTransition(swiper.params.speed);
          }
          // Find slides currently in view
          if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
            if (swiper.params.centeredSlides) {
              swiper.visibleSlides.each(function (index, slide) {
                activeSlides.push(slide);
              });
            } else {
              for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
                var index = swiper.activeIndex + i;
                if (index > swiper.slides.length) { break; }
                activeSlides.push(swiper.slides.eq(index)[0]);
              }
            }
          } else {
            activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
          }
    
          // Find new height from highest slide in view
          for (i = 0; i < activeSlides.length; i += 1) {
            if (typeof activeSlides[i] !== 'undefined') {
              var height = activeSlides[i].offsetHeight;
              newHeight = height > newHeight ? height : newHeight;
            }
          }
    
          // Update Height
          if (newHeight) { swiper.$wrapperEl.css('height', (newHeight + "px")); }
        }
    
        function updateSlidesOffset () {
          var swiper = this;
          var slides = swiper.slides;
          for (var i = 0; i < slides.length; i += 1) {
            slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
          }
        }
    
        function updateSlidesProgress (translate) {
          if ( translate === void 0 ) translate = (this && this.translate) || 0;
    
          var swiper = this;
          var params = swiper.params;
    
          var slides = swiper.slides;
          var rtl = swiper.rtlTranslate;
    
          if (slides.length === 0) { return; }
          if (typeof slides[0].swiperSlideOffset === 'undefined') { swiper.updateSlidesOffset(); }
    
          var offsetCenter = -translate;
          if (rtl) { offsetCenter = translate; }
    
          // Visible Slides
          slides.removeClass(params.slideVisibleClass);
    
          swiper.visibleSlidesIndexes = [];
          swiper.visibleSlides = [];
    
          for (var i = 0; i < slides.length; i += 1) {
            var slide = slides[i];
            var slideProgress = (
              (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0)) - slide.swiperSlideOffset
            ) / (slide.swiperSlideSize + params.spaceBetween);
            if (params.watchSlidesVisibility || (params.centeredSlides && params.autoHeight)) {
              var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
              var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
              var isVisible = (slideBefore >= 0 && slideBefore < swiper.size - 1)
                        || (slideAfter > 1 && slideAfter <= swiper.size)
                        || (slideBefore <= 0 && slideAfter >= swiper.size);
              if (isVisible) {
                swiper.visibleSlides.push(slide);
                swiper.visibleSlidesIndexes.push(i);
                slides.eq(i).addClass(params.slideVisibleClass);
              }
            }
            slide.progress = rtl ? -slideProgress : slideProgress;
          }
          swiper.visibleSlides = $(swiper.visibleSlides);
        }
    
        function updateProgress (translate) {
          var swiper = this;
          if (typeof translate === 'undefined') {
            var multiplier = swiper.rtlTranslate ? -1 : 1;
            // eslint-disable-next-line
            translate = (swiper && swiper.translate && (swiper.translate * multiplier)) || 0;
          }
          var params = swiper.params;
          var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
          var progress = swiper.progress;
          var isBeginning = swiper.isBeginning;
          var isEnd = swiper.isEnd;
          var wasBeginning = isBeginning;
          var wasEnd = isEnd;
          if (translatesDiff === 0) {
            progress = 0;
            isBeginning = true;
            isEnd = true;
          } else {
            progress = (translate - swiper.minTranslate()) / (translatesDiff);
            isBeginning = progress <= 0;
            isEnd = progress >= 1;
          }
          Utils.extend(swiper, {
            progress: progress,
            isBeginning: isBeginning,
            isEnd: isEnd,
          });
    
          if (params.watchSlidesProgress || params.watchSlidesVisibility || (params.centeredSlides && params.autoHeight)) { swiper.updateSlidesProgress(translate); }
    
          if (isBeginning && !wasBeginning) {
            swiper.emit('reachBeginning toEdge');
          }
          if (isEnd && !wasEnd) {
            swiper.emit('reachEnd toEdge');
          }
          if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {
            swiper.emit('fromEdge');
          }
    
          swiper.emit('progress', progress);
        }
    
        function updateSlidesClasses () {
          var swiper = this;
    
          var slides = swiper.slides;
          var params = swiper.params;
          var $wrapperEl = swiper.$wrapperEl;
          var activeIndex = swiper.activeIndex;
          var realIndex = swiper.realIndex;
          var isVirtual = swiper.virtual && params.virtual.enabled;
    
          slides.removeClass(((params.slideActiveClass) + " " + (params.slideNextClass) + " " + (params.slidePrevClass) + " " + (params.slideDuplicateActiveClass) + " " + (params.slideDuplicateNextClass) + " " + (params.slideDuplicatePrevClass)));
    
          var activeSlide;
          if (isVirtual) {
            activeSlide = swiper.$wrapperEl.find(("." + (params.slideClass) + "[data-swiper-slide-index=\"" + activeIndex + "\"]"));
          } else {
            activeSlide = slides.eq(activeIndex);
          }
    
          // Active classes
          activeSlide.addClass(params.slideActiveClass);
    
          if (params.loop) {
            // Duplicate to all looped slides
            if (activeSlide.hasClass(params.slideDuplicateClass)) {
              $wrapperEl
                .children(("." + (params.slideClass) + ":not(." + (params.slideDuplicateClass) + ")[data-swiper-slide-index=\"" + realIndex + "\"]"))
                .addClass(params.slideDuplicateActiveClass);
            } else {
              $wrapperEl
                .children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + realIndex + "\"]"))
                .addClass(params.slideDuplicateActiveClass);
            }
          }
          // Next Slide
          var nextSlide = activeSlide.nextAll(("." + (params.slideClass))).eq(0).addClass(params.slideNextClass);
          if (params.loop && nextSlide.length === 0) {
            nextSlide = slides.eq(0);
            nextSlide.addClass(params.slideNextClass);
          }
          // Prev Slide
          var prevSlide = activeSlide.prevAll(("." + (params.slideClass))).eq(0).addClass(params.slidePrevClass);
          if (params.loop && prevSlide.length === 0) {
            prevSlide = slides.eq(-1);
            prevSlide.addClass(params.slidePrevClass);
          }
          if (params.loop) {
            // Duplicate to all looped slides
            if (nextSlide.hasClass(params.slideDuplicateClass)) {
              $wrapperEl
                .children(("." + (params.slideClass) + ":not(." + (params.slideDuplicateClass) + ")[data-swiper-slide-index=\"" + (nextSlide.attr('data-swiper-slide-index')) + "\"]"))
                .addClass(params.slideDuplicateNextClass);
            } else {
              $wrapperEl
                .children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + (nextSlide.attr('data-swiper-slide-index')) + "\"]"))
                .addClass(params.slideDuplicateNextClass);
            }
            if (prevSlide.hasClass(params.slideDuplicateClass)) {
              $wrapperEl
                .children(("." + (params.slideClass) + ":not(." + (params.slideDuplicateClass) + ")[data-swiper-slide-index=\"" + (prevSlide.attr('data-swiper-slide-index')) + "\"]"))
                .addClass(params.slideDuplicatePrevClass);
            } else {
              $wrapperEl
                .children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + (prevSlide.attr('data-swiper-slide-index')) + "\"]"))
                .addClass(params.slideDuplicatePrevClass);
            }
          }
        }
    
        function updateActiveIndex (newActiveIndex) {
          var swiper = this;
          var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
          var slidesGrid = swiper.slidesGrid;
          var snapGrid = swiper.snapGrid;
          var params = swiper.params;
          var previousIndex = swiper.activeIndex;
          var previousRealIndex = swiper.realIndex;
          var previousSnapIndex = swiper.snapIndex;
          var activeIndex = newActiveIndex;
          var snapIndex;
          if (typeof activeIndex === 'undefined') {
            for (var i = 0; i < slidesGrid.length; i += 1) {
              if (typeof slidesGrid[i + 1] !== 'undefined') {
                if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - ((slidesGrid[i + 1] - slidesGrid[i]) / 2)) {
                  activeIndex = i;
                } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
                  activeIndex = i + 1;
                }
              } else if (translate >= slidesGrid[i]) {
                activeIndex = i;
              }
            }
            // Normalize slideIndex
            if (params.normalizeSlideIndex) {
              if (activeIndex < 0 || typeof activeIndex === 'undefined') { activeIndex = 0; }
            }
          }
          if (snapGrid.indexOf(translate) >= 0) {
            snapIndex = snapGrid.indexOf(translate);
          } else {
            var skip = Math.min(params.slidesPerGroupSkip, activeIndex);
            snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
          }
          if (snapIndex >= snapGrid.length) { snapIndex = snapGrid.length - 1; }
          if (activeIndex === previousIndex) {
            if (snapIndex !== previousSnapIndex) {
              swiper.snapIndex = snapIndex;
              swiper.emit('snapIndexChange');
            }
            return;
          }
    
          // Get real index
          var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
    
          Utils.extend(swiper, {
            snapIndex: snapIndex,
            realIndex: realIndex,
            previousIndex: previousIndex,
            activeIndex: activeIndex,
          });
          swiper.emit('activeIndexChange');
          swiper.emit('snapIndexChange');
          if (previousRealIndex !== realIndex) {
            swiper.emit('realIndexChange');
          }
          if (swiper.initialized || swiper.params.runCallbacksOnInit) {
            swiper.emit('slideChange');
          }
        }
    
        function updateClickedSlide (e) {
          var swiper = this;
          var params = swiper.params;
          var slide = $(e.target).closest(("." + (params.slideClass)))[0];
          var slideFound = false;
          if (slide) {
            for (var i = 0; i < swiper.slides.length; i += 1) {
              if (swiper.slides[i] === slide) { slideFound = true; }
            }
          }
    
          if (slide && slideFound) {
            swiper.clickedSlide = slide;
            if (swiper.virtual && swiper.params.virtual.enabled) {
              swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
            } else {
              swiper.clickedIndex = $(slide).index();
            }
          } else {
            swiper.clickedSlide = undefined;
            swiper.clickedIndex = undefined;
            return;
          }
          if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
            swiper.slideToClickedSlide();
          }
        }
    
        var update = {
          updateSize: updateSize,
          updateSlides: updateSlides,
          updateAutoHeight: updateAutoHeight,
          updateSlidesOffset: updateSlidesOffset,
          updateSlidesProgress: updateSlidesProgress,
          updateProgress: updateProgress,
          updateSlidesClasses: updateSlidesClasses,
          updateActiveIndex: updateActiveIndex,
          updateClickedSlide: updateClickedSlide,
        };
    
        function getTranslate (axis) {
          if ( axis === void 0 ) axis = this.isHorizontal() ? 'x' : 'y';
    
          var swiper = this;
    
          var params = swiper.params;
          var rtl = swiper.rtlTranslate;
          var translate = swiper.translate;
          var $wrapperEl = swiper.$wrapperEl;
    
          if (params.virtualTranslate) {
            return rtl ? -translate : translate;
          }
          if (params.cssMode) {
            return translate;
          }
    
          var currentTranslate = Utils.getTranslate($wrapperEl[0], axis);
          if (rtl) { currentTranslate = -currentTranslate; }
    
          return currentTranslate || 0;
        }
    
        function setTranslate (translate, byController) {
          var swiper = this;
          var rtl = swiper.rtlTranslate;
          var params = swiper.params;
          var $wrapperEl = swiper.$wrapperEl;
          var wrapperEl = swiper.wrapperEl;
          var progress = swiper.progress;
          var x = 0;
          var y = 0;
          var z = 0;
    
          if (swiper.isHorizontal()) {
            x = rtl ? -translate : translate;
          } else {
            y = translate;
          }
    
          if (params.roundLengths) {
            x = Math.floor(x);
            y = Math.floor(y);
          }
    
          if (params.cssMode) {
            wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
          } else if (!params.virtualTranslate) {
            $wrapperEl.transform(("translate3d(" + x + "px, " + y + "px, " + z + "px)"));
          }
          swiper.previousTranslate = swiper.translate;
          swiper.translate = swiper.isHorizontal() ? x : y;
    
          // Check if we need to update progress
          var newProgress;
          var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
          if (translatesDiff === 0) {
            newProgress = 0;
          } else {
            newProgress = (translate - swiper.minTranslate()) / (translatesDiff);
          }
          if (newProgress !== progress) {
            swiper.updateProgress(translate);
          }
    
          swiper.emit('setTranslate', swiper.translate, byController);
        }
    
        function minTranslate () {
          return (-this.snapGrid[0]);
        }
    
        function maxTranslate () {
          return (-this.snapGrid[this.snapGrid.length - 1]);
        }
    
        function translateTo (translate, speed, runCallbacks, translateBounds, internal) {
          var obj;
    
          if ( translate === void 0 ) translate = 0;
          if ( speed === void 0 ) speed = this.params.speed;
          if ( runCallbacks === void 0 ) runCallbacks = true;
          if ( translateBounds === void 0 ) translateBounds = true;
          var swiper = this;
    
          var params = swiper.params;
          var wrapperEl = swiper.wrapperEl;
    
          if (swiper.animating && params.preventInteractionOnTransition) {
            return false;
          }
    
          var minTranslate = swiper.minTranslate();
          var maxTranslate = swiper.maxTranslate();
          var newTranslate;
          if (translateBounds && translate > minTranslate) { newTranslate = minTranslate; }
          else if (translateBounds && translate < maxTranslate) { newTranslate = maxTranslate; }
          else { newTranslate = translate; }
    
          // Update progress
          swiper.updateProgress(newTranslate);
    
          if (params.cssMode) {
            var isH = swiper.isHorizontal();
            if (speed === 0) {
              wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
            } else {
              // eslint-disable-next-line
              if (wrapperEl.scrollTo) {
                wrapperEl.scrollTo(( obj = {}, obj[isH ? 'left' : 'top'] = -newTranslate, obj.behavior = 'smooth', obj ));
              } else {
                wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
              }
            }
            return true;
          }
    
          if (speed === 0) {
            swiper.setTransition(0);
            swiper.setTranslate(newTranslate);
            if (runCallbacks) {
              swiper.emit('beforeTransitionStart', speed, internal);
              swiper.emit('transitionEnd');
            }
          } else {
            swiper.setTransition(speed);
            swiper.setTranslate(newTranslate);
            if (runCallbacks) {
              swiper.emit('beforeTransitionStart', speed, internal);
              swiper.emit('transitionStart');
            }
            if (!swiper.animating) {
              swiper.animating = true;
              if (!swiper.onTranslateToWrapperTransitionEnd) {
                swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
                  if (!swiper || swiper.destroyed) { return; }
                  if (e.target !== this) { return; }
                  swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
                  swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
                  swiper.onTranslateToWrapperTransitionEnd = null;
                  delete swiper.onTranslateToWrapperTransitionEnd;
                  if (runCallbacks) {
                    swiper.emit('transitionEnd');
                  }
                };
              }
              swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
              swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
            }
          }
    
          return true;
        }
    
        var translate = {
          getTranslate: getTranslate,
          setTranslate: setTranslate,
          minTranslate: minTranslate,
          maxTranslate: maxTranslate,
          translateTo: translateTo,
        };
    
        function setTransition (duration, byController) {
          var swiper = this;
    
          if (!swiper.params.cssMode) {
            swiper.$wrapperEl.transition(duration);
          }
    
          swiper.emit('setTransition', duration, byController);
        }
    
        function transitionStart (runCallbacks, direction) {
          if ( runCallbacks === void 0 ) runCallbacks = true;
    
          var swiper = this;
          var activeIndex = swiper.activeIndex;
          var params = swiper.params;
          var previousIndex = swiper.previousIndex;
          if (params.cssMode) { return; }
          if (params.autoHeight) {
            swiper.updateAutoHeight();
          }
    
          var dir = direction;
          if (!dir) {
            if (activeIndex > previousIndex) { dir = 'next'; }
            else if (activeIndex < previousIndex) { dir = 'prev'; }
            else { dir = 'reset'; }
          }
    
          swiper.emit('transitionStart');
    
          if (runCallbacks && activeIndex !== previousIndex) {
            if (dir === 'reset') {
              swiper.emit('slideResetTransitionStart');
              return;
            }
            swiper.emit('slideChangeTransitionStart');
            if (dir === 'next') {
              swiper.emit('slideNextTransitionStart');
            } else {
              swiper.emit('slidePrevTransitionStart');
            }
          }
        }
    
        function transitionEnd$1 (runCallbacks, direction) {
          if ( runCallbacks === void 0 ) runCallbacks = true;
    
          var swiper = this;
          var activeIndex = swiper.activeIndex;
          var previousIndex = swiper.previousIndex;
          var params = swiper.params;
          swiper.animating = false;
          if (params.cssMode) { return; }
          swiper.setTransition(0);
    
          var dir = direction;
          if (!dir) {
            if (activeIndex > previousIndex) { dir = 'next'; }
            else if (activeIndex < previousIndex) { dir = 'prev'; }
            else { dir = 'reset'; }
          }
    
          swiper.emit('transitionEnd');
    
          if (runCallbacks && activeIndex !== previousIndex) {
            if (dir === 'reset') {
              swiper.emit('slideResetTransitionEnd');
              return;
            }
            swiper.emit('slideChangeTransitionEnd');
            if (dir === 'next') {
              swiper.emit('slideNextTransitionEnd');
            } else {
              swiper.emit('slidePrevTransitionEnd');
            }
          }
        }
    
        var transition$1 = {
          setTransition: setTransition,
          transitionStart: transitionStart,
          transitionEnd: transitionEnd$1,
        };
    
        function slideTo (index, speed, runCallbacks, internal) {
          var obj;
    
          if ( index === void 0 ) index = 0;
          if ( speed === void 0 ) speed = this.params.speed;
          if ( runCallbacks === void 0 ) runCallbacks = true;
          var swiper = this;
          var slideIndex = index;
          if (slideIndex < 0) { slideIndex = 0; }
    
          var params = swiper.params;
          var snapGrid = swiper.snapGrid;
          var slidesGrid = swiper.slidesGrid;
          var previousIndex = swiper.previousIndex;
          var activeIndex = swiper.activeIndex;
          var rtl = swiper.rtlTranslate;
          var wrapperEl = swiper.wrapperEl;
          if (swiper.animating && params.preventInteractionOnTransition) {
            return false;
          }
    
          var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
          var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
          if (snapIndex >= snapGrid.length) { snapIndex = snapGrid.length - 1; }
    
          if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
            swiper.emit('beforeSlideChangeStart');
          }
    
          var translate = -snapGrid[snapIndex];
    
          // Update progress
          swiper.updateProgress(translate);
    
          // Normalize slideIndex
          if (params.normalizeSlideIndex) {
            for (var i = 0; i < slidesGrid.length; i += 1) {
              if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {
                slideIndex = i;
              }
            }
          }
          // Directions locks
          if (swiper.initialized && slideIndex !== activeIndex) {
            if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
              return false;
            }
            if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
              if ((activeIndex || 0) !== slideIndex) { return false; }
            }
          }
    
          var direction;
          if (slideIndex > activeIndex) { direction = 'next'; }
          else if (slideIndex < activeIndex) { direction = 'prev'; }
          else { direction = 'reset'; }
    
    
          // Update Index
          if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {
            swiper.updateActiveIndex(slideIndex);
            // Update Height
            if (params.autoHeight) {
              swiper.updateAutoHeight();
            }
            swiper.updateSlidesClasses();
            if (params.effect !== 'slide') {
              swiper.setTranslate(translate);
            }
            if (direction !== 'reset') {
              swiper.transitionStart(runCallbacks, direction);
              swiper.transitionEnd(runCallbacks, direction);
            }
            return false;
          }
          if (params.cssMode) {
            var isH = swiper.isHorizontal();
            var t = -translate;
            if (rtl) {
              t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;
            }
            if (speed === 0) {
              wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
            } else {
              // eslint-disable-next-line
              if (wrapperEl.scrollTo) {
                wrapperEl.scrollTo(( obj = {}, obj[isH ? 'left' : 'top'] = t, obj.behavior = 'smooth', obj ));
              } else {
                wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
              }
            }
            return true;
          }
    
          if (speed === 0) {
            swiper.setTransition(0);
            swiper.setTranslate(translate);
            swiper.updateActiveIndex(slideIndex);
            swiper.updateSlidesClasses();
            swiper.emit('beforeTransitionStart', speed, internal);
            swiper.transitionStart(runCallbacks, direction);
            swiper.transitionEnd(runCallbacks, direction);
          } else {
            swiper.setTransition(speed);
            swiper.setTranslate(translate);
            swiper.updateActiveIndex(slideIndex);
            swiper.updateSlidesClasses();
            swiper.emit('beforeTransitionStart', speed, internal);
            swiper.transitionStart(runCallbacks, direction);
            if (!swiper.animating) {
              swiper.animating = true;
              if (!swiper.onSlideToWrapperTransitionEnd) {
                swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
                  if (!swiper || swiper.destroyed) { return; }
                  if (e.target !== this) { return; }
                  swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
                  swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
                  swiper.onSlideToWrapperTransitionEnd = null;
                  delete swiper.onSlideToWrapperTransitionEnd;
                  swiper.transitionEnd(runCallbacks, direction);
                };
              }
              swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
              swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
            }
          }
    
          return true;
        }
    
        function slideToLoop (index, speed, runCallbacks, internal) {
          if ( index === void 0 ) index = 0;
          if ( speed === void 0 ) speed = this.params.speed;
          if ( runCallbacks === void 0 ) runCallbacks = true;
    
          var swiper = this;
          var newIndex = index;
          if (swiper.params.loop) {
            newIndex += swiper.loopedSlides;
          }
    
          return swiper.slideTo(newIndex, speed, runCallbacks, internal);
        }
    
        /* eslint no-unused-vars: "off" */
        function slideNext (speed, runCallbacks, internal) {
          if ( speed === void 0 ) speed = this.params.speed;
          if ( runCallbacks === void 0 ) runCallbacks = true;
    
          var swiper = this;
          var params = swiper.params;
          var animating = swiper.animating;
          var increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;
          if (params.loop) {
            if (animating) { return false; }
            swiper.loopFix();
            // eslint-disable-next-line
            swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
          }
          return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
        }
    
        /* eslint no-unused-vars: "off" */
        function slidePrev (speed, runCallbacks, internal) {
          if ( speed === void 0 ) speed = this.params.speed;
          if ( runCallbacks === void 0 ) runCallbacks = true;
    
          var swiper = this;
          var params = swiper.params;
          var animating = swiper.animating;
          var snapGrid = swiper.snapGrid;
          var slidesGrid = swiper.slidesGrid;
          var rtlTranslate = swiper.rtlTranslate;
    
          if (params.loop) {
            if (animating) { return false; }
            swiper.loopFix();
            // eslint-disable-next-line
            swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
          }
          var translate = rtlTranslate ? swiper.translate : -swiper.translate;
          function normalize(val) {
            if (val < 0) { return -Math.floor(Math.abs(val)); }
            return Math.floor(val);
          }
          var normalizedTranslate = normalize(translate);
          var normalizedSnapGrid = snapGrid.map(function (val) { return normalize(val); });
          var normalizedSlidesGrid = slidesGrid.map(function (val) { return normalize(val); });
    
          var currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];
          var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
          if (typeof prevSnap === 'undefined' && params.cssMode) {
            snapGrid.forEach(function (snap) {
              if (!prevSnap && normalizedTranslate >= snap) { prevSnap = snap; }
            });
          }
          var prevIndex;
          if (typeof prevSnap !== 'undefined') {
            prevIndex = slidesGrid.indexOf(prevSnap);
            if (prevIndex < 0) { prevIndex = swiper.activeIndex - 1; }
          }
          return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
        }
    
        /* eslint no-unused-vars: "off" */
        function slideReset (speed, runCallbacks, internal) {
          if ( speed === void 0 ) speed = this.params.speed;
          if ( runCallbacks === void 0 ) runCallbacks = true;
    
          var swiper = this;
          return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
        }
    
        /* eslint no-unused-vars: "off" */
        function slideToClosest (speed, runCallbacks, internal, threshold) {
          if ( speed === void 0 ) speed = this.params.speed;
          if ( runCallbacks === void 0 ) runCallbacks = true;
          if ( threshold === void 0 ) threshold = 0.5;
    
          var swiper = this;
          var index = swiper.activeIndex;
          var skip = Math.min(swiper.params.slidesPerGroupSkip, index);
          var snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
    
          var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    
          if (translate >= swiper.snapGrid[snapIndex]) {
            // The current translate is on or after the current snap index, so the choice
            // is between the current index and the one after it.
            var currentSnap = swiper.snapGrid[snapIndex];
            var nextSnap = swiper.snapGrid[snapIndex + 1];
            if ((translate - currentSnap) > (nextSnap - currentSnap) * threshold) {
              index += swiper.params.slidesPerGroup;
            }
          } else {
            // The current translate is before the current snap index, so the choice
            // is between the current index and the one before it.
            var prevSnap = swiper.snapGrid[snapIndex - 1];
            var currentSnap$1 = swiper.snapGrid[snapIndex];
            if ((translate - prevSnap) <= (currentSnap$1 - prevSnap) * threshold) {
              index -= swiper.params.slidesPerGroup;
            }
          }
          index = Math.max(index, 0);
          index = Math.min(index, swiper.slidesGrid.length - 1);
    
          return swiper.slideTo(index, speed, runCallbacks, internal);
        }
    
        function slideToClickedSlide () {
          var swiper = this;
          var params = swiper.params;
          var $wrapperEl = swiper.$wrapperEl;
    
          var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
          var slideToIndex = swiper.clickedIndex;
          var realIndex;
          if (params.loop) {
            if (swiper.animating) { return; }
            realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);
            if (params.centeredSlides) {
              if (
                (slideToIndex < swiper.loopedSlides - (slidesPerView / 2))
                || (slideToIndex > (swiper.slides.length - swiper.loopedSlides) + (slidesPerView / 2))
              ) {
                swiper.loopFix();
                slideToIndex = $wrapperEl
                  .children(("." + (params.slideClass) + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + (params.slideDuplicateClass) + ")"))
                  .eq(0)
                  .index();
    
                Utils.nextTick(function () {
                  swiper.slideTo(slideToIndex);
                });
              } else {
                swiper.slideTo(slideToIndex);
              }
            } else if (slideToIndex > swiper.slides.length - slidesPerView) {
              swiper.loopFix();
              slideToIndex = $wrapperEl
                .children(("." + (params.slideClass) + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + (params.slideDuplicateClass) + ")"))
                .eq(0)
                .index();
    
              Utils.nextTick(function () {
                swiper.slideTo(slideToIndex);
              });
            } else {
              swiper.slideTo(slideToIndex);
            }
          } else {
            swiper.slideTo(slideToIndex);
          }
        }
    
        var slide = {
          slideTo: slideTo,
          slideToLoop: slideToLoop,
          slideNext: slideNext,
          slidePrev: slidePrev,
          slideReset: slideReset,
          slideToClosest: slideToClosest,
          slideToClickedSlide: slideToClickedSlide,
        };
    
        function loopCreate () {
          var swiper = this;
          var params = swiper.params;
          var $wrapperEl = swiper.$wrapperEl;
          // Remove duplicated slides
          $wrapperEl.children(("." + (params.slideClass) + "." + (params.slideDuplicateClass))).remove();
    
          var slides = $wrapperEl.children(("." + (params.slideClass)));
    
          if (params.loopFillGroupWithBlank) {
            var blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);
            if (blankSlidesNum !== params.slidesPerGroup) {
              for (var i = 0; i < blankSlidesNum; i += 1) {
                var blankNode = $(doc.createElement('div')).addClass(((params.slideClass) + " " + (params.slideBlankClass)));
                $wrapperEl.append(blankNode);
              }
              slides = $wrapperEl.children(("." + (params.slideClass)));
            }
          }
    
          if (params.slidesPerView === 'auto' && !params.loopedSlides) { params.loopedSlides = slides.length; }
    
          swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
          swiper.loopedSlides += params.loopAdditionalSlides;
          if (swiper.loopedSlides > slides.length) {
            swiper.loopedSlides = slides.length;
          }
    
          var prependSlides = [];
          var appendSlides = [];
          slides.each(function (index, el) {
            var slide = $(el);
            if (index < swiper.loopedSlides) { appendSlides.push(el); }
            if (index < slides.length && index >= slides.length - swiper.loopedSlides) { prependSlides.push(el); }
            slide.attr('data-swiper-slide-index', index);
          });
          for (var i$1 = 0; i$1 < appendSlides.length; i$1 += 1) {
            $wrapperEl.append($(appendSlides[i$1].cloneNode(true)).addClass(params.slideDuplicateClass));
          }
          for (var i$2 = prependSlides.length - 1; i$2 >= 0; i$2 -= 1) {
            $wrapperEl.prepend($(prependSlides[i$2].cloneNode(true)).addClass(params.slideDuplicateClass));
          }
        }
    
        function loopFix () {
          var swiper = this;
    
          swiper.emit('beforeLoopFix');
    
          var activeIndex = swiper.activeIndex;
          var slides = swiper.slides;
          var loopedSlides = swiper.loopedSlides;
          var allowSlidePrev = swiper.allowSlidePrev;
          var allowSlideNext = swiper.allowSlideNext;
          var snapGrid = swiper.snapGrid;
          var rtl = swiper.rtlTranslate;
          var newIndex;
          swiper.allowSlidePrev = true;
          swiper.allowSlideNext = true;
    
          var snapTranslate = -snapGrid[activeIndex];
          var diff = snapTranslate - swiper.getTranslate();
    
          // Fix For Negative Oversliding
          if (activeIndex < loopedSlides) {
            newIndex = (slides.length - (loopedSlides * 3)) + activeIndex;
            newIndex += loopedSlides;
            var slideChanged = swiper.slideTo(newIndex, 0, false, true);
            if (slideChanged && diff !== 0) {
              swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
            }
          } else if (activeIndex >= slides.length - loopedSlides) {
            // Fix For Positive Oversliding
            newIndex = -slides.length + activeIndex + loopedSlides;
            newIndex += loopedSlides;
            var slideChanged$1 = swiper.slideTo(newIndex, 0, false, true);
            if (slideChanged$1 && diff !== 0) {
              swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
            }
          }
          swiper.allowSlidePrev = allowSlidePrev;
          swiper.allowSlideNext = allowSlideNext;
    
          swiper.emit('loopFix');
        }
    
        function loopDestroy () {
          var swiper = this;
          var $wrapperEl = swiper.$wrapperEl;
          var params = swiper.params;
          var slides = swiper.slides;
          $wrapperEl.children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + ",." + (params.slideClass) + "." + (params.slideBlankClass))).remove();
          slides.removeAttr('data-swiper-slide-index');
        }
    
        var loop = {
          loopCreate: loopCreate,
          loopFix: loopFix,
          loopDestroy: loopDestroy,
        };
    
        function setGrabCursor (moving) {
          var swiper = this;
          if (Support.touch || !swiper.params.simulateTouch || (swiper.params.watchOverflow && swiper.isLocked) || swiper.params.cssMode) { return; }
          var el = swiper.el;
          el.style.cursor = 'move';
          el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
          el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
          el.style.cursor = moving ? 'grabbing' : 'grab';
        }
    
        function unsetGrabCursor () {
          var swiper = this;
          if (Support.touch || (swiper.params.watchOverflow && swiper.isLocked) || swiper.params.cssMode) { return; }
          swiper.el.style.cursor = '';
        }
    
        var grabCursor = {
          setGrabCursor: setGrabCursor,
          unsetGrabCursor: unsetGrabCursor,
        };
    
        function appendSlide (slides) {
          var swiper = this;
          var $wrapperEl = swiper.$wrapperEl;
          var params = swiper.params;
          if (params.loop) {
            swiper.loopDestroy();
          }
          if (typeof slides === 'object' && 'length' in slides) {
            for (var i = 0; i < slides.length; i += 1) {
              if (slides[i]) { $wrapperEl.append(slides[i]); }
            }
          } else {
            $wrapperEl.append(slides);
          }
          if (params.loop) {
            swiper.loopCreate();
          }
          if (!(params.observer && Support.observer)) {
            swiper.update();
          }
        }
    
        function prependSlide (slides) {
          var swiper = this;
          var params = swiper.params;
          var $wrapperEl = swiper.$wrapperEl;
          var activeIndex = swiper.activeIndex;
    
          if (params.loop) {
            swiper.loopDestroy();
          }
          var newActiveIndex = activeIndex + 1;
          if (typeof slides === 'object' && 'length' in slides) {
            for (var i = 0; i < slides.length; i += 1) {
              if (slides[i]) { $wrapperEl.prepend(slides[i]); }
            }
            newActiveIndex = activeIndex + slides.length;
          } else {
            $wrapperEl.prepend(slides);
          }
          if (params.loop) {
            swiper.loopCreate();
          }
          if (!(params.observer && Support.observer)) {
            swiper.update();
          }
          swiper.slideTo(newActiveIndex, 0, false);
        }
    
        function addSlide (index, slides) {
          var swiper = this;
          var $wrapperEl = swiper.$wrapperEl;
          var params = swiper.params;
          var activeIndex = swiper.activeIndex;
          var activeIndexBuffer = activeIndex;
          if (params.loop) {
            activeIndexBuffer -= swiper.loopedSlides;
            swiper.loopDestroy();
            swiper.slides = $wrapperEl.children(("." + (params.slideClass)));
          }
          var baseLength = swiper.slides.length;
          if (index <= 0) {
            swiper.prependSlide(slides);
            return;
          }
          if (index >= baseLength) {
            swiper.appendSlide(slides);
            return;
          }
          var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
    
          var slidesBuffer = [];
          for (var i = baseLength - 1; i >= index; i -= 1) {
            var currentSlide = swiper.slides.eq(i);
            currentSlide.remove();
            slidesBuffer.unshift(currentSlide);
          }
    
          if (typeof slides === 'object' && 'length' in slides) {
            for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {
              if (slides[i$1]) { $wrapperEl.append(slides[i$1]); }
            }
            newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
          } else {
            $wrapperEl.append(slides);
          }
    
          for (var i$2 = 0; i$2 < slidesBuffer.length; i$2 += 1) {
            $wrapperEl.append(slidesBuffer[i$2]);
          }
    
          if (params.loop) {
            swiper.loopCreate();
          }
          if (!(params.observer && Support.observer)) {
            swiper.update();
          }
          if (params.loop) {
            swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
          } else {
            swiper.slideTo(newActiveIndex, 0, false);
          }
        }
    
        function removeSlide (slidesIndexes) {
          var swiper = this;
          var params = swiper.params;
          var $wrapperEl = swiper.$wrapperEl;
          var activeIndex = swiper.activeIndex;
    
          var activeIndexBuffer = activeIndex;
          if (params.loop) {
            activeIndexBuffer -= swiper.loopedSlides;
            swiper.loopDestroy();
            swiper.slides = $wrapperEl.children(("." + (params.slideClass)));
          }
          var newActiveIndex = activeIndexBuffer;
          var indexToRemove;
    
          if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
            for (var i = 0; i < slidesIndexes.length; i += 1) {
              indexToRemove = slidesIndexes[i];
              if (swiper.slides[indexToRemove]) { swiper.slides.eq(indexToRemove).remove(); }
              if (indexToRemove < newActiveIndex) { newActiveIndex -= 1; }
            }
            newActiveIndex = Math.max(newActiveIndex, 0);
          } else {
            indexToRemove = slidesIndexes;
            if (swiper.slides[indexToRemove]) { swiper.slides.eq(indexToRemove).remove(); }
            if (indexToRemove < newActiveIndex) { newActiveIndex -= 1; }
            newActiveIndex = Math.max(newActiveIndex, 0);
          }
    
          if (params.loop) {
            swiper.loopCreate();
          }
    
          if (!(params.observer && Support.observer)) {
            swiper.update();
          }
          if (params.loop) {
            swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
          } else {
            swiper.slideTo(newActiveIndex, 0, false);
          }
        }
    
        function removeAllSlides () {
          var swiper = this;
    
          var slidesIndexes = [];
          for (var i = 0; i < swiper.slides.length; i += 1) {
            slidesIndexes.push(i);
          }
          swiper.removeSlide(slidesIndexes);
        }
    
        var manipulation = {
          appendSlide: appendSlide,
          prependSlide: prependSlide,
          addSlide: addSlide,
          removeSlide: removeSlide,
          removeAllSlides: removeAllSlides,
        };
    
        var Device = (function Device() {
          var platform = win.navigator.platform;
          var ua = win.navigator.userAgent;
    
          var device = {
            ios: false,
            android: false,
            androidChrome: false,
            desktop: false,
            iphone: false,
            ipod: false,
            ipad: false,
            edge: false,
            ie: false,
            firefox: false,
            macos: false,
            windows: false,
            cordova: !!(win.cordova || win.phonegap),
            phonegap: !!(win.cordova || win.phonegap),
            electron: false,
          };
    
          var screenWidth = win.screen.width;
          var screenHeight = win.screen.height;
    
          var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
          var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
          var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
          var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
          var ie = ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;
          var edge = ua.indexOf('Edge/') >= 0;
          var firefox = ua.indexOf('Gecko/') >= 0 && ua.indexOf('Firefox/') >= 0;
          var windows = platform === 'Win32';
          var electron = ua.toLowerCase().indexOf('electron') >= 0;
          var macos = platform === 'MacIntel';
    
          // iPadOs 13 fix
          if (!ipad
            && macos
            && Support.touch
            && (
              (screenWidth === 1024 && screenHeight === 1366) // Pro 12.9
              || (screenWidth === 834 && screenHeight === 1194) // Pro 11
              || (screenWidth === 834 && screenHeight === 1112) // Pro 10.5
              || (screenWidth === 768 && screenHeight === 1024) // other
            )
          ) {
            ipad = ua.match(/(Version)\/([\d.]+)/);
            macos = false;
          }
    
          device.ie = ie;
          device.edge = edge;
          device.firefox = firefox;
    
          // Android
          if (android && !windows) {
            device.os = 'android';
            device.osVersion = android[2];
            device.android = true;
            device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;
          }
          if (ipad || iphone || ipod) {
            device.os = 'ios';
            device.ios = true;
          }
          // iOS
          if (iphone && !ipod) {
            device.osVersion = iphone[2].replace(/_/g, '.');
            device.iphone = true;
          }
          if (ipad) {
            device.osVersion = ipad[2].replace(/_/g, '.');
            device.ipad = true;
          }
          if (ipod) {
            device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
            device.ipod = true;
          }
          // iOS 8+ changed UA
          if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {
            if (device.osVersion.split('.')[0] === '10') {
              device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
            }
          }
    
          // Webview
          device.webView = !!((iphone || ipad || ipod) && (ua.match(/.*AppleWebKit(?!.*Safari)/i) || win.navigator.standalone))
            || (win.matchMedia && win.matchMedia('(display-mode: standalone)').matches);
          device.webview = device.webView;
          device.standalone = device.webView;
    
          // Desktop
          device.desktop = !(device.ios || device.android) || electron;
          if (device.desktop) {
            device.electron = electron;
            device.macos = macos;
            device.windows = windows;
            if (device.macos) {
              device.os = 'macos';
            }
            if (device.windows) {
              device.os = 'windows';
            }
          }
    
          // Pixel Ratio
          device.pixelRatio = win.devicePixelRatio || 1;
    
          // Export object
          return device;
        }());
    
        function onTouchStart (event) {
          var swiper = this;
          var data = swiper.touchEventsData;
          var params = swiper.params;
          var touches = swiper.touches;
    
          if (swiper.animating && params.preventInteractionOnTransition) {
            return;
          }
          var e = event;
          if (e.originalEvent) { e = e.originalEvent; }
          var $targetEl = $(e.target);
    
          if (params.touchEventsTarget === 'wrapper') {
            if (!$targetEl.closest(swiper.wrapperEl).length) { return; }
          }
          data.isTouchEvent = e.type === 'touchstart';
          if (!data.isTouchEvent && 'which' in e && e.which === 3) { return; }
          if (!data.isTouchEvent && 'button' in e && e.button > 0) { return; }
          if (data.isTouched && data.isMoved) { return; }
          if (params.noSwiping && $targetEl.closest(params.noSwipingSelector ? params.noSwipingSelector : ("." + (params.noSwipingClass)))[0]) {
            swiper.allowClick = true;
            return;
          }
          if (params.swipeHandler) {
            if (!$targetEl.closest(params.swipeHandler)[0]) { return; }
          }
    
          touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
          touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
          var startX = touches.currentX;
          var startY = touches.currentY;
    
          // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore
    
          var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
          var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
          if (
            edgeSwipeDetection
            && ((startX <= edgeSwipeThreshold)
            || (startX >= win.screen.width - edgeSwipeThreshold))
          ) {
            return;
          }
    
          Utils.extend(data, {
            isTouched: true,
            isMoved: false,
            allowTouchCallbacks: true,
            isScrolling: undefined,
            startMoving: undefined,
          });
    
          touches.startX = startX;
          touches.startY = startY;
          data.touchStartTime = Utils.now();
          swiper.allowClick = true;
          swiper.updateSize();
          swiper.swipeDirection = undefined;
          if (params.threshold > 0) { data.allowThresholdMove = false; }
          if (e.type !== 'touchstart') {
            var preventDefault = true;
            if ($targetEl.is(data.formElements)) { preventDefault = false; }
            if (
              doc.activeElement
              && $(doc.activeElement).is(data.formElements)
              && doc.activeElement !== $targetEl[0]
            ) {
              doc.activeElement.blur();
            }
    
            var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
            if (params.touchStartForcePreventDefault || shouldPreventDefault) {
              e.preventDefault();
            }
          }
          swiper.emit('touchStart', e);
        }
    
        function onTouchMove (event) {
          var swiper = this;
          var data = swiper.touchEventsData;
          var params = swiper.params;
          var touches = swiper.touches;
          var rtl = swiper.rtlTranslate;
          var e = event;
          if (e.originalEvent) { e = e.originalEvent; }
          if (!data.isTouched) {
            if (data.startMoving && data.isScrolling) {
              swiper.emit('touchMoveOpposite', e);
            }
            return;
          }
          if (data.isTouchEvent && e.type !== 'touchmove') { return; }
          var targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
          var pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
          var pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;
          if (e.preventedByNestedSwiper) {
            touches.startX = pageX;
            touches.startY = pageY;
            return;
          }
          if (!swiper.allowTouchMove) {
            // isMoved = true;
            swiper.allowClick = false;
            if (data.isTouched) {
              Utils.extend(touches, {
                startX: pageX,
                startY: pageY,
                currentX: pageX,
                currentY: pageY,
              });
              data.touchStartTime = Utils.now();
            }
            return;
          }
          if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
            if (swiper.isVertical()) {
              // Vertical
              if (
                (pageY < touches.startY && swiper.translate <= swiper.maxTranslate())
                || (pageY > touches.startY && swiper.translate >= swiper.minTranslate())
              ) {
                data.isTouched = false;
                data.isMoved = false;
                return;
              }
            } else if (
              (pageX < touches.startX && swiper.translate <= swiper.maxTranslate())
              || (pageX > touches.startX && swiper.translate >= swiper.minTranslate())
            ) {
              return;
            }
          }
          if (data.isTouchEvent && doc.activeElement) {
            if (e.target === doc.activeElement && $(e.target).is(data.formElements)) {
              data.isMoved = true;
              swiper.allowClick = false;
              return;
            }
          }
          if (data.allowTouchCallbacks) {
            swiper.emit('touchMove', e);
          }
          if (e.targetTouches && e.targetTouches.length > 1) { return; }
    
          touches.currentX = pageX;
          touches.currentY = pageY;
    
          var diffX = touches.currentX - touches.startX;
          var diffY = touches.currentY - touches.startY;
          if (swiper.params.threshold && Math.sqrt((Math.pow( diffX, 2 )) + (Math.pow( diffY, 2 ))) < swiper.params.threshold) { return; }
    
          if (typeof data.isScrolling === 'undefined') {
            var touchAngle;
            if ((swiper.isHorizontal() && touches.currentY === touches.startY) || (swiper.isVertical() && touches.currentX === touches.startX)) {
              data.isScrolling = false;
            } else {
              // eslint-disable-next-line
              if ((diffX * diffX) + (diffY * diffY) >= 25) {
                touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;
                data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : (90 - touchAngle > params.touchAngle);
              }
            }
          }
          if (data.isScrolling) {
            swiper.emit('touchMoveOpposite', e);
          }
          if (typeof data.startMoving === 'undefined') {
            if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
              data.startMoving = true;
            }
          }
          if (data.isScrolling) {
            data.isTouched = false;
            return;
          }
          if (!data.startMoving) {
            return;
          }
          swiper.allowClick = false;
          if (!params.cssMode && e.cancelable) {
            e.preventDefault();
          }
          if (params.touchMoveStopPropagation && !params.nested) {
            e.stopPropagation();
          }
    
          if (!data.isMoved) {
            if (params.loop) {
              swiper.loopFix();
            }
            data.startTranslate = swiper.getTranslate();
            swiper.setTransition(0);
            if (swiper.animating) {
              swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
            }
            data.allowMomentumBounce = false;
            // Grab Cursor
            if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
              swiper.setGrabCursor(true);
            }
            swiper.emit('sliderFirstMove', e);
          }
          swiper.emit('sliderMove', e);
          data.isMoved = true;
    
          var diff = swiper.isHorizontal() ? diffX : diffY;
          touches.diff = diff;
    
          diff *= params.touchRatio;
          if (rtl) { diff = -diff; }
    
          swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
          data.currentTranslate = diff + data.startTranslate;
    
          var disableParentSwiper = true;
          var resistanceRatio = params.resistanceRatio;
          if (params.touchReleaseOnEdges) {
            resistanceRatio = 0;
          }
          if ((diff > 0 && data.currentTranslate > swiper.minTranslate())) {
            disableParentSwiper = false;
            if (params.resistance) { data.currentTranslate = (swiper.minTranslate() - 1) + (Math.pow( (-swiper.minTranslate() + data.startTranslate + diff), resistanceRatio )); }
          } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
            disableParentSwiper = false;
            if (params.resistance) { data.currentTranslate = (swiper.maxTranslate() + 1) - (Math.pow( (swiper.maxTranslate() - data.startTranslate - diff), resistanceRatio )); }
          }
    
          if (disableParentSwiper) {
            e.preventedByNestedSwiper = true;
          }
    
          // Directions locks
          if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
            data.currentTranslate = data.startTranslate;
          }
          if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
            data.currentTranslate = data.startTranslate;
          }
    
    
          // Threshold
          if (params.threshold > 0) {
            if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
              if (!data.allowThresholdMove) {
                data.allowThresholdMove = true;
                touches.startX = touches.currentX;
                touches.startY = touches.currentY;
                data.currentTranslate = data.startTranslate;
                touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
                return;
              }
            } else {
              data.currentTranslate = data.startTranslate;
              return;
            }
          }
    
          if (!params.followFinger || params.cssMode) { return; }
    
          // Update active index in free mode
          if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
          }
          if (params.freeMode) {
            // Velocity
            if (data.velocities.length === 0) {
              data.velocities.push({
                position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
                time: data.touchStartTime,
              });
            }
            data.velocities.push({
              position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
              time: Utils.now(),
            });
          }
          // Update progress
          swiper.updateProgress(data.currentTranslate);
          // Update translate
          swiper.setTranslate(data.currentTranslate);
        }
    
        function onTouchEnd (event) {
          var swiper = this;
          var data = swiper.touchEventsData;
    
          var params = swiper.params;
          var touches = swiper.touches;
          var rtl = swiper.rtlTranslate;
          var $wrapperEl = swiper.$wrapperEl;
          var slidesGrid = swiper.slidesGrid;
          var snapGrid = swiper.snapGrid;
          var e = event;
          if (e.originalEvent) { e = e.originalEvent; }
          if (data.allowTouchCallbacks) {
            swiper.emit('touchEnd', e);
          }
          data.allowTouchCallbacks = false;
          if (!data.isTouched) {
            if (data.isMoved && params.grabCursor) {
              swiper.setGrabCursor(false);
            }
            data.isMoved = false;
            data.startMoving = false;
            return;
          }
          // Return Grab Cursor
          if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
            swiper.setGrabCursor(false);
          }
    
          // Time diff
          var touchEndTime = Utils.now();
          var timeDiff = touchEndTime - data.touchStartTime;
    
          // Tap, doubleTap, Click
          if (swiper.allowClick) {
            swiper.updateClickedSlide(e);
            swiper.emit('tap click', e);
            if (timeDiff < 300 && (touchEndTime - data.lastClickTime) < 300) {
              swiper.emit('doubleTap doubleClick', e);
            }
          }
    
          data.lastClickTime = Utils.now();
          Utils.nextTick(function () {
            if (!swiper.destroyed) { swiper.allowClick = true; }
          });
    
          if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
            data.isTouched = false;
            data.isMoved = false;
            data.startMoving = false;
            return;
          }
          data.isTouched = false;
          data.isMoved = false;
          data.startMoving = false;
    
          var currentPos;
          if (params.followFinger) {
            currentPos = rtl ? swiper.translate : -swiper.translate;
          } else {
            currentPos = -data.currentTranslate;
          }
    
          if (params.cssMode) {
            return;
          }
    
          if (params.freeMode) {
            if (currentPos < -swiper.minTranslate()) {
              swiper.slideTo(swiper.activeIndex);
              return;
            }
            if (currentPos > -swiper.maxTranslate()) {
              if (swiper.slides.length < snapGrid.length) {
                swiper.slideTo(snapGrid.length - 1);
              } else {
                swiper.slideTo(swiper.slides.length - 1);
              }
              return;
            }
    
            if (params.freeModeMomentum) {
              if (data.velocities.length > 1) {
                var lastMoveEvent = data.velocities.pop();
                var velocityEvent = data.velocities.pop();
    
                var distance = lastMoveEvent.position - velocityEvent.position;
                var time = lastMoveEvent.time - velocityEvent.time;
                swiper.velocity = distance / time;
                swiper.velocity /= 2;
                if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
                  swiper.velocity = 0;
                }
                // this implies that the user stopped moving a finger then released.
                // There would be no events with distance zero, so the last event is stale.
                if (time > 150 || (Utils.now() - lastMoveEvent.time) > 300) {
                  swiper.velocity = 0;
                }
              } else {
                swiper.velocity = 0;
              }
              swiper.velocity *= params.freeModeMomentumVelocityRatio;
    
              data.velocities.length = 0;
              var momentumDuration = 1000 * params.freeModeMomentumRatio;
              var momentumDistance = swiper.velocity * momentumDuration;
    
              var newPosition = swiper.translate + momentumDistance;
              if (rtl) { newPosition = -newPosition; }
    
              var doBounce = false;
              var afterBouncePosition;
              var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
              var needsLoopFix;
              if (newPosition < swiper.maxTranslate()) {
                if (params.freeModeMomentumBounce) {
                  if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                    newPosition = swiper.maxTranslate() - bounceAmount;
                  }
                  afterBouncePosition = swiper.maxTranslate();
                  doBounce = true;
                  data.allowMomentumBounce = true;
                } else {
                  newPosition = swiper.maxTranslate();
                }
                if (params.loop && params.centeredSlides) { needsLoopFix = true; }
              } else if (newPosition > swiper.minTranslate()) {
                if (params.freeModeMomentumBounce) {
                  if (newPosition - swiper.minTranslate() > bounceAmount) {
                    newPosition = swiper.minTranslate() + bounceAmount;
                  }
                  afterBouncePosition = swiper.minTranslate();
                  doBounce = true;
                  data.allowMomentumBounce = true;
                } else {
                  newPosition = swiper.minTranslate();
                }
                if (params.loop && params.centeredSlides) { needsLoopFix = true; }
              } else if (params.freeModeSticky) {
                var nextSlide;
                for (var j = 0; j < snapGrid.length; j += 1) {
                  if (snapGrid[j] > -newPosition) {
                    nextSlide = j;
                    break;
                  }
                }
    
                if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
                  newPosition = snapGrid[nextSlide];
                } else {
                  newPosition = snapGrid[nextSlide - 1];
                }
                newPosition = -newPosition;
              }
              if (needsLoopFix) {
                swiper.once('transitionEnd', function () {
                  swiper.loopFix();
                });
              }
              // Fix duration
              if (swiper.velocity !== 0) {
                if (rtl) {
                  momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
                } else {
                  momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
                }
                if (params.freeModeSticky) {
                  // If freeModeSticky is active and the user ends a swipe with a slow-velocity
                  // event, then durations can be 20+ seconds to slide one (or zero!) slides.
                  // It's easy to see this when simulating touch with mouse events. To fix this,
                  // limit single-slide swipes to the default slide duration. This also has the
                  // nice side effect of matching slide speed if the user stopped moving before
                  // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
                  // For faster swipes, also apply limits (albeit higher ones).
                  var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
                  var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
                  if (moveDistance < currentSlideSize) {
                    momentumDuration = params.speed;
                  } else if (moveDistance < 2 * currentSlideSize) {
                    momentumDuration = params.speed * 1.5;
                  } else {
                    momentumDuration = params.speed * 2.5;
                  }
                }
              } else if (params.freeModeSticky) {
                swiper.slideToClosest();
                return;
              }
    
              if (params.freeModeMomentumBounce && doBounce) {
                swiper.updateProgress(afterBouncePosition);
                swiper.setTransition(momentumDuration);
                swiper.setTranslate(newPosition);
                swiper.transitionStart(true, swiper.swipeDirection);
                swiper.animating = true;
                $wrapperEl.transitionEnd(function () {
                  if (!swiper || swiper.destroyed || !data.allowMomentumBounce) { return; }
                  swiper.emit('momentumBounce');
                  swiper.setTransition(params.speed);
                  setTimeout(function () {
                    swiper.setTranslate(afterBouncePosition);
                    $wrapperEl.transitionEnd(function () {
                      if (!swiper || swiper.destroyed) { return; }
                      swiper.transitionEnd();
                    });
                  }, 0);
                });
              } else if (swiper.velocity) {
                swiper.updateProgress(newPosition);
                swiper.setTransition(momentumDuration);
                swiper.setTranslate(newPosition);
                swiper.transitionStart(true, swiper.swipeDirection);
                if (!swiper.animating) {
                  swiper.animating = true;
                  $wrapperEl.transitionEnd(function () {
                    if (!swiper || swiper.destroyed) { return; }
                    swiper.transitionEnd();
                  });
                }
              } else {
                swiper.updateProgress(newPosition);
              }
    
              swiper.updateActiveIndex();
              swiper.updateSlidesClasses();
            } else if (params.freeModeSticky) {
              swiper.slideToClosest();
              return;
            }
    
            if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
              swiper.updateProgress();
              swiper.updateActiveIndex();
              swiper.updateSlidesClasses();
            }
            return;
          }
    
          // Find current slide
          var stopIndex = 0;
          var groupSize = swiper.slidesSizesGrid[0];
          for (var i = 0; i < slidesGrid.length; i += (i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup)) {
            var increment$1 = (i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup);
            if (typeof slidesGrid[i + increment$1] !== 'undefined') {
              if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment$1]) {
                stopIndex = i;
                groupSize = slidesGrid[i + increment$1] - slidesGrid[i];
              }
            } else if (currentPos >= slidesGrid[i]) {
              stopIndex = i;
              groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
            }
          }
    
          // Find current slide size
          var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
          var increment = (stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup);
    
          if (timeDiff > params.longSwipesMs) {
            // Long touches
            if (!params.longSwipes) {
              swiper.slideTo(swiper.activeIndex);
              return;
            }
            if (swiper.swipeDirection === 'next') {
              if (ratio >= params.longSwipesRatio) { swiper.slideTo(stopIndex + increment); }
              else { swiper.slideTo(stopIndex); }
            }
            if (swiper.swipeDirection === 'prev') {
              if (ratio > (1 - params.longSwipesRatio)) { swiper.slideTo(stopIndex + increment); }
              else { swiper.slideTo(stopIndex); }
            }
          } else {
            // Short swipes
            if (!params.shortSwipes) {
              swiper.slideTo(swiper.activeIndex);
              return;
            }
            var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
            if (!isNavButtonTarget) {
              if (swiper.swipeDirection === 'next') {
                swiper.slideTo(stopIndex + increment);
              }
              if (swiper.swipeDirection === 'prev') {
                swiper.slideTo(stopIndex);
              }
            } else if (e.target === swiper.navigation.nextEl) {
              swiper.slideTo(stopIndex + increment);
            } else {
              swiper.slideTo(stopIndex);
            }
          }
        }
    
        function onResize () {
          var swiper = this;
    
          var params = swiper.params;
          var el = swiper.el;
    
          if (el && el.offsetWidth === 0) { return; }
    
          // Breakpoints
          if (params.breakpoints) {
            swiper.setBreakpoint();
          }
    
          // Save locks
          var allowSlideNext = swiper.allowSlideNext;
          var allowSlidePrev = swiper.allowSlidePrev;
          var snapGrid = swiper.snapGrid;
    
          // Disable locks on resize
          swiper.allowSlideNext = true;
          swiper.allowSlidePrev = true;
    
          swiper.updateSize();
          swiper.updateSlides();
    
          swiper.updateSlidesClasses();
          if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
            swiper.slideTo(swiper.slides.length - 1, 0, false, true);
          } else {
            swiper.slideTo(swiper.activeIndex, 0, false, true);
          }
    
          if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
            swiper.autoplay.run();
          }
          // Return locks after resize
          swiper.allowSlidePrev = allowSlidePrev;
          swiper.allowSlideNext = allowSlideNext;
    
          if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
            swiper.checkOverflow();
          }
        }
    
        function onClick (e) {
          var swiper = this;
          if (!swiper.allowClick) {
            if (swiper.params.preventClicks) { e.preventDefault(); }
            if (swiper.params.preventClicksPropagation && swiper.animating) {
              e.stopPropagation();
              e.stopImmediatePropagation();
            }
          }
        }
    
        function onScroll () {
          var swiper = this;
          var wrapperEl = swiper.wrapperEl;
          var rtlTranslate = swiper.rtlTranslate;
          swiper.previousTranslate = swiper.translate;
          if (swiper.isHorizontal()) {
            if (rtlTranslate) {
              swiper.translate = ((wrapperEl.scrollWidth - wrapperEl.offsetWidth) - wrapperEl.scrollLeft);
            } else {
              swiper.translate = -wrapperEl.scrollLeft;
            }
          } else {
            swiper.translate = -wrapperEl.scrollTop;
          }
          // eslint-disable-next-line
          if (swiper.translate === -0) { swiper.translate = 0; }
    
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
    
          var newProgress;
          var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
          if (translatesDiff === 0) {
            newProgress = 0;
          } else {
            newProgress = (swiper.translate - swiper.minTranslate()) / (translatesDiff);
          }
          if (newProgress !== swiper.progress) {
            swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
          }
    
          swiper.emit('setTranslate', swiper.translate, false);
        }
    
        var dummyEventAttached = false;
        function dummyEventListener() {}
    
        function attachEvents() {
          var swiper = this;
          var params = swiper.params;
          var touchEvents = swiper.touchEvents;
          var el = swiper.el;
          var wrapperEl = swiper.wrapperEl;
    
          swiper.onTouchStart = onTouchStart.bind(swiper);
          swiper.onTouchMove = onTouchMove.bind(swiper);
          swiper.onTouchEnd = onTouchEnd.bind(swiper);
          if (params.cssMode) {
            swiper.onScroll = onScroll.bind(swiper);
          }
    
          swiper.onClick = onClick.bind(swiper);
    
          var capture = !!params.nested;
    
          // Touch Events
          if (!Support.touch && Support.pointerEvents) {
            el.addEventListener(touchEvents.start, swiper.onTouchStart, false);
            doc.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
            doc.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
          } else {
            if (Support.touch) {
              var passiveListener = touchEvents.start === 'touchstart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
              el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
              el.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? { passive: false, capture: capture } : capture);
              el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
              if (touchEvents.cancel) {
                el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
              }
              if (!dummyEventAttached) {
                doc.addEventListener('touchstart', dummyEventListener);
                dummyEventAttached = true;
              }
            }
            if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
              el.addEventListener('mousedown', swiper.onTouchStart, false);
              doc.addEventListener('mousemove', swiper.onTouchMove, capture);
              doc.addEventListener('mouseup', swiper.onTouchEnd, false);
            }
          }
          // Prevent Links Clicks
          if (params.preventClicks || params.preventClicksPropagation) {
            el.addEventListener('click', swiper.onClick, true);
          }
          if (params.cssMode) {
            wrapperEl.addEventListener('scroll', swiper.onScroll);
          }
    
          // Resize handler
          if (params.updateOnWindowResize) {
            swiper.on((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize, true);
          } else {
            swiper.on('observerUpdate', onResize, true);
          }
        }
    
        function detachEvents() {
          var swiper = this;
    
          var params = swiper.params;
          var touchEvents = swiper.touchEvents;
          var el = swiper.el;
          var wrapperEl = swiper.wrapperEl;
    
          var capture = !!params.nested;
    
          // Touch Events
          if (!Support.touch && Support.pointerEvents) {
            el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
            doc.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
            doc.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
          } else {
            if (Support.touch) {
              var passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
              el.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
              el.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
              el.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
              if (touchEvents.cancel) {
                el.removeEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
              }
            }
            if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
              el.removeEventListener('mousedown', swiper.onTouchStart, false);
              doc.removeEventListener('mousemove', swiper.onTouchMove, capture);
              doc.removeEventListener('mouseup', swiper.onTouchEnd, false);
            }
          }
          // Prevent Links Clicks
          if (params.preventClicks || params.preventClicksPropagation) {
            el.removeEventListener('click', swiper.onClick, true);
          }
    
          if (params.cssMode) {
            wrapperEl.removeEventListener('scroll', swiper.onScroll);
          }
    
          // Resize handler
          swiper.off((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize);
        }
    
        var events = {
          attachEvents: attachEvents,
          detachEvents: detachEvents,
        };
    
        function setBreakpoint () {
          var swiper = this;
          var activeIndex = swiper.activeIndex;
          var initialized = swiper.initialized;
          var loopedSlides = swiper.loopedSlides; if ( loopedSlides === void 0 ) loopedSlides = 0;
          var params = swiper.params;
          var $el = swiper.$el;
          var breakpoints = params.breakpoints;
          if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) { return; }
    
          // Get breakpoint for window width and update parameters
          var breakpoint = swiper.getBreakpoint(breakpoints);
    
          if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
            var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
            if (breakpointOnlyParams) {
              ['slidesPerView', 'spaceBetween', 'slidesPerGroup', 'slidesPerGroupSkip', 'slidesPerColumn'].forEach(function (param) {
                var paramValue = breakpointOnlyParams[param];
                if (typeof paramValue === 'undefined') { return; }
                if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
                  breakpointOnlyParams[param] = 'auto';
                } else if (param === 'slidesPerView') {
                  breakpointOnlyParams[param] = parseFloat(paramValue);
                } else {
                  breakpointOnlyParams[param] = parseInt(paramValue, 10);
                }
              });
            }
    
            var breakpointParams = breakpointOnlyParams || swiper.originalParams;
            var wasMultiRow = params.slidesPerColumn > 1;
            var isMultiRow = breakpointParams.slidesPerColumn > 1;
            if (wasMultiRow && !isMultiRow) {
              $el.removeClass(((params.containerModifierClass) + "multirow " + (params.containerModifierClass) + "multirow-column"));
            } else if (!wasMultiRow && isMultiRow) {
              $el.addClass(((params.containerModifierClass) + "multirow"));
              if (breakpointParams.slidesPerColumnFill === 'column') {
                $el.addClass(((params.containerModifierClass) + "multirow-column"));
              }
            }
    
            var directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
            var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
    
            if (directionChanged && initialized) {
              swiper.changeDirection();
            }
    
            Utils.extend(swiper.params, breakpointParams);
    
            Utils.extend(swiper, {
              allowTouchMove: swiper.params.allowTouchMove,
              allowSlideNext: swiper.params.allowSlideNext,
              allowSlidePrev: swiper.params.allowSlidePrev,
            });
    
            swiper.currentBreakpoint = breakpoint;
    
            if (needsReLoop && initialized) {
              swiper.loopDestroy();
              swiper.loopCreate();
              swiper.updateSlides();
              swiper.slideTo((activeIndex - loopedSlides) + swiper.loopedSlides, 0, false);
            }
    
            swiper.emit('breakpoint', breakpointParams);
          }
        }
    
        function getBreakpoint (breakpoints) {
          // Get breakpoint for window width
          if (!breakpoints) { return undefined; }
          var breakpoint = false;
    
          var points = Object.keys(breakpoints).map(function (point) {
            if (typeof point === 'string' && point.indexOf('@') === 0) {
              var minRatio = parseFloat(point.substr(1));
              var value = win.innerHeight * minRatio;
              return { value: value, point: point };
            }
            return { value: point, point: point };
          });
    
          points.sort(function (a, b) { return parseInt(a.value, 10) - parseInt(b.value, 10); });
          for (var i = 0; i < points.length; i += 1) {
            var ref = points[i];
            var point = ref.point;
            var value = ref.value;
            if (value <= win.innerWidth) {
              breakpoint = point;
            }
          }
          return breakpoint || 'max';
        }
    
        var breakpoints = { setBreakpoint: setBreakpoint, getBreakpoint: getBreakpoint };
    
        function addClasses () {
          var swiper = this;
          var classNames = swiper.classNames;
          var params = swiper.params;
          var rtl = swiper.rtl;
          var $el = swiper.$el;
          var suffixes = [];
    
          suffixes.push('initialized');
          suffixes.push(params.direction);
    
          if (params.freeMode) {
            suffixes.push('free-mode');
          }
          if (params.autoHeight) {
            suffixes.push('autoheight');
          }
          if (rtl) {
            suffixes.push('rtl');
          }
          if (params.slidesPerColumn > 1) {
            suffixes.push('multirow');
            if (params.slidesPerColumnFill === 'column') {
              suffixes.push('multirow-column');
            }
          }
          if (Device.android) {
            suffixes.push('android');
          }
          if (Device.ios) {
            suffixes.push('ios');
          }
    
          if (params.cssMode) {
            suffixes.push('css-mode');
          }
    
          suffixes.forEach(function (suffix) {
            classNames.push(params.containerModifierClass + suffix);
          });
    
          $el.addClass(classNames.join(' '));
        }
    
        function removeClasses () {
          var swiper = this;
          var $el = swiper.$el;
          var classNames = swiper.classNames;
    
          $el.removeClass(classNames.join(' '));
        }
    
        var classes = { addClasses: addClasses, removeClasses: removeClasses };
    
        function loadImage (imageEl, src, srcset, sizes, checkForComplete, callback) {
          var image;
          function onReady() {
            if (callback) { callback(); }
          }
          var isPicture = $(imageEl).parent('picture')[0];
    
          if (!isPicture && (!imageEl.complete || !checkForComplete)) {
            if (src) {
              image = new win.Image();
              image.onload = onReady;
              image.onerror = onReady;
              if (sizes) {
                image.sizes = sizes;
              }
              if (srcset) {
                image.srcset = srcset;
              }
              if (src) {
                image.src = src;
              }
            } else {
              onReady();
            }
          } else {
            // image already loaded...
            onReady();
          }
        }
    
        function preloadImages () {
          var swiper = this;
          swiper.imagesToLoad = swiper.$el.find('img');
          function onReady() {
            if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) { return; }
            if (swiper.imagesLoaded !== undefined) { swiper.imagesLoaded += 1; }
            if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
              if (swiper.params.updateOnImagesReady) { swiper.update(); }
              swiper.emit('imagesReady');
            }
          }
          for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
            var imageEl = swiper.imagesToLoad[i];
            swiper.loadImage(
              imageEl,
              imageEl.currentSrc || imageEl.getAttribute('src'),
              imageEl.srcset || imageEl.getAttribute('srcset'),
              imageEl.sizes || imageEl.getAttribute('sizes'),
              true,
              onReady
            );
          }
        }
    
        var images = {
          loadImage: loadImage,
          preloadImages: preloadImages,
        };
    
        function checkOverflow() {
          var swiper = this;
          var params = swiper.params;
          var wasLocked = swiper.isLocked;
          var lastSlidePosition = swiper.slides.length > 0 && (params.slidesOffsetBefore + (params.spaceBetween * (swiper.slides.length - 1)) + ((swiper.slides[0]).offsetWidth) * swiper.slides.length);
    
          if (params.slidesOffsetBefore && params.slidesOffsetAfter && lastSlidePosition) {
            swiper.isLocked = lastSlidePosition <= swiper.size;
          } else {
            swiper.isLocked = swiper.snapGrid.length === 1;
          }
    
          swiper.allowSlideNext = !swiper.isLocked;
          swiper.allowSlidePrev = !swiper.isLocked;
    
          // events
          if (wasLocked !== swiper.isLocked) { swiper.emit(swiper.isLocked ? 'lock' : 'unlock'); }
    
          if (wasLocked && wasLocked !== swiper.isLocked) {
            swiper.isEnd = false;
            if (swiper.navigation) { swiper.navigation.update(); }
          }
        }
    
        var checkOverflow$1 = { checkOverflow: checkOverflow };
    
        var defaults = {
          init: true,
          direction: 'horizontal',
          touchEventsTarget: 'container',
          initialSlide: 0,
          speed: 300,
          cssMode: false,
          updateOnWindowResize: true,
          //
          preventInteractionOnTransition: false,
    
          // To support iOS's swipe-to-go-back gesture (when being used in-app).
          edgeSwipeDetection: false,
          edgeSwipeThreshold: 20,
    
          // Free mode
          freeMode: false,
          freeModeMomentum: true,
          freeModeMomentumRatio: 1,
          freeModeMomentumBounce: true,
          freeModeMomentumBounceRatio: 1,
          freeModeMomentumVelocityRatio: 1,
          freeModeSticky: false,
          freeModeMinimumVelocity: 0.02,
    
          // Autoheight
          autoHeight: false,
    
          // Set wrapper width
          setWrapperSize: false,
    
          // Virtual Translate
          virtualTranslate: false,
    
          // Effects
          effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
    
          // Breakpoints
          breakpoints: undefined,
    
          // Slides grid
          spaceBetween: 0,
          slidesPerView: 1,
          slidesPerColumn: 1,
          slidesPerColumnFill: 'column',
          slidesPerGroup: 1,
          slidesPerGroupSkip: 0,
          centeredSlides: false,
          centeredSlidesBounds: false,
          slidesOffsetBefore: 0, // in px
          slidesOffsetAfter: 0, // in px
          normalizeSlideIndex: true,
          centerInsufficientSlides: false,
    
          // Disable swiper and hide navigation when container not overflow
          watchOverflow: false,
    
          // Round length
          roundLengths: false,
    
          // Touches
          touchRatio: 1,
          touchAngle: 45,
          simulateTouch: true,
          shortSwipes: true,
          longSwipes: true,
          longSwipesRatio: 0.5,
          longSwipesMs: 300,
          followFinger: true,
          allowTouchMove: true,
          threshold: 0,
          touchMoveStopPropagation: false,
          touchStartPreventDefault: true,
          touchStartForcePreventDefault: false,
          touchReleaseOnEdges: false,
    
          // Unique Navigation Elements
          uniqueNavElements: true,
    
          // Resistance
          resistance: true,
          resistanceRatio: 0.85,
    
          // Progress
          watchSlidesProgress: false,
          watchSlidesVisibility: false,
    
          // Cursor
          grabCursor: false,
    
          // Clicks
          preventClicks: true,
          preventClicksPropagation: true,
          slideToClickedSlide: false,
    
          // Images
          preloadImages: true,
          updateOnImagesReady: true,
    
          // loop
          loop: false,
          loopAdditionalSlides: 0,
          loopedSlides: null,
          loopFillGroupWithBlank: false,
    
          // Swiping/no swiping
          allowSlidePrev: true,
          allowSlideNext: true,
          swipeHandler: null, // '.swipe-handler',
          noSwiping: true,
          noSwipingClass: 'swiper-no-swiping',
          noSwipingSelector: null,
    
          // Passive Listeners
          passiveListeners: true,
    
          // NS
          containerModifierClass: 'swiper-container-', // NEW
          slideClass: 'swiper-slide',
          slideBlankClass: 'swiper-slide-invisible-blank',
          slideActiveClass: 'swiper-slide-active',
          slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
          slideVisibleClass: 'swiper-slide-visible',
          slideDuplicateClass: 'swiper-slide-duplicate',
          slideNextClass: 'swiper-slide-next',
          slideDuplicateNextClass: 'swiper-slide-duplicate-next',
          slidePrevClass: 'swiper-slide-prev',
          slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
          wrapperClass: 'swiper-wrapper',
    
          // Callbacks
          runCallbacksOnInit: true,
        };
    
        /* eslint no-param-reassign: "off" */
    
        var prototypes = {
          update: update,
          translate: translate,
          transition: transition$1,
          slide: slide,
          loop: loop,
          grabCursor: grabCursor,
          manipulation: manipulation,
          events: events,
          breakpoints: breakpoints,
          checkOverflow: checkOverflow$1,
          classes: classes,
          images: images,
        };
    
        var extendedDefaults = {};
    
        var Swiper = /*@__PURE__*/(function (SwiperClass) {
          function Swiper() {
            var assign;
    
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];
            var el;
            var params;
            if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {
              params = args[0];
            } else {
              (assign = args, el = assign[0], params = assign[1]);
            }
            if (!params) { params = {}; }
    
            params = Utils.extend({}, params);
            if (el && !params.el) { params.el = el; }
    
            SwiperClass.call(this, params);
    
            Object.keys(prototypes).forEach(function (prototypeGroup) {
              Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {
                if (!Swiper.prototype[protoMethod]) {
                  Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
                }
              });
            });
    
            // Swiper Instance
            var swiper = this;
            if (typeof swiper.modules === 'undefined') {
              swiper.modules = {};
            }
            Object.keys(swiper.modules).forEach(function (moduleName) {
              var module = swiper.modules[moduleName];
              if (module.params) {
                var moduleParamName = Object.keys(module.params)[0];
                var moduleParams = module.params[moduleParamName];
                if (typeof moduleParams !== 'object' || moduleParams === null) { return; }
                if (!(moduleParamName in params && 'enabled' in moduleParams)) { return; }
                if (params[moduleParamName] === true) {
                  params[moduleParamName] = { enabled: true };
                }
                if (
                  typeof params[moduleParamName] === 'object'
                  && !('enabled' in params[moduleParamName])
                ) {
                  params[moduleParamName].enabled = true;
                }
                if (!params[moduleParamName]) { params[moduleParamName] = { enabled: false }; }
              }
            });
    
            // Extend defaults with modules params
            var swiperParams = Utils.extend({}, defaults);
            swiper.useModulesParams(swiperParams);
    
            // Extend defaults with passed params
            swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);
            swiper.originalParams = Utils.extend({}, swiper.params);
            swiper.passedParams = Utils.extend({}, params);
    
            // Save Dom lib
            swiper.$ = $;
    
            // Find el
            var $el = $(swiper.params.el);
            el = $el[0];
    
            if (!el) {
              return undefined;
            }
    
            if ($el.length > 1) {
              var swipers = [];
              $el.each(function (index, containerEl) {
                var newParams = Utils.extend({}, params, { el: containerEl });
                swipers.push(new Swiper(newParams));
              });
              return swipers;
            }
    
            el.swiper = swiper;
            $el.data('swiper', swiper);
    
            // Find Wrapper
            var $wrapperEl;
            if (el && el.shadowRoot && el.shadowRoot.querySelector) {
              $wrapperEl = $(el.shadowRoot.querySelector(("." + (swiper.params.wrapperClass))));
              // Children needs to return slot items
              $wrapperEl.children = function (options) { return $el.children(options); };
            } else {
              $wrapperEl = $el.children(("." + (swiper.params.wrapperClass)));
            }
            // Extend Swiper
            Utils.extend(swiper, {
              $el: $el,
              el: el,
              $wrapperEl: $wrapperEl,
              wrapperEl: $wrapperEl[0],
    
              // Classes
              classNames: [],
    
              // Slides
              slides: $(),
              slidesGrid: [],
              snapGrid: [],
              slidesSizesGrid: [],
    
              // isDirection
              isHorizontal: function isHorizontal() {
                return swiper.params.direction === 'horizontal';
              },
              isVertical: function isVertical() {
                return swiper.params.direction === 'vertical';
              },
              // RTL
              rtl: (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
              rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
              wrongRTL: $wrapperEl.css('display') === '-webkit-box',
    
              // Indexes
              activeIndex: 0,
              realIndex: 0,
    
              //
              isBeginning: true,
              isEnd: false,
    
              // Props
              translate: 0,
              previousTranslate: 0,
              progress: 0,
              velocity: 0,
              animating: false,
    
              // Locks
              allowSlideNext: swiper.params.allowSlideNext,
              allowSlidePrev: swiper.params.allowSlidePrev,
    
              // Touch Events
              touchEvents: (function touchEvents() {
                var touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
                var desktop = ['mousedown', 'mousemove', 'mouseup'];
                if (Support.pointerEvents) {
                  desktop = ['pointerdown', 'pointermove', 'pointerup'];
                }
                swiper.touchEventsTouch = {
                  start: touch[0],
                  move: touch[1],
                  end: touch[2],
                  cancel: touch[3],
                };
                swiper.touchEventsDesktop = {
                  start: desktop[0],
                  move: desktop[1],
                  end: desktop[2],
                };
                return Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
              }()),
              touchEventsData: {
                isTouched: undefined,
                isMoved: undefined,
                allowTouchCallbacks: undefined,
                touchStartTime: undefined,
                isScrolling: undefined,
                currentTranslate: undefined,
                startTranslate: undefined,
                allowThresholdMove: undefined,
                // Form elements to match
                formElements: 'input, select, option, textarea, button, video, label',
                // Last click time
                lastClickTime: Utils.now(),
                clickTimeout: undefined,
                // Velocities
                velocities: [],
                allowMomentumBounce: undefined,
                isTouchEvent: undefined,
                startMoving: undefined,
              },
    
              // Clicks
              allowClick: true,
    
              // Touches
              allowTouchMove: swiper.params.allowTouchMove,
    
              touches: {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0,
              },
    
              // Images
              imagesToLoad: [],
              imagesLoaded: 0,
    
            });
    
            // Install Modules
            swiper.useModules();
    
            // Init
            if (swiper.params.init) {
              swiper.init();
            }
    
            // Return app instance
            return swiper;
          }
    
          if ( SwiperClass ) Swiper.__proto__ = SwiperClass;
          Swiper.prototype = Object.create( SwiperClass && SwiperClass.prototype );
          Swiper.prototype.constructor = Swiper;
    
          var staticAccessors = { extendedDefaults: { configurable: true },defaults: { configurable: true },Class: { configurable: true },$: { configurable: true } };
    
          Swiper.prototype.slidesPerViewDynamic = function slidesPerViewDynamic () {
            var swiper = this;
            var params = swiper.params;
            var slides = swiper.slides;
            var slidesGrid = swiper.slidesGrid;
            var swiperSize = swiper.size;
            var activeIndex = swiper.activeIndex;
            var spv = 1;
            if (params.centeredSlides) {
              var slideSize = slides[activeIndex].swiperSlideSize;
              var breakLoop;
              for (var i = activeIndex + 1; i < slides.length; i += 1) {
                if (slides[i] && !breakLoop) {
                  slideSize += slides[i].swiperSlideSize;
                  spv += 1;
                  if (slideSize > swiperSize) { breakLoop = true; }
                }
              }
              for (var i$1 = activeIndex - 1; i$1 >= 0; i$1 -= 1) {
                if (slides[i$1] && !breakLoop) {
                  slideSize += slides[i$1].swiperSlideSize;
                  spv += 1;
                  if (slideSize > swiperSize) { breakLoop = true; }
                }
              }
            } else {
              for (var i$2 = activeIndex + 1; i$2 < slides.length; i$2 += 1) {
                if (slidesGrid[i$2] - slidesGrid[activeIndex] < swiperSize) {
                  spv += 1;
                }
              }
            }
            return spv;
          };
    
          Swiper.prototype.update = function update () {
            var swiper = this;
            if (!swiper || swiper.destroyed) { return; }
            var snapGrid = swiper.snapGrid;
            var params = swiper.params;
            // Breakpoints
            if (params.breakpoints) {
              swiper.setBreakpoint();
            }
            swiper.updateSize();
            swiper.updateSlides();
            swiper.updateProgress();
            swiper.updateSlidesClasses();
    
            function setTranslate() {
              var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
              var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
              swiper.setTranslate(newTranslate);
              swiper.updateActiveIndex();
              swiper.updateSlidesClasses();
            }
            var translated;
            if (swiper.params.freeMode) {
              setTranslate();
              if (swiper.params.autoHeight) {
                swiper.updateAutoHeight();
              }
            } else {
              if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
                translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
              } else {
                translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
              }
              if (!translated) {
                setTranslate();
              }
            }
            if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
              swiper.checkOverflow();
            }
            swiper.emit('update');
          };
    
          Swiper.prototype.changeDirection = function changeDirection (newDirection, needUpdate) {
            if ( needUpdate === void 0 ) needUpdate = true;
    
            var swiper = this;
            var currentDirection = swiper.params.direction;
            if (!newDirection) {
              // eslint-disable-next-line
              newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
            }
            if ((newDirection === currentDirection) || (newDirection !== 'horizontal' && newDirection !== 'vertical')) {
              return swiper;
            }
    
            swiper.$el
              .removeClass(("" + (swiper.params.containerModifierClass) + currentDirection))
              .addClass(("" + (swiper.params.containerModifierClass) + newDirection));
    
            swiper.params.direction = newDirection;
    
            swiper.slides.each(function (slideIndex, slideEl) {
              if (newDirection === 'vertical') {
                slideEl.style.width = '';
              } else {
                slideEl.style.height = '';
              }
            });
    
            swiper.emit('changeDirection');
            if (needUpdate) { swiper.update(); }
    
            return swiper;
          };
    
          Swiper.prototype.init = function init () {
            var swiper = this;
            if (swiper.initialized) { return; }
    
            swiper.emit('beforeInit');
    
            // Set breakpoint
            if (swiper.params.breakpoints) {
              swiper.setBreakpoint();
            }
    
            // Add Classes
            swiper.addClasses();
    
            // Create loop
            if (swiper.params.loop) {
              swiper.loopCreate();
            }
    
            // Update size
            swiper.updateSize();
    
            // Update slides
            swiper.updateSlides();
    
            if (swiper.params.watchOverflow) {
              swiper.checkOverflow();
            }
    
            // Set Grab Cursor
            if (swiper.params.grabCursor) {
              swiper.setGrabCursor();
            }
    
            if (swiper.params.preloadImages) {
              swiper.preloadImages();
            }
    
            // Slide To Initial Slide
            if (swiper.params.loop) {
              swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
            } else {
              swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
            }
    
            // Attach events
            swiper.attachEvents();
    
            // Init Flag
            swiper.initialized = true;
    
            // Emit
            swiper.emit('init');
          };
    
          Swiper.prototype.destroy = function destroy (deleteInstance, cleanStyles) {
            if ( deleteInstance === void 0 ) deleteInstance = true;
            if ( cleanStyles === void 0 ) cleanStyles = true;
    
            var swiper = this;
            var params = swiper.params;
            var $el = swiper.$el;
            var $wrapperEl = swiper.$wrapperEl;
            var slides = swiper.slides;
    
            if (typeof swiper.params === 'undefined' || swiper.destroyed) {
              return null;
            }
    
            swiper.emit('beforeDestroy');
    
            // Init Flag
            swiper.initialized = false;
    
            // Detach events
            swiper.detachEvents();
    
            // Destroy loop
            if (params.loop) {
              swiper.loopDestroy();
            }
    
            // Cleanup styles
            if (cleanStyles) {
              swiper.removeClasses();
              $el.removeAttr('style');
              $wrapperEl.removeAttr('style');
              if (slides && slides.length) {
                slides
                  .removeClass([
                    params.slideVisibleClass,
                    params.slideActiveClass,
                    params.slideNextClass,
                    params.slidePrevClass ].join(' '))
                  .removeAttr('style')
                  .removeAttr('data-swiper-slide-index');
              }
            }
    
            swiper.emit('destroy');
    
            // Detach emitter events
            Object.keys(swiper.eventsListeners).forEach(function (eventName) {
              swiper.off(eventName);
            });
    
            if (deleteInstance !== false) {
              swiper.$el[0].swiper = null;
              swiper.$el.data('swiper', null);
              Utils.deleteProps(swiper);
            }
            swiper.destroyed = true;
    
            return null;
          };
    
          Swiper.extendDefaults = function extendDefaults (newDefaults) {
            Utils.extend(extendedDefaults, newDefaults);
          };
    
          staticAccessors.extendedDefaults.get = function () {
            return extendedDefaults;
          };
    
          staticAccessors.defaults.get = function () {
            return defaults;
          };
    
          staticAccessors.Class.get = function () {
            return SwiperClass;
          };
    
          staticAccessors.$.get = function () {
            return $;
          };
    
          Object.defineProperties( Swiper, staticAccessors );
    
          return Swiper;
        }(SwiperClass));
    
        var Device$1 = {
          name: 'device',
          proto: {
            device: Device,
          },
          static: {
            device: Device,
          },
        };
    
        var Support$1 = {
          name: 'support',
          proto: {
            support: Support,
          },
          static: {
            support: Support,
          },
        };
    
        var Browser = (function Browser() {
          function isSafari() {
            var ua = win.navigator.userAgent.toLowerCase();
            return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);
          }
          return {
            isEdge: !!win.navigator.userAgent.match(/Edge/g),
            isSafari: isSafari(),
            isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(win.navigator.userAgent),
          };
        }());
    
        var Browser$1 = {
          name: 'browser',
          proto: {
            browser: Browser,
          },
          static: {
            browser: Browser,
          },
        };
    
        var Resize = {
          name: 'resize',
          create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
              resize: {
                resizeHandler: function resizeHandler() {
                  if (!swiper || swiper.destroyed || !swiper.initialized) { return; }
                  swiper.emit('beforeResize');
                  swiper.emit('resize');
                },
                orientationChangeHandler: function orientationChangeHandler() {
                  if (!swiper || swiper.destroyed || !swiper.initialized) { return; }
                  swiper.emit('orientationchange');
                },
              },
            });
          },
          on: {
            init: function init() {
              var swiper = this;
              // Emit resize
              win.addEventListener('resize', swiper.resize.resizeHandler);
    
              // Emit orientationchange
              win.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
            },
            destroy: function destroy() {
              var swiper = this;
              win.removeEventListener('resize', swiper.resize.resizeHandler);
              win.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
            },
          },
        };
    
        var Observer = {
          func: win.MutationObserver || win.WebkitMutationObserver,
          attach: function attach(target, options) {
            if ( options === void 0 ) options = {};
    
            var swiper = this;
    
            var ObserverFunc = Observer.func;
            var observer = new ObserverFunc(function (mutations) {
              // The observerUpdate event should only be triggered
              // once despite the number of mutations.  Additional
              // triggers are redundant and are very costly
              if (mutations.length === 1) {
                swiper.emit('observerUpdate', mutations[0]);
                return;
              }
              var observerUpdate = function observerUpdate() {
                swiper.emit('observerUpdate', mutations[0]);
              };
    
              if (win.requestAnimationFrame) {
                win.requestAnimationFrame(observerUpdate);
              } else {
                win.setTimeout(observerUpdate, 0);
              }
            });
    
            observer.observe(target, {
              attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
              childList: typeof options.childList === 'undefined' ? true : options.childList,
              characterData: typeof options.characterData === 'undefined' ? true : options.characterData,
            });
    
            swiper.observer.observers.push(observer);
          },
          init: function init() {
            var swiper = this;
            if (!Support.observer || !swiper.params.observer) { return; }
            if (swiper.params.observeParents) {
              var containerParents = swiper.$el.parents();
              for (var i = 0; i < containerParents.length; i += 1) {
                swiper.observer.attach(containerParents[i]);
              }
            }
            // Observe container
            swiper.observer.attach(swiper.$el[0], { childList: swiper.params.observeSlideChildren });
    
            // Observe wrapper
            swiper.observer.attach(swiper.$wrapperEl[0], { attributes: false });
          },
          destroy: function destroy() {
            var swiper = this;
            swiper.observer.observers.forEach(function (observer) {
              observer.disconnect();
            });
            swiper.observer.observers = [];
          },
        };
    
        var Observer$1 = {
          name: 'observer',
          params: {
            observer: false,
            observeParents: false,
            observeSlideChildren: false,
          },
          create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
              observer: {
                init: Observer.init.bind(swiper),
                attach: Observer.attach.bind(swiper),
                destroy: Observer.destroy.bind(swiper),
                observers: [],
              },
            });
          },
          on: {
            init: function init() {
              var swiper = this;
              swiper.observer.init();
            },
            destroy: function destroy() {
              var swiper = this;
              swiper.observer.destroy();
            },
          },
        };
    
        var Virtual = {
          update: function update(force) {
            var swiper = this;
            var ref = swiper.params;
            var slidesPerView = ref.slidesPerView;
            var slidesPerGroup = ref.slidesPerGroup;
            var centeredSlides = ref.centeredSlides;
            var ref$1 = swiper.params.virtual;
            var addSlidesBefore = ref$1.addSlidesBefore;
            var addSlidesAfter = ref$1.addSlidesAfter;
            var ref$2 = swiper.virtual;
            var previousFrom = ref$2.from;
            var previousTo = ref$2.to;
            var slides = ref$2.slides;
            var previousSlidesGrid = ref$2.slidesGrid;
            var renderSlide = ref$2.renderSlide;
            var previousOffset = ref$2.offset;
            swiper.updateActiveIndex();
            var activeIndex = swiper.activeIndex || 0;
    
            var offsetProp;
            if (swiper.rtlTranslate) { offsetProp = 'right'; }
            else { offsetProp = swiper.isHorizontal() ? 'left' : 'top'; }
    
            var slidesAfter;
            var slidesBefore;
            if (centeredSlides) {
              slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
              slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
            } else {
              slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesBefore;
              slidesBefore = slidesPerGroup + addSlidesAfter;
            }
            var from = Math.max((activeIndex || 0) - slidesBefore, 0);
            var to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
            var offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
    
            Utils.extend(swiper.virtual, {
              from: from,
              to: to,
              offset: offset,
              slidesGrid: swiper.slidesGrid,
            });
    
            function onRendered() {
              swiper.updateSlides();
              swiper.updateProgress();
              swiper.updateSlidesClasses();
              if (swiper.lazy && swiper.params.lazy.enabled) {
                swiper.lazy.load();
              }
            }
    
            if (previousFrom === from && previousTo === to && !force) {
              if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
                swiper.slides.css(offsetProp, (offset + "px"));
              }
              swiper.updateProgress();
              return;
            }
            if (swiper.params.virtual.renderExternal) {
              swiper.params.virtual.renderExternal.call(swiper, {
                offset: offset,
                from: from,
                to: to,
                slides: (function getSlides() {
                  var slidesToRender = [];
                  for (var i = from; i <= to; i += 1) {
                    slidesToRender.push(slides[i]);
                  }
                  return slidesToRender;
                }()),
              });
              onRendered();
              return;
            }
            var prependIndexes = [];
            var appendIndexes = [];
            if (force) {
              swiper.$wrapperEl.find(("." + (swiper.params.slideClass))).remove();
            } else {
              for (var i = previousFrom; i <= previousTo; i += 1) {
                if (i < from || i > to) {
                  swiper.$wrapperEl.find(("." + (swiper.params.slideClass) + "[data-swiper-slide-index=\"" + i + "\"]")).remove();
                }
              }
            }
            for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {
              if (i$1 >= from && i$1 <= to) {
                if (typeof previousTo === 'undefined' || force) {
                  appendIndexes.push(i$1);
                } else {
                  if (i$1 > previousTo) { appendIndexes.push(i$1); }
                  if (i$1 < previousFrom) { prependIndexes.push(i$1); }
                }
              }
            }
            appendIndexes.forEach(function (index) {
              swiper.$wrapperEl.append(renderSlide(slides[index], index));
            });
            prependIndexes.sort(function (a, b) { return b - a; }).forEach(function (index) {
              swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
            });
            swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, (offset + "px"));
            onRendered();
          },
          renderSlide: function renderSlide(slide, index) {
            var swiper = this;
            var params = swiper.params.virtual;
            if (params.cache && swiper.virtual.cache[index]) {
              return swiper.virtual.cache[index];
            }
            var $slideEl = params.renderSlide
              ? $(params.renderSlide.call(swiper, slide, index))
              : $(("<div class=\"" + (swiper.params.slideClass) + "\" data-swiper-slide-index=\"" + index + "\">" + slide + "</div>"));
            if (!$slideEl.attr('data-swiper-slide-index')) { $slideEl.attr('data-swiper-slide-index', index); }
            if (params.cache) { swiper.virtual.cache[index] = $slideEl; }
            return $slideEl;
          },
          appendSlide: function appendSlide(slides) {
            var swiper = this;
            if (typeof slides === 'object' && 'length' in slides) {
              for (var i = 0; i < slides.length; i += 1) {
                if (slides[i]) { swiper.virtual.slides.push(slides[i]); }
              }
            } else {
              swiper.virtual.slides.push(slides);
            }
            swiper.virtual.update(true);
          },
          prependSlide: function prependSlide(slides) {
            var swiper = this;
            var activeIndex = swiper.activeIndex;
            var newActiveIndex = activeIndex + 1;
            var numberOfNewSlides = 1;
    
            if (Array.isArray(slides)) {
              for (var i = 0; i < slides.length; i += 1) {
                if (slides[i]) { swiper.virtual.slides.unshift(slides[i]); }
              }
              newActiveIndex = activeIndex + slides.length;
              numberOfNewSlides = slides.length;
            } else {
              swiper.virtual.slides.unshift(slides);
            }
            if (swiper.params.virtual.cache) {
              var cache = swiper.virtual.cache;
              var newCache = {};
              Object.keys(cache).forEach(function (cachedIndex) {
                var $cachedEl = cache[cachedIndex];
                var cachedElIndex = $cachedEl.attr('data-swiper-slide-index');
                if (cachedElIndex) {
                  $cachedEl.attr('data-swiper-slide-index', parseInt(cachedElIndex, 10) + 1);
                }
                newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
              });
              swiper.virtual.cache = newCache;
            }
            swiper.virtual.update(true);
            swiper.slideTo(newActiveIndex, 0);
          },
          removeSlide: function removeSlide(slidesIndexes) {
            var swiper = this;
            if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) { return; }
            var activeIndex = swiper.activeIndex;
            if (Array.isArray(slidesIndexes)) {
              for (var i = slidesIndexes.length - 1; i >= 0; i -= 1) {
                swiper.virtual.slides.splice(slidesIndexes[i], 1);
                if (swiper.params.virtual.cache) {
                  delete swiper.virtual.cache[slidesIndexes[i]];
                }
                if (slidesIndexes[i] < activeIndex) { activeIndex -= 1; }
                activeIndex = Math.max(activeIndex, 0);
              }
            } else {
              swiper.virtual.slides.splice(slidesIndexes, 1);
              if (swiper.params.virtual.cache) {
                delete swiper.virtual.cache[slidesIndexes];
              }
              if (slidesIndexes < activeIndex) { activeIndex -= 1; }
              activeIndex = Math.max(activeIndex, 0);
            }
            swiper.virtual.update(true);
            swiper.slideTo(activeIndex, 0);
          },
          removeAllSlides: function removeAllSlides() {
            var swiper = this;
            swiper.virtual.slides = [];
            if (swiper.params.virtual.cache) {
              swiper.virtual.cache = {};
            }
            swiper.virtual.update(true);
            swiper.slideTo(0, 0);
          },
        };
    
        var Virtual$1 = {
          name: 'virtual',
          params: {
            virtual: {
              enabled: false,
              slides: [],
              cache: true,
              renderSlide: null,
              renderExternal: null,
              addSlidesBefore: 0,
              addSlidesAfter: 0,
            },
          },
          create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
              virtual: {
                update: Virtual.update.bind(swiper),
                appendSlide: Virtual.appendSlide.bind(swiper),
                prependSlide: Virtual.prependSlide.bind(swiper),
                removeSlide: Virtual.removeSlide.bind(swiper),
                removeAllSlides: Virtual.removeAllSlides.bind(swiper),
                renderSlide: Virtual.renderSlide.bind(swiper),
                slides: swiper.params.virtual.slides,
                cache: {},
              },
            });
          },
          on: {
            beforeInit: function beforeInit() {
              var swiper = this;
              if (!swiper.params.virtual.enabled) { return; }
              swiper.classNames.push(((swiper.params.containerModifierClass) + "virtual"));
              var overwriteParams = {
                watchSlidesProgress: true,
              };
              Utils.extend(swiper.params, overwriteParams);
              Utils.extend(swiper.originalParams, overwriteParams);
    
              if (!swiper.params.initialSlide) {
                swiper.virtual.update();
              }
            },
            setTranslate: function setTranslate() {
              var swiper = this;
              if (!swiper.params.virtual.enabled) { return; }
              swiper.virtual.update();
            },
          },
        };
    
        var Keyboard = {
          handle: function handle(event) {
            var swiper = this;
            var rtl = swiper.rtlTranslate;
            var e = event;
            if (e.originalEvent) { e = e.originalEvent; } // jquery fix
            var kc = e.keyCode || e.charCode;
            var pageUpDown = swiper.params.keyboard.pageUpDown;
            var isPageUp = pageUpDown && kc === 33;
            var isPageDown = pageUpDown && kc === 34;
            var isArrowLeft = kc === 37;
            var isArrowRight = kc === 39;
            var isArrowUp = kc === 38;
            var isArrowDown = kc === 40;
            // Directions locks
            if (!swiper.allowSlideNext && ((swiper.isHorizontal() && isArrowRight) || (swiper.isVertical() && isArrowDown) || isPageDown)) {
              return false;
            }
            if (!swiper.allowSlidePrev && ((swiper.isHorizontal() && isArrowLeft) || (swiper.isVertical() && isArrowUp) || isPageUp)) {
              return false;
            }
            if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
              return undefined;
            }
            if (doc.activeElement && doc.activeElement.nodeName && (doc.activeElement.nodeName.toLowerCase() === 'input' || doc.activeElement.nodeName.toLowerCase() === 'textarea')) {
              return undefined;
            }
            if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
              var inView = false;
              // Check that swiper should be inside of visible area of window
              if (swiper.$el.parents(("." + (swiper.params.slideClass))).length > 0 && swiper.$el.parents(("." + (swiper.params.slideActiveClass))).length === 0) {
                return undefined;
              }
              var windowWidth = win.innerWidth;
              var windowHeight = win.innerHeight;
              var swiperOffset = swiper.$el.offset();
              if (rtl) { swiperOffset.left -= swiper.$el[0].scrollLeft; }
              var swiperCoord = [
                [swiperOffset.left, swiperOffset.top],
                [swiperOffset.left + swiper.width, swiperOffset.top],
                [swiperOffset.left, swiperOffset.top + swiper.height],
                [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height] ];
              for (var i = 0; i < swiperCoord.length; i += 1) {
                var point = swiperCoord[i];
                if (
                  point[0] >= 0 && point[0] <= windowWidth
                  && point[1] >= 0 && point[1] <= windowHeight
                ) {
                  inView = true;
                }
              }
              if (!inView) { return undefined; }
            }
            if (swiper.isHorizontal()) {
              if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
                if (e.preventDefault) { e.preventDefault(); }
                else { e.returnValue = false; }
              }
              if (((isPageDown || isArrowRight) && !rtl) || ((isPageUp || isArrowLeft) && rtl)) { swiper.slideNext(); }
              if (((isPageUp || isArrowLeft) && !rtl) || ((isPageDown || isArrowRight) && rtl)) { swiper.slidePrev(); }
            } else {
              if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
                if (e.preventDefault) { e.preventDefault(); }
                else { e.returnValue = false; }
              }
              if (isPageDown || isArrowDown) { swiper.slideNext(); }
              if (isPageUp || isArrowUp) { swiper.slidePrev(); }
            }
            swiper.emit('keyPress', kc);
            return undefined;
          },
          enable: function enable() {
            var swiper = this;
            if (swiper.keyboard.enabled) { return; }
            $(doc).on('keydown', swiper.keyboard.handle);
            swiper.keyboard.enabled = true;
          },
          disable: function disable() {
            var swiper = this;
            if (!swiper.keyboard.enabled) { return; }
            $(doc).off('keydown', swiper.keyboard.handle);
            swiper.keyboard.enabled = false;
          },
        };
    
        var Keyboard$1 = {
          name: 'keyboard',
          params: {
            keyboard: {
              enabled: false,
              onlyInViewport: true,
              pageUpDown: true,
            },
          },
          create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
              keyboard: {
                enabled: false,
                enable: Keyboard.enable.bind(swiper),
                disable: Keyboard.disable.bind(swiper),
                handle: Keyboard.handle.bind(swiper),
              },
            });
          },
          on: {
            init: function init() {
              var swiper = this;
              if (swiper.params.keyboard.enabled) {
                swiper.keyboard.enable();
              }
            },
            destroy: function destroy() {
              var swiper = this;
              if (swiper.keyboard.enabled) {
                swiper.keyboard.disable();
              }
            },
          },
        };
    
        function isEventSupported() {
          var eventName = 'onwheel';
          var isSupported = eventName in doc;
    
          if (!isSupported) {
            var element = doc.createElement('div');
            element.setAttribute(eventName, 'return;');
            isSupported = typeof element[eventName] === 'function';
          }
    
          if (!isSupported
            && doc.implementation
            && doc.implementation.hasFeature
            // always returns true in newer browsers as per the standard.
            // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
            && doc.implementation.hasFeature('', '') !== true
          ) {
            // This is the only way to test support for the `wheel` event in IE9+.
            isSupported = doc.implementation.hasFeature('Events.wheel', '3.0');
          }
    
          return isSupported;
        }
        var Mousewheel = {
          lastScrollTime: Utils.now(),
          lastEventBeforeSnap: undefined,
          recentWheelEvents: [],
          event: function event() {
            if (win.navigator.userAgent.indexOf('firefox') > -1) { return 'DOMMouseScroll'; }
            return isEventSupported() ? 'wheel' : 'mousewheel';
          },
          normalize: function normalize(e) {
            // Reasonable defaults
            var PIXEL_STEP = 10;
            var LINE_HEIGHT = 40;
            var PAGE_HEIGHT = 800;
    
            var sX = 0;
            var sY = 0; // spinX, spinY
            var pX = 0;
            var pY = 0; // pixelX, pixelY
    
            // Legacy
            if ('detail' in e) {
              sY = e.detail;
            }
            if ('wheelDelta' in e) {
              sY = -e.wheelDelta / 120;
            }
            if ('wheelDeltaY' in e) {
              sY = -e.wheelDeltaY / 120;
            }
            if ('wheelDeltaX' in e) {
              sX = -e.wheelDeltaX / 120;
            }
    
            // side scrolling on FF with DOMMouseScroll
            if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
              sX = sY;
              sY = 0;
            }
    
            pX = sX * PIXEL_STEP;
            pY = sY * PIXEL_STEP;
    
            if ('deltaY' in e) {
              pY = e.deltaY;
            }
            if ('deltaX' in e) {
              pX = e.deltaX;
            }
    
            if (e.shiftKey && !pX) { // if user scrolls with shift he wants horizontal scroll
              pX = pY;
              pY = 0;
            }
    
            if ((pX || pY) && e.deltaMode) {
              if (e.deltaMode === 1) { // delta in LINE units
                pX *= LINE_HEIGHT;
                pY *= LINE_HEIGHT;
              } else { // delta in PAGE units
                pX *= PAGE_HEIGHT;
                pY *= PAGE_HEIGHT;
              }
            }
    
            // Fall-back if spin cannot be determined
            if (pX && !sX) {
              sX = (pX < 1) ? -1 : 1;
            }
            if (pY && !sY) {
              sY = (pY < 1) ? -1 : 1;
            }
    
            return {
              spinX: sX,
              spinY: sY,
              pixelX: pX,
              pixelY: pY,
            };
          },
          handleMouseEnter: function handleMouseEnter() {
            var swiper = this;
            swiper.mouseEntered = true;
          },
          handleMouseLeave: function handleMouseLeave() {
            var swiper = this;
            swiper.mouseEntered = false;
          },
          handle: function handle(event) {
            var e = event;
            var swiper = this;
            var params = swiper.params.mousewheel;
    
            if (swiper.params.cssMode) {
              e.preventDefault();
            }
    
            var target = swiper.$el;
            if (swiper.params.mousewheel.eventsTarged !== 'container') {
              target = $(swiper.params.mousewheel.eventsTarged);
            }
            if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) { return true; }
    
            if (e.originalEvent) { e = e.originalEvent; } // jquery fix
            var delta = 0;
            var rtlFactor = swiper.rtlTranslate ? -1 : 1;
    
            var data = Mousewheel.normalize(e);
    
            if (params.forceToAxis) {
              if (swiper.isHorizontal()) {
                if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) { delta = -data.pixelX * rtlFactor; }
                else { return true; }
              } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) { delta = -data.pixelY; }
              else { return true; }
            } else {
              delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
            }
    
            if (delta === 0) { return true; }
    
            if (params.invert) { delta = -delta; }
    
            if (!swiper.params.freeMode) {
              // Register the new event in a variable which stores the relevant data
              var newEvent = {
                time: Utils.now(),
                delta: Math.abs(delta),
                direction: Math.sign(delta),
                raw: event,
              };
    
              // Keep the most recent events
              var recentWheelEvents = swiper.mousewheel.recentWheelEvents;
              if (recentWheelEvents.length >= 2) {
                recentWheelEvents.shift(); // only store the last N events
              }
              var prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
              recentWheelEvents.push(newEvent);
    
              // If there is at least one previous recorded event:
              //   If direction has changed or
              //   if the scroll is quicker than the previous one:
              //     Animate the slider.
              // Else (this is the first time the wheel is moved):
              //     Animate the slider.
              if (prevEvent) {
                if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
                  swiper.mousewheel.animateSlider(newEvent);
                }
              } else {
                swiper.mousewheel.animateSlider(newEvent);
              }
    
              // If it's time to release the scroll:
              //   Return now so you don't hit the preventDefault.
              if (swiper.mousewheel.releaseScroll(newEvent)) {
                return true;
              }
            } else {
              // Freemode or scrollContainer:
    
              // If we recently snapped after a momentum scroll, then ignore wheel events
              // to give time for the deceleration to finish. Stop ignoring after 500 msecs
              // or if it's a new scroll (larger delta or inverse sign as last event before
              // an end-of-momentum snap).
              var newEvent$1 = { time: Utils.now(), delta: Math.abs(delta), direction: Math.sign(delta) };
              var ref = swiper.mousewheel;
              var lastEventBeforeSnap = ref.lastEventBeforeSnap;
              var ignoreWheelEvents = lastEventBeforeSnap
                && newEvent$1.time < lastEventBeforeSnap.time + 500
                && newEvent$1.delta <= lastEventBeforeSnap.delta
                && newEvent$1.direction === lastEventBeforeSnap.direction;
              if (!ignoreWheelEvents) {
                swiper.mousewheel.lastEventBeforeSnap = undefined;
    
                if (swiper.params.loop) {
                  swiper.loopFix();
                }
                var position = swiper.getTranslate() + (delta * params.sensitivity);
                var wasBeginning = swiper.isBeginning;
                var wasEnd = swiper.isEnd;
    
                if (position >= swiper.minTranslate()) { position = swiper.minTranslate(); }
                if (position <= swiper.maxTranslate()) { position = swiper.maxTranslate(); }
    
                swiper.setTransition(0);
                swiper.setTranslate(position);
                swiper.updateProgress();
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
    
                if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {
                  swiper.updateSlidesClasses();
                }
    
                if (swiper.params.freeModeSticky) {
                  // When wheel scrolling starts with sticky (aka snap) enabled, then detect
                  // the end of a momentum scroll by storing recent (N=15?) wheel events.
                  // 1. do all N events have decreasing or same (absolute value) delta?
                  // 2. did all N events arrive in the last M (M=500?) msecs?
                  // 3. does the earliest event have an (absolute value) delta that's
                  //    at least P (P=1?) larger than the most recent event's delta?
                  // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
                  // If 1-4 are "yes" then we're near the end of a momuntum scroll deceleration.
                  // Snap immediately and ignore remaining wheel events in this scroll.
                  // See comment above for "remaining wheel events in this scroll" determination.
                  // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
                  clearTimeout(swiper.mousewheel.timeout);
                  swiper.mousewheel.timeout = undefined;
                  var recentWheelEvents$1 = swiper.mousewheel.recentWheelEvents;
                  if (recentWheelEvents$1.length >= 15) {
                    recentWheelEvents$1.shift(); // only store the last N events
                  }
                  var prevEvent$1 = recentWheelEvents$1.length ? recentWheelEvents$1[recentWheelEvents$1.length - 1] : undefined;
                  var firstEvent = recentWheelEvents$1[0];
                  recentWheelEvents$1.push(newEvent$1);
                  if (prevEvent$1 && (newEvent$1.delta > prevEvent$1.delta || newEvent$1.direction !== prevEvent$1.direction)) {
                    // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
                    recentWheelEvents$1.splice(0);
                  } else if (recentWheelEvents$1.length >= 15
                      && newEvent$1.time - firstEvent.time < 500
                      && firstEvent.delta - newEvent$1.delta >= 1
                      && newEvent$1.delta <= 6
                  ) {
                    // We're at the end of the deceleration of a momentum scroll, so there's no need
                    // to wait for more events. Snap ASAP on the next tick.
                    // Also, because there's some remaining momentum we'll bias the snap in the
                    // direction of the ongoing scroll because it's better UX for the scroll to snap
                    // in the same direction as the scroll instead of reversing to snap.  Therefore,
                    // if it's already scrolled more than 20% in the current direction, keep going.
                    var snapToThreshold = delta > 0 ? 0.8 : 0.2;
                    swiper.mousewheel.lastEventBeforeSnap = newEvent$1;
                    recentWheelEvents$1.splice(0);
                    swiper.mousewheel.timeout = Utils.nextTick(function () {
                      swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
                    }, 0); // no delay; move on next tick
                  }
                  if (!swiper.mousewheel.timeout) {
                    // if we get here, then we haven't detected the end of a momentum scroll, so
                    // we'll consider a scroll "complete" when there haven't been any wheel events
                    // for 500ms.
                    swiper.mousewheel.timeout = Utils.nextTick(function () {
                      var snapToThreshold = 0.5;
                      swiper.mousewheel.lastEventBeforeSnap = newEvent$1;
                      recentWheelEvents$1.splice(0);
                      swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
                    }, 500);
                  }
                }
    
                // Emit event
                if (!ignoreWheelEvents) { swiper.emit('scroll', e); }
    
                // Stop autoplay
                if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) { swiper.autoplay.stop(); }
                // Return page scroll on edge positions
                if (position === swiper.minTranslate() || position === swiper.maxTranslate()) { return true; }
              }
            }
    
            if (e.preventDefault) { e.preventDefault(); }
            else { e.returnValue = false; }
            return false;
          },
          animateSlider: function animateSlider(newEvent) {
            var swiper = this;
            // If the movement is NOT big enough and
            // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
            //   Don't go any further (avoid insignificant scroll movement).
            if (newEvent.delta >= 6 && Utils.now() - swiper.mousewheel.lastScrollTime < 60) {
              // Return false as a default
              return true;
            }
            // If user is scrolling towards the end:
            //   If the slider hasn't hit the latest slide or
            //   if the slider is a loop and
            //   if the slider isn't moving right now:
            //     Go to next slide and
            //     emit a scroll event.
            // Else (the user is scrolling towards the beginning) and
            // if the slider hasn't hit the first slide or
            // if the slider is a loop and
            // if the slider isn't moving right now:
            //   Go to prev slide and
            //   emit a scroll event.
            if (newEvent.direction < 0) {
              if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
                swiper.slideNext();
                swiper.emit('scroll', newEvent.raw);
              }
            } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
              swiper.slidePrev();
              swiper.emit('scroll', newEvent.raw);
            }
            // If you got here is because an animation has been triggered so store the current time
            swiper.mousewheel.lastScrollTime = (new win.Date()).getTime();
            // Return false as a default
            return false;
          },
          releaseScroll: function releaseScroll(newEvent) {
            var swiper = this;
            var params = swiper.params.mousewheel;
            if (newEvent.direction < 0) {
              if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
                // Return true to animate scroll on edges
                return true;
              }
            } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
              // Return true to animate scroll on edges
              return true;
            }
            return false;
          },
          enable: function enable() {
            var swiper = this;
            var event = Mousewheel.event();
            if (swiper.params.cssMode) {
              swiper.wrapperEl.removeEventListener(event, swiper.mousewheel.handle);
              return true;
            }
            if (!event) { return false; }
            if (swiper.mousewheel.enabled) { return false; }
            var target = swiper.$el;
            if (swiper.params.mousewheel.eventsTarged !== 'container') {
              target = $(swiper.params.mousewheel.eventsTarged);
            }
            target.on('mouseenter', swiper.mousewheel.handleMouseEnter);
            target.on('mouseleave', swiper.mousewheel.handleMouseLeave);
            target.on(event, swiper.mousewheel.handle);
            swiper.mousewheel.enabled = true;
            return true;
          },
          disable: function disable() {
            var swiper = this;
            var event = Mousewheel.event();
            if (swiper.params.cssMode) {
              swiper.wrapperEl.addEventListener(event, swiper.mousewheel.handle);
              return true;
            }
            if (!event) { return false; }
            if (!swiper.mousewheel.enabled) { return false; }
            var target = swiper.$el;
            if (swiper.params.mousewheel.eventsTarged !== 'container') {
              target = $(swiper.params.mousewheel.eventsTarged);
            }
            target.off(event, swiper.mousewheel.handle);
            swiper.mousewheel.enabled = false;
            return true;
          },
        };
    
        var Mousewheel$1 = {
          name: 'mousewheel',
          params: {
            mousewheel: {
              enabled: false,
              releaseOnEdges: false,
              invert: false,
              forceToAxis: false,
              sensitivity: 1,
              eventsTarged: 'container',
            },
          },
          create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
              mousewheel: {
                enabled: false,
                enable: Mousewheel.enable.bind(swiper),
                disable: Mousewheel.disable.bind(swiper),
                handle: Mousewheel.handle.bind(swiper),
                handleMouseEnter: Mousewheel.handleMouseEnter.bind(swiper),
                handleMouseLeave: Mousewheel.handleMouseLeave.bind(swiper),
                animateSlider: Mousewheel.animateSlider.bind(swiper),
                releaseScroll: Mousewheel.releaseScroll.bind(swiper),
                lastScrollTime: Utils.now(),
                lastEventBeforeSnap: undefined,
                recentWheelEvents: [],
              },
            });
          },
          on: {
            init: function init() {
              var swiper = this;
              if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
                swiper.mousewheel.disable();
              }
              if (swiper.params.mousewheel.enabled) { swiper.mousewheel.enable(); }
            },
            destroy: function destroy() {
              var swiper = this;
              if (swiper.params.cssMode) {
                swiper.mousewheel.enable();
              }
              if (swiper.mousewheel.enabled) { swiper.mousewheel.disable(); }
            },
          },
        };
    
        var Navigation = {
          update: function update() {
            // Update Navigation Buttons
            var swiper = this;
            var params = swiper.params.navigation;
    
            if (swiper.params.loop) { return; }
            var ref = swiper.navigation;
            var $nextEl = ref.$nextEl;
            var $prevEl = ref.$prevEl;
    
            if ($prevEl && $prevEl.length > 0) {
              if (swiper.isBeginning) {
                $prevEl.addClass(params.disabledClass);
              } else {
                $prevEl.removeClass(params.disabledClass);
              }
              $prevEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
            }
            if ($nextEl && $nextEl.length > 0) {
              if (swiper.isEnd) {
                $nextEl.addClass(params.disabledClass);
              } else {
                $nextEl.removeClass(params.disabledClass);
              }
              $nextEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
            }
          },
          onPrevClick: function onPrevClick(e) {
            var swiper = this;
            e.preventDefault();
            if (swiper.isBeginning && !swiper.params.loop) { return; }
            swiper.slidePrev();
          },
          onNextClick: function onNextClick(e) {
            var swiper = this;
            e.preventDefault();
            if (swiper.isEnd && !swiper.params.loop) { return; }
            swiper.slideNext();
          },
          init: function init() {
            var swiper = this;
            var params = swiper.params.navigation;
            if (!(params.nextEl || params.prevEl)) { return; }
    
            var $nextEl;
            var $prevEl;
            if (params.nextEl) {
              $nextEl = $(params.nextEl);
              if (
                swiper.params.uniqueNavElements
                && typeof params.nextEl === 'string'
                && $nextEl.length > 1
                && swiper.$el.find(params.nextEl).length === 1
              ) {
                $nextEl = swiper.$el.find(params.nextEl);
              }
            }
            if (params.prevEl) {
              $prevEl = $(params.prevEl);
              if (
                swiper.params.uniqueNavElements
                && typeof params.prevEl === 'string'
                && $prevEl.length > 1
                && swiper.$el.find(params.prevEl).length === 1
              ) {
                $prevEl = swiper.$el.find(params.prevEl);
              }
            }
    
            if ($nextEl && $nextEl.length > 0) {
              $nextEl.on('click', swiper.navigation.onNextClick);
            }
            if ($prevEl && $prevEl.length > 0) {
              $prevEl.on('click', swiper.navigation.onPrevClick);
            }
    
            Utils.extend(swiper.navigation, {
              $nextEl: $nextEl,
              nextEl: $nextEl && $nextEl[0],
              $prevEl: $prevEl,
              prevEl: $prevEl && $prevEl[0],
            });
          },
          destroy: function destroy() {
            var swiper = this;
            var ref = swiper.navigation;
            var $nextEl = ref.$nextEl;
            var $prevEl = ref.$prevEl;
            if ($nextEl && $nextEl.length) {
              $nextEl.off('click', swiper.navigation.onNextClick);
              $nextEl.removeClass(swiper.params.navigation.disabledClass);
            }
            if ($prevEl && $prevEl.length) {
              $prevEl.off('click', swiper.navigation.onPrevClick);
              $prevEl.removeClass(swiper.params.navigation.disabledClass);
            }
          },
        };
    
        var Navigation$1 = {
          name: 'navigation',
          params: {
            navigation: {
              nextEl: null,
              prevEl: null,
    
              hideOnClick: false,
              disabledClass: 'swiper-button-disabled',
              hiddenClass: 'swiper-button-hidden',
              lockClass: 'swiper-button-lock',
            },
          },
          create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
              navigation: {
                init: Navigation.init.bind(swiper),
                update: Navigation.update.bind(swiper),
                destroy: Navigation.destroy.bind(swiper),
                onNextClick: Navigation.onNextClick.bind(swiper),
                onPrevClick: Navigation.onPrevClick.bind(swiper),
              },
            });
          },
          on: {
            init: function init() {
              var swiper = this;
              swiper.navigation.init();
              swiper.navigation.update();
            },
            toEdge: function toEdge() {
              var swiper = this;
              swiper.navigation.update();
            },
            fromEdge: function fromEdge() {
              var swiper = this;
              swiper.navigation.update();
            },
            destroy: function destroy() {
              var swiper = this;
              swiper.navigation.destroy();
            },
            click: function click(e) {
              var swiper = this;
              var ref = swiper.navigation;
              var $nextEl = ref.$nextEl;
              var $prevEl = ref.$prevEl;
              if (
                swiper.params.navigation.hideOnClick
                && !$(e.target).is($prevEl)
                && !$(e.target).is($nextEl)
              ) {
                var isHidden;
                if ($nextEl) {
                  isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
                } else if ($prevEl) {
                  isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
                }
                if (isHidden === true) {
                  swiper.emit('navigationShow', swiper);
                } else {
                  swiper.emit('navigationHide', swiper);
                }
                if ($nextEl) {
                  $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
                }
                if ($prevEl) {
                  $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
                }
              }
            },
          },
        };
    
        var Pagination = {
          update: function update() {
            // Render || Update Pagination bullets/items
            var swiper = this;
            var rtl = swiper.rtl;
            var params = swiper.params.pagination;
            if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) { return; }
            var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
            var $el = swiper.pagination.$el;
            // Current/Total
            var current;
            var total = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
            if (swiper.params.loop) {
              current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
              if (current > slidesLength - 1 - (swiper.loopedSlides * 2)) {
                current -= (slidesLength - (swiper.loopedSlides * 2));
              }
              if (current > total - 1) { current -= total; }
              if (current < 0 && swiper.params.paginationType !== 'bullets') { current = total + current; }
            } else if (typeof swiper.snapIndex !== 'undefined') {
              current = swiper.snapIndex;
            } else {
              current = swiper.activeIndex || 0;
            }
            // Types
            if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
              var bullets = swiper.pagination.bullets;
              var firstIndex;
              var lastIndex;
              var midIndex;
              if (params.dynamicBullets) {
                swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
                $el.css(swiper.isHorizontal() ? 'width' : 'height', ((swiper.pagination.bulletSize * (params.dynamicMainBullets + 4)) + "px"));
                if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
                  swiper.pagination.dynamicBulletIndex += (current - swiper.previousIndex);
                  if (swiper.pagination.dynamicBulletIndex > (params.dynamicMainBullets - 1)) {
                    swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
                  } else if (swiper.pagination.dynamicBulletIndex < 0) {
                    swiper.pagination.dynamicBulletIndex = 0;
                  }
                }
                firstIndex = current - swiper.pagination.dynamicBulletIndex;
                lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
                midIndex = (lastIndex + firstIndex) / 2;
              }
              bullets.removeClass(((params.bulletActiveClass) + " " + (params.bulletActiveClass) + "-next " + (params.bulletActiveClass) + "-next-next " + (params.bulletActiveClass) + "-prev " + (params.bulletActiveClass) + "-prev-prev " + (params.bulletActiveClass) + "-main"));
              if ($el.length > 1) {
                bullets.each(function (index, bullet) {
                  var $bullet = $(bullet);
                  var bulletIndex = $bullet.index();
                  if (bulletIndex === current) {
                    $bullet.addClass(params.bulletActiveClass);
                  }
                  if (params.dynamicBullets) {
                    if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                      $bullet.addClass(((params.bulletActiveClass) + "-main"));
                    }
                    if (bulletIndex === firstIndex) {
                      $bullet
                        .prev()
                        .addClass(((params.bulletActiveClass) + "-prev"))
                        .prev()
                        .addClass(((params.bulletActiveClass) + "-prev-prev"));
                    }
                    if (bulletIndex === lastIndex) {
                      $bullet
                        .next()
                        .addClass(((params.bulletActiveClass) + "-next"))
                        .next()
                        .addClass(((params.bulletActiveClass) + "-next-next"));
                    }
                  }
                });
              } else {
                var $bullet = bullets.eq(current);
                var bulletIndex = $bullet.index();
                $bullet.addClass(params.bulletActiveClass);
                if (params.dynamicBullets) {
                  var $firstDisplayedBullet = bullets.eq(firstIndex);
                  var $lastDisplayedBullet = bullets.eq(lastIndex);
                  for (var i = firstIndex; i <= lastIndex; i += 1) {
                    bullets.eq(i).addClass(((params.bulletActiveClass) + "-main"));
                  }
                  if (swiper.params.loop) {
                    if (bulletIndex >= bullets.length - params.dynamicMainBullets) {
                      for (var i$1 = params.dynamicMainBullets; i$1 >= 0; i$1 -= 1) {
                        bullets.eq(bullets.length - i$1).addClass(((params.bulletActiveClass) + "-main"));
                      }
                      bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(((params.bulletActiveClass) + "-prev"));
                    } else {
                      $firstDisplayedBullet
                        .prev()
                        .addClass(((params.bulletActiveClass) + "-prev"))
                        .prev()
                        .addClass(((params.bulletActiveClass) + "-prev-prev"));
                      $lastDisplayedBullet
                        .next()
                        .addClass(((params.bulletActiveClass) + "-next"))
                        .next()
                        .addClass(((params.bulletActiveClass) + "-next-next"));
                    }
                  } else {
                    $firstDisplayedBullet
                      .prev()
                      .addClass(((params.bulletActiveClass) + "-prev"))
                      .prev()
                      .addClass(((params.bulletActiveClass) + "-prev-prev"));
                    $lastDisplayedBullet
                      .next()
                      .addClass(((params.bulletActiveClass) + "-next"))
                      .next()
                      .addClass(((params.bulletActiveClass) + "-next-next"));
                  }
                }
              }
              if (params.dynamicBullets) {
                var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
                var bulletsOffset = (((swiper.pagination.bulletSize * dynamicBulletsLength) - (swiper.pagination.bulletSize)) / 2) - (midIndex * swiper.pagination.bulletSize);
                var offsetProp = rtl ? 'right' : 'left';
                bullets.css(swiper.isHorizontal() ? offsetProp : 'top', (bulletsOffset + "px"));
              }
            }
            if (params.type === 'fraction') {
              $el.find(("." + (params.currentClass))).text(params.formatFractionCurrent(current + 1));
              $el.find(("." + (params.totalClass))).text(params.formatFractionTotal(total));
            }
            if (params.type === 'progressbar') {
              var progressbarDirection;
              if (params.progressbarOpposite) {
                progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
              } else {
                progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
              }
              var scale = (current + 1) / total;
              var scaleX = 1;
              var scaleY = 1;
              if (progressbarDirection === 'horizontal') {
                scaleX = scale;
              } else {
                scaleY = scale;
              }
              $el.find(("." + (params.progressbarFillClass))).transform(("translate3d(0,0,0) scaleX(" + scaleX + ") scaleY(" + scaleY + ")")).transition(swiper.params.speed);
            }
            if (params.type === 'custom' && params.renderCustom) {
              $el.html(params.renderCustom(swiper, current + 1, total));
              swiper.emit('paginationRender', swiper, $el[0]);
            } else {
              swiper.emit('paginationUpdate', swiper, $el[0]);
            }
            $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
          },
          render: function render() {
            // Render Container
            var swiper = this;
            var params = swiper.params.pagination;
            if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) { return; }
            var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    
            var $el = swiper.pagination.$el;
            var paginationHTML = '';
            if (params.type === 'bullets') {
              var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
              for (var i = 0; i < numberOfBullets; i += 1) {
                if (params.renderBullet) {
                  paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
                } else {
                  paginationHTML += "<" + (params.bulletElement) + " class=\"" + (params.bulletClass) + "\"></" + (params.bulletElement) + ">";
                }
              }
              $el.html(paginationHTML);
              swiper.pagination.bullets = $el.find(("." + (params.bulletClass)));
            }
            if (params.type === 'fraction') {
              if (params.renderFraction) {
                paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
              } else {
                paginationHTML = "<span class=\"" + (params.currentClass) + "\"></span>"
                + ' / '
                + "<span class=\"" + (params.totalClass) + "\"></span>";
              }
              $el.html(paginationHTML);
            }
            if (params.type === 'progressbar') {
              if (params.renderProgressbar) {
                paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
              } else {
                paginationHTML = "<span class=\"" + (params.progressbarFillClass) + "\"></span>";
              }
              $el.html(paginationHTML);
            }
            if (params.type !== 'custom') {
              swiper.emit('paginationRender', swiper.pagination.$el[0]);
            }
          },
          init: function init() {
            var swiper = this;
            var params = swiper.params.pagination;
            if (!params.el) { return; }
    
            var $el = $(params.el);
            if ($el.length === 0) { return; }
    
            if (
              swiper.params.uniqueNavElements
              && typeof params.el === 'string'
              && $el.length > 1
            ) {
              $el = swiper.$el.find(params.el);
            }
    
            if (params.type === 'bullets' && params.clickable) {
              $el.addClass(params.clickableClass);
            }
    
            $el.addClass(params.modifierClass + params.type);
    
            if (params.type === 'bullets' && params.dynamicBullets) {
              $el.addClass(("" + (params.modifierClass) + (params.type) + "-dynamic"));
              swiper.pagination.dynamicBulletIndex = 0;
              if (params.dynamicMainBullets < 1) {
                params.dynamicMainBullets = 1;
              }
            }
            if (params.type === 'progressbar' && params.progressbarOpposite) {
              $el.addClass(params.progressbarOppositeClass);
            }
    
            if (params.clickable) {
              $el.on('click', ("." + (params.bulletClass)), function onClick(e) {
                e.preventDefault();
                var index = $(this).index() * swiper.params.slidesPerGroup;
                if (swiper.params.loop) { index += swiper.loopedSlides; }
                swiper.slideTo(index);
              });
            }
    
            Utils.extend(swiper.pagination, {
              $el: $el,
              el: $el[0],
            });
          },
          destroy: function destroy() {
            var swiper = this;
            var params = swiper.params.pagination;
            if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) { return; }
            var $el = swiper.pagination.$el;
    
            $el.removeClass(params.hiddenClass);
            $el.removeClass(params.modifierClass + params.type);
            if (swiper.pagination.bullets) { swiper.pagination.bullets.removeClass(params.bulletActiveClass); }
            if (params.clickable) {
              $el.off('click', ("." + (params.bulletClass)));
            }
          },
        };
    
        var Pagination$1 = {
          name: 'pagination',
          params: {
            pagination: {
              el: null,
              bulletElement: 'span',
              clickable: false,
              hideOnClick: false,
              renderBullet: null,
              renderProgressbar: null,
              renderFraction: null,
              renderCustom: null,
              progressbarOpposite: false,
              type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'
              dynamicBullets: false,
              dynamicMainBullets: 1,
              formatFractionCurrent: function (number) { return number; },
              formatFractionTotal: function (number) { return number; },
              bulletClass: 'swiper-pagination-bullet',
              bulletActiveClass: 'swiper-pagination-bullet-active',
              modifierClass: 'swiper-pagination-', // NEW
              currentClass: 'swiper-pagination-current',
              totalClass: 'swiper-pagination-total',
              hiddenClass: 'swiper-pagination-hidden',
              progressbarFillClass: 'swiper-pagination-progressbar-fill',
              progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
              clickableClass: 'swiper-pagination-clickable', // NEW
              lockClass: 'swiper-pagination-lock',
            },
          },
          create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
              pagination: {
                init: Pagination.init.bind(swiper),
                render: Pagination.render.bind(swiper),
                update: Pagination.update.bind(swiper),
                destroy: Pagination.destroy.bind(swiper),
                dynamicBulletIndex: 0,
              },
            });
          },
          on: {
            init: function init() {
              var swiper = this;
              swiper.pagination.init();
              swiper.pagination.render();
              swiper.pagination.update();
            },
            activeIndexChange: function activeIndexChange() {
              var swiper = this;
              if (swiper.params.loop) {
                swiper.pagination.update();
              } else if (typeof swiper.snapIndex === 'undefined') {
                swiper.pagination.update();
              }
            },
            snapIndexChange: function snapIndexChange() {
              var swiper = this;
              if (!swiper.params.loop) {
                swiper.pagination.update();
              }
            },
            slidesLengthChange: function slidesLengthChange() {
              var swiper = this;
              if (swiper.params.loop) {
                swiper.pagination.render();
                swiper.pagination.update();
              }
            },
            snapGridLengthChange: function snapGridLengthChange() {
              var swiper = this;
              if (!swiper.params.loop) {
                swiper.pagination.render();
                swiper.pagination.update();
              }
            },
            destroy: function destroy() {
              var swiper = this;
              swiper.pagination.destroy();
            },
            click: function click(e) {
              var swiper = this;
              if (
                swiper.params.pagination.el
                && swiper.params.pagination.hideOnClick
                && swiper.pagination.$el.length > 0
                && !$(e.target).hasClass(swiper.params.pagination.bulletClass)
              ) {
                var isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);
                if (isHidden === true) {
                  swiper.emit('paginationShow', swiper);
                } else {
                  swiper.emit('paginationHide', swiper);
                }
                swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
              }
            },
          },
        };
    
        var Scrollbar = {
          setTranslate: function setTranslate() {
            var swiper = this;
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) { return; }
            var scrollbar = swiper.scrollbar;
            var rtl = swiper.rtlTranslate;
            var progress = swiper.progress;
            var dragSize = scrollbar.dragSize;
            var trackSize = scrollbar.trackSize;
            var $dragEl = scrollbar.$dragEl;
            var $el = scrollbar.$el;
            var params = swiper.params.scrollbar;
    
            var newSize = dragSize;
            var newPos = (trackSize - dragSize) * progress;
            if (rtl) {
              newPos = -newPos;
              if (newPos > 0) {
                newSize = dragSize - newPos;
                newPos = 0;
              } else if (-newPos + dragSize > trackSize) {
                newSize = trackSize + newPos;
              }
            } else if (newPos < 0) {
              newSize = dragSize + newPos;
              newPos = 0;
            } else if (newPos + dragSize > trackSize) {
              newSize = trackSize - newPos;
            }
            if (swiper.isHorizontal()) {
              $dragEl.transform(("translate3d(" + newPos + "px, 0, 0)"));
              $dragEl[0].style.width = newSize + "px";
            } else {
              $dragEl.transform(("translate3d(0px, " + newPos + "px, 0)"));
              $dragEl[0].style.height = newSize + "px";
            }
            if (params.hide) {
              clearTimeout(swiper.scrollbar.timeout);
              $el[0].style.opacity = 1;
              swiper.scrollbar.timeout = setTimeout(function () {
                $el[0].style.opacity = 0;
                $el.transition(400);
              }, 1000);
            }
          },
          setTransition: function setTransition(duration) {
            var swiper = this;
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) { return; }
            swiper.scrollbar.$dragEl.transition(duration);
          },
          updateSize: function updateSize() {
            var swiper = this;
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) { return; }
    
            var scrollbar = swiper.scrollbar;
            var $dragEl = scrollbar.$dragEl;
            var $el = scrollbar.$el;
    
            $dragEl[0].style.width = '';
            $dragEl[0].style.height = '';
            var trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
    
            var divider = swiper.size / swiper.virtualSize;
            var moveDivider = divider * (trackSize / swiper.size);
            var dragSize;
            if (swiper.params.scrollbar.dragSize === 'auto') {
              dragSize = trackSize * divider;
            } else {
              dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
            }
    
            if (swiper.isHorizontal()) {
              $dragEl[0].style.width = dragSize + "px";
            } else {
              $dragEl[0].style.height = dragSize + "px";
            }
    
            if (divider >= 1) {
              $el[0].style.display = 'none';
            } else {
              $el[0].style.display = '';
            }
            if (swiper.params.scrollbar.hide) {
              $el[0].style.opacity = 0;
            }
            Utils.extend(scrollbar, {
              trackSize: trackSize,
              divider: divider,
              moveDivider: moveDivider,
              dragSize: dragSize,
            });
            scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
          },
          getPointerPosition: function getPointerPosition(e) {
            var swiper = this;
            if (swiper.isHorizontal()) {
              return ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].clientX : e.clientX);
            }
            return ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].clientY : e.clientY);
          },
          setDragPosition: function setDragPosition(e) {
            var swiper = this;
            var scrollbar = swiper.scrollbar;
            var rtl = swiper.rtlTranslate;
            var $el = scrollbar.$el;
            var dragSize = scrollbar.dragSize;
            var trackSize = scrollbar.trackSize;
            var dragStartPos = scrollbar.dragStartPos;
    
            var positionRatio;
            positionRatio = ((scrollbar.getPointerPosition(e)) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top']
              - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
            positionRatio = Math.max(Math.min(positionRatio, 1), 0);
            if (rtl) {
              positionRatio = 1 - positionRatio;
            }
    
            var position = swiper.minTranslate() + ((swiper.maxTranslate() - swiper.minTranslate()) * positionRatio);
    
            swiper.updateProgress(position);
            swiper.setTranslate(position);
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
          },
          onDragStart: function onDragStart(e) {
            var swiper = this;
            var params = swiper.params.scrollbar;
            var scrollbar = swiper.scrollbar;
            var $wrapperEl = swiper.$wrapperEl;
            var $el = scrollbar.$el;
            var $dragEl = scrollbar.$dragEl;
            swiper.scrollbar.isTouched = true;
            swiper.scrollbar.dragStartPos = (e.target === $dragEl[0] || e.target === $dragEl)
              ? scrollbar.getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
            e.preventDefault();
            e.stopPropagation();
    
            $wrapperEl.transition(100);
            $dragEl.transition(100);
            scrollbar.setDragPosition(e);
    
            clearTimeout(swiper.scrollbar.dragTimeout);
    
            $el.transition(0);
            if (params.hide) {
              $el.css('opacity', 1);
            }
            if (swiper.params.cssMode) {
              swiper.$wrapperEl.css('scroll-snap-type', 'none');
            }
            swiper.emit('scrollbarDragStart', e);
          },
          onDragMove: function onDragMove(e) {
            var swiper = this;
            var scrollbar = swiper.scrollbar;
            var $wrapperEl = swiper.$wrapperEl;
            var $el = scrollbar.$el;
            var $dragEl = scrollbar.$dragEl;
    
            if (!swiper.scrollbar.isTouched) { return; }
            if (e.preventDefault) { e.preventDefault(); }
            else { e.returnValue = false; }
            scrollbar.setDragPosition(e);
            $wrapperEl.transition(0);
            $el.transition(0);
            $dragEl.transition(0);
            swiper.emit('scrollbarDragMove', e);
          },
          onDragEnd: function onDragEnd(e) {
            var swiper = this;
    
            var params = swiper.params.scrollbar;
            var scrollbar = swiper.scrollbar;
            var $wrapperEl = swiper.$wrapperEl;
            var $el = scrollbar.$el;
    
            if (!swiper.scrollbar.isTouched) { return; }
            swiper.scrollbar.isTouched = false;
            if (swiper.params.cssMode) {
              swiper.$wrapperEl.css('scroll-snap-type', '');
              $wrapperEl.transition('');
            }
            if (params.hide) {
              clearTimeout(swiper.scrollbar.dragTimeout);
              swiper.scrollbar.dragTimeout = Utils.nextTick(function () {
                $el.css('opacity', 0);
                $el.transition(400);
              }, 1000);
            }
            swiper.emit('scrollbarDragEnd', e);
            if (params.snapOnRelease) {
              swiper.slideToClosest();
            }
          },
          enableDraggable: function enableDraggable() {
            var swiper = this;
            if (!swiper.params.scrollbar.el) { return; }
            var scrollbar = swiper.scrollbar;
            var touchEventsTouch = swiper.touchEventsTouch;
            var touchEventsDesktop = swiper.touchEventsDesktop;
            var params = swiper.params;
            var $el = scrollbar.$el;
            var target = $el[0];
            var activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;
            var passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
            if (!Support.touch) {
              target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
              doc.addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
              doc.addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
            } else {
              target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
              target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
              target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
            }
          },
          disableDraggable: function disableDraggable() {
            var swiper = this;
            if (!swiper.params.scrollbar.el) { return; }
            var scrollbar = swiper.scrollbar;
            var touchEventsTouch = swiper.touchEventsTouch;
            var touchEventsDesktop = swiper.touchEventsDesktop;
            var params = swiper.params;
            var $el = scrollbar.$el;
            var target = $el[0];
            var activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;
            var passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
            if (!Support.touch) {
              target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
              doc.removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
              doc.removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
            } else {
              target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
              target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
              target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
            }
          },
          init: function init() {
            var swiper = this;
            if (!swiper.params.scrollbar.el) { return; }
            var scrollbar = swiper.scrollbar;
            var $swiperEl = swiper.$el;
            var params = swiper.params.scrollbar;
    
            var $el = $(params.el);
            if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
              $el = $swiperEl.find(params.el);
            }
    
            var $dragEl = $el.find(("." + (swiper.params.scrollbar.dragClass)));
            if ($dragEl.length === 0) {
              $dragEl = $(("<div class=\"" + (swiper.params.scrollbar.dragClass) + "\"></div>"));
              $el.append($dragEl);
            }
    
            Utils.extend(scrollbar, {
              $el: $el,
              el: $el[0],
              $dragEl: $dragEl,
              dragEl: $dragEl[0],
            });
    
            if (params.draggable) {
              scrollbar.enableDraggable();
            }
          },
          destroy: function destroy() {
            var swiper = this;
            swiper.scrollbar.disableDraggable();
          },
        };
    
        var Scrollbar$1 = {
          name: 'scrollbar',
          params: {
            scrollbar: {
              el: null,
              dragSize: 'auto',
              hide: false,
              draggable: false,
              snapOnRelease: true,
              lockClass: 'swiper-scrollbar-lock',
              dragClass: 'swiper-scrollbar-drag',
            },
          },
          create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
              scrollbar: {
                init: Scrollbar.init.bind(swiper),
                destroy: Scrollbar.destroy.bind(swiper),
                updateSize: Scrollbar.updateSize.bind(swiper),
                setTranslate: Scrollbar.setTranslate.bind(swiper),
                setTransition: Scrollbar.setTransition.bind(swiper),
                enableDraggable: Scrollbar.enableDraggable.bind(swiper),
                disableDraggable: Scrollbar.disableDraggable.bind(swiper),
                setDragPosition: Scrollbar.setDragPosition.bind(swiper),
                getPointerPosition: Scrollbar.getPointerPosition.bind(swiper),
                onDragStart: Scrollbar.onDragStart.bind(swiper),
                onDragMove: Scrollbar.onDragMove.bind(swiper),
                onDragEnd: Scrollbar.onDragEnd.bind(swiper),
                isTouched: false,
                timeout: null,
                dragTimeout: null,
              },
            });
          },
          on: {
            init: function init() {
              var swiper = this;
              swiper.scrollbar.init();
              swiper.scrollbar.updateSize();
              swiper.scrollbar.setTranslate();
            },
            update: function update() {
              var swiper = this;
              swiper.scrollbar.updateSize();
            },
            resize: function resize() {
              var swiper = this;
              swiper.scrollbar.updateSize();
            },
            observerUpdate: function observerUpdate() {
              var swiper = this;
              swiper.scrollbar.updateSize();
            },
            setTranslate: function setTranslate() {
              var swiper = this;
              swiper.scrollbar.setTranslate();
            },
            setTransition: function setTransition(duration) {
              var swiper = this;
              swiper.scrollbar.setTransition(duration);
            },
            destroy: function destroy() {
              var swiper = this;
              swiper.scrollbar.destroy();
            },
          },
        };
    
        var Parallax = {
          setTransform: function setTransform(el, progress) {
            var swiper = this;
            var rtl = swiper.rtl;
    
            var $el = $(el);
            var rtlFactor = rtl ? -1 : 1;
    
            var p = $el.attr('data-swiper-parallax') || '0';
            var x = $el.attr('data-swiper-parallax-x');
            var y = $el.attr('data-swiper-parallax-y');
            var scale = $el.attr('data-swiper-parallax-scale');
            var opacity = $el.attr('data-swiper-parallax-opacity');
    
            if (x || y) {
              x = x || '0';
              y = y || '0';
            } else if (swiper.isHorizontal()) {
              x = p;
              y = '0';
            } else {
              y = p;
              x = '0';
            }
    
            if ((x).indexOf('%') >= 0) {
              x = (parseInt(x, 10) * progress * rtlFactor) + "%";
            } else {
              x = (x * progress * rtlFactor) + "px";
            }
            if ((y).indexOf('%') >= 0) {
              y = (parseInt(y, 10) * progress) + "%";
            } else {
              y = (y * progress) + "px";
            }
    
            if (typeof opacity !== 'undefined' && opacity !== null) {
              var currentOpacity = opacity - ((opacity - 1) * (1 - Math.abs(progress)));
              $el[0].style.opacity = currentOpacity;
            }
            if (typeof scale === 'undefined' || scale === null) {
              $el.transform(("translate3d(" + x + ", " + y + ", 0px)"));
            } else {
              var currentScale = scale - ((scale - 1) * (1 - Math.abs(progress)));
              $el.transform(("translate3d(" + x + ", " + y + ", 0px) scale(" + currentScale + ")"));
            }
          },
          setTranslate: function setTranslate() {
            var swiper = this;
            var $el = swiper.$el;
            var slides = swiper.slides;
            var progress = swiper.progress;
            var snapGrid = swiper.snapGrid;
            $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]')
              .each(function (index, el) {
                swiper.parallax.setTransform(el, progress);
              });
            slides.each(function (slideIndex, slideEl) {
              var slideProgress = slideEl.progress;
              if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
                slideProgress += Math.ceil(slideIndex / 2) - (progress * (snapGrid.length - 1));
              }
              slideProgress = Math.min(Math.max(slideProgress, -1), 1);
              $(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]')
                .each(function (index, el) {
                  swiper.parallax.setTransform(el, slideProgress);
                });
            });
          },
          setTransition: function setTransition(duration) {
            if ( duration === void 0 ) duration = this.params.speed;
    
            var swiper = this;
            var $el = swiper.$el;
            $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]')
              .each(function (index, parallaxEl) {
                var $parallaxEl = $(parallaxEl);
                var parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
                if (duration === 0) { parallaxDuration = 0; }
                $parallaxEl.transition(parallaxDuration);
              });
          },
        };
    
        var Parallax$1 = {
          name: 'parallax',
          params: {
            parallax: {
              enabled: false,
            },
          },
          create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
              parallax: {
                setTransform: Parallax.setTransform.bind(swiper),
                setTranslate: Parallax.setTranslate.bind(swiper),
                setTransition: Parallax.setTransition.bind(swiper),
              },
            });
          },
          on: {
            beforeInit: function beforeInit() {
              var swiper = this;
              if (!swiper.params.parallax.enabled) { return; }
              swiper.params.watchSlidesProgress = true;
              swiper.originalParams.watchSlidesProgress = true;
            },
            init: function init() {
              var swiper = this;
              if (!swiper.params.parallax.enabled) { return; }
              swiper.parallax.setTranslate();
            },
            setTranslate: function setTranslate() {
              var swiper = this;
              if (!swiper.params.parallax.enabled) { return; }
              swiper.parallax.setTranslate();
            },
            setTransition: function setTransition(duration) {
              var swiper = this;
              if (!swiper.params.parallax.enabled) { return; }
              swiper.parallax.setTransition(duration);
            },
          },
        };
    
        var Zoom = {
          // Calc Scale From Multi-touches
          getDistanceBetweenTouches: function getDistanceBetweenTouches(e) {
            if (e.targetTouches.length < 2) { return 1; }
            var x1 = e.targetTouches[0].pageX;
            var y1 = e.targetTouches[0].pageY;
            var x2 = e.targetTouches[1].pageX;
            var y2 = e.targetTouches[1].pageY;
            var distance = Math.sqrt((Math.pow( (x2 - x1), 2 )) + (Math.pow( (y2 - y1), 2 )));
            return distance;
          },
          // Events
          onGestureStart: function onGestureStart(e) {
            var swiper = this;
            var params = swiper.params.zoom;
            var zoom = swiper.zoom;
            var gesture = zoom.gesture;
            zoom.fakeGestureTouched = false;
            zoom.fakeGestureMoved = false;
            if (!Support.gestures) {
              if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {
                return;
              }
              zoom.fakeGestureTouched = true;
              gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
            }
            if (!gesture.$slideEl || !gesture.$slideEl.length) {
              gesture.$slideEl = $(e.target).closest(("." + (swiper.params.slideClass)));
              if (gesture.$slideEl.length === 0) { gesture.$slideEl = swiper.slides.eq(swiper.activeIndex); }
              gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
              gesture.$imageWrapEl = gesture.$imageEl.parent(("." + (params.containerClass)));
              gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
              if (gesture.$imageWrapEl.length === 0) {
                gesture.$imageEl = undefined;
                return;
              }
            }
            if (gesture.$imageEl) {
              gesture.$imageEl.transition(0);
            }
            swiper.zoom.isScaling = true;
          },
          onGestureChange: function onGestureChange(e) {
            var swiper = this;
            var params = swiper.params.zoom;
            var zoom = swiper.zoom;
            var gesture = zoom.gesture;
            if (!Support.gestures) {
              if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {
                return;
              }
              zoom.fakeGestureMoved = true;
              gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
            if (Support.gestures) {
              zoom.scale = e.scale * zoom.currentScale;
            } else {
              zoom.scale = (gesture.scaleMove / gesture.scaleStart) * zoom.currentScale;
            }
            if (zoom.scale > gesture.maxRatio) {
              zoom.scale = (gesture.maxRatio - 1) + (Math.pow( ((zoom.scale - gesture.maxRatio) + 1), 0.5 ));
            }
            if (zoom.scale < params.minRatio) {
              zoom.scale = (params.minRatio + 1) - (Math.pow( ((params.minRatio - zoom.scale) + 1), 0.5 ));
            }
            gesture.$imageEl.transform(("translate3d(0,0,0) scale(" + (zoom.scale) + ")"));
          },
          onGestureEnd: function onGestureEnd(e) {
            var swiper = this;
            var params = swiper.params.zoom;
            var zoom = swiper.zoom;
            var gesture = zoom.gesture;
            if (!Support.gestures) {
              if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
                return;
              }
              if (e.type !== 'touchend' || (e.type === 'touchend' && e.changedTouches.length < 2 && !Device.android)) {
                return;
              }
              zoom.fakeGestureTouched = false;
              zoom.fakeGestureMoved = false;
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
            zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
            gesture.$imageEl.transition(swiper.params.speed).transform(("translate3d(0,0,0) scale(" + (zoom.scale) + ")"));
            zoom.currentScale = zoom.scale;
            zoom.isScaling = false;
            if (zoom.scale === 1) { gesture.$slideEl = undefined; }
          },
          onTouchStart: function onTouchStart(e) {
            var swiper = this;
            var zoom = swiper.zoom;
            var gesture = zoom.gesture;
            var image = zoom.image;
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
            if (image.isTouched) { return; }
            if (Device.android && e.cancelable) { e.preventDefault(); }
            image.isTouched = true;
            image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
            image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
          },
          onTouchMove: function onTouchMove(e) {
            var swiper = this;
            var zoom = swiper.zoom;
            var gesture = zoom.gesture;
            var image = zoom.image;
            var velocity = zoom.velocity;
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
            swiper.allowClick = false;
            if (!image.isTouched || !gesture.$slideEl) { return; }
    
            if (!image.isMoved) {
              image.width = gesture.$imageEl[0].offsetWidth;
              image.height = gesture.$imageEl[0].offsetHeight;
              image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
              image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
              gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
              gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
              gesture.$imageWrapEl.transition(0);
              if (swiper.rtl) {
                image.startX = -image.startX;
                image.startY = -image.startY;
              }
            }
            // Define if we need image drag
            var scaledWidth = image.width * zoom.scale;
            var scaledHeight = image.height * zoom.scale;
    
            if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) { return; }
    
            image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
            image.maxX = -image.minX;
            image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
            image.maxY = -image.minY;
    
            image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
            image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
    
            if (!image.isMoved && !zoom.isScaling) {
              if (
                swiper.isHorizontal()
                && (
                  (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x)
                  || (Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)
                )
              ) {
                image.isTouched = false;
                return;
              } if (
                !swiper.isHorizontal()
                && (
                  (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y)
                  || (Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)
                )
              ) {
                image.isTouched = false;
                return;
              }
            }
            if (e.cancelable) {
              e.preventDefault();
            }
            e.stopPropagation();
    
            image.isMoved = true;
            image.currentX = (image.touchesCurrent.x - image.touchesStart.x) + image.startX;
            image.currentY = (image.touchesCurrent.y - image.touchesStart.y) + image.startY;
    
            if (image.currentX < image.minX) {
              image.currentX = (image.minX + 1) - (Math.pow( ((image.minX - image.currentX) + 1), 0.8 ));
            }
            if (image.currentX > image.maxX) {
              image.currentX = (image.maxX - 1) + (Math.pow( ((image.currentX - image.maxX) + 1), 0.8 ));
            }
    
            if (image.currentY < image.minY) {
              image.currentY = (image.minY + 1) - (Math.pow( ((image.minY - image.currentY) + 1), 0.8 ));
            }
            if (image.currentY > image.maxY) {
              image.currentY = (image.maxY - 1) + (Math.pow( ((image.currentY - image.maxY) + 1), 0.8 ));
            }
    
            // Velocity
            if (!velocity.prevPositionX) { velocity.prevPositionX = image.touchesCurrent.x; }
            if (!velocity.prevPositionY) { velocity.prevPositionY = image.touchesCurrent.y; }
            if (!velocity.prevTime) { velocity.prevTime = Date.now(); }
            velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
            velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
            if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) { velocity.x = 0; }
            if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) { velocity.y = 0; }
            velocity.prevPositionX = image.touchesCurrent.x;
            velocity.prevPositionY = image.touchesCurrent.y;
            velocity.prevTime = Date.now();
    
            gesture.$imageWrapEl.transform(("translate3d(" + (image.currentX) + "px, " + (image.currentY) + "px,0)"));
          },
          onTouchEnd: function onTouchEnd() {
            var swiper = this;
            var zoom = swiper.zoom;
            var gesture = zoom.gesture;
            var image = zoom.image;
            var velocity = zoom.velocity;
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
            if (!image.isTouched || !image.isMoved) {
              image.isTouched = false;
              image.isMoved = false;
              return;
            }
            image.isTouched = false;
            image.isMoved = false;
            var momentumDurationX = 300;
            var momentumDurationY = 300;
            var momentumDistanceX = velocity.x * momentumDurationX;
            var newPositionX = image.currentX + momentumDistanceX;
            var momentumDistanceY = velocity.y * momentumDurationY;
            var newPositionY = image.currentY + momentumDistanceY;
    
            // Fix duration
            if (velocity.x !== 0) { momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x); }
            if (velocity.y !== 0) { momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y); }
            var momentumDuration = Math.max(momentumDurationX, momentumDurationY);
    
            image.currentX = newPositionX;
            image.currentY = newPositionY;
    
            // Define if we need image drag
            var scaledWidth = image.width * zoom.scale;
            var scaledHeight = image.height * zoom.scale;
            image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
            image.maxX = -image.minX;
            image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
            image.maxY = -image.minY;
            image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
            image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
    
            gesture.$imageWrapEl.transition(momentumDuration).transform(("translate3d(" + (image.currentX) + "px, " + (image.currentY) + "px,0)"));
          },
          onTransitionEnd: function onTransitionEnd() {
            var swiper = this;
            var zoom = swiper.zoom;
            var gesture = zoom.gesture;
            if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
              if (gesture.$imageEl) {
                gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
              }
              if (gesture.$imageWrapEl) {
                gesture.$imageWrapEl.transform('translate3d(0,0,0)');
              }
    
              zoom.scale = 1;
              zoom.currentScale = 1;
    
              gesture.$slideEl = undefined;
              gesture.$imageEl = undefined;
              gesture.$imageWrapEl = undefined;
            }
          },
          // Toggle Zoom
          toggle: function toggle(e) {
            var swiper = this;
            var zoom = swiper.zoom;
    
            if (zoom.scale && zoom.scale !== 1) {
              // Zoom Out
              zoom.out();
            } else {
              // Zoom In
              zoom.in(e);
            }
          },
          in: function in$1(e) {
            var swiper = this;
    
            var zoom = swiper.zoom;
            var params = swiper.params.zoom;
            var gesture = zoom.gesture;
            var image = zoom.image;
    
            if (!gesture.$slideEl) {
              if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
                gesture.$slideEl = swiper.$wrapperEl.children(("." + (swiper.params.slideActiveClass)));
              } else {
                gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
              }
              gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
              gesture.$imageWrapEl = gesture.$imageEl.parent(("." + (params.containerClass)));
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
    
            gesture.$slideEl.addClass(("" + (params.zoomedSlideClass)));
    
            var touchX;
            var touchY;
            var offsetX;
            var offsetY;
            var diffX;
            var diffY;
            var translateX;
            var translateY;
            var imageWidth;
            var imageHeight;
            var scaledWidth;
            var scaledHeight;
            var translateMinX;
            var translateMinY;
            var translateMaxX;
            var translateMaxY;
            var slideWidth;
            var slideHeight;
    
            if (typeof image.touchesStart.x === 'undefined' && e) {
              touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
              touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
            } else {
              touchX = image.touchesStart.x;
              touchY = image.touchesStart.y;
            }
    
            zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
            zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
            if (e) {
              slideWidth = gesture.$slideEl[0].offsetWidth;
              slideHeight = gesture.$slideEl[0].offsetHeight;
              offsetX = gesture.$slideEl.offset().left;
              offsetY = gesture.$slideEl.offset().top;
              diffX = (offsetX + (slideWidth / 2)) - touchX;
              diffY = (offsetY + (slideHeight / 2)) - touchY;
    
              imageWidth = gesture.$imageEl[0].offsetWidth;
              imageHeight = gesture.$imageEl[0].offsetHeight;
              scaledWidth = imageWidth * zoom.scale;
              scaledHeight = imageHeight * zoom.scale;
    
              translateMinX = Math.min(((slideWidth / 2) - (scaledWidth / 2)), 0);
              translateMinY = Math.min(((slideHeight / 2) - (scaledHeight / 2)), 0);
              translateMaxX = -translateMinX;
              translateMaxY = -translateMinY;
    
              translateX = diffX * zoom.scale;
              translateY = diffY * zoom.scale;
    
              if (translateX < translateMinX) {
                translateX = translateMinX;
              }
              if (translateX > translateMaxX) {
                translateX = translateMaxX;
              }
    
              if (translateY < translateMinY) {
                translateY = translateMinY;
              }
              if (translateY > translateMaxY) {
                translateY = translateMaxY;
              }
            } else {
              translateX = 0;
              translateY = 0;
            }
            gesture.$imageWrapEl.transition(300).transform(("translate3d(" + translateX + "px, " + translateY + "px,0)"));
            gesture.$imageEl.transition(300).transform(("translate3d(0,0,0) scale(" + (zoom.scale) + ")"));
          },
          out: function out() {
            var swiper = this;
    
            var zoom = swiper.zoom;
            var params = swiper.params.zoom;
            var gesture = zoom.gesture;
    
            if (!gesture.$slideEl) {
              if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
                gesture.$slideEl = swiper.$wrapperEl.children(("." + (swiper.params.slideActiveClass)));
              } else {
                gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
              }
              gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
              gesture.$imageWrapEl = gesture.$imageEl.parent(("." + (params.containerClass)));
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
    
            zoom.scale = 1;
            zoom.currentScale = 1;
            gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
            gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
            gesture.$slideEl.removeClass(("" + (params.zoomedSlideClass)));
            gesture.$slideEl = undefined;
          },
          // Attach/Detach Events
          enable: function enable() {
            var swiper = this;
            var zoom = swiper.zoom;
            if (zoom.enabled) { return; }
            zoom.enabled = true;
    
            var passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;
            var activeListenerWithCapture = Support.passiveListener ? { passive: false, capture: true } : true;
    
            var slideSelector = "." + (swiper.params.slideClass);
    
            // Scale image
            if (Support.gestures) {
              swiper.$wrapperEl.on('gesturestart', slideSelector, zoom.onGestureStart, passiveListener);
              swiper.$wrapperEl.on('gesturechange', slideSelector, zoom.onGestureChange, passiveListener);
              swiper.$wrapperEl.on('gestureend', slideSelector, zoom.onGestureEnd, passiveListener);
            } else if (swiper.touchEvents.start === 'touchstart') {
              swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
              swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
              swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);
              if (swiper.touchEvents.cancel) {
                swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
              }
            }
    
            // Move image
            swiper.$wrapperEl.on(swiper.touchEvents.move, ("." + (swiper.params.zoom.containerClass)), zoom.onTouchMove, activeListenerWithCapture);
          },
          disable: function disable() {
            var swiper = this;
            var zoom = swiper.zoom;
            if (!zoom.enabled) { return; }
    
            swiper.zoom.enabled = false;
    
            var passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;
            var activeListenerWithCapture = Support.passiveListener ? { passive: false, capture: true } : true;
    
            var slideSelector = "." + (swiper.params.slideClass);
    
            // Scale image
            if (Support.gestures) {
              swiper.$wrapperEl.off('gesturestart', slideSelector, zoom.onGestureStart, passiveListener);
              swiper.$wrapperEl.off('gesturechange', slideSelector, zoom.onGestureChange, passiveListener);
              swiper.$wrapperEl.off('gestureend', slideSelector, zoom.onGestureEnd, passiveListener);
            } else if (swiper.touchEvents.start === 'touchstart') {
              swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
              swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
              swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);
              if (swiper.touchEvents.cancel) {
                swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
              }
            }
    
            // Move image
            swiper.$wrapperEl.off(swiper.touchEvents.move, ("." + (swiper.params.zoom.containerClass)), zoom.onTouchMove, activeListenerWithCapture);
          },
        };
    
        var Zoom$1 = {
          name: 'zoom',
          params: {
            zoom: {
              enabled: false,
              maxRatio: 3,
              minRatio: 1,
              toggle: true,
              containerClass: 'swiper-zoom-container',
              zoomedSlideClass: 'swiper-slide-zoomed',
            },
          },
          create: function create() {
            var swiper = this;
            var zoom = {
              enabled: false,
              scale: 1,
              currentScale: 1,
              isScaling: false,
              gesture: {
                $slideEl: undefined,
                slideWidth: undefined,
                slideHeight: undefined,
                $imageEl: undefined,
                $imageWrapEl: undefined,
                maxRatio: 3,
              },
              image: {
                isTouched: undefined,
                isMoved: undefined,
                currentX: undefined,
                currentY: undefined,
                minX: undefined,
                minY: undefined,
                maxX: undefined,
                maxY: undefined,
                width: undefined,
                height: undefined,
                startX: undefined,
                startY: undefined,
                touchesStart: {},
                touchesCurrent: {},
              },
              velocity: {
                x: undefined,
                y: undefined,
                prevPositionX: undefined,
                prevPositionY: undefined,
                prevTime: undefined,
              },
            };
    
            ('onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out').split(' ').forEach(function (methodName) {
              zoom[methodName] = Zoom[methodName].bind(swiper);
            });
            Utils.extend(swiper, {
              zoom: zoom,
            });
    
            var scale = 1;
            Object.defineProperty(swiper.zoom, 'scale', {
              get: function get() {
                return scale;
              },
              set: function set(value) {
                if (scale !== value) {
                  var imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : undefined;
                  var slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : undefined;
                  swiper.emit('zoomChange', value, imageEl, slideEl);
                }
                scale = value;
              },
            });
          },
          on: {
            init: function init() {
              var swiper = this;
              if (swiper.params.zoom.enabled) {
                swiper.zoom.enable();
              }
            },
            destroy: function destroy() {
              var swiper = this;
              swiper.zoom.disable();
            },
            touchStart: function touchStart(e) {
              var swiper = this;
              if (!swiper.zoom.enabled) { return; }
              swiper.zoom.onTouchStart(e);
            },
            touchEnd: function touchEnd(e) {
              var swiper = this;
              if (!swiper.zoom.enabled) { return; }
              swiper.zoom.onTouchEnd(e);
            },
            doubleTap: function doubleTap(e) {
              var swiper = this;
              if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
                swiper.zoom.toggle(e);
              }
            },
            transitionEnd: function transitionEnd() {
              var swiper = this;
              if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
                swiper.zoom.onTransitionEnd();
              }
            },
            slideChange: function slideChange() {
              var swiper = this;
              if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
                swiper.zoom.onTransitionEnd();
              }
            },
          },
        };
    
        var Lazy = {
          loadInSlide: function loadInSlide(index, loadInDuplicate) {
            if ( loadInDuplicate === void 0 ) loadInDuplicate = true;
    
            var swiper = this;
            var params = swiper.params.lazy;
            if (typeof index === 'undefined') { return; }
            if (swiper.slides.length === 0) { return; }
            var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    
            var $slideEl = isVirtual
              ? swiper.$wrapperEl.children(("." + (swiper.params.slideClass) + "[data-swiper-slide-index=\"" + index + "\"]"))
              : swiper.slides.eq(index);
    
            var $images = $slideEl.find(("." + (params.elementClass) + ":not(." + (params.loadedClass) + "):not(." + (params.loadingClass) + ")"));
            if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
              $images = $images.add($slideEl[0]);
            }
            if ($images.length === 0) { return; }
    
            $images.each(function (imageIndex, imageEl) {
              var $imageEl = $(imageEl);
              $imageEl.addClass(params.loadingClass);
    
              var background = $imageEl.attr('data-background');
              var src = $imageEl.attr('data-src');
              var srcset = $imageEl.attr('data-srcset');
              var sizes = $imageEl.attr('data-sizes');
              var $pictureEl = $imageEl.parent('picture');
    
              swiper.loadImage($imageEl[0], (src || background), srcset, sizes, false, function () {
                if (typeof swiper === 'undefined' || swiper === null || !swiper || (swiper && !swiper.params) || swiper.destroyed) { return; }
                if (background) {
                  $imageEl.css('background-image', ("url(\"" + background + "\")"));
                  $imageEl.removeAttr('data-background');
                } else {
                  if (srcset) {
                    $imageEl.attr('srcset', srcset);
                    $imageEl.removeAttr('data-srcset');
                  }
                  if (sizes) {
                    $imageEl.attr('sizes', sizes);
                    $imageEl.removeAttr('data-sizes');
                  }
                  if ($pictureEl.length) {
                    $pictureEl.children('source').each(function (sourceIndex, sourceEl) {
                      var $source = $(sourceEl);
    
                      if ($source.attr('data-srcset')) {
                        $source.attr('srcset', $source.attr('data-srcset'));
                        $source.removeAttr('data-srcset');
                      }
                    });
                  }
                  if (src) {
                    $imageEl.attr('src', src);
                    $imageEl.removeAttr('data-src');
                  }
                }
    
                $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
                $slideEl.find(("." + (params.preloaderClass))).remove();
                if (swiper.params.loop && loadInDuplicate) {
                  var slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');
                  if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
                    var originalSlide = swiper.$wrapperEl.children(("[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]:not(." + (swiper.params.slideDuplicateClass) + ")"));
                    swiper.lazy.loadInSlide(originalSlide.index(), false);
                  } else {
                    var duplicatedSlide = swiper.$wrapperEl.children(("." + (swiper.params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]"));
                    swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
                  }
                }
                swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);
                if (swiper.params.autoHeight) {
                  swiper.updateAutoHeight();
                }
              });
    
              swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
            });
          },
          load: function load() {
            var swiper = this;
            var $wrapperEl = swiper.$wrapperEl;
            var swiperParams = swiper.params;
            var slides = swiper.slides;
            var activeIndex = swiper.activeIndex;
            var isVirtual = swiper.virtual && swiperParams.virtual.enabled;
            var params = swiperParams.lazy;
    
            var slidesPerView = swiperParams.slidesPerView;
            if (slidesPerView === 'auto') {
              slidesPerView = 0;
            }
    
            function slideExist(index) {
              if (isVirtual) {
                if ($wrapperEl.children(("." + (swiperParams.slideClass) + "[data-swiper-slide-index=\"" + index + "\"]")).length) {
                  return true;
                }
              } else if (slides[index]) { return true; }
              return false;
            }
    
            function slideIndex(slideEl) {
              if (isVirtual) {
                return $(slideEl).attr('data-swiper-slide-index');
              }
              return $(slideEl).index();
            }
    
            if (!swiper.lazy.initialImageLoaded) { swiper.lazy.initialImageLoaded = true; }
            if (swiper.params.watchSlidesVisibility) {
              $wrapperEl.children(("." + (swiperParams.slideVisibleClass))).each(function (elIndex, slideEl) {
                var index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();
                swiper.lazy.loadInSlide(index);
              });
            } else if (slidesPerView > 1) {
              for (var i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
                if (slideExist(i)) { swiper.lazy.loadInSlide(i); }
              }
            } else {
              swiper.lazy.loadInSlide(activeIndex);
            }
            if (params.loadPrevNext) {
              if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {
                var amount = params.loadPrevNextAmount;
                var spv = slidesPerView;
                var maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
                var minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
                // Next Slides
                for (var i$1 = activeIndex + slidesPerView; i$1 < maxIndex; i$1 += 1) {
                  if (slideExist(i$1)) { swiper.lazy.loadInSlide(i$1); }
                }
                // Prev Slides
                for (var i$2 = minIndex; i$2 < activeIndex; i$2 += 1) {
                  if (slideExist(i$2)) { swiper.lazy.loadInSlide(i$2); }
                }
              } else {
                var nextSlide = $wrapperEl.children(("." + (swiperParams.slideNextClass)));
                if (nextSlide.length > 0) { swiper.lazy.loadInSlide(slideIndex(nextSlide)); }
    
                var prevSlide = $wrapperEl.children(("." + (swiperParams.slidePrevClass)));
                if (prevSlide.length > 0) { swiper.lazy.loadInSlide(slideIndex(prevSlide)); }
              }
            }
          },
        };
    
        var Lazy$1 = {
          name: 'lazy',
          params: {
            lazy: {
              enabled: false,
              loadPrevNext: false,
              loadPrevNextAmount: 1,
              loadOnTransitionStart: false,
    
              elementClass: 'swiper-lazy',
              loadingClass: 'swiper-lazy-loading',
              loadedClass: 'swiper-lazy-loaded',
              preloaderClass: 'swiper-lazy-preloader',
            },
          },
          create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
              lazy: {
                initialImageLoaded: false,
                load: Lazy.load.bind(swiper),
                loadInSlide: Lazy.loadInSlide.bind(swiper),
              },
            });
          },
          on: {
            beforeInit: function beforeInit() {
              var swiper = this;
              if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
                swiper.params.preloadImages = false;
              }
            },
            init: function init() {
              var swiper = this;
              if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
                swiper.lazy.load();
              }
            },
            scroll: function scroll() {
              var swiper = this;
              if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
                swiper.lazy.load();
              }
            },
            resize: function resize() {
              var swiper = this;
              if (swiper.params.lazy.enabled) {
                swiper.lazy.load();
              }
            },
            scrollbarDragMove: function scrollbarDragMove() {
              var swiper = this;
              if (swiper.params.lazy.enabled) {
                swiper.lazy.load();
              }
            },
            transitionStart: function transitionStart() {
              var swiper = this;
              if (swiper.params.lazy.enabled) {
                if (swiper.params.lazy.loadOnTransitionStart || (!swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded)) {
                  swiper.lazy.load();
                }
              }
            },
            transitionEnd: function transitionEnd() {
              var swiper = this;
              if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
                swiper.lazy.load();
              }
            },
            slideChange: function slideChange() {
              var swiper = this;
              if (swiper.params.lazy.enabled && swiper.params.cssMode) {
                swiper.lazy.load();
              }
            },
          },
        };
    
        /* eslint no-bitwise: ["error", { "allow": [">>"] }] */
    
        var Controller = {
          LinearSpline: function LinearSpline(x, y) {
            var binarySearch = (function search() {
              var maxIndex;
              var minIndex;
              var guess;
              return function (array, val) {
                minIndex = -1;
                maxIndex = array.length;
                while (maxIndex - minIndex > 1) {
                  guess = maxIndex + minIndex >> 1;
                  if (array[guess] <= val) {
                    minIndex = guess;
                  } else {
                    maxIndex = guess;
                  }
                }
                return maxIndex;
              };
            }());
            this.x = x;
            this.y = y;
            this.lastIndex = x.length - 1;
            // Given an x value (x2), return the expected y2 value:
            // (x1,y1) is the known point before given value,
            // (x3,y3) is the known point after given value.
            var i1;
            var i3;
    
            this.interpolate = function interpolate(x2) {
              if (!x2) { return 0; }
    
              // Get the indexes of x1 and x3 (the array indexes before and after given x2):
              i3 = binarySearch(this.x, x2);
              i1 = i3 - 1;
    
              // We have our indexes i1 & i3, so we can calculate already:
              // y2 := ((x2x1)  (y3y1))  (x3x1) + y1
              return (((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1])) + this.y[i1];
            };
            return this;
          },
          // xxx: for now i will just save one spline function to to
          getInterpolateFunction: function getInterpolateFunction(c) {
            var swiper = this;
            if (!swiper.controller.spline) {
              swiper.controller.spline = swiper.params.loop
                ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid)
                : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
            }
          },
          setTranslate: function setTranslate(setTranslate$1, byController) {
            var swiper = this;
            var controlled = swiper.controller.control;
            var multiplier;
            var controlledTranslate;
            function setControlledTranslate(c) {
              // this will create an Interpolate function based on the snapGrids
              // x is the Grid of the scrolled scroller and y will be the controlled scroller
              // it makes sense to create this only once and recall it for the interpolation
              // the function does a lot of value caching for performance
              var translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
              if (swiper.params.controller.by === 'slide') {
                swiper.controller.getInterpolateFunction(c);
                // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
                // but it did not work out
                controlledTranslate = -swiper.controller.spline.interpolate(-translate);
              }
    
              if (!controlledTranslate || swiper.params.controller.by === 'container') {
                multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
                controlledTranslate = ((translate - swiper.minTranslate()) * multiplier) + c.minTranslate();
              }
    
              if (swiper.params.controller.inverse) {
                controlledTranslate = c.maxTranslate() - controlledTranslate;
              }
              c.updateProgress(controlledTranslate);
              c.setTranslate(controlledTranslate, swiper);
              c.updateActiveIndex();
              c.updateSlidesClasses();
            }
            if (Array.isArray(controlled)) {
              for (var i = 0; i < controlled.length; i += 1) {
                if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                  setControlledTranslate(controlled[i]);
                }
              }
            } else if (controlled instanceof Swiper && byController !== controlled) {
              setControlledTranslate(controlled);
            }
          },
          setTransition: function setTransition(duration, byController) {
            var swiper = this;
            var controlled = swiper.controller.control;
            var i;
            function setControlledTransition(c) {
              c.setTransition(duration, swiper);
              if (duration !== 0) {
                c.transitionStart();
                if (c.params.autoHeight) {
                  Utils.nextTick(function () {
                    c.updateAutoHeight();
                  });
                }
                c.$wrapperEl.transitionEnd(function () {
                  if (!controlled) { return; }
                  if (c.params.loop && swiper.params.controller.by === 'slide') {
                    c.loopFix();
                  }
                  c.transitionEnd();
                });
              }
            }
            if (Array.isArray(controlled)) {
              for (i = 0; i < controlled.length; i += 1) {
                if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                  setControlledTransition(controlled[i]);
                }
              }
            } else if (controlled instanceof Swiper && byController !== controlled) {
              setControlledTransition(controlled);
            }
          },
        };
        var Controller$1 = {
          name: 'controller',
          params: {
            controller: {
              control: undefined,
              inverse: false,
              by: 'slide', // or 'container'
            },
          },
          create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
              controller: {
                control: swiper.params.controller.control,
                getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),
                setTranslate: Controller.setTranslate.bind(swiper),
                setTransition: Controller.setTransition.bind(swiper),
              },
            });
          },
          on: {
            update: function update() {
              var swiper = this;
              if (!swiper.controller.control) { return; }
              if (swiper.controller.spline) {
                swiper.controller.spline = undefined;
                delete swiper.controller.spline;
              }
            },
            resize: function resize() {
              var swiper = this;
              if (!swiper.controller.control) { return; }
              if (swiper.controller.spline) {
                swiper.controller.spline = undefined;
                delete swiper.controller.spline;
              }
            },
            observerUpdate: function observerUpdate() {
              var swiper = this;
              if (!swiper.controller.control) { return; }
              if (swiper.controller.spline) {
                swiper.controller.spline = undefined;
                delete swiper.controller.spline;
              }
            },
            setTranslate: function setTranslate(translate, byController) {
              var swiper = this;
              if (!swiper.controller.control) { return; }
              swiper.controller.setTranslate(translate, byController);
            },
            setTransition: function setTransition(duration, byController) {
              var swiper = this;
              if (!swiper.controller.control) { return; }
              swiper.controller.setTransition(duration, byController);
            },
          },
        };
    
        var a11y = {
          makeElFocusable: function makeElFocusable($el) {
            $el.attr('tabIndex', '0');
            return $el;
          },
          makeElNotFocusable: function makeElNotFocusable($el) {
            $el.attr('tabIndex', '-1');
            return $el;
          },
          addElRole: function addElRole($el, role) {
            $el.attr('role', role);
            return $el;
          },
          addElLabel: function addElLabel($el, label) {
            $el.attr('aria-label', label);
            return $el;
          },
          disableEl: function disableEl($el) {
            $el.attr('aria-disabled', true);
            return $el;
          },
          enableEl: function enableEl($el) {
            $el.attr('aria-disabled', false);
            return $el;
          },
          onEnterKey: function onEnterKey(e) {
            var swiper = this;
            var params = swiper.params.a11y;
            if (e.keyCode !== 13) { return; }
            var $targetEl = $(e.target);
            if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
              if (!(swiper.isEnd && !swiper.params.loop)) {
                swiper.slideNext();
              }
              if (swiper.isEnd) {
                swiper.a11y.notify(params.lastSlideMessage);
              } else {
                swiper.a11y.notify(params.nextSlideMessage);
              }
            }
            if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
              if (!(swiper.isBeginning && !swiper.params.loop)) {
                swiper.slidePrev();
              }
              if (swiper.isBeginning) {
                swiper.a11y.notify(params.firstSlideMessage);
              } else {
                swiper.a11y.notify(params.prevSlideMessage);
              }
            }
            if (swiper.pagination && $targetEl.is(("." + (swiper.params.pagination.bulletClass)))) {
              $targetEl[0].click();
            }
          },
          notify: function notify(message) {
            var swiper = this;
            var notification = swiper.a11y.liveRegion;
            if (notification.length === 0) { return; }
            notification.html('');
            notification.html(message);
          },
          updateNavigation: function updateNavigation() {
            var swiper = this;
    
            if (swiper.params.loop || !swiper.navigation) { return; }
            var ref = swiper.navigation;
            var $nextEl = ref.$nextEl;
            var $prevEl = ref.$prevEl;
    
            if ($prevEl && $prevEl.length > 0) {
              if (swiper.isBeginning) {
                swiper.a11y.disableEl($prevEl);
                swiper.a11y.makeElNotFocusable($prevEl);
              } else {
                swiper.a11y.enableEl($prevEl);
                swiper.a11y.makeElFocusable($prevEl);
              }
            }
            if ($nextEl && $nextEl.length > 0) {
              if (swiper.isEnd) {
                swiper.a11y.disableEl($nextEl);
                swiper.a11y.makeElNotFocusable($nextEl);
              } else {
                swiper.a11y.enableEl($nextEl);
                swiper.a11y.makeElFocusable($nextEl);
              }
            }
          },
          updatePagination: function updatePagination() {
            var swiper = this;
            var params = swiper.params.a11y;
            if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
              swiper.pagination.bullets.each(function (bulletIndex, bulletEl) {
                var $bulletEl = $(bulletEl);
                swiper.a11y.makeElFocusable($bulletEl);
                swiper.a11y.addElRole($bulletEl, 'button');
                swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1));
              });
            }
          },
          init: function init() {
            var swiper = this;
    
            swiper.$el.append(swiper.a11y.liveRegion);
    
            // Navigation
            var params = swiper.params.a11y;
            var $nextEl;
            var $prevEl;
            if (swiper.navigation && swiper.navigation.$nextEl) {
              $nextEl = swiper.navigation.$nextEl;
            }
            if (swiper.navigation && swiper.navigation.$prevEl) {
              $prevEl = swiper.navigation.$prevEl;
            }
            if ($nextEl) {
              swiper.a11y.makeElFocusable($nextEl);
              swiper.a11y.addElRole($nextEl, 'button');
              swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
              $nextEl.on('keydown', swiper.a11y.onEnterKey);
            }
            if ($prevEl) {
              swiper.a11y.makeElFocusable($prevEl);
              swiper.a11y.addElRole($prevEl, 'button');
              swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
              $prevEl.on('keydown', swiper.a11y.onEnterKey);
            }
    
            // Pagination
            if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
              swiper.pagination.$el.on('keydown', ("." + (swiper.params.pagination.bulletClass)), swiper.a11y.onEnterKey);
            }
          },
          destroy: function destroy() {
            var swiper = this;
            if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) { swiper.a11y.liveRegion.remove(); }
    
            var $nextEl;
            var $prevEl;
            if (swiper.navigation && swiper.navigation.$nextEl) {
              $nextEl = swiper.navigation.$nextEl;
            }
            if (swiper.navigation && swiper.navigation.$prevEl) {
              $prevEl = swiper.navigation.$prevEl;
            }
            if ($nextEl) {
              $nextEl.off('keydown', swiper.a11y.onEnterKey);
            }
            if ($prevEl) {
              $prevEl.off('keydown', swiper.a11y.onEnterKey);
            }
    
            // Pagination
            if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
              swiper.pagination.$el.off('keydown', ("." + (swiper.params.pagination.bulletClass)), swiper.a11y.onEnterKey);
            }
          },
        };
        var A11y = {
          name: 'a11y',
          params: {
            a11y: {
              enabled: true,
              notificationClass: 'swiper-notification',
              prevSlideMessage: 'Previous slide',
              nextSlideMessage: 'Next slide',
              firstSlideMessage: 'This is the first slide',
              lastSlideMessage: 'This is the last slide',
              paginationBulletMessage: 'Go to slide {{index}}',
            },
          },
          create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
              a11y: {
                liveRegion: $(("<span class=\"" + (swiper.params.a11y.notificationClass) + "\" aria-live=\"assertive\" aria-atomic=\"true\"></span>")),
              },
            });
            Object.keys(a11y).forEach(function (methodName) {
              swiper.a11y[methodName] = a11y[methodName].bind(swiper);
            });
          },
          on: {
            init: function init() {
              var swiper = this;
              if (!swiper.params.a11y.enabled) { return; }
              swiper.a11y.init();
              swiper.a11y.updateNavigation();
            },
            toEdge: function toEdge() {
              var swiper = this;
              if (!swiper.params.a11y.enabled) { return; }
              swiper.a11y.updateNavigation();
            },
            fromEdge: function fromEdge() {
              var swiper = this;
              if (!swiper.params.a11y.enabled) { return; }
              swiper.a11y.updateNavigation();
            },
            paginationUpdate: function paginationUpdate() {
              var swiper = this;
              if (!swiper.params.a11y.enabled) { return; }
              swiper.a11y.updatePagination();
            },
            destroy: function destroy() {
              var swiper = this;
              if (!swiper.params.a11y.enabled) { return; }
              swiper.a11y.destroy();
            },
          },
        };
    
        var History = {
          init: function init() {
            var swiper = this;
            if (!swiper.params.history) { return; }
            if (!win.history || !win.history.pushState) {
              swiper.params.history.enabled = false;
              swiper.params.hashNavigation.enabled = true;
              return;
            }
            var history = swiper.history;
            history.initialized = true;
            history.paths = History.getPathValues();
            if (!history.paths.key && !history.paths.value) { return; }
            history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);
            if (!swiper.params.history.replaceState) {
              win.addEventListener('popstate', swiper.history.setHistoryPopState);
            }
          },
          destroy: function destroy() {
            var swiper = this;
            if (!swiper.params.history.replaceState) {
              win.removeEventListener('popstate', swiper.history.setHistoryPopState);
            }
          },
          setHistoryPopState: function setHistoryPopState() {
            var swiper = this;
            swiper.history.paths = History.getPathValues();
            swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);
          },
          getPathValues: function getPathValues() {
            var pathArray = win.location.pathname.slice(1).split('/').filter(function (part) { return part !== ''; });
            var total = pathArray.length;
            var key = pathArray[total - 2];
            var value = pathArray[total - 1];
            return { key: key, value: value };
          },
          setHistory: function setHistory(key, index) {
            var swiper = this;
            if (!swiper.history.initialized || !swiper.params.history.enabled) { return; }
            var slide = swiper.slides.eq(index);
            var value = History.slugify(slide.attr('data-history'));
            if (!win.location.pathname.includes(key)) {
              value = key + "/" + value;
            }
            var currentState = win.history.state;
            if (currentState && currentState.value === value) {
              return;
            }
            if (swiper.params.history.replaceState) {
              win.history.replaceState({ value: value }, null, value);
            } else {
              win.history.pushState({ value: value }, null, value);
            }
          },
          slugify: function slugify(text) {
            return text.toString()
              .replace(/\s+/g, '-')
              .replace(/[^\w-]+/g, '')
              .replace(/--+/g, '-')
              .replace(/^-+/, '')
              .replace(/-+$/, '');
          },
          scrollToSlide: function scrollToSlide(speed, value, runCallbacks) {
            var swiper = this;
            if (value) {
              for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
                var slide = swiper.slides.eq(i);
                var slideHistory = History.slugify(slide.attr('data-history'));
                if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
                  var index = slide.index();
                  swiper.slideTo(index, speed, runCallbacks);
                }
              }
            } else {
              swiper.slideTo(0, speed, runCallbacks);
            }
          },
        };
    
        var History$1 = {
          name: 'history',
          params: {
            history: {
              enabled: false,
              replaceState: false,
              key: 'slides',
            },
          },
          create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
              history: {
                init: History.init.bind(swiper),
                setHistory: History.setHistory.bind(swiper),
                setHistoryPopState: History.setHistoryPopState.bind(swiper),
                scrollToSlide: History.scrollToSlide.bind(swiper),
                destroy: History.destroy.bind(swiper),
              },
            });
          },
          on: {
            init: function init() {
              var swiper = this;
              if (swiper.params.history.enabled) {
                swiper.history.init();
              }
            },
            destroy: function destroy() {
              var swiper = this;
              if (swiper.params.history.enabled) {
                swiper.history.destroy();
              }
            },
            transitionEnd: function transitionEnd() {
              var swiper = this;
              if (swiper.history.initialized) {
                swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
              }
            },
            slideChange: function slideChange() {
              var swiper = this;
              if (swiper.history.initialized && swiper.params.cssMode) {
                swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
              }
            },
          },
        };
    
        var HashNavigation = {
          onHashCange: function onHashCange() {
            var swiper = this;
            swiper.emit('hashChange');
            var newHash = doc.location.hash.replace('#', '');
            var activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');
            if (newHash !== activeSlideHash) {
              var newIndex = swiper.$wrapperEl.children(("." + (swiper.params.slideClass) + "[data-hash=\"" + newHash + "\"]")).index();
              if (typeof newIndex === 'undefined') { return; }
              swiper.slideTo(newIndex);
            }
          },
          setHash: function setHash() {
            var swiper = this;
            if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) { return; }
            if (swiper.params.hashNavigation.replaceState && win.history && win.history.replaceState) {
              win.history.replaceState(null, null, (("#" + (swiper.slides.eq(swiper.activeIndex).attr('data-hash'))) || ''));
              swiper.emit('hashSet');
            } else {
              var slide = swiper.slides.eq(swiper.activeIndex);
              var hash = slide.attr('data-hash') || slide.attr('data-history');
              doc.location.hash = hash || '';
              swiper.emit('hashSet');
            }
          },
          init: function init() {
            var swiper = this;
            if (!swiper.params.hashNavigation.enabled || (swiper.params.history && swiper.params.history.enabled)) { return; }
            swiper.hashNavigation.initialized = true;
            var hash = doc.location.hash.replace('#', '');
            if (hash) {
              var speed = 0;
              for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
                var slide = swiper.slides.eq(i);
                var slideHash = slide.attr('data-hash') || slide.attr('data-history');
                if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
                  var index = slide.index();
                  swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
                }
              }
            }
            if (swiper.params.hashNavigation.watchState) {
              $(win).on('hashchange', swiper.hashNavigation.onHashCange);
            }
          },
          destroy: function destroy() {
            var swiper = this;
            if (swiper.params.hashNavigation.watchState) {
              $(win).off('hashchange', swiper.hashNavigation.onHashCange);
            }
          },
        };
        var HashNavigation$1 = {
          name: 'hash-navigation',
          params: {
            hashNavigation: {
              enabled: false,
              replaceState: false,
              watchState: false,
            },
          },
          create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
              hashNavigation: {
                initialized: false,
                init: HashNavigation.init.bind(swiper),
                destroy: HashNavigation.destroy.bind(swiper),
                setHash: HashNavigation.setHash.bind(swiper),
                onHashCange: HashNavigation.onHashCange.bind(swiper),
              },
            });
          },
          on: {
            init: function init() {
              var swiper = this;
              if (swiper.params.hashNavigation.enabled) {
                swiper.hashNavigation.init();
              }
            },
            destroy: function destroy() {
              var swiper = this;
              if (swiper.params.hashNavigation.enabled) {
                swiper.hashNavigation.destroy();
              }
            },
            transitionEnd: function transitionEnd() {
              var swiper = this;
              if (swiper.hashNavigation.initialized) {
                swiper.hashNavigation.setHash();
              }
            },
            slideChange: function slideChange() {
              var swiper = this;
              if (swiper.hashNavigation.initialized && swiper.params.cssMode) {
                swiper.hashNavigation.setHash();
              }
            },
          },
        };
    
        /* eslint no-underscore-dangle: "off" */
    
        var Autoplay = {
          run: function run() {
            var swiper = this;
            var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
            var delay = swiper.params.autoplay.delay;
            if ($activeSlideEl.attr('data-swiper-autoplay')) {
              delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
            }
            clearTimeout(swiper.autoplay.timeout);
            swiper.autoplay.timeout = Utils.nextTick(function () {
              if (swiper.params.autoplay.reverseDirection) {
                if (swiper.params.loop) {
                  swiper.loopFix();
                  swiper.slidePrev(swiper.params.speed, true, true);
                  swiper.emit('autoplay');
                } else if (!swiper.isBeginning) {
                  swiper.slidePrev(swiper.params.speed, true, true);
                  swiper.emit('autoplay');
                } else if (!swiper.params.autoplay.stopOnLastSlide) {
                  swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
                  swiper.emit('autoplay');
                } else {
                  swiper.autoplay.stop();
                }
              } else if (swiper.params.loop) {
                swiper.loopFix();
                swiper.slideNext(swiper.params.speed, true, true);
                swiper.emit('autoplay');
              } else if (!swiper.isEnd) {
                swiper.slideNext(swiper.params.speed, true, true);
                swiper.emit('autoplay');
              } else if (!swiper.params.autoplay.stopOnLastSlide) {
                swiper.slideTo(0, swiper.params.speed, true, true);
                swiper.emit('autoplay');
              } else {
                swiper.autoplay.stop();
              }
              if (swiper.params.cssMode && swiper.autoplay.running) { swiper.autoplay.run(); }
            }, delay);
          },
          start: function start() {
            var swiper = this;
            if (typeof swiper.autoplay.timeout !== 'undefined') { return false; }
            if (swiper.autoplay.running) { return false; }
            swiper.autoplay.running = true;
            swiper.emit('autoplayStart');
            swiper.autoplay.run();
            return true;
          },
          stop: function stop() {
            var swiper = this;
            if (!swiper.autoplay.running) { return false; }
            if (typeof swiper.autoplay.timeout === 'undefined') { return false; }
    
            if (swiper.autoplay.timeout) {
              clearTimeout(swiper.autoplay.timeout);
              swiper.autoplay.timeout = undefined;
            }
            swiper.autoplay.running = false;
            swiper.emit('autoplayStop');
            return true;
          },
          pause: function pause(speed) {
            var swiper = this;
            if (!swiper.autoplay.running) { return; }
            if (swiper.autoplay.paused) { return; }
            if (swiper.autoplay.timeout) { clearTimeout(swiper.autoplay.timeout); }
            swiper.autoplay.paused = true;
            if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
              swiper.autoplay.paused = false;
              swiper.autoplay.run();
            } else {
              swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);
              swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
            }
          },
        };
    
        var Autoplay$1 = {
          name: 'autoplay',
          params: {
            autoplay: {
              enabled: false,
              delay: 3000,
              waitForTransition: true,
              disableOnInteraction: true,
              stopOnLastSlide: false,
              reverseDirection: false,
            },
          },
          create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
              autoplay: {
                running: false,
                paused: false,
                run: Autoplay.run.bind(swiper),
                start: Autoplay.start.bind(swiper),
                stop: Autoplay.stop.bind(swiper),
                pause: Autoplay.pause.bind(swiper),
                onVisibilityChange: function onVisibilityChange() {
                  if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
                    swiper.autoplay.pause();
                  }
                  if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
                    swiper.autoplay.run();
                    swiper.autoplay.paused = false;
                  }
                },
                onTransitionEnd: function onTransitionEnd(e) {
                  if (!swiper || swiper.destroyed || !swiper.$wrapperEl) { return; }
                  if (e.target !== this) { return; }
                  swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);
                  swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
                  swiper.autoplay.paused = false;
                  if (!swiper.autoplay.running) {
                    swiper.autoplay.stop();
                  } else {
                    swiper.autoplay.run();
                  }
                },
              },
            });
          },
          on: {
            init: function init() {
              var swiper = this;
              if (swiper.params.autoplay.enabled) {
                swiper.autoplay.start();
                document.addEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
              }
            },
            beforeTransitionStart: function beforeTransitionStart(speed, internal) {
              var swiper = this;
              if (swiper.autoplay.running) {
                if (internal || !swiper.params.autoplay.disableOnInteraction) {
                  swiper.autoplay.pause(speed);
                } else {
                  swiper.autoplay.stop();
                }
              }
            },
            sliderFirstMove: function sliderFirstMove() {
              var swiper = this;
              if (swiper.autoplay.running) {
                if (swiper.params.autoplay.disableOnInteraction) {
                  swiper.autoplay.stop();
                } else {
                  swiper.autoplay.pause();
                }
              }
            },
            touchEnd: function touchEnd() {
              var swiper = this;
              if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
                swiper.autoplay.run();
              }
            },
            destroy: function destroy() {
              var swiper = this;
              if (swiper.autoplay.running) {
                swiper.autoplay.stop();
              }
              document.removeEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
            },
          },
        };
    
        var Fade = {
          setTranslate: function setTranslate() {
            var swiper = this;
            var slides = swiper.slides;
            for (var i = 0; i < slides.length; i += 1) {
              var $slideEl = swiper.slides.eq(i);
              var offset = $slideEl[0].swiperSlideOffset;
              var tx = -offset;
              if (!swiper.params.virtualTranslate) { tx -= swiper.translate; }
              var ty = 0;
              if (!swiper.isHorizontal()) {
                ty = tx;
                tx = 0;
              }
              var slideOpacity = swiper.params.fadeEffect.crossFade
                ? Math.max(1 - Math.abs($slideEl[0].progress), 0)
                : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
              $slideEl
                .css({
                  opacity: slideOpacity,
                })
                .transform(("translate3d(" + tx + "px, " + ty + "px, 0px)"));
            }
          },
          setTransition: function setTransition(duration) {
            var swiper = this;
            var slides = swiper.slides;
            var $wrapperEl = swiper.$wrapperEl;
            slides.transition(duration);
            if (swiper.params.virtualTranslate && duration !== 0) {
              var eventTriggered = false;
              slides.transitionEnd(function () {
                if (eventTriggered) { return; }
                if (!swiper || swiper.destroyed) { return; }
                eventTriggered = true;
                swiper.animating = false;
                var triggerEvents = ['webkitTransitionEnd', 'transitionend'];
                for (var i = 0; i < triggerEvents.length; i += 1) {
                  $wrapperEl.trigger(triggerEvents[i]);
                }
              });
            }
          },
        };
    
        var EffectFade = {
          name: 'effect-fade',
          params: {
            fadeEffect: {
              crossFade: false,
            },
          },
          create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
              fadeEffect: {
                setTranslate: Fade.setTranslate.bind(swiper),
                setTransition: Fade.setTransition.bind(swiper),
              },
            });
          },
          on: {
            beforeInit: function beforeInit() {
              var swiper = this;
              if (swiper.params.effect !== 'fade') { return; }
              swiper.classNames.push(((swiper.params.containerModifierClass) + "fade"));
              var overwriteParams = {
                slidesPerView: 1,
                slidesPerColumn: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: true,
                spaceBetween: 0,
                virtualTranslate: true,
              };
              Utils.extend(swiper.params, overwriteParams);
              Utils.extend(swiper.originalParams, overwriteParams);
            },
            setTranslate: function setTranslate() {
              var swiper = this;
              if (swiper.params.effect !== 'fade') { return; }
              swiper.fadeEffect.setTranslate();
            },
            setTransition: function setTransition(duration) {
              var swiper = this;
              if (swiper.params.effect !== 'fade') { return; }
              swiper.fadeEffect.setTransition(duration);
            },
          },
        };
    
        var Cube = {
          setTranslate: function setTranslate() {
            var swiper = this;
            var $el = swiper.$el;
            var $wrapperEl = swiper.$wrapperEl;
            var slides = swiper.slides;
            var swiperWidth = swiper.width;
            var swiperHeight = swiper.height;
            var rtl = swiper.rtlTranslate;
            var swiperSize = swiper.size;
            var params = swiper.params.cubeEffect;
            var isHorizontal = swiper.isHorizontal();
            var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            var wrapperRotate = 0;
            var $cubeShadowEl;
            if (params.shadow) {
              if (isHorizontal) {
                $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');
                if ($cubeShadowEl.length === 0) {
                  $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
                  $wrapperEl.append($cubeShadowEl);
                }
                $cubeShadowEl.css({ height: (swiperWidth + "px") });
              } else {
                $cubeShadowEl = $el.find('.swiper-cube-shadow');
                if ($cubeShadowEl.length === 0) {
                  $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
                  $el.append($cubeShadowEl);
                }
              }
            }
            for (var i = 0; i < slides.length; i += 1) {
              var $slideEl = slides.eq(i);
              var slideIndex = i;
              if (isVirtual) {
                slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
              }
              var slideAngle = slideIndex * 90;
              var round = Math.floor(slideAngle / 360);
              if (rtl) {
                slideAngle = -slideAngle;
                round = Math.floor(-slideAngle / 360);
              }
              var progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
              var tx = 0;
              var ty = 0;
              var tz = 0;
              if (slideIndex % 4 === 0) {
                tx = -round * 4 * swiperSize;
                tz = 0;
              } else if ((slideIndex - 1) % 4 === 0) {
                tx = 0;
                tz = -round * 4 * swiperSize;
              } else if ((slideIndex - 2) % 4 === 0) {
                tx = swiperSize + (round * 4 * swiperSize);
                tz = swiperSize;
              } else if ((slideIndex - 3) % 4 === 0) {
                tx = -swiperSize;
                tz = (3 * swiperSize) + (swiperSize * 4 * round);
              }
              if (rtl) {
                tx = -tx;
              }
    
              if (!isHorizontal) {
                ty = tx;
                tx = 0;
              }
    
              var transform = "rotateX(" + (isHorizontal ? 0 : -slideAngle) + "deg) rotateY(" + (isHorizontal ? slideAngle : 0) + "deg) translate3d(" + tx + "px, " + ty + "px, " + tz + "px)";
              if (progress <= 1 && progress > -1) {
                wrapperRotate = (slideIndex * 90) + (progress * 90);
                if (rtl) { wrapperRotate = (-slideIndex * 90) - (progress * 90); }
              }
              $slideEl.transform(transform);
              if (params.slideShadows) {
                // Set shadows
                var shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
                var shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
                if (shadowBefore.length === 0) {
                  shadowBefore = $(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'left' : 'top') + "\"></div>"));
                  $slideEl.append(shadowBefore);
                }
                if (shadowAfter.length === 0) {
                  shadowAfter = $(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'right' : 'bottom') + "\"></div>"));
                  $slideEl.append(shadowAfter);
                }
                if (shadowBefore.length) { shadowBefore[0].style.opacity = Math.max(-progress, 0); }
                if (shadowAfter.length) { shadowAfter[0].style.opacity = Math.max(progress, 0); }
              }
            }
            $wrapperEl.css({
              '-webkit-transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),
              '-moz-transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),
              '-ms-transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),
              'transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),
            });
    
            if (params.shadow) {
              if (isHorizontal) {
                $cubeShadowEl.transform(("translate3d(0px, " + ((swiperWidth / 2) + params.shadowOffset) + "px, " + (-swiperWidth / 2) + "px) rotateX(90deg) rotateZ(0deg) scale(" + (params.shadowScale) + ")"));
              } else {
                var shadowAngle = Math.abs(wrapperRotate) - (Math.floor(Math.abs(wrapperRotate) / 90) * 90);
                var multiplier = 1.5 - (
                  (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2)
                  + (Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2)
                );
                var scale1 = params.shadowScale;
                var scale2 = params.shadowScale / multiplier;
                var offset = params.shadowOffset;
                $cubeShadowEl.transform(("scale3d(" + scale1 + ", 1, " + scale2 + ") translate3d(0px, " + ((swiperHeight / 2) + offset) + "px, " + (-swiperHeight / 2 / scale2) + "px) rotateX(-90deg)"));
              }
            }
            var zFactor = (Browser.isSafari || Browser.isWebView) ? (-swiperSize / 2) : 0;
            $wrapperEl
              .transform(("translate3d(0px,0," + zFactor + "px) rotateX(" + (swiper.isHorizontal() ? 0 : wrapperRotate) + "deg) rotateY(" + (swiper.isHorizontal() ? -wrapperRotate : 0) + "deg)"));
          },
          setTransition: function setTransition(duration) {
            var swiper = this;
            var $el = swiper.$el;
            var slides = swiper.slides;
            slides
              .transition(duration)
              .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
              .transition(duration);
            if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
              $el.find('.swiper-cube-shadow').transition(duration);
            }
          },
        };
    
        var EffectCube = {
          name: 'effect-cube',
          params: {
            cubeEffect: {
              slideShadows: true,
              shadow: true,
              shadowOffset: 20,
              shadowScale: 0.94,
            },
          },
          create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
              cubeEffect: {
                setTranslate: Cube.setTranslate.bind(swiper),
                setTransition: Cube.setTransition.bind(swiper),
              },
            });
          },
          on: {
            beforeInit: function beforeInit() {
              var swiper = this;
              if (swiper.params.effect !== 'cube') { return; }
              swiper.classNames.push(((swiper.params.containerModifierClass) + "cube"));
              swiper.classNames.push(((swiper.params.containerModifierClass) + "3d"));
              var overwriteParams = {
                slidesPerView: 1,
                slidesPerColumn: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: true,
                resistanceRatio: 0,
                spaceBetween: 0,
                centeredSlides: false,
                virtualTranslate: true,
              };
              Utils.extend(swiper.params, overwriteParams);
              Utils.extend(swiper.originalParams, overwriteParams);
            },
            setTranslate: function setTranslate() {
              var swiper = this;
              if (swiper.params.effect !== 'cube') { return; }
              swiper.cubeEffect.setTranslate();
            },
            setTransition: function setTransition(duration) {
              var swiper = this;
              if (swiper.params.effect !== 'cube') { return; }
              swiper.cubeEffect.setTransition(duration);
            },
          },
        };
    
        var Flip = {
          setTranslate: function setTranslate() {
            var swiper = this;
            var slides = swiper.slides;
            var rtl = swiper.rtlTranslate;
            for (var i = 0; i < slides.length; i += 1) {
              var $slideEl = slides.eq(i);
              var progress = $slideEl[0].progress;
              if (swiper.params.flipEffect.limitRotation) {
                progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
              }
              var offset = $slideEl[0].swiperSlideOffset;
              var rotate = -180 * progress;
              var rotateY = rotate;
              var rotateX = 0;
              var tx = -offset;
              var ty = 0;
              if (!swiper.isHorizontal()) {
                ty = tx;
                tx = 0;
                rotateX = -rotateY;
                rotateY = 0;
              } else if (rtl) {
                rotateY = -rotateY;
              }
    
              $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
    
              if (swiper.params.flipEffect.slideShadows) {
                // Set shadows
                var shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
                var shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
                if (shadowBefore.length === 0) {
                  shadowBefore = $(("<div class=\"swiper-slide-shadow-" + (swiper.isHorizontal() ? 'left' : 'top') + "\"></div>"));
                  $slideEl.append(shadowBefore);
                }
                if (shadowAfter.length === 0) {
                  shadowAfter = $(("<div class=\"swiper-slide-shadow-" + (swiper.isHorizontal() ? 'right' : 'bottom') + "\"></div>"));
                  $slideEl.append(shadowAfter);
                }
                if (shadowBefore.length) { shadowBefore[0].style.opacity = Math.max(-progress, 0); }
                if (shadowAfter.length) { shadowAfter[0].style.opacity = Math.max(progress, 0); }
              }
              $slideEl
                .transform(("translate3d(" + tx + "px, " + ty + "px, 0px) rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)"));
            }
          },
          setTransition: function setTransition(duration) {
            var swiper = this;
            var slides = swiper.slides;
            var activeIndex = swiper.activeIndex;
            var $wrapperEl = swiper.$wrapperEl;
            slides
              .transition(duration)
              .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
              .transition(duration);
            if (swiper.params.virtualTranslate && duration !== 0) {
              var eventTriggered = false;
              // eslint-disable-next-line
              slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {
                if (eventTriggered) { return; }
                if (!swiper || swiper.destroyed) { return; }
                // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;
                eventTriggered = true;
                swiper.animating = false;
                var triggerEvents = ['webkitTransitionEnd', 'transitionend'];
                for (var i = 0; i < triggerEvents.length; i += 1) {
                  $wrapperEl.trigger(triggerEvents[i]);
                }
              });
            }
          },
        };
    
        var EffectFlip = {
          name: 'effect-flip',
          params: {
            flipEffect: {
              slideShadows: true,
              limitRotation: true,
            },
          },
          create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
              flipEffect: {
                setTranslate: Flip.setTranslate.bind(swiper),
                setTransition: Flip.setTransition.bind(swiper),
              },
            });
          },
          on: {
            beforeInit: function beforeInit() {
              var swiper = this;
              if (swiper.params.effect !== 'flip') { return; }
              swiper.classNames.push(((swiper.params.containerModifierClass) + "flip"));
              swiper.classNames.push(((swiper.params.containerModifierClass) + "3d"));
              var overwriteParams = {
                slidesPerView: 1,
                slidesPerColumn: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: true,
                spaceBetween: 0,
                virtualTranslate: true,
              };
              Utils.extend(swiper.params, overwriteParams);
              Utils.extend(swiper.originalParams, overwriteParams);
            },
            setTranslate: function setTranslate() {
              var swiper = this;
              if (swiper.params.effect !== 'flip') { return; }
              swiper.flipEffect.setTranslate();
            },
            setTransition: function setTransition(duration) {
              var swiper = this;
              if (swiper.params.effect !== 'flip') { return; }
              swiper.flipEffect.setTransition(duration);
            },
          },
        };
    
        var Coverflow = {
          setTranslate: function setTranslate() {
            var swiper = this;
            var swiperWidth = swiper.width;
            var swiperHeight = swiper.height;
            var slides = swiper.slides;
            var $wrapperEl = swiper.$wrapperEl;
            var slidesSizesGrid = swiper.slidesSizesGrid;
            var params = swiper.params.coverflowEffect;
            var isHorizontal = swiper.isHorizontal();
            var transform = swiper.translate;
            var center = isHorizontal ? -transform + (swiperWidth / 2) : -transform + (swiperHeight / 2);
            var rotate = isHorizontal ? params.rotate : -params.rotate;
            var translate = params.depth;
            // Each slide offset from center
            for (var i = 0, length = slides.length; i < length; i += 1) {
              var $slideEl = slides.eq(i);
              var slideSize = slidesSizesGrid[i];
              var slideOffset = $slideEl[0].swiperSlideOffset;
              var offsetMultiplier = ((center - slideOffset - (slideSize / 2)) / slideSize) * params.modifier;
    
              var rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
              var rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
              // var rotateZ = 0
              var translateZ = -translate * Math.abs(offsetMultiplier);
    
              var stretch = params.stretch;
              // Allow percentage to make a relative stretch for responsive sliders
              if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
                stretch = ((parseFloat(params.stretch) / 100) * slideSize);
              }
              var translateY = isHorizontal ? 0 : stretch * (offsetMultiplier);
              var translateX = isHorizontal ? stretch * (offsetMultiplier) : 0;
    
              var scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);
    
              // Fix for ultra small values
              if (Math.abs(translateX) < 0.001) { translateX = 0; }
              if (Math.abs(translateY) < 0.001) { translateY = 0; }
              if (Math.abs(translateZ) < 0.001) { translateZ = 0; }
              if (Math.abs(rotateY) < 0.001) { rotateY = 0; }
              if (Math.abs(rotateX) < 0.001) { rotateX = 0; }
              if (Math.abs(scale) < 0.001) { scale = 0; }
    
              var slideTransform = "translate3d(" + translateX + "px," + translateY + "px," + translateZ + "px)  rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg) scale(" + scale + ")";
    
              $slideEl.transform(slideTransform);
              $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
              if (params.slideShadows) {
                // Set shadows
                var $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
                var $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
                if ($shadowBeforeEl.length === 0) {
                  $shadowBeforeEl = $(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'left' : 'top') + "\"></div>"));
                  $slideEl.append($shadowBeforeEl);
                }
                if ($shadowAfterEl.length === 0) {
                  $shadowAfterEl = $(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'right' : 'bottom') + "\"></div>"));
                  $slideEl.append($shadowAfterEl);
                }
                if ($shadowBeforeEl.length) { $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0; }
                if ($shadowAfterEl.length) { $shadowAfterEl[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0; }
              }
            }
    
            // Set correct perspective for IE10
            if (Support.pointerEvents || Support.prefixedPointerEvents) {
              var ws = $wrapperEl[0].style;
              ws.perspectiveOrigin = center + "px 50%";
            }
          },
          setTransition: function setTransition(duration) {
            var swiper = this;
            swiper.slides
              .transition(duration)
              .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
              .transition(duration);
          },
        };
    
        var EffectCoverflow = {
          name: 'effect-coverflow',
          params: {
            coverflowEffect: {
              rotate: 50,
              stretch: 0,
              depth: 100,
              scale: 1,
              modifier: 1,
              slideShadows: true,
            },
          },
          create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
              coverflowEffect: {
                setTranslate: Coverflow.setTranslate.bind(swiper),
                setTransition: Coverflow.setTransition.bind(swiper),
              },
            });
          },
          on: {
            beforeInit: function beforeInit() {
              var swiper = this;
              if (swiper.params.effect !== 'coverflow') { return; }
    
              swiper.classNames.push(((swiper.params.containerModifierClass) + "coverflow"));
              swiper.classNames.push(((swiper.params.containerModifierClass) + "3d"));
    
              swiper.params.watchSlidesProgress = true;
              swiper.originalParams.watchSlidesProgress = true;
            },
            setTranslate: function setTranslate() {
              var swiper = this;
              if (swiper.params.effect !== 'coverflow') { return; }
              swiper.coverflowEffect.setTranslate();
            },
            setTransition: function setTransition(duration) {
              var swiper = this;
              if (swiper.params.effect !== 'coverflow') { return; }
              swiper.coverflowEffect.setTransition(duration);
            },
          },
        };
    
        var Thumbs = {
          init: function init() {
            var swiper = this;
            var ref = swiper.params;
            var thumbsParams = ref.thumbs;
            var SwiperClass = swiper.constructor;
            if (thumbsParams.swiper instanceof SwiperClass) {
              swiper.thumbs.swiper = thumbsParams.swiper;
              Utils.extend(swiper.thumbs.swiper.originalParams, {
                watchSlidesProgress: true,
                slideToClickedSlide: false,
              });
              Utils.extend(swiper.thumbs.swiper.params, {
                watchSlidesProgress: true,
                slideToClickedSlide: false,
              });
            } else if (Utils.isObject(thumbsParams.swiper)) {
              swiper.thumbs.swiper = new SwiperClass(Utils.extend({}, thumbsParams.swiper, {
                watchSlidesVisibility: true,
                watchSlidesProgress: true,
                slideToClickedSlide: false,
              }));
              swiper.thumbs.swiperCreated = true;
            }
            swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
            swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);
          },
          onThumbClick: function onThumbClick() {
            var swiper = this;
            var thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper) { return; }
            var clickedIndex = thumbsSwiper.clickedIndex;
            var clickedSlide = thumbsSwiper.clickedSlide;
            if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) { return; }
            if (typeof clickedIndex === 'undefined' || clickedIndex === null) { return; }
            var slideToIndex;
            if (thumbsSwiper.params.loop) {
              slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
            } else {
              slideToIndex = clickedIndex;
            }
            if (swiper.params.loop) {
              var currentIndex = swiper.activeIndex;
              if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
                swiper.loopFix();
                // eslint-disable-next-line
                swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
                currentIndex = swiper.activeIndex;
              }
              var prevIndex = swiper.slides.eq(currentIndex).prevAll(("[data-swiper-slide-index=\"" + slideToIndex + "\"]")).eq(0).index();
              var nextIndex = swiper.slides.eq(currentIndex).nextAll(("[data-swiper-slide-index=\"" + slideToIndex + "\"]")).eq(0).index();
              if (typeof prevIndex === 'undefined') { slideToIndex = nextIndex; }
              else if (typeof nextIndex === 'undefined') { slideToIndex = prevIndex; }
              else if (nextIndex - currentIndex < currentIndex - prevIndex) { slideToIndex = nextIndex; }
              else { slideToIndex = prevIndex; }
            }
            swiper.slideTo(slideToIndex);
          },
          update: function update(initial) {
            var swiper = this;
            var thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper) { return; }
    
            var slidesPerView = thumbsSwiper.params.slidesPerView === 'auto'
              ? thumbsSwiper.slidesPerViewDynamic()
              : thumbsSwiper.params.slidesPerView;
    
            var autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
            var useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
            if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
              var currentThumbsIndex = thumbsSwiper.activeIndex;
              var newThumbsIndex;
              var direction;
              if (thumbsSwiper.params.loop) {
                if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
                  thumbsSwiper.loopFix();
                  // eslint-disable-next-line
                  thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
                  currentThumbsIndex = thumbsSwiper.activeIndex;
                }
                // Find actual thumbs index to slide to
                var prevThumbsIndex = thumbsSwiper.slides
                  .eq(currentThumbsIndex)
                  .prevAll(("[data-swiper-slide-index=\"" + (swiper.realIndex) + "\"]")).eq(0)
                  .index();
                var nextThumbsIndex = thumbsSwiper.slides
                  .eq(currentThumbsIndex)
                  .nextAll(("[data-swiper-slide-index=\"" + (swiper.realIndex) + "\"]")).eq(0)
                  .index();
                if (typeof prevThumbsIndex === 'undefined') { newThumbsIndex = nextThumbsIndex; }
                else if (typeof nextThumbsIndex === 'undefined') { newThumbsIndex = prevThumbsIndex; }
                else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) { newThumbsIndex = currentThumbsIndex; }
                else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) { newThumbsIndex = nextThumbsIndex; }
                else { newThumbsIndex = prevThumbsIndex; }
                direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
              } else {
                newThumbsIndex = swiper.realIndex;
                direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
              }
              if (useOffset) {
                newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
              }
    
              if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
                if (thumbsSwiper.params.centeredSlides) {
                  if (newThumbsIndex > currentThumbsIndex) {
                    newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
                  } else {
                    newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
                  }
                } else if (newThumbsIndex > currentThumbsIndex) {
                  newThumbsIndex = newThumbsIndex - slidesPerView + 1;
                }
                thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
              }
            }
    
            // Activate thumbs
            var thumbsToActivate = 1;
            var thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
    
            if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
              thumbsToActivate = swiper.params.slidesPerView;
            }
    
            if (!swiper.params.thumbs.multipleActiveThumbs) {
              thumbsToActivate = 1;
            }
    
            thumbsToActivate = Math.floor(thumbsToActivate);
    
            thumbsSwiper.slides.removeClass(thumbActiveClass);
            if (thumbsSwiper.params.loop || (thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled)) {
              for (var i = 0; i < thumbsToActivate; i += 1) {
                thumbsSwiper.$wrapperEl.children(("[data-swiper-slide-index=\"" + (swiper.realIndex + i) + "\"]")).addClass(thumbActiveClass);
              }
            } else {
              for (var i$1 = 0; i$1 < thumbsToActivate; i$1 += 1) {
                thumbsSwiper.slides.eq(swiper.realIndex + i$1).addClass(thumbActiveClass);
              }
            }
          },
        };
        var Thumbs$1 = {
          name: 'thumbs',
          params: {
            thumbs: {
              swiper: null,
              multipleActiveThumbs: true,
              autoScrollOffset: 0,
              slideThumbActiveClass: 'swiper-slide-thumb-active',
              thumbsContainerClass: 'swiper-container-thumbs',
            },
          },
          create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
              thumbs: {
                swiper: null,
                init: Thumbs.init.bind(swiper),
                update: Thumbs.update.bind(swiper),
                onThumbClick: Thumbs.onThumbClick.bind(swiper),
              },
            });
          },
          on: {
            beforeInit: function beforeInit() {
              var swiper = this;
              var ref = swiper.params;
              var thumbs = ref.thumbs;
              if (!thumbs || !thumbs.swiper) { return; }
              swiper.thumbs.init();
              swiper.thumbs.update(true);
            },
            slideChange: function slideChange() {
              var swiper = this;
              if (!swiper.thumbs.swiper) { return; }
              swiper.thumbs.update();
            },
            update: function update() {
              var swiper = this;
              if (!swiper.thumbs.swiper) { return; }
              swiper.thumbs.update();
            },
            resize: function resize() {
              var swiper = this;
              if (!swiper.thumbs.swiper) { return; }
              swiper.thumbs.update();
            },
            observerUpdate: function observerUpdate() {
              var swiper = this;
              if (!swiper.thumbs.swiper) { return; }
              swiper.thumbs.update();
            },
            setTransition: function setTransition(duration) {
              var swiper = this;
              var thumbsSwiper = swiper.thumbs.swiper;
              if (!thumbsSwiper) { return; }
              thumbsSwiper.setTransition(duration);
            },
            beforeDestroy: function beforeDestroy() {
              var swiper = this;
              var thumbsSwiper = swiper.thumbs.swiper;
              if (!thumbsSwiper) { return; }
              if (swiper.thumbs.swiperCreated && thumbsSwiper) {
                thumbsSwiper.destroy();
              }
            },
          },
        };
    
        // Swiper Class
    
        var components = [
          Device$1,
          Support$1,
          Browser$1,
          Resize,
          Observer$1,
          Virtual$1,
          Keyboard$1,
          Mousewheel$1,
          Navigation$1,
          Pagination$1,
          Scrollbar$1,
          Parallax$1,
          Zoom$1,
          Lazy$1,
          Controller$1,
          A11y,
          History$1,
          HashNavigation$1,
          Autoplay$1,
          EffectFade,
          EffectCube,
          EffectFlip,
          EffectCoverflow,
          Thumbs$1
        ];
    
        if (typeof Swiper.use === 'undefined') {
          Swiper.use = Swiper.Class.use;
          Swiper.installModule = Swiper.Class.installModule;
        }
    
        Swiper.use(components);
    
        return Swiper;
    
    })));
    //# sourceMappingURL=swiper.js.map
    // ==================================================
    // fancyBox v3.3.5
    //
    // Licensed GPLv3 for open source use
    // or fancyBox Commercial License for commercial use
    //
    // http://fancyapps.com/fancybox/
    // Copyright 2018 fancyApps
    //
    // ==================================================
    !function(t,e,n,o){"use strict";function i(t,e){var o,i,a=[],s=0;t&&t.isDefaultPrevented()||(t.preventDefault(),e=t&&t.data?t.data.options:e||{},o=e.$target||n(t.currentTarget),i=o.attr("data-fancybox")||"",i?(a=e.selector?n(e.selector):t.data?t.data.items:[],a=a.length?a.filter('[data-fancybox="'+i+'"]'):n('[data-fancybox="'+i+'"]'),s=a.index(o),s<0&&(s=0)):a=[o],n.fancybox.open(a,e,s))}if(t.console=t.console||{info:function(t){}},n){if(n.fn.fancybox)return void console.info("fancyBox already initialized");var a={loop:!1,gutter:50,keyboard:!0,arrows:!0,infobar:!0,smallBtn:"auto",toolbar:"auto",buttons:["zoom","thumbs","close"],idleTime:3,protect:!1,modal:!1,image:{preload:!1},ajax:{settings:{data:{fancybox:!0}}},iframe:{tpl:'<iframe id="fancybox-frame{rnd}" name="fancybox-frame{rnd}" class="fancybox-iframe" frameborder="0" vspace="0" hspace="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen allowtransparency="true" src=""></iframe>',preload:!0,css:{},attr:{scrolling:"auto"}},defaultType:"image",animationEffect:"zoom",animationDuration:366,zoomOpacity:"auto",transitionEffect:"fade",transitionDuration:366,slideClass:"",baseClass:"",baseTpl:'<div class="fancybox-container" role="dialog" tabindex="-1"><div class="fancybox-bg"></div><div class="fancybox-inner"><div class="fancybox-infobar"><span data-fancybox-index></span>&nbsp;/&nbsp;<span data-fancybox-count></span></div><div class="fancybox-toolbar">{{buttons}}</div><div class="fancybox-navigation">{{arrows}}</div><div class="fancybox-stage"></div><div class="fancybox-caption"></div></div></div>',spinnerTpl:'<div class="fancybox-loading"></div>',errorTpl:'<div class="fancybox-error"><p>{{ERROR}}</p></div>',btnTpl:{download:'<a download data-fancybox-download class="fancybox-button fancybox-button--download" title="{{DOWNLOAD}}" href="javascript:;"><svg viewBox="0 0 40 40"><path d="M13,16 L20,23 L27,16 M20,7 L20,23 M10,24 L10,28 L30,28 L30,24" /></svg></a>',zoom:'<button data-fancybox-zoom class="fancybox-button fancybox-button--zoom" title="{{ZOOM}}"><svg viewBox="0 0 40 40"><path d="M18,17 m-8,0 a8,8 0 1,0 16,0 a8,8 0 1,0 -16,0 M24,22 L31,29" /></svg></button>',close:'<button data-fancybox-close class="fancybox-button fancybox-button--close" title="{{CLOSE}}"><svg viewBox="0 0 40 40"><path d="M10,10 L30,30 M30,10 L10,30" /></svg></button>',smallBtn:'<button data-fancybox-close class="fancybox-close-small" title="{{CLOSE}}"><svg viewBox="0 0 32 32"><path d="M10,10 L22,22 M22,10 L10,22"></path></svg></button>',arrowLeft:'<a data-fancybox-prev class="fancybox-button fancybox-button--arrow_left" title="{{PREV}}" href="javascript:;"><svg viewBox="0 0 40 40"><path d="M18,12 L10,20 L18,28 M10,20 L30,20"></path></svg></a>',arrowRight:'<a data-fancybox-next class="fancybox-button fancybox-button--arrow_right" title="{{NEXT}}" href="javascript:;"><svg viewBox="0 0 40 40"><path d="M10,20 L30,20 M22,12 L30,20 L22,28"></path></svg></a>'},parentEl:"body",autoFocus:!1,backFocus:!0,trapFocus:!0,fullScreen:{autoStart:!1},touch:{vertical:!0,momentum:!0},hash:null,media:{},slideShow:{autoStart:!1,speed:4e3},thumbs:{autoStart:!1,hideOnClose:!0,parentEl:".fancybox-container",axis:"y"},wheel:"auto",onInit:n.noop,beforeLoad:n.noop,afterLoad:n.noop,beforeShow:n.noop,afterShow:n.noop,beforeClose:n.noop,afterClose:n.noop,onActivate:n.noop,onDeactivate:n.noop,clickContent:function(t,e){return"image"===t.type&&"zoom"},clickSlide:"close",clickOutside:"close",dblclickContent:!1,dblclickSlide:!1,dblclickOutside:!1,mobile:{idleTime:!1,clickContent:function(t,e){return"image"===t.type&&"toggleControls"},clickSlide:function(t,e){return"image"===t.type?"toggleControls":"close"},dblclickContent:function(t,e){return"image"===t.type&&"zoom"},dblclickSlide:function(t,e){return"image"===t.type&&"zoom"}},lang:"en",i18n:{en:{CLOSE:"Close",NEXT:"Next",PREV:"Previous",ERROR:"The requested content cannot be loaded. <br/> Please try again later.",PLAY_START:"Start slideshow",PLAY_STOP:"Pause slideshow",FULL_SCREEN:"Full screen",THUMBS:"Thumbnails",DOWNLOAD:"Download",SHARE:"Share",ZOOM:"Zoom"},de:{CLOSE:"Schliessen",NEXT:"Weiter",PREV:"Zurck",ERROR:"Die angeforderten Daten konnten nicht geladen werden. <br/> Bitte versuchen Sie es spter nochmal.",PLAY_START:"Diaschau starten",PLAY_STOP:"Diaschau beenden",FULL_SCREEN:"Vollbild",THUMBS:"Vorschaubilder",DOWNLOAD:"Herunterladen",SHARE:"Teilen",ZOOM:"Mastab"}}},s=n(t),r=n(e),c=0,l=function(t){return t&&t.hasOwnProperty&&t instanceof n},d=function(){return t.requestAnimationFrame||t.webkitRequestAnimationFrame||t.mozRequestAnimationFrame||t.oRequestAnimationFrame||function(e){return t.setTimeout(e,1e3/60)}}(),u=function(){var t,n=e.createElement("fakeelement"),i={transition:"transitionend",OTransition:"oTransitionEnd",MozTransition:"transitionend",WebkitTransition:"webkitTransitionEnd"};for(t in i)if(n.style[t]!==o)return i[t];return"transitionend"}(),f=function(t){return t&&t.length&&t[0].offsetHeight},p=function(t,e){var o=n.extend(!0,{},t,e);return n.each(e,function(t,e){n.isArray(e)&&(o[t]=e)}),o},h=function(t,o,i){var a=this;a.opts=p({index:i},n.fancybox.defaults),n.isPlainObject(o)&&(a.opts=p(a.opts,o)),n.fancybox.isMobile&&(a.opts=p(a.opts,a.opts.mobile)),a.id=a.opts.id||++c,a.currIndex=parseInt(a.opts.index,10)||0,a.prevIndex=null,a.prevPos=null,a.currPos=0,a.firstRun=!0,a.group=[],a.slides={},a.addContent(t),a.group.length&&(a.$lastFocus=n(e.activeElement).trigger("blur"),a.init())};n.extend(h.prototype,{init:function(){var i,a,s,r=this,c=r.group[r.currIndex],l=c.opts,d=n.fancybox.scrollbarWidth;n.fancybox.getInstance()||l.hideScrollbar===!1||(n("body").addClass("fancybox-active"),!n.fancybox.isMobile&&e.body.scrollHeight>t.innerHeight&&(d===o&&(i=n('<div style="width:100px;height:100px;overflow:scroll;" />').appendTo("body"),d=n.fancybox.scrollbarWidth=i[0].offsetWidth-i[0].clientWidth,i.remove()),n("head").append('<style id="fancybox-style-noscroll" type="text/css">.compensate-for-scrollbar { margin-right: '+d+"px; }</style>"),n("body").addClass("compensate-for-scrollbar"))),s="",n.each(l.buttons,function(t,e){s+=l.btnTpl[e]||""}),a=n(r.translate(r,l.baseTpl.replace("{{buttons}}",s).replace("{{arrows}}",l.btnTpl.arrowLeft+l.btnTpl.arrowRight))).attr("id","fancybox-container-"+r.id).addClass("fancybox-is-hidden").addClass(l.baseClass).data("FancyBox",r).appendTo(l.parentEl),r.$refs={container:a},["bg","inner","infobar","toolbar","stage","caption","navigation"].forEach(function(t){r.$refs[t]=a.find(".fancybox-"+t)}),r.trigger("onInit"),r.activate(),r.jumpTo(r.currIndex)},translate:function(t,e){var n=t.opts.i18n[t.opts.lang];return e.replace(/\{\{(\w+)\}\}/g,function(t,e){var i=n[e];return i===o?t:i})},addContent:function(t){var e,i=this,a=n.makeArray(t);n.each(a,function(t,e){var a,s,r,c,l,d={},u={};n.isPlainObject(e)?(d=e,u=e.opts||e):"object"===n.type(e)&&n(e).length?(a=n(e),u=a.data()||{},u=n.extend(!0,{},u,u.options),u.$orig=a,d.src=i.opts.src||u.src||a.attr("href"),d.type||d.src||(d.type="inline",d.src=e)):d={type:"html",src:e+""},d.opts=n.extend(!0,{},i.opts,u),n.isArray(u.buttons)&&(d.opts.buttons=u.buttons),s=d.type||d.opts.type,c=d.src||"",!s&&c&&((r=c.match(/\.(mp4|mov|ogv)((\?|#).*)?$/i))?(s="video",d.opts.videoFormat||(d.opts.videoFormat="video/"+("ogv"===r[1]?"ogg":r[1]))):c.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i)?s="image":c.match(/\.(pdf)((\?|#).*)?$/i)?s="iframe":"#"===c.charAt(0)&&(s="inline")),s?d.type=s:i.trigger("objectNeedsType",d),d.contentType||(d.contentType=n.inArray(d.type,["html","inline","ajax"])>-1?"html":d.type),d.index=i.group.length,"auto"==d.opts.smallBtn&&(d.opts.smallBtn=n.inArray(d.type,["html","inline","ajax"])>-1),"auto"===d.opts.toolbar&&(d.opts.toolbar=!d.opts.smallBtn),d.opts.$trigger&&d.index===i.opts.index&&(d.opts.$thumb=d.opts.$trigger.find("img:first")),d.opts.$thumb&&d.opts.$thumb.length||!d.opts.$orig||(d.opts.$thumb=d.opts.$orig.find("img:first")),"function"===n.type(d.opts.caption)&&(d.opts.caption=d.opts.caption.apply(e,[i,d])),"function"===n.type(i.opts.caption)&&(d.opts.caption=i.opts.caption.apply(e,[i,d])),d.opts.caption instanceof n||(d.opts.caption=d.opts.caption===o?"":d.opts.caption+""),"ajax"===d.type&&(l=c.split(/\s+/,2),l.length>1&&(d.src=l.shift(),d.opts.filter=l.shift())),d.opts.modal&&(d.opts=n.extend(!0,d.opts,{infobar:0,toolbar:0,smallBtn:0,keyboard:0,slideShow:0,fullScreen:0,thumbs:0,touch:0,clickContent:!1,clickSlide:!1,clickOutside:!1,dblclickContent:!1,dblclickSlide:!1,dblclickOutside:!1})),i.group.push(d)}),Object.keys(i.slides).length&&(i.updateControls(),e=i.Thumbs,e&&e.isActive&&(e.create(),e.focus()))},addEvents:function(){var o=this;o.removeEvents(),o.$refs.container.on("click.fb-close","[data-fancybox-close]",function(t){t.stopPropagation(),t.preventDefault(),o.close(t)}).on("touchstart.fb-prev click.fb-prev","[data-fancybox-prev]",function(t){t.stopPropagation(),t.preventDefault(),o.previous()}).on("touchstart.fb-next click.fb-next","[data-fancybox-next]",function(t){t.stopPropagation(),t.preventDefault(),o.next()}).on("click.fb","[data-fancybox-zoom]",function(t){o[o.isScaledDown()?"scaleToActual":"scaleToFit"]()}),s.on("orientationchange.fb resize.fb",function(t){t&&t.originalEvent&&"resize"===t.originalEvent.type?d(function(){o.update()}):(o.$refs.stage.hide(),setTimeout(function(){o.$refs.stage.show(),o.update()},n.fancybox.isMobile?600:250))}),r.on("focusin.fb",function(t){var o=n.fancybox?n.fancybox.getInstance():null;o.isClosing||!o.current||!o.current.opts.trapFocus||n(t.target).hasClass("fancybox-container")||n(t.target).is(e)||o&&"fixed"!==n(t.target).css("position")&&!o.$refs.container.has(t.target).length&&(t.stopPropagation(),o.focus())}),r.on("keydown.fb",function(t){var e=o.current,i=t.keyCode||t.which;if(e&&e.opts.keyboard&&!(t.ctrlKey||t.altKey||t.shiftKey||n(t.target).is("input")||n(t.target).is("textarea")))return 8===i||27===i?(t.preventDefault(),void o.close(t)):37===i||38===i?(t.preventDefault(),void o.previous()):39===i||40===i?(t.preventDefault(),void o.next()):void o.trigger("afterKeydown",t,i)}),o.group[o.currIndex].opts.idleTime&&(o.idleSecondsCounter=0,r.on("mousemove.fb-idle mouseleave.fb-idle mousedown.fb-idle touchstart.fb-idle touchmove.fb-idle scroll.fb-idle keydown.fb-idle",function(t){o.idleSecondsCounter=0,o.isIdle&&o.showControls(),o.isIdle=!1}),o.idleInterval=t.setInterval(function(){o.idleSecondsCounter++,o.idleSecondsCounter>=o.group[o.currIndex].opts.idleTime&&!o.isDragging&&(o.isIdle=!0,o.idleSecondsCounter=0,o.hideControls())},1e3))},removeEvents:function(){var e=this;s.off("orientationchange.fb resize.fb"),r.off("focusin.fb keydown.fb .fb-idle"),this.$refs.container.off(".fb-close .fb-prev .fb-next"),e.idleInterval&&(t.clearInterval(e.idleInterval),e.idleInterval=null)},previous:function(t){return this.jumpTo(this.currPos-1,t)},next:function(t){return this.jumpTo(this.currPos+1,t)},jumpTo:function(t,e){var i,a,s,r,c,l,d,u=this,p=u.group.length;if(!(u.isDragging||u.isClosing||u.isAnimating&&u.firstRun)){if(t=parseInt(t,10),a=u.current?u.current.opts.loop:u.opts.loop,!a&&(t<0||t>=p))return!1;if(i=u.firstRun=!Object.keys(u.slides).length,!(p<2&&!i&&u.isDragging)){if(r=u.current,u.prevIndex=u.currIndex,u.prevPos=u.currPos,s=u.createSlide(t),p>1&&((a||s.index>0)&&u.createSlide(t-1),(a||s.index<p-1)&&u.createSlide(t+1)),u.current=s,u.currIndex=s.index,u.currPos=s.pos,u.trigger("beforeShow",i),u.updateControls(),l=n.fancybox.getTranslate(s.$slide),s.isMoved=(0!==l.left||0!==l.top)&&!s.$slide.hasClass("fancybox-animated"),s.forcedDuration=o,n.isNumeric(e)?s.forcedDuration=e:e=s.opts[i?"animationDuration":"transitionDuration"],e=parseInt(e,10),i)return s.opts.animationEffect&&e&&u.$refs.container.css("transition-duration",e+"ms"),u.$refs.container.removeClass("fancybox-is-hidden"),f(u.$refs.container),u.$refs.container.addClass("fancybox-is-open"),f(u.$refs.container),s.$slide.addClass("fancybox-slide--previous"),u.loadSlide(s),s.$slide.removeClass("fancybox-slide--previous").addClass("fancybox-slide--current"),void u.preload("image");n.each(u.slides,function(t,e){n.fancybox.stop(e.$slide)}),s.$slide.removeClass("fancybox-slide--next fancybox-slide--previous").addClass("fancybox-slide--current"),s.isMoved?(c=Math.round(s.$slide.width()),n.each(u.slides,function(t,o){var i=o.pos-s.pos;n.fancybox.animate(o.$slide,{top:0,left:i*c+i*o.opts.gutter},e,function(){o.$slide.removeAttr("style").removeClass("fancybox-slide--next fancybox-slide--previous"),o.pos===u.currPos&&(s.isMoved=!1,u.complete())})})):u.$refs.stage.children().removeAttr("style"),s.isLoaded?u.revealContent(s):u.loadSlide(s),u.preload("image"),r.pos!==s.pos&&(d="fancybox-slide--"+(r.pos>s.pos?"next":"previous"),r.$slide.removeClass("fancybox-slide--complete fancybox-slide--current fancybox-slide--next fancybox-slide--previous"),r.isComplete=!1,e&&(s.isMoved||s.opts.transitionEffect)&&(s.isMoved?r.$slide.addClass(d):(d="fancybox-animated "+d+" fancybox-fx-"+s.opts.transitionEffect,n.fancybox.animate(r.$slide,d,e,function(){r.$slide.removeClass(d).removeAttr("style")}))))}}},createSlide:function(t){var e,o,i=this;return o=t%i.group.length,o=o<0?i.group.length+o:o,!i.slides[t]&&i.group[o]&&(e=n('<div class="fancybox-slide"></div>').appendTo(i.$refs.stage),i.slides[t]=n.extend(!0,{},i.group[o],{pos:t,$slide:e,isLoaded:!1}),i.updateSlide(i.slides[t])),i.slides[t]},scaleToActual:function(t,e,i){var a,s,r,c,l,d=this,u=d.current,f=u.$content,p=n.fancybox.getTranslate(u.$slide).width,h=n.fancybox.getTranslate(u.$slide).height,g=u.width,b=u.height;!d.isAnimating&&f&&"image"==u.type&&u.isLoaded&&!u.hasError&&(n.fancybox.stop(f),d.isAnimating=!0,t=t===o?.5*p:t,e=e===o?.5*h:e,a=n.fancybox.getTranslate(f),a.top-=n.fancybox.getTranslate(u.$slide).top,a.left-=n.fancybox.getTranslate(u.$slide).left,c=g/a.width,l=b/a.height,s=.5*p-.5*g,r=.5*h-.5*b,g>p&&(s=a.left*c-(t*c-t),s>0&&(s=0),s<p-g&&(s=p-g)),b>h&&(r=a.top*l-(e*l-e),r>0&&(r=0),r<h-b&&(r=h-b)),d.updateCursor(g,b),n.fancybox.animate(f,{top:r,left:s,scaleX:c,scaleY:l},i||330,function(){d.isAnimating=!1}),d.SlideShow&&d.SlideShow.isActive&&d.SlideShow.stop())},scaleToFit:function(t){var e,o=this,i=o.current,a=i.$content;!o.isAnimating&&a&&"image"==i.type&&i.isLoaded&&!i.hasError&&(n.fancybox.stop(a),o.isAnimating=!0,e=o.getFitPos(i),o.updateCursor(e.width,e.height),n.fancybox.animate(a,{top:e.top,left:e.left,scaleX:e.width/a.width(),scaleY:e.height/a.height()},t||330,function(){o.isAnimating=!1}))},getFitPos:function(t){var e,n,o,i,a,s=this,r=t.$content,c=t.width||t.opts.width,l=t.height||t.opts.height,d={};return!!(t.isLoaded&&r&&r.length)&&(i={top:parseInt(t.$slide.css("paddingTop"),10),right:parseInt(t.$slide.css("paddingRight"),10),bottom:parseInt(t.$slide.css("paddingBottom"),10),left:parseInt(t.$slide.css("paddingLeft"),10)},e=parseInt(s.$refs.stage.width(),10)-(i.left+i.right),n=parseInt(s.$refs.stage.height(),10)-(i.top+i.bottom),c&&l||(c=e,l=n),o=Math.min(1,e/c,n/l),c=Math.floor(o*c),l=Math.floor(o*l),"image"===t.type?(d.top=Math.floor(.5*(n-l))+i.top,d.left=Math.floor(.5*(e-c))+i.left):"video"===t.contentType&&(a=t.opts.width&&t.opts.height?c/l:t.opts.ratio||16/9,l>c/a?l=c/a:c>l*a&&(c=l*a)),d.width=c,d.height=l,d)},update:function(){var t=this;n.each(t.slides,function(e,n){t.updateSlide(n)})},updateSlide:function(t,e){var o=this,i=t&&t.$content,a=t.width||t.opts.width,s=t.height||t.opts.height;i&&(a||s||"video"===t.contentType)&&!t.hasError&&(n.fancybox.stop(i),n.fancybox.setTranslate(i,o.getFitPos(t)),t.pos===o.currPos&&(o.isAnimating=!1,o.updateCursor())),t.$slide.trigger("refresh"),o.$refs.toolbar.toggleClass("compensate-for-scrollbar",t.$slide.get(0).scrollHeight>t.$slide.get(0).clientHeight),o.trigger("onUpdate",t)},centerSlide:function(t,e){var i,a,s=this;s.current&&(i=Math.round(t.$slide.width()),a=t.pos-s.current.pos,n.fancybox.animate(t.$slide,{top:0,left:a*i+a*t.opts.gutter,opacity:1},e===o?0:e,null,!1))},updateCursor:function(t,e){var o,i=this,a=i.current,s=i.$refs.container.removeClass("fancybox-is-zoomable fancybox-can-zoomIn fancybox-can-drag fancybox-can-zoomOut");a&&!i.isClosing&&(o=i.isZoomable(),s.toggleClass("fancybox-is-zoomable",o),n("[data-fancybox-zoom]").prop("disabled",!o),o&&("zoom"===a.opts.clickContent||n.isFunction(a.opts.clickContent)&&"zoom"===a.opts.clickContent(a))?i.isScaledDown(t,e)?s.addClass("fancybox-can-zoomIn"):a.opts.touch?s.addClass("fancybox-can-drag"):s.addClass("fancybox-can-zoomOut"):a.opts.touch&&"video"!==a.contentType&&s.addClass("fancybox-can-drag"))},isZoomable:function(){var t,e=this,n=e.current;if(n&&!e.isClosing&&"image"===n.type&&!n.hasError){if(!n.isLoaded)return!0;if(t=e.getFitPos(n),n.width>t.width||n.height>t.height)return!0}return!1},isScaledDown:function(t,e){var i=this,a=!1,s=i.current,r=s.$content;return t!==o&&e!==o?a=t<s.width&&e<s.height:r&&(a=n.fancybox.getTranslate(r),a=a.width<s.width&&a.height<s.height),a},canPan:function(){var t,e=this,n=!1,o=e.current;return"image"===o.type&&(t=o.$content)&&!o.hasError&&(n=e.getFitPos(o),n=Math.abs(t.width()-n.width)>1||Math.abs(t.height()-n.height)>1),n},loadSlide:function(t){var e,o,i,a=this;if(!t.isLoading&&!t.isLoaded){switch(t.isLoading=!0,a.trigger("beforeLoad",t),e=t.type,o=t.$slide,o.off("refresh").trigger("onReset").addClass(t.opts.slideClass),e){case"image":a.setImage(t);break;case"iframe":a.setIframe(t);break;case"html":a.setContent(t,t.src||t.content);break;case"video":a.setContent(t,'<video class="fancybox-video" controls controlsList="nodownload"><source src="'+t.src+'" type="'+t.opts.videoFormat+"\">Your browser doesn't support HTML5 video</video");break;case"inline":n(t.src).length?a.setContent(t,n(t.src)):a.setError(t);break;case"ajax":a.showLoading(t),i=n.ajax(n.extend({},t.opts.ajax.settings,{url:t.src,success:function(e,n){"success"===n&&a.setContent(t,e)},error:function(e,n){e&&"abort"!==n&&a.setError(t)}})),o.one("onReset",function(){i.abort()});break;default:a.setError(t)}return!0}},setImage:function(e){var o,i,a,s,r,c=this,l=e.opts.srcset||e.opts.image.srcset;if(e.timouts=setTimeout(function(){var t=e.$image;!e.isLoading||t&&t[0].complete||e.hasError||c.showLoading(e)},350),l){s=t.devicePixelRatio||1,r=t.innerWidth*s,a=l.split(",").map(function(t){var e={};return t.trim().split(/\s+/).forEach(function(t,n){var o=parseInt(t.substring(0,t.length-1),10);return 0===n?e.url=t:void(o&&(e.value=o,e.postfix=t[t.length-1]))}),e}),a.sort(function(t,e){return t.value-e.value});for(var d=0;d<a.length;d++){var u=a[d];if("w"===u.postfix&&u.value>=r||"x"===u.postfix&&u.value>=s){i=u;break}}!i&&a.length&&(i=a[a.length-1]),i&&(e.src=i.url,e.width&&e.height&&"w"==i.postfix&&(e.height=e.width/e.height*i.value,e.width=i.value),e.opts.srcset=l)}e.$content=n('<div class="fancybox-content"></div>').addClass("fancybox-is-hidden").appendTo(e.$slide.addClass("fancybox-slide--image")),o=e.opts.thumb||!(!e.opts.$thumb||!e.opts.$thumb.length)&&e.opts.$thumb.attr("src"),e.opts.preload!==!1&&e.opts.width&&e.opts.height&&o&&(e.width=e.opts.width,e.height=e.opts.height,e.$ghost=n("<img />").one("error",function(){n(this).remove(),e.$ghost=null}).one("load",function(){c.afterLoad(e)}).addClass("fancybox-image").appendTo(e.$content).attr("src",o)),c.setBigImage(e)},setBigImage:function(t){var e=this,o=n("<img />");t.$image=o.one("error",function(){e.setError(t)}).one("load",function(){var n;t.$ghost||(e.resolveImageSlideSize(t,this.naturalWidth,this.naturalHeight),e.afterLoad(t)),t.timouts&&(clearTimeout(t.timouts),t.timouts=null),e.isClosing||(t.opts.srcset&&(n=t.opts.sizes,n&&"auto"!==n||(n=(t.width/t.height>1&&s.width()/s.height()>1?"100":Math.round(t.width/t.height*100))+"vw"),o.attr("sizes",n).attr("srcset",t.opts.srcset)),t.$ghost&&setTimeout(function(){t.$ghost&&!e.isClosing&&t.$ghost.hide()},Math.min(300,Math.max(1e3,t.height/1600))),e.hideLoading(t))}).addClass("fancybox-image").attr("src",t.src).appendTo(t.$content),(o[0].complete||"complete"==o[0].readyState)&&o[0].naturalWidth&&o[0].naturalHeight?o.trigger("load"):o[0].error&&o.trigger("error")},resolveImageSlideSize:function(t,e,n){var o=parseInt(t.opts.width,10),i=parseInt(t.opts.height,10);t.width=e,t.height=n,o>0&&(t.width=o,t.height=Math.floor(o*n/e)),i>0&&(t.width=Math.floor(i*e/n),t.height=i)},setIframe:function(t){var e,i=this,a=t.opts.iframe,s=t.$slide;t.$content=n('<div class="fancybox-content'+(a.preload?" fancybox-is-hidden":"")+'"></div>').css(a.css).appendTo(s),s.addClass("fancybox-slide--"+t.contentType),t.$iframe=e=n(a.tpl.replace(/\{rnd\}/g,(new Date).getTime())).attr(a.attr).appendTo(t.$content),a.preload?(i.showLoading(t),e.on("load.fb error.fb",function(e){this.isReady=1,t.$slide.trigger("refresh"),i.afterLoad(t)}),s.on("refresh.fb",function(){var n,i,s=t.$content,r=a.css.width,c=a.css.height;if(1===e[0].isReady){try{n=e.contents(),i=n.find("body")}catch(t){}i&&i.length&&i.children().length&&(s.css({width:"",height:""}),r===o&&(r=Math.ceil(Math.max(i[0].clientWidth,i.outerWidth(!0)))),r&&s.width(r),c===o&&(c=Math.ceil(Math.max(i[0].clientHeight,i.outerHeight(!0)))),c&&s.height(c)),s.removeClass("fancybox-is-hidden")}})):this.afterLoad(t),e.attr("src",t.src),s.one("onReset",function(){try{n(this).find("iframe").hide().unbind().attr("src","//about:blank")}catch(t){}n(this).off("refresh.fb").empty(),t.isLoaded=!1})},setContent:function(t,e){var o=this;o.isClosing||(o.hideLoading(t),t.$content&&n.fancybox.stop(t.$content),t.$slide.empty(),l(e)&&e.parent().length?(e.parent().parent(".fancybox-slide--inline").trigger("onReset"),t.$placeholder=n("<div>").hide().insertAfter(e),e.css("display","inline-block")):t.hasError||("string"===n.type(e)&&(e=n("<div>").append(n.trim(e)).contents(),3===e[0].nodeType&&(e=n("<div>").html(e))),t.opts.filter&&(e=n("<div>").html(e).find(t.opts.filter))),t.$slide.one("onReset",function(){n(this).find("video,audio").trigger("pause"),t.$placeholder&&(t.$placeholder.after(e.hide()).remove(),t.$placeholder=null),t.$smallBtn&&(t.$smallBtn.remove(),t.$smallBtn=null),t.hasError||(n(this).empty(),t.isLoaded=!1)}),n(e).appendTo(t.$slide),n(e).is("video,audio")&&(n(e).addClass("fancybox-video"),n(e).wrap("<div></div>"),t.contentType="video",t.opts.width=t.opts.width||n(e).attr("width"),t.opts.height=t.opts.height||n(e).attr("height")),t.$content=t.$slide.children().filter("div,form,main,video,audio").first().addClass("fancybox-content"),t.$slide.addClass("fancybox-slide--"+t.contentType),this.afterLoad(t))},setError:function(t){t.hasError=!0,t.$slide.trigger("onReset").removeClass("fancybox-slide--"+t.contentType).addClass("fancybox-slide--error"),t.contentType="html",this.setContent(t,this.translate(t,t.opts.errorTpl)),t.pos===this.currPos&&(this.isAnimating=!1)},showLoading:function(t){var e=this;t=t||e.current,t&&!t.$spinner&&(t.$spinner=n(e.translate(e,e.opts.spinnerTpl)).appendTo(t.$slide))},hideLoading:function(t){var e=this;t=t||e.current,t&&t.$spinner&&(t.$spinner.remove(),delete t.$spinner)},afterLoad:function(t){var e=this;e.isClosing||(t.isLoading=!1,t.isLoaded=!0,e.trigger("afterLoad",t),e.hideLoading(t),t.pos===e.currPos&&e.updateCursor(),!t.opts.smallBtn||t.$smallBtn&&t.$smallBtn.length||(t.$smallBtn=n(e.translate(t,t.opts.btnTpl.smallBtn)).prependTo(t.$content)),t.opts.protect&&t.$content&&!t.hasError&&(t.$content.on("contextmenu.fb",function(t){return 2==t.button&&t.preventDefault(),!0}),"image"===t.type&&n('<div class="fancybox-spaceball"></div>').appendTo(t.$content)),e.revealContent(t))},revealContent:function(t){var e,i,a,s,r=this,c=t.$slide,l=!1,d=!1;return e=t.opts[r.firstRun?"animationEffect":"transitionEffect"],a=t.opts[r.firstRun?"animationDuration":"transitionDuration"],a=parseInt(t.forcedDuration===o?a:t.forcedDuration,10),t.pos===r.currPos&&(t.isComplete?e=!1:r.isAnimating=!0),!t.isMoved&&t.pos===r.currPos&&a||(e=!1),"zoom"===e&&(t.pos===r.currPos&&a&&"image"===t.type&&!t.hasError&&(d=r.getThumbPos(t))?l=r.getFitPos(t):e="fade"),"zoom"===e?(l.scaleX=l.width/d.width,l.scaleY=l.height/d.height,s=t.opts.zoomOpacity,"auto"==s&&(s=Math.abs(t.width/t.height-d.width/d.height)>.1),s&&(d.opacity=.1,l.opacity=1),n.fancybox.setTranslate(t.$content.removeClass("fancybox-is-hidden"),d),f(t.$content),void n.fancybox.animate(t.$content,l,a,function(){r.isAnimating=!1,r.complete()})):(r.updateSlide(t),e?(n.fancybox.stop(c),i="fancybox-animated fancybox-slide--"+(t.pos>=r.prevPos?"next":"previous")+" fancybox-fx-"+e,c.removeAttr("style").removeClass("fancybox-slide--current fancybox-slide--next fancybox-slide--previous").addClass(i),t.$content.removeClass("fancybox-is-hidden"),f(c),void n.fancybox.animate(c,"fancybox-slide--current",a,function(e){c.removeClass(i).removeAttr("style"),t.pos===r.currPos&&r.complete()},!0)):(f(c),t.$content.removeClass("fancybox-is-hidden"),void(t.pos===r.currPos&&r.complete())))},getThumbPos:function(o){var i,a=this,s=!1,r=o.opts.$thumb,c=r&&r.length&&r[0].ownerDocument===e?r.offset():0,l=function(e){for(var o,i=e[0],a=i.getBoundingClientRect(),s=[];null!==i.parentElement;)"hidden"!==n(i.parentElement).css("overflow")&&"auto"!==n(i.parentElement).css("overflow")||s.push(i.parentElement.getBoundingClientRect()),i=i.parentElement;return o=s.every(function(t){var e=Math.min(a.right,t.right)-Math.max(a.left,t.left),n=Math.min(a.bottom,t.bottom)-Math.max(a.top,t.top);return e>0&&n>0}),o&&a.bottom>0&&a.right>0&&a.left<n(t).width()&&a.top<n(t).height()};return c&&l(r)&&(i=a.$refs.stage.offset(),s={top:c.top-i.top+parseFloat(r.css("border-top-width")||0),left:c.left-i.left+parseFloat(r.css("border-left-width")||0),width:r.width(),height:r.height(),scaleX:1,scaleY:1}),s},complete:function(){var t=this,o=t.current,i={};!o.isMoved&&o.isLoaded&&(o.isComplete||(o.isComplete=!0,o.$slide.siblings().trigger("onReset"),t.preload("inline"),f(o.$slide),o.$slide.addClass("fancybox-slide--complete"),n.each(t.slides,function(e,o){o.pos>=t.currPos-1&&o.pos<=t.currPos+1?i[o.pos]=o:o&&(n.fancybox.stop(o.$slide),o.$slide.off().remove())}),t.slides=i),t.isAnimating=!1,t.updateCursor(),t.trigger("afterShow"),o.$slide.find("video,audio").filter(":visible:first").trigger("play"),(n(e.activeElement).is("[disabled]")||o.opts.autoFocus&&"image"!=o.type&&"iframe"!==o.type)&&t.focus())},preload:function(t){var e=this,n=e.slides[e.currPos+1],o=e.slides[e.currPos-1];n&&n.type===t&&e.loadSlide(n),o&&o.type===t&&e.loadSlide(o)},focus:function(){var t,e=this.current;this.isClosing||e&&e.isComplete&&e.$content&&(t=e.$content.find("input[autofocus]:enabled:visible:first"),t.length||(t=e.$content.find("button,:input,[tabindex],a").filter(":enabled:visible:first")),t=t&&t.length?t:e.$content,t.trigger("focus"))},activate:function(){var t=this;n(".fancybox-container").each(function(){var e=n(this).data("FancyBox");e&&e.id!==t.id&&!e.isClosing&&(e.trigger("onDeactivate"),e.removeEvents(),e.isVisible=!1)}),t.isVisible=!0,(t.current||t.isIdle)&&(t.update(),t.updateControls()),t.trigger("onActivate"),t.addEvents()},close:function(t,e){var o,i,a,s,r,c,l,p=this,h=p.current,g=function(){p.cleanUp(t)};return!p.isClosing&&(p.isClosing=!0,p.trigger("beforeClose",t)===!1?(p.isClosing=!1,d(function(){p.update()}),!1):(p.removeEvents(),h.timouts&&clearTimeout(h.timouts),a=h.$content,o=h.opts.animationEffect,i=n.isNumeric(e)?e:o?h.opts.animationDuration:0,h.$slide.off(u).removeClass("fancybox-slide--complete fancybox-slide--next fancybox-slide--previous fancybox-animated"),h.$slide.siblings().trigger("onReset").remove(),i&&p.$refs.container.removeClass("fancybox-is-open").addClass("fancybox-is-closing"),p.hideLoading(h),p.hideControls(),p.updateCursor(),"zoom"!==o||t!==!0&&a&&i&&"image"===h.type&&!h.hasError&&(l=p.getThumbPos(h))||(o="fade"),"zoom"===o?(n.fancybox.stop(a),s=n.fancybox.getTranslate(a),c={top:s.top,left:s.left,scaleX:s.width/l.width,scaleY:s.height/l.height,width:l.width,height:l.height},r=h.opts.zoomOpacity,"auto"==r&&(r=Math.abs(h.width/h.height-l.width/l.height)>.1),r&&(l.opacity=0),n.fancybox.setTranslate(a,c),f(a),n.fancybox.animate(a,l,i,g),!0):(o&&i?t===!0?setTimeout(g,i):n.fancybox.animate(h.$slide.removeClass("fancybox-slide--current"),"fancybox-animated fancybox-slide--previous fancybox-fx-"+o,i,g):g(),!0)))},cleanUp:function(t){var e,o=this,i=n("body");o.current.$slide.trigger("onReset"),o.$refs.container.empty().remove(),o.trigger("afterClose",t),o.$lastFocus&&o.current.opts.backFocus&&o.$lastFocus.trigger("focus"),o.current=null,e=n.fancybox.getInstance(),e?e.activate():(i.removeClass("fancybox-active compensate-for-scrollbar"),n("#fancybox-style-noscroll").remove())},trigger:function(t,e){var o,i=Array.prototype.slice.call(arguments,1),a=this,s=e&&e.opts?e:a.current;return s?i.unshift(s):s=a,i.unshift(a),n.isFunction(s.opts[t])&&(o=s.opts[t].apply(s,i)),o===!1?o:void("afterClose"!==t&&a.$refs?a.$refs.container.trigger(t+".fb",i):r.trigger(t+".fb",i))},updateControls:function(t){var e=this,n=e.current,o=n.index,i=n.opts.caption,a=e.$refs.container,s=e.$refs.caption;n.$slide.trigger("refresh"),e.$caption=i&&i.length?s.html(i):null,e.isHiddenControls||e.isIdle||e.showControls(),a.find("[data-fancybox-count]").html(e.group.length),a.find("[data-fancybox-index]").html(o+1),a.find("[data-fancybox-prev]").toggleClass("disabled",!n.opts.loop&&o<=0),a.find("[data-fancybox-next]").toggleClass("disabled",!n.opts.loop&&o>=e.group.length-1),"image"===n.type?a.find("[data-fancybox-zoom]").show().end().find("[data-fancybox-download]").attr("href",n.opts.image.src||n.src).show():n.opts.toolbar&&a.find("[data-fancybox-download],[data-fancybox-zoom]").hide()},hideControls:function(){this.isHiddenControls=!0,this.$refs.container.removeClass("fancybox-show-infobar fancybox-show-toolbar fancybox-show-caption fancybox-show-nav")},showControls:function(){var t=this,e=t.current?t.current.opts:t.opts,n=t.$refs.container;t.isHiddenControls=!1,t.idleSecondsCounter=0,n.toggleClass("fancybox-show-toolbar",!(!e.toolbar||!e.buttons)).toggleClass("fancybox-show-infobar",!!(e.infobar&&t.group.length>1)).toggleClass("fancybox-show-nav",!!(e.arrows&&t.group.length>1)).toggleClass("fancybox-is-modal",!!e.modal),t.$caption?n.addClass("fancybox-show-caption "):n.removeClass("fancybox-show-caption")},toggleControls:function(){this.isHiddenControls?this.showControls():this.hideControls()}}),n.fancybox={version:"3.3.5",defaults:a,getInstance:function(t){var e=n('.fancybox-container:not(".fancybox-is-closing"):last').data("FancyBox"),o=Array.prototype.slice.call(arguments,1);return e instanceof h&&("string"===n.type(t)?e[t].apply(e,o):"function"===n.type(t)&&t.apply(e,o),e)},open:function(t,e,n){return new h(t,e,n)},close:function(t){var e=this.getInstance();e&&(e.close(),t===!0&&this.close())},destroy:function(){this.close(!0),r.add("body").off("click.fb-start","**")},isMobile:e.createTouch!==o&&/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),use3d:function(){var n=e.createElement("div");return t.getComputedStyle&&t.getComputedStyle(n)&&t.getComputedStyle(n).getPropertyValue("transform")&&!(e.documentMode&&e.documentMode<11)}(),getTranslate:function(t){var e;return!(!t||!t.length)&&(e=t[0].getBoundingClientRect(),{top:e.top||0,left:e.left||0,width:e.width,height:e.height,opacity:parseFloat(t.css("opacity"))})},setTranslate:function(t,e){var n="",i={};if(t&&e)return e.left===o&&e.top===o||(n=(e.left===o?t.position().left:e.left)+"px, "+(e.top===o?t.position().top:e.top)+"px",n=this.use3d?"translate3d("+n+", 0px)":"translate("+n+")"),e.scaleX!==o&&e.scaleY!==o&&(n=(n.length?n+" ":"")+"scale("+e.scaleX+", "+e.scaleY+")"),n.length&&(i.transform=n),e.opacity!==o&&(i.opacity=e.opacity),e.width!==o&&(i.width=e.width),e.height!==o&&(i.height=e.height),t.css(i)},animate:function(t,e,i,a,s){var r=!1;n.isFunction(i)&&(a=i,i=null),n.isPlainObject(e)||t.removeAttr("style"),n.fancybox.stop(t),t.on(u,function(o){(!o||!o.originalEvent||t.is(o.originalEvent.target)&&"z-index"!=o.originalEvent.propertyName)&&(n.fancybox.stop(t),r&&n.fancybox.setTranslate(t,r),
    n.isPlainObject(e)?s===!1&&t.removeAttr("style"):s!==!0&&t.removeClass(e),n.isFunction(a)&&a(o))}),n.isNumeric(i)&&t.css("transition-duration",i+"ms"),n.isPlainObject(e)?(e.scaleX!==o&&e.scaleY!==o&&(r=n.extend({},e,{width:t.width()*e.scaleX,height:t.height()*e.scaleY,scaleX:1,scaleY:1}),delete e.width,delete e.height,t.parent().hasClass("fancybox-slide--image")&&t.parent().addClass("fancybox-is-scaling")),n.fancybox.setTranslate(t,e)):t.addClass(e),t.data("timer",setTimeout(function(){t.trigger("transitionend")},i+16))},stop:function(t){t&&t.length&&(clearTimeout(t.data("timer")),t.off("transitionend").css("transition-duration",""),t.parent().removeClass("fancybox-is-scaling"))}},n.fn.fancybox=function(t){var e;return t=t||{},e=t.selector||!1,e?n("body").off("click.fb-start",e).on("click.fb-start",e,{options:t},i):this.off("click.fb-start").on("click.fb-start",{items:this,options:t},i),this},r.on("click.fb-start","[data-fancybox]",i),r.on("click.fb-start","[data-trigger]",function(t){i(t,{$target:n('[data-fancybox="'+n(t.currentTarget).attr("data-trigger")+'"]').eq(n(t.currentTarget).attr("data-index")||0),$trigger:n(this)})})}}(window,document,window.jQuery||jQuery),function(t){"use strict";var e=function(e,n,o){if(e)return o=o||"","object"===t.type(o)&&(o=t.param(o,!0)),t.each(n,function(t,n){e=e.replace("$"+t,n||"")}),o.length&&(e+=(e.indexOf("?")>0?"&":"?")+o),e},n={youtube:{matcher:/(youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(watch\?(.*&)?v=|v\/|u\/|embed\/?)?(videoseries\?list=(.*)|[\w-]{11}|\?listType=(.*)&list=(.*))(.*)/i,params:{autoplay:1,autohide:1,fs:1,rel:0,hd:1,wmode:"transparent",enablejsapi:1,html5:1},paramPlace:8,type:"iframe",url:"//www.youtube.com/embed/$4",thumb:"//img.youtube.com/vi/$4/hqdefault.jpg"},vimeo:{matcher:/^.+vimeo.com\/(.*\/)?([\d]+)(.*)?/,params:{autoplay:1,hd:1,show_title:1,show_byline:1,show_portrait:0,fullscreen:1,api:1},paramPlace:3,type:"iframe",url:"//player.vimeo.com/video/$2"},instagram:{matcher:/(instagr\.am|instagram\.com)\/p\/([a-zA-Z0-9_\-]+)\/?/i,type:"image",url:"//$1/p/$2/media/?size=l"},gmap_place:{matcher:/(maps\.)?google\.([a-z]{2,3}(\.[a-z]{2})?)\/(((maps\/(place\/(.*)\/)?\@(.*),(\d+.?\d+?)z))|(\?ll=))(.*)?/i,type:"iframe",url:function(t){return"//maps.google."+t[2]+"/?ll="+(t[9]?t[9]+"&z="+Math.floor(t[10])+(t[12]?t[12].replace(/^\//,"&"):""):t[12]+"").replace(/\?/,"&")+"&output="+(t[12]&&t[12].indexOf("layer=c")>0?"svembed":"embed")}},gmap_search:{matcher:/(maps\.)?google\.([a-z]{2,3}(\.[a-z]{2})?)\/(maps\/search\/)(.*)/i,type:"iframe",url:function(t){return"//maps.google."+t[2]+"/maps?q="+t[5].replace("query=","q=").replace("api=1","")+"&output=embed"}}};t(document).on("objectNeedsType.fb",function(o,i,a){var s,r,c,l,d,u,f,p=a.src||"",h=!1;s=t.extend(!0,{},n,a.opts.media),t.each(s,function(n,o){if(c=p.match(o.matcher)){if(h=o.type,f=n,u={},o.paramPlace&&c[o.paramPlace]){d=c[o.paramPlace],"?"==d[0]&&(d=d.substring(1)),d=d.split("&");for(var i=0;i<d.length;++i){var s=d[i].split("=",2);2==s.length&&(u[s[0]]=decodeURIComponent(s[1].replace(/\+/g," ")))}}return l=t.extend(!0,{},o.params,a.opts[n],u),p="function"===t.type(o.url)?o.url.call(this,c,l,a):e(o.url,c,l),r="function"===t.type(o.thumb)?o.thumb.call(this,c,l,a):e(o.thumb,c),"youtube"===n?p=p.replace(/&t=((\d+)m)?(\d+)s/,function(t,e,n,o){return"&start="+((n?60*parseInt(n,10):0)+parseInt(o,10))}):"vimeo"===n&&(p=p.replace("&%23","#")),!1}}),h?(a.opts.thumb||a.opts.$thumb&&a.opts.$thumb.length||(a.opts.thumb=r),"iframe"===h&&(a.opts=t.extend(!0,a.opts,{iframe:{preload:!1,attr:{scrolling:"no"}}})),t.extend(a,{type:h,src:p,origSrc:a.src,contentSource:f,contentType:"image"===h?"image":"gmap_place"==f||"gmap_search"==f?"map":"video"})):p&&(a.type=a.opts.defaultType)})}(window.jQuery||jQuery),function(t,e,n){"use strict";var o=function(){return t.requestAnimationFrame||t.webkitRequestAnimationFrame||t.mozRequestAnimationFrame||t.oRequestAnimationFrame||function(e){return t.setTimeout(e,1e3/60)}}(),i=function(){return t.cancelAnimationFrame||t.webkitCancelAnimationFrame||t.mozCancelAnimationFrame||t.oCancelAnimationFrame||function(e){t.clearTimeout(e)}}(),a=function(e){var n=[];e=e.originalEvent||e||t.e,e=e.touches&&e.touches.length?e.touches:e.changedTouches&&e.changedTouches.length?e.changedTouches:[e];for(var o in e)e[o].pageX?n.push({x:e[o].pageX,y:e[o].pageY}):e[o].clientX&&n.push({x:e[o].clientX,y:e[o].clientY});return n},s=function(t,e,n){return e&&t?"x"===n?t.x-e.x:"y"===n?t.y-e.y:Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2)):0},r=function(t){if(t.is('a,area,button,[role="button"],input,label,select,summary,textarea,video,audio')||n.isFunction(t.get(0).onclick)||t.data("selectable"))return!0;for(var e=0,o=t[0].attributes,i=o.length;e<i;e++)if("data-fancybox-"===o[e].nodeName.substr(0,14))return!0;return!1},c=function(e){var n=t.getComputedStyle(e)["overflow-y"],o=t.getComputedStyle(e)["overflow-x"],i=("scroll"===n||"auto"===n)&&e.scrollHeight>e.clientHeight,a=("scroll"===o||"auto"===o)&&e.scrollWidth>e.clientWidth;return i||a},l=function(t){for(var e=!1;;){if(e=c(t.get(0)))break;if(t=t.parent(),!t.length||t.hasClass("fancybox-stage")||t.is("body"))break}return e},d=function(t){var e=this;e.instance=t,e.$bg=t.$refs.bg,e.$stage=t.$refs.stage,e.$container=t.$refs.container,e.destroy(),e.$container.on("touchstart.fb.touch mousedown.fb.touch",n.proxy(e,"ontouchstart"))};d.prototype.destroy=function(){this.$container.off(".fb.touch")},d.prototype.ontouchstart=function(o){var i=this,c=n(o.target),d=i.instance,u=d.current,f=u.$content,p="touchstart"==o.type;if(p&&i.$container.off("mousedown.fb.touch"),(!o.originalEvent||2!=o.originalEvent.button)&&c.length&&!r(c)&&!r(c.parent())&&(c.is("img")||!(o.originalEvent.clientX>c[0].clientWidth+c.offset().left))){if(!u||d.isAnimating||d.isClosing)return o.stopPropagation(),void o.preventDefault();if(i.realPoints=i.startPoints=a(o),i.startPoints.length){if(o.stopPropagation(),i.startEvent=o,i.canTap=!0,i.$target=c,i.$content=f,i.opts=u.opts.touch,i.isPanning=!1,i.isSwiping=!1,i.isZooming=!1,i.isScrolling=!1,i.startTime=(new Date).getTime(),i.distanceX=i.distanceY=i.distance=0,i.canvasWidth=Math.round(u.$slide[0].clientWidth),i.canvasHeight=Math.round(u.$slide[0].clientHeight),i.contentLastPos=null,i.contentStartPos=n.fancybox.getTranslate(i.$content)||{top:0,left:0},i.sliderStartPos=i.sliderLastPos||n.fancybox.getTranslate(u.$slide),i.stagePos=n.fancybox.getTranslate(d.$refs.stage),i.sliderStartPos.top-=i.stagePos.top,i.sliderStartPos.left-=i.stagePos.left,i.contentStartPos.top-=i.stagePos.top,i.contentStartPos.left-=i.stagePos.left,n(e).off(".fb.touch").on(p?"touchend.fb.touch touchcancel.fb.touch":"mouseup.fb.touch mouseleave.fb.touch",n.proxy(i,"ontouchend")).on(p?"touchmove.fb.touch":"mousemove.fb.touch",n.proxy(i,"ontouchmove")),n.fancybox.isMobile&&e.addEventListener("scroll",i.onscroll,!0),!i.opts&&!d.canPan()||!c.is(i.$stage)&&!i.$stage.find(c).length)return void(c.is(".fancybox-image")&&o.preventDefault());n.fancybox.isMobile&&(l(c)||l(c.parent()))||o.preventDefault(),(1===i.startPoints.length||u.hasError)&&(i.instance.canPan()?(n.fancybox.stop(i.$content),i.$content.css("transition-duration",""),i.isPanning=!0):i.isSwiping=!0,i.$container.addClass("fancybox-controls--isGrabbing")),2===i.startPoints.length&&"image"===u.type&&(u.isLoaded||u.$ghost)&&(i.canTap=!1,i.isSwiping=!1,i.isPanning=!1,i.isZooming=!0,n.fancybox.stop(i.$content),i.$content.css("transition-duration",""),i.centerPointStartX=.5*(i.startPoints[0].x+i.startPoints[1].x)-n(t).scrollLeft(),i.centerPointStartY=.5*(i.startPoints[0].y+i.startPoints[1].y)-n(t).scrollTop(),i.percentageOfImageAtPinchPointX=(i.centerPointStartX-i.contentStartPos.left)/i.contentStartPos.width,i.percentageOfImageAtPinchPointY=(i.centerPointStartY-i.contentStartPos.top)/i.contentStartPos.height,i.startDistanceBetweenFingers=s(i.startPoints[0],i.startPoints[1]))}}},d.prototype.onscroll=function(t){var n=this;n.isScrolling=!0,e.removeEventListener("scroll",n.onscroll,!0)},d.prototype.ontouchmove=function(t){var e=this,o=n(t.target);return void 0!==t.originalEvent.buttons&&0===t.originalEvent.buttons?void e.ontouchend(t):e.isScrolling||!o.is(e.$stage)&&!e.$stage.find(o).length?void(e.canTap=!1):(e.newPoints=a(t),void((e.opts||e.instance.canPan())&&e.newPoints.length&&e.newPoints.length&&(e.isSwiping&&e.isSwiping===!0||t.preventDefault(),e.distanceX=s(e.newPoints[0],e.startPoints[0],"x"),e.distanceY=s(e.newPoints[0],e.startPoints[0],"y"),e.distance=s(e.newPoints[0],e.startPoints[0]),e.distance>0&&(e.isSwiping?e.onSwipe(t):e.isPanning?e.onPan():e.isZooming&&e.onZoom()))))},d.prototype.onSwipe=function(e){var a,s=this,r=s.isSwiping,c=s.sliderStartPos.left||0;if(r!==!0)"x"==r&&(s.distanceX>0&&(s.instance.group.length<2||0===s.instance.current.index&&!s.instance.current.opts.loop)?c+=Math.pow(s.distanceX,.8):s.distanceX<0&&(s.instance.group.length<2||s.instance.current.index===s.instance.group.length-1&&!s.instance.current.opts.loop)?c-=Math.pow(-s.distanceX,.8):c+=s.distanceX),s.sliderLastPos={top:"x"==r?0:s.sliderStartPos.top+s.distanceY,left:c},s.requestId&&(i(s.requestId),s.requestId=null),s.requestId=o(function(){s.sliderLastPos&&(n.each(s.instance.slides,function(t,e){var o=e.pos-s.instance.currPos;n.fancybox.setTranslate(e.$slide,{top:s.sliderLastPos.top,left:s.sliderLastPos.left+o*s.canvasWidth+o*e.opts.gutter})}),s.$container.addClass("fancybox-is-sliding"))});else if(Math.abs(s.distance)>10){if(s.canTap=!1,s.instance.group.length<2&&s.opts.vertical?s.isSwiping="y":s.instance.isDragging||s.opts.vertical===!1||"auto"===s.opts.vertical&&n(t).width()>800?s.isSwiping="x":(a=Math.abs(180*Math.atan2(s.distanceY,s.distanceX)/Math.PI),s.isSwiping=a>45&&a<135?"y":"x"),s.canTap=!1,"y"===s.isSwiping&&n.fancybox.isMobile&&(l(s.$target)||l(s.$target.parent())))return void(s.isScrolling=!0);s.instance.isDragging=s.isSwiping,s.startPoints=s.newPoints,n.each(s.instance.slides,function(t,e){n.fancybox.stop(e.$slide),e.$slide.css("transition-duration",""),e.inTransition=!1,e.pos===s.instance.current.pos&&(s.sliderStartPos.left=n.fancybox.getTranslate(e.$slide).left-n.fancybox.getTranslate(s.instance.$refs.stage).left)}),s.instance.SlideShow&&s.instance.SlideShow.isActive&&s.instance.SlideShow.stop()}},d.prototype.onPan=function(){var t=this;return s(t.newPoints[0],t.realPoints[0])<(n.fancybox.isMobile?10:5)?void(t.startPoints=t.newPoints):(t.canTap=!1,t.contentLastPos=t.limitMovement(),t.requestId&&(i(t.requestId),t.requestId=null),void(t.requestId=o(function(){n.fancybox.setTranslate(t.$content,t.contentLastPos)})))},d.prototype.limitMovement=function(){var t,e,n,o,i,a,s=this,r=s.canvasWidth,c=s.canvasHeight,l=s.distanceX,d=s.distanceY,u=s.contentStartPos,f=u.left,p=u.top,h=u.width,g=u.height;return i=h>r?f+l:f,a=p+d,t=Math.max(0,.5*r-.5*h),e=Math.max(0,.5*c-.5*g),n=Math.min(r-h,.5*r-.5*h),o=Math.min(c-g,.5*c-.5*g),l>0&&i>t&&(i=t-1+Math.pow(-t+f+l,.8)||0),l<0&&i<n&&(i=n+1-Math.pow(n-f-l,.8)||0),d>0&&a>e&&(a=e-1+Math.pow(-e+p+d,.8)||0),d<0&&a<o&&(a=o+1-Math.pow(o-p-d,.8)||0),{top:a,left:i}},d.prototype.limitPosition=function(t,e,n,o){var i=this,a=i.canvasWidth,s=i.canvasHeight;return n>a?(t=t>0?0:t,t=t<a-n?a-n:t):t=Math.max(0,a/2-n/2),o>s?(e=e>0?0:e,e=e<s-o?s-o:e):e=Math.max(0,s/2-o/2),{top:e,left:t}},d.prototype.onZoom=function(){var e=this,a=e.contentStartPos,r=a.width,c=a.height,l=a.left,d=a.top,u=s(e.newPoints[0],e.newPoints[1]),f=u/e.startDistanceBetweenFingers,p=Math.floor(r*f),h=Math.floor(c*f),g=(r-p)*e.percentageOfImageAtPinchPointX,b=(c-h)*e.percentageOfImageAtPinchPointY,m=(e.newPoints[0].x+e.newPoints[1].x)/2-n(t).scrollLeft(),y=(e.newPoints[0].y+e.newPoints[1].y)/2-n(t).scrollTop(),v=m-e.centerPointStartX,x=y-e.centerPointStartY,w=l+(g+v),$=d+(b+x),S={top:$,left:w,scaleX:f,scaleY:f};e.canTap=!1,e.newWidth=p,e.newHeight=h,e.contentLastPos=S,e.requestId&&(i(e.requestId),e.requestId=null),e.requestId=o(function(){n.fancybox.setTranslate(e.$content,e.contentLastPos)})},d.prototype.ontouchend=function(t){var o=this,s=Math.max((new Date).getTime()-o.startTime,1),r=o.isSwiping,c=o.isPanning,l=o.isZooming,d=o.isScrolling;return o.endPoints=a(t),o.$container.removeClass("fancybox-controls--isGrabbing"),n(e).off(".fb.touch"),e.removeEventListener("scroll",o.onscroll,!0),o.requestId&&(i(o.requestId),o.requestId=null),o.isSwiping=!1,o.isPanning=!1,o.isZooming=!1,o.isScrolling=!1,o.instance.isDragging=!1,o.canTap?o.onTap(t):(o.speed=366,o.velocityX=o.distanceX/s*.5,o.velocityY=o.distanceY/s*.5,o.speedX=Math.max(.5*o.speed,Math.min(1.5*o.speed,1/Math.abs(o.velocityX)*o.speed)),void(c?o.endPanning():l?o.endZooming():o.endSwiping(r,d)))},d.prototype.endSwiping=function(t,e){var o=this,i=!1,a=o.instance.group.length;o.sliderLastPos=null,"y"==t&&!e&&Math.abs(o.distanceY)>50?(n.fancybox.animate(o.instance.current.$slide,{top:o.sliderStartPos.top+o.distanceY+150*o.velocityY,opacity:0},200),i=o.instance.close(!0,200)):"x"==t&&o.distanceX>50&&a>1?i=o.instance.previous(o.speedX):"x"==t&&o.distanceX<-50&&a>1&&(i=o.instance.next(o.speedX)),i!==!1||"x"!=t&&"y"!=t||(e||a<2?o.instance.centerSlide(o.instance.current,150):o.instance.jumpTo(o.instance.current.index)),o.$container.removeClass("fancybox-is-sliding")},d.prototype.endPanning=function(){var t,e,o,i=this;i.contentLastPos&&(i.opts.momentum===!1?(t=i.contentLastPos.left,e=i.contentLastPos.top):(t=i.contentLastPos.left+i.velocityX*i.speed,e=i.contentLastPos.top+i.velocityY*i.speed),o=i.limitPosition(t,e,i.contentStartPos.width,i.contentStartPos.height),o.width=i.contentStartPos.width,o.height=i.contentStartPos.height,n.fancybox.animate(i.$content,o,330))},d.prototype.endZooming=function(){var t,e,o,i,a=this,s=a.instance.current,r=a.newWidth,c=a.newHeight;a.contentLastPos&&(t=a.contentLastPos.left,e=a.contentLastPos.top,i={top:e,left:t,width:r,height:c,scaleX:1,scaleY:1},n.fancybox.setTranslate(a.$content,i),r<a.canvasWidth&&c<a.canvasHeight?a.instance.scaleToFit(150):r>s.width||c>s.height?a.instance.scaleToActual(a.centerPointStartX,a.centerPointStartY,150):(o=a.limitPosition(t,e,r,c),n.fancybox.setTranslate(a.$content,n.fancybox.getTranslate(a.$content)),n.fancybox.animate(a.$content,o,150)))},d.prototype.onTap=function(e){var o,i=this,s=n(e.target),r=i.instance,c=r.current,l=e&&a(e)||i.startPoints,d=l[0]?l[0].x-n(t).scrollLeft()-i.stagePos.left:0,u=l[0]?l[0].y-n(t).scrollTop()-i.stagePos.top:0,f=function(t){var o=c.opts[t];if(n.isFunction(o)&&(o=o.apply(r,[c,e])),o)switch(o){case"close":r.close(i.startEvent);break;case"toggleControls":r.toggleControls(!0);break;case"next":r.next();break;case"nextOrClose":r.group.length>1?r.next():r.close(i.startEvent);break;case"zoom":"image"==c.type&&(c.isLoaded||c.$ghost)&&(r.canPan()?r.scaleToFit():r.isScaledDown()?r.scaleToActual(d,u):r.group.length<2&&r.close(i.startEvent))}};if((!e.originalEvent||2!=e.originalEvent.button)&&(s.is("img")||!(d>s[0].clientWidth+s.offset().left))){if(s.is(".fancybox-bg,.fancybox-inner,.fancybox-outer,.fancybox-container"))o="Outside";else if(s.is(".fancybox-slide"))o="Slide";else{if(!r.current.$content||!r.current.$content.find(s).addBack().filter(s).length)return;o="Content"}if(i.tapped){if(clearTimeout(i.tapped),i.tapped=null,Math.abs(d-i.tapX)>50||Math.abs(u-i.tapY)>50)return this;f("dblclick"+o)}else i.tapX=d,i.tapY=u,c.opts["dblclick"+o]&&c.opts["dblclick"+o]!==c.opts["click"+o]?i.tapped=setTimeout(function(){i.tapped=null,f("click"+o)},500):f("click"+o);return this}},n(e).on("onActivate.fb",function(t,e){e&&!e.Guestures&&(e.Guestures=new d(e))})}(window,document,window.jQuery||jQuery),function(t,e){"use strict";e.extend(!0,e.fancybox.defaults,{btnTpl:{slideShow:'<button data-fancybox-play class="fancybox-button fancybox-button--play" title="{{PLAY_START}}"><svg viewBox="0 0 40 40"><path d="M13,12 L27,20 L13,27 Z" /><path d="M15,10 v19 M23,10 v19" /></svg></button>'},slideShow:{autoStart:!1,speed:3e3}});var n=function(t){this.instance=t,this.init()};e.extend(n.prototype,{timer:null,isActive:!1,$button:null,init:function(){var t=this;t.$button=t.instance.$refs.toolbar.find("[data-fancybox-play]").on("click",function(){t.toggle()}),(t.instance.group.length<2||!t.instance.group[t.instance.currIndex].opts.slideShow)&&t.$button.hide()},set:function(t){var e=this;e.instance&&e.instance.current&&(t===!0||e.instance.current.opts.loop||e.instance.currIndex<e.instance.group.length-1)?e.timer=setTimeout(function(){e.isActive&&e.instance.jumpTo((e.instance.currIndex+1)%e.instance.group.length)},e.instance.current.opts.slideShow.speed):(e.stop(),e.instance.idleSecondsCounter=0,e.instance.showControls())},clear:function(){var t=this;clearTimeout(t.timer),t.timer=null},start:function(){var t=this,e=t.instance.current;e&&(t.isActive=!0,t.$button.attr("title",e.opts.i18n[e.opts.lang].PLAY_STOP).removeClass("fancybox-button--play").addClass("fancybox-button--pause"),t.set(!0))},stop:function(){var t=this,e=t.instance.current;t.clear(),t.$button.attr("title",e.opts.i18n[e.opts.lang].PLAY_START).removeClass("fancybox-button--pause").addClass("fancybox-button--play"),t.isActive=!1},toggle:function(){var t=this;t.isActive?t.stop():t.start()}}),e(t).on({"onInit.fb":function(t,e){e&&!e.SlideShow&&(e.SlideShow=new n(e))},"beforeShow.fb":function(t,e,n,o){var i=e&&e.SlideShow;o?i&&n.opts.slideShow.autoStart&&i.start():i&&i.isActive&&i.clear()},"afterShow.fb":function(t,e,n){var o=e&&e.SlideShow;o&&o.isActive&&o.set()},"afterKeydown.fb":function(n,o,i,a,s){var r=o&&o.SlideShow;!r||!i.opts.slideShow||80!==s&&32!==s||e(t.activeElement).is("button,a,input")||(a.preventDefault(),r.toggle())},"beforeClose.fb onDeactivate.fb":function(t,e){var n=e&&e.SlideShow;n&&n.stop()}}),e(t).on("visibilitychange",function(){var n=e.fancybox.getInstance(),o=n&&n.SlideShow;o&&o.isActive&&(t.hidden?o.clear():o.set())})}(document,window.jQuery||jQuery),function(t,e){"use strict";var n=function(){for(var e=[["requestFullscreen","exitFullscreen","fullscreenElement","fullscreenEnabled","fullscreenchange","fullscreenerror"],["webkitRequestFullscreen","webkitExitFullscreen","webkitFullscreenElement","webkitFullscreenEnabled","webkitfullscreenchange","webkitfullscreenerror"],["webkitRequestFullScreen","webkitCancelFullScreen","webkitCurrentFullScreenElement","webkitCancelFullScreen","webkitfullscreenchange","webkitfullscreenerror"],["mozRequestFullScreen","mozCancelFullScreen","mozFullScreenElement","mozFullScreenEnabled","mozfullscreenchange","mozfullscreenerror"],["msRequestFullscreen","msExitFullscreen","msFullscreenElement","msFullscreenEnabled","MSFullscreenChange","MSFullscreenError"]],n={},o=0;o<e.length;o++){var i=e[o];if(i&&i[1]in t){for(var a=0;a<i.length;a++)n[e[0][a]]=i[a];return n}}return!1}();if(!n)return void(e&&e.fancybox&&(e.fancybox.defaults.btnTpl.fullScreen=!1));var o={request:function(e){e=e||t.documentElement,e[n.requestFullscreen](e.ALLOW_KEYBOARD_INPUT)},exit:function(){t[n.exitFullscreen]()},toggle:function(e){e=e||t.documentElement,this.isFullscreen()?this.exit():this.request(e)},isFullscreen:function(){return Boolean(t[n.fullscreenElement])},enabled:function(){return Boolean(t[n.fullscreenEnabled])}};e.extend(!0,e.fancybox.defaults,{btnTpl:{fullScreen:'<button data-fancybox-fullscreen class="fancybox-button fancybox-button--fullscreen" title="{{FULL_SCREEN}}"><svg viewBox="0 0 40 40"><path d="M9,12 v16 h22 v-16 h-22 v8" /></svg></button>'},fullScreen:{autoStart:!1}}),e(t).on({"onInit.fb":function(t,e){var n;e&&e.group[e.currIndex].opts.fullScreen?(n=e.$refs.container,n.on("click.fb-fullscreen","[data-fancybox-fullscreen]",function(t){t.stopPropagation(),t.preventDefault(),o.toggle()}),e.opts.fullScreen&&e.opts.fullScreen.autoStart===!0&&o.request(),e.FullScreen=o):e&&e.$refs.toolbar.find("[data-fancybox-fullscreen]").hide()},"afterKeydown.fb":function(t,e,n,o,i){e&&e.FullScreen&&70===i&&(o.preventDefault(),e.FullScreen.toggle())},"beforeClose.fb":function(t,e){e&&e.FullScreen&&e.$refs.container.hasClass("fancybox-is-fullscreen")&&o.exit()}}),e(t).on(n.fullscreenchange,function(){var t=o.isFullscreen(),n=e.fancybox.getInstance();n&&(n.current&&"image"===n.current.type&&n.isAnimating&&(n.current.$content.css("transition","none"),n.isAnimating=!1,n.update(!0,!0,0)),n.trigger("onFullscreenChange",t),n.$refs.container.toggleClass("fancybox-is-fullscreen",t))})}(document,window.jQuery||jQuery),function(t,e){"use strict";var n="fancybox-thumbs",o=n+"-active",i=n+"-loading";e.fancybox.defaults=e.extend(!0,{btnTpl:{thumbs:'<button data-fancybox-thumbs class="fancybox-button fancybox-button--thumbs" title="{{THUMBS}}"><svg viewBox="0 0 120 120"><path d="M30,30 h14 v14 h-14 Z M50,30 h14 v14 h-14 Z M70,30 h14 v14 h-14 Z M30,50 h14 v14 h-14 Z M50,50 h14 v14 h-14 Z M70,50 h14 v14 h-14 Z M30,70 h14 v14 h-14 Z M50,70 h14 v14 h-14 Z M70,70 h14 v14 h-14 Z" /></svg></button>'},thumbs:{autoStart:!1,hideOnClose:!0,parentEl:".fancybox-container",axis:"y"}},e.fancybox.defaults);var a=function(t){this.init(t)};e.extend(a.prototype,{$button:null,$grid:null,$list:null,isVisible:!1,isActive:!1,init:function(t){var e,n,o=this;o.instance=t,t.Thumbs=o,o.opts=t.group[t.currIndex].opts.thumbs,e=t.group[0],e=e.opts.thumb||!(!e.opts.$thumb||!e.opts.$thumb.length)&&e.opts.$thumb.attr("src"),t.group.length>1&&(n=t.group[1],n=n.opts.thumb||!(!n.opts.$thumb||!n.opts.$thumb.length)&&n.opts.$thumb.attr("src")),o.$button=t.$refs.toolbar.find("[data-fancybox-thumbs]"),o.opts&&e&&n&&e&&n?(o.$button.show().on("click",function(){o.toggle()}),o.isActive=!0):o.$button.hide()},create:function(){var t,o=this,a=o.instance,s=o.opts.parentEl,r=[];o.$grid||(o.$grid=e('<div class="'+n+" "+n+"-"+o.opts.axis+'"></div>').appendTo(a.$refs.container.find(s).addBack().filter(s)),o.$grid.on("click","li",function(){a.jumpTo(e(this).attr("data-index"))})),o.$list||(o.$list=e("<ul>").appendTo(o.$grid)),e.each(a.group,function(e,n){t=n.opts.thumb||(n.opts.$thumb?n.opts.$thumb.attr("src"):null),t||"image"!==n.type||(t=n.src),r.push('<li data-index="'+e+'" tabindex="0" class="'+i+'"'+(t&&t.length?' style="background-image:url('+t+')" />':"")+"></li>")}),o.$list[0].innerHTML=r.join(""),"x"===o.opts.axis&&o.$list.width(parseInt(o.$grid.css("padding-right"),10)+a.group.length*o.$list.children().eq(0).outerWidth(!0))},focus:function(t){var e,n,i=this,a=i.$list,s=i.$grid;i.instance.current&&(e=a.children().removeClass(o).filter('[data-index="'+i.instance.current.index+'"]').addClass(o),n=e.position(),"y"===i.opts.axis&&(n.top<0||n.top>a.height()-e.outerHeight())?a.stop().animate({scrollTop:a.scrollTop()+n.top},t):"x"===i.opts.axis&&(n.left<s.scrollLeft()||n.left>s.scrollLeft()+(s.width()-e.outerWidth()))&&a.parent().stop().animate({scrollLeft:n.left},t))},update:function(){var t=this;t.instance.$refs.container.toggleClass("fancybox-show-thumbs",this.isVisible),t.isVisible?(t.$grid||t.create(),t.instance.trigger("onThumbsShow"),t.focus(0)):t.$grid&&t.instance.trigger("onThumbsHide"),t.instance.update()},hide:function(){this.isVisible=!1,this.update()},show:function(){this.isVisible=!0,this.update()},toggle:function(){this.isVisible=!this.isVisible,this.update()}}),e(t).on({"onInit.fb":function(t,e){var n;e&&!e.Thumbs&&(n=new a(e),n.isActive&&n.opts.autoStart===!0&&n.show())},"beforeShow.fb":function(t,e,n,o){var i=e&&e.Thumbs;i&&i.isVisible&&i.focus(o?0:250)},"afterKeydown.fb":function(t,e,n,o,i){var a=e&&e.Thumbs;a&&a.isActive&&71===i&&(o.preventDefault(),a.toggle())},"beforeClose.fb":function(t,e){var n=e&&e.Thumbs;n&&n.isVisible&&n.opts.hideOnClose!==!1&&n.$grid.hide()}})}(document,window.jQuery||jQuery),function(t,e){"use strict";function n(t){var e={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#x2F;","`":"&#x60;","=":"&#x3D;"};return String(t).replace(/[&<>"'`=\/]/g,function(t){return e[t]})}e.extend(!0,e.fancybox.defaults,{btnTpl:{share:'<button data-fancybox-share class="fancybox-button fancybox-button--share" title="{{SHARE}}"><svg viewBox="0 0 40 40"><path d="M6,30 C8,18 19,16 23,16 L23,16 L23,10 L33,20 L23,29 L23,24 C19,24 8,27 6,30 Z"></svg></button>'},share:{url:function(t,e){return!t.currentHash&&"inline"!==e.type&&"html"!==e.type&&(e.origSrc||e.src)||window.location},tpl:'<div class="fancybox-share"><h1>{{SHARE}}</h1><p><a class="fancybox-share__button fancybox-share__button--fb" href="https://www.facebook.com/sharer/sharer.php?u={{url}}"><svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m287 456v-299c0-21 6-35 35-35h38v-63c-7-1-29-3-55-3-54 0-91 33-91 94v306m143-254h-205v72h196" /></svg><span>Facebook</span></a><a class="fancybox-share__button fancybox-share__button--tw" href="https://twitter.com/intent/tweet?url={{url}}&text={{descr}}"><svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m456 133c-14 7-31 11-47 13 17-10 30-27 37-46-15 10-34 16-52 20-61-62-157-7-141 75-68-3-129-35-169-85-22 37-11 86 26 109-13 0-26-4-37-9 0 39 28 72 65 80-12 3-25 4-37 2 10 33 41 57 77 57-42 30-77 38-122 34 170 111 378-32 359-208 16-11 30-25 41-42z" /></svg><span>Twitter</span></a><a class="fancybox-share__button fancybox-share__button--pt" href="https://www.pinterest.com/pin/create/button/?url={{url}}&description={{descr}}&media={{media}}"><svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m265 56c-109 0-164 78-164 144 0 39 15 74 47 87 5 2 10 0 12-5l4-19c2-6 1-8-3-13-9-11-15-25-15-45 0-58 43-110 113-110 62 0 96 38 96 88 0 67-30 122-73 122-24 0-42-19-36-44 6-29 20-60 20-81 0-19-10-35-31-35-25 0-44 26-44 60 0 21 7 36 7 36l-30 125c-8 37-1 83 0 87 0 3 4 4 5 2 2-3 32-39 42-75l16-64c8 16 31 29 56 29 74 0 124-67 124-157 0-69-58-132-146-132z" fill="#fff"/></svg><span>Pinterest</span></a></p><p><input class="fancybox-share__input" type="text" value="{{url_raw}}" /></p></div>'}}),e(t).on("click","[data-fancybox-share]",function(){var t,o,i=e.fancybox.getInstance(),a=i.current||null;a&&("function"===e.type(a.opts.share.url)&&(t=a.opts.share.url.apply(a,[i,a])),o=a.opts.share.tpl.replace(/\{\{media\}\}/g,"image"===a.type?encodeURIComponent(a.src):"").replace(/\{\{url\}\}/g,encodeURIComponent(t)).replace(/\{\{url_raw\}\}/g,n(t)).replace(/\{\{descr\}\}/g,i.$caption?encodeURIComponent(i.$caption.text()):""),e.fancybox.open({src:i.translate(i,o),type:"html",opts:{animationEffect:!1,afterLoad:function(t,e){i.$refs.container.one("beforeClose.fb",function(){t.close(null,0)}),e.$content.find(".fancybox-share__links a").click(function(){return window.open(this.href,"Share","width=550, height=450"),!1})}}}))})}(document,window.jQuery||jQuery),function(t,e,n){"use strict";function o(){var t=e.location.hash.substr(1),n=t.split("-"),o=n.length>1&&/^\+?\d+$/.test(n[n.length-1])?parseInt(n.pop(-1),10)||1:1,i=n.join("-");return{hash:t,index:o<1?1:o,gallery:i}}function i(t){var e;""!==t.gallery&&(e=n("[data-fancybox='"+n.escapeSelector(t.gallery)+"']").eq(t.index-1).trigger("click.fb-start"))}function a(t){var e,n;return!!t&&(e=t.current?t.current.opts:t.opts,n=e.hash||(e.$orig?e.$orig.data("fancybox"):""),""!==n&&n)}n.escapeSelector||(n.escapeSelector=function(t){var e=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g,n=function(t,e){return e?"\0"===t?"":t.slice(0,-1)+"\\"+t.charCodeAt(t.length-1).toString(16)+" ":"\\"+t};return(t+"").replace(e,n)}),n(function(){n.fancybox.defaults.hash!==!1&&(n(t).on({"onInit.fb":function(t,e){var n,i;e.group[e.currIndex].opts.hash!==!1&&(n=o(),i=a(e),i&&n.gallery&&i==n.gallery&&(e.currIndex=n.index-1))},"beforeShow.fb":function(n,o,i,s){var r;i&&i.opts.hash!==!1&&(r=a(o),r&&(o.currentHash=r+(o.group.length>1?"-"+(i.index+1):""),e.location.hash!=="#"+o.currentHash&&(o.origHash||(o.origHash=e.location.hash),o.hashTimer&&clearTimeout(o.hashTimer),o.hashTimer=setTimeout(function(){"replaceState"in e.history?(e.history[s?"pushState":"replaceState"]({},t.title,e.location.pathname+e.location.search+"#"+o.currentHash),s&&(o.hasCreatedHistory=!0)):e.location.hash=o.currentHash,o.hashTimer=null},300))))},"beforeClose.fb":function(n,o,i){var s;i.opts.hash!==!1&&(s=a(o),o.currentHash&&o.hasCreatedHistory?e.history.back():o.currentHash&&("replaceState"in e.history?e.history.replaceState({},t.title,e.location.pathname+e.location.search+(o.origHash||"")):e.location.hash=o.origHash),o.currentHash=null,clearTimeout(o.hashTimer))}}),n(e).on("hashchange.fb",function(){var t,e=o();n.each(n(".fancybox-container").get().reverse(),function(e,o){var i=n(o).data("FancyBox");if(i.currentHash)return t=i,!1}),t?!t.currentHash||t.currentHash===e.gallery+"-"+e.index||1===e.index&&t.currentHash==e.gallery||(t.currentHash=null,t.close()):""!==e.gallery&&i(e)}),setTimeout(function(){n.fancybox.getInstance()||i(o())},50))})}(document,window,window.jQuery||jQuery),function(t,e){"use strict";var n=(new Date).getTime();e(t).on({"onInit.fb":function(t,e,o){e.$refs.stage.on("mousewheel DOMMouseScroll wheel MozMousePixelScroll",function(t){var o=e.current,i=(new Date).getTime();e.group.length<2||o.opts.wheel===!1||"auto"===o.opts.wheel&&"image"!==o.type||(t.preventDefault(),t.stopPropagation(),o.$slide.hasClass("fancybox-animated")||(t=t.originalEvent||t,i-n<250||(n=i,e[(-t.deltaY||-t.deltaX||t.wheelDelta||-t.detail)<0?"next":"previous"]())))})}})}(document,window.jQuery||jQuery);
    // Generated by CoffeeScript 1.9.2
    
    /**
    @license Sticky-kit v1.1.2 | WTFPL | Leaf Corcoran 2015 | http://leafo.net
     */
    
    (function() {
      var $, win;
    
      $ = this.jQuery || window.jQuery;
    
      win = $(window);
    
      $.fn.stick_in_parent = function(opts) {
        var doc, elm, enable_bottoming, fn, i, inner_scrolling, len, manual_spacer, offset_top, parent_selector, recalc_every, sticky_class;
        if (opts == null) {
          opts = {};
        }
        sticky_class = opts.sticky_class, inner_scrolling = opts.inner_scrolling, recalc_every = opts.recalc_every, parent_selector = opts.parent, offset_top = opts.offset_top, manual_spacer = opts.spacer, enable_bottoming = opts.bottoming;
        if (offset_top == null) {
          offset_top = 0;
        }
        if (parent_selector == null) {
          parent_selector = void 0;
        }
        if (inner_scrolling == null) {
          inner_scrolling = true;
        }
        if (sticky_class == null) {
          sticky_class = "is_stuck";
        }
        doc = $(document);
        if (enable_bottoming == null) {
          enable_bottoming = true;
        }
        fn = function(elm, padding_bottom, parent_top, parent_height, top, height, el_float, detached) {
          var bottomed, detach, fixed, last_pos, last_scroll_height, offset, parent, recalc, recalc_and_tick, recalc_counter, spacer, tick;
          if (elm.data("sticky_kit")) {
            return;
          }
          elm.data("sticky_kit", true);
          last_scroll_height = doc.height();
          parent = elm.parent();
          if (parent_selector != null) {
            parent = parent.closest(parent_selector);
          }
          if (!parent.length) {
            throw "failed to find stick parent";
          }
          fixed = false;
          bottomed = false;
          spacer = manual_spacer != null ? manual_spacer && elm.closest(manual_spacer) : $("<div />");
          if (spacer) {
            spacer.css('position', elm.css('position'));
          }
          recalc = function() {
            var border_top, padding_top, restore;
            if (detached) {
              return;
            }
            last_scroll_height = doc.height();
            border_top = parseInt(parent.css("border-top-width"), 10);
            padding_top = parseInt(parent.css("padding-top"), 10);
            padding_bottom = parseInt(parent.css("padding-bottom"), 10);
            parent_top = parent.offset().top + border_top + padding_top;
            parent_height = parent.height();
            if (fixed) {
              fixed = false;
              bottomed = false;
              if (manual_spacer == null) {
                elm.insertAfter(spacer);
                spacer.detach();
              }
              elm.css({
                position: "",
                top: "",
                width: "",
                bottom: ""
              }).removeClass(sticky_class);
              restore = true;
            }
            top = elm.offset().top - (parseInt(elm.css("margin-top"), 10) || 0) - offset_top;
            height = elm.outerHeight(true);
            el_float = elm.css("float");
            if (spacer) {
              spacer.css({
                width: elm.outerWidth(true),
                height: height,
                display: elm.css("display"),
                "vertical-align": elm.css("vertical-align"),
                "float": el_float
              });
            }
            if (restore) {
              return tick();
            }
          };
          recalc();
          if (height === parent_height) {
            return;
          }
          last_pos = void 0;
          offset = offset_top;
          recalc_counter = recalc_every;
          tick = function() {
            var css, delta, recalced, scroll, will_bottom, win_height;
            if (detached) {
              return;
            }
            recalced = false;
            if (recalc_counter != null) {
              recalc_counter -= 1;
              if (recalc_counter <= 0) {
                recalc_counter = recalc_every;
                recalc();
                recalced = true;
              }
            }
            if (!recalced && doc.height() !== last_scroll_height) {
              recalc();
              recalced = true;
            }
            scroll = win.scrollTop();
            if (last_pos != null) {
              delta = scroll - last_pos;
            }
            last_pos = scroll;
            if (fixed) {
              if (enable_bottoming) {
                will_bottom = scroll + height + offset > parent_height + parent_top;
                if (bottomed && !will_bottom) {
                  bottomed = false;
                  elm.css({
                    position: "fixed",
                    bottom: "",
                    top: offset
                  }).trigger("sticky_kit:unbottom");
                }
              }
              if (scroll < top) {
                fixed = false;
                offset = offset_top;
                if (manual_spacer == null) {
                  if (el_float === "left" || el_float === "right") {
                    elm.insertAfter(spacer);
                  }
                  spacer.detach();
                }
                css = {
                  position: "",
                  width: "",
                  top: ""
                };
                elm.css(css).removeClass(sticky_class).trigger("sticky_kit:unstick");
              }
              if (inner_scrolling) {
                win_height = win.height();
                if (height + offset_top > win_height) {
                  if (!bottomed) {
                    offset -= delta;
                    offset = Math.max(win_height - height, offset);
                    offset = Math.min(offset_top, offset);
                    if (fixed) {
                      elm.css({
                        top: offset + "px"
                      });
                    }
                  }
                }
              }
            } else {
              if (scroll > top) {
                fixed = true;
                css = {
                  position: "fixed",
                  top: offset
                };
                css.width = elm.css("box-sizing") === "border-box" ? elm.outerWidth() + "px" : elm.width() + "px";
                elm.css(css).addClass(sticky_class);
                if (manual_spacer == null) {
                  elm.after(spacer);
                  if (el_float === "left" || el_float === "right") {
                    spacer.append(elm);
                  }
                }
                elm.trigger("sticky_kit:stick");
              }
            }
            if (fixed && enable_bottoming) {
              if (will_bottom == null) {
                will_bottom = scroll + height + offset > parent_height + parent_top;
              }
              if (!bottomed && will_bottom) {
                bottomed = true;
                if (parent.css("position") === "static") {
                  parent.css({
                    position: "relative"
                  });
                }
                return elm.css({
                  position: "absolute",
                  bottom: padding_bottom,
                  top: "auto"
                }).trigger("sticky_kit:bottom");
              }
            }
          };
          recalc_and_tick = function() {
            recalc();
            return tick();
          };
          detach = function() {
            detached = true;
            win.off("touchmove", tick);
            win.off("scroll", tick);
            win.off("resize", recalc_and_tick);
            $(document.body).off("sticky_kit:recalc", recalc_and_tick);
            elm.off("sticky_kit:detach", detach);
            elm.removeData("sticky_kit");
            elm.css({
              position: "",
              bottom: "",
              top: "",
              width: ""
            });
            parent.position("position", "");
            if (fixed) {
              if (manual_spacer == null) {
                if (el_float === "left" || el_float === "right") {
                  elm.insertAfter(spacer);
                }
                spacer.remove();
              }
              return elm.removeClass(sticky_class);
            }
          };
          win.on("touchmove", tick);
          win.on("scroll", tick);
          win.on("resize", recalc_and_tick);
          $(document.body).on("sticky_kit:recalc", recalc_and_tick);
          elm.on("sticky_kit:detach", detach);
          return setTimeout(tick, 0);
        };
        for (i = 0, len = this.length; i < len; i++) {
          elm = this[i];
          fn($(elm));
        }
        return this;
      };
    
    }).call(this);
    
    !function(e){e(["jquery"],function(e){return function(){function t(e,t,n){return g({type:O.error,iconClass:m().iconClasses.error,message:e,optionsOverride:n,title:t})}function n(t,n){return t||(t=m()),v=e("#"+t.containerId),v.length?v:(n&&(v=d(t)),v)}function o(e,t,n){return g({type:O.info,iconClass:m().iconClasses.info,message:e,optionsOverride:n,title:t})}function s(e){C=e}function i(e,t,n){return g({type:O.success,iconClass:m().iconClasses.success,message:e,optionsOverride:n,title:t})}function a(e,t,n){return g({type:O.warning,iconClass:m().iconClasses.warning,message:e,optionsOverride:n,title:t})}function r(e,t){var o=m();v||n(o),u(e,o,t)||l(o)}function c(t){var o=m();return v||n(o),t&&0===e(":focus",t).length?void h(t):void(v.children().length&&v.remove())}function l(t){for(var n=v.children(),o=n.length-1;o>=0;o--)u(e(n[o]),t)}function u(t,n,o){var s=!(!o||!o.force)&&o.force;return!(!t||!s&&0!==e(":focus",t).length)&&(t[n.hideMethod]({duration:n.hideDuration,easing:n.hideEasing,complete:function(){h(t)}}),!0)}function d(t){return v=e("<div/>").attr("id",t.containerId).addClass(t.positionClass),v.appendTo(e(t.target)),v}function p(){return{tapToDismiss:!0,toastClass:"toast",containerId:"toast-container",debug:!1,showMethod:"fadeIn",showDuration:300,showEasing:"swing",onShown:void 0,hideMethod:"fadeOut",hideDuration:1e3,hideEasing:"swing",onHidden:void 0,closeMethod:!1,closeDuration:!1,closeEasing:!1,closeOnHover:!0,extendedTimeOut:1e3,iconClasses:{error:"toast-error",info:"toast-info",success:"toast-success",warning:"toast-warning"},iconClass:"toast-info",positionClass:"toast-top-right",timeOut:5e3,titleClass:"toast-title",messageClass:"toast-message",escapeHtml:!1,target:"body",closeHtml:'<button type="button">&times;</button>',closeClass:"toast-close-button",newestOnTop:!0,preventDuplicates:!1,progressBar:!1,progressClass:"toast-progress",rtl:!1}}function f(e){C&&C(e)}function g(t){function o(e){return null==e&&(e=""),e.replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/'/g,"&#39;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}function s(){c(),u(),d(),p(),g(),C(),l(),i()}function i(){var e="";switch(t.iconClass){case"toast-success":case"toast-info":e="polite";break;default:e="assertive"}I.attr("aria-live",e)}function a(){E.closeOnHover&&I.hover(H,D),!E.onclick&&E.tapToDismiss&&I.click(b),E.closeButton&&j&&j.click(function(e){e.stopPropagation?e.stopPropagation():void 0!==e.cancelBubble&&e.cancelBubble!==!0&&(e.cancelBubble=!0),E.onCloseClick&&E.onCloseClick(e),b(!0)}),E.onclick&&I.click(function(e){E.onclick(e),b()})}function r(){I.hide(),I[E.showMethod]({duration:E.showDuration,easing:E.showEasing,complete:E.onShown}),E.timeOut>0&&(k=setTimeout(b,E.timeOut),F.maxHideTime=parseFloat(E.timeOut),F.hideEta=(new Date).getTime()+F.maxHideTime,E.progressBar&&(F.intervalId=setInterval(x,10)))}function c(){t.iconClass&&I.addClass(E.toastClass).addClass(y)}function l(){E.newestOnTop?v.prepend(I):v.append(I)}function u(){if(t.title){var e=t.title;E.escapeHtml&&(e=o(t.title)),M.append(e).addClass(E.titleClass),I.append(M)}}function d(){if(t.message){var e=t.message;E.escapeHtml&&(e=o(t.message)),B.append(e).addClass(E.messageClass),I.append(B)}}function p(){E.closeButton&&(j.addClass(E.closeClass).attr("role","button"),I.prepend(j))}function g(){E.progressBar&&(q.addClass(E.progressClass),I.prepend(q))}function C(){E.rtl&&I.addClass("rtl")}function O(e,t){if(e.preventDuplicates){if(t.message===w)return!0;w=t.message}return!1}function b(t){var n=t&&E.closeMethod!==!1?E.closeMethod:E.hideMethod,o=t&&E.closeDuration!==!1?E.closeDuration:E.hideDuration,s=t&&E.closeEasing!==!1?E.closeEasing:E.hideEasing;if(!e(":focus",I).length||t)return clearTimeout(F.intervalId),I[n]({duration:o,easing:s,complete:function(){h(I),clearTimeout(k),E.onHidden&&"hidden"!==P.state&&E.onHidden(),P.state="hidden",P.endTime=new Date,f(P)}})}function D(){(E.timeOut>0||E.extendedTimeOut>0)&&(k=setTimeout(b,E.extendedTimeOut),F.maxHideTime=parseFloat(E.extendedTimeOut),F.hideEta=(new Date).getTime()+F.maxHideTime)}function H(){clearTimeout(k),F.hideEta=0,I.stop(!0,!0)[E.showMethod]({duration:E.showDuration,easing:E.showEasing})}function x(){var e=(F.hideEta-(new Date).getTime())/F.maxHideTime*100;q.width(e+"%")}var E=m(),y=t.iconClass||E.iconClass;if("undefined"!=typeof t.optionsOverride&&(E=e.extend(E,t.optionsOverride),y=t.optionsOverride.iconClass||y),!O(E,t)){T++,v=n(E,!0);var k=null,I=e("<div/>"),M=e("<div/>"),B=e("<div/>"),q=e("<div/>"),j=e(E.closeHtml),F={intervalId:null,hideEta:null,maxHideTime:null},P={toastId:T,state:"visible",startTime:new Date,options:E,map:t};return s(),r(),a(),f(P),E.debug&&console&&console.log(P),I}}function m(){return e.extend({},p(),b.options)}function h(e){v||(v=n()),e.is(":visible")||(e.remove(),e=null,0===v.children().length&&(v.remove(),w=void 0))}var v,C,w,T=0,O={error:"error",info:"info",success:"success",warning:"warning"},b={clear:r,remove:c,error:t,getContainer:n,info:o,options:{},subscribe:s,success:i,version:"2.1.3",warning:a};return b}()})}("function"==typeof define&&define.amd?define:function(e,t){"undefined"!=typeof module&&module.exports?module.exports=t(require("jquery")):window.toastr=t(window.jQuery)});
    
    /*!
     * Select2 4.0.5
     * https://select2.github.io
     *
     * Released under the MIT license
     * https://github.com/select2/select2/blob/master/LICENSE.md
     */
    (function (factory) {
      if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
      } else if (typeof module === 'object' && module.exports) {
        // Node/CommonJS
        module.exports = function (root, jQuery) {
          if (jQuery === undefined) {
            // require('jQuery') returns a factory that requires window to
            // build a jQuery instance, we normalize how we use modules
            // that require this pattern but the window provided is a noop
            // if it's defined (how jquery works)
            if (typeof window !== 'undefined') {
              jQuery = require('jquery');
            }
            else {
              jQuery = require('jquery')(root);
            }
          }
          factory(jQuery);
          return jQuery;
        };
      } else {
        // Browser globals
        factory(jQuery);
      }
    } (function (jQuery) {
      // This is needed so we can catch the AMD loader configuration and use it
      // The inner file should be wrapped (by `banner.start.js`) in a function that
      // returns the AMD loader references.
      var S2 =(function () {
      // Restore the Select2 AMD loader so it can be used
      // Needed mostly in the language files, where the loader is not inserted
      if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) {
        var S2 = jQuery.fn.select2.amd;
      }
    var S2;(function () { if (!S2 || !S2.requirejs) {
    if (!S2) { S2 = {}; } else { require = S2; }
    /**
     * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.
     * Released under MIT license, http://github.com/requirejs/almond/LICENSE
     */
    //Going sloppy to avoid 'use strict' string cost, but strict practices should
    //be followed.
    /*global setTimeout: false */
    
    var requirejs, require, define;
    (function (undef) {
        var main, req, makeMap, handlers,
            defined = {},
            waiting = {},
            config = {},
            defining = {},
            hasOwn = Object.prototype.hasOwnProperty,
            aps = [].slice,
            jsSuffixRegExp = /\.js$/;
    
        function hasProp(obj, prop) {
            return hasOwn.call(obj, prop);
        }
    
        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @returns {String} normalized name
         */
        function normalize(name, baseName) {
            var nameParts, nameSegment, mapValue, foundMap, lastIndex,
                foundI, foundStarMap, starI, i, j, part, normalizedBaseParts,
                baseParts = baseName && baseName.split("/"),
                map = config.map,
                starMap = (map && map['*']) || {};
    
            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;
    
                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }
    
                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }
    
                //start trimDots
                for (i = 0; i < name.length; i++) {
                    part = name[i];
                    if (part === '.') {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === '..') {
                        // If at the start, or previous value is still ..,
                        // keep them so that when converted to a path it may
                        // still work when converted to a path, even though
                        // as an ID it is less than ideal. In larger point
                        // releases, may be better to just kick out an error.
                        if (i === 0 || (i === 1 && name[2] === '..') || name[i - 1] === '..') {
                            continue;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots
    
                name = name.join('/');
            }
    
            //Apply map config if available.
            if ((baseParts || starMap) && map) {
                nameParts = name.split('/');
    
                for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join("/");
    
                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = map[baseParts.slice(0, j).join('/')];
    
                            //baseName segment has  config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = mapValue[nameSegment];
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break;
                                }
                            }
                        }
                    }
    
                    if (foundMap) {
                        break;
                    }
    
                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && starMap[nameSegment]) {
                        foundStarMap = starMap[nameSegment];
                        starI = i;
                    }
                }
    
                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }
    
                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }
    
            return name;
        }
    
        function makeRequire(relName, forceSync) {
            return function () {
                //A version of a require function that passes a moduleName
                //value for items that may need to
                //look up paths relative to the moduleName
                var args = aps.call(arguments, 0);
    
                //If first arg is not require('string'), and there is only
                //one arg, it is the array form without a callback. Insert
                //a null so that the following concat is correct.
                if (typeof args[0] !== 'string' && args.length === 1) {
                    args.push(null);
                }
                return req.apply(undef, args.concat([relName, forceSync]));
            };
        }
    
        function makeNormalize(relName) {
            return function (name) {
                return normalize(name, relName);
            };
        }
    
        function makeLoad(depName) {
            return function (value) {
                defined[depName] = value;
            };
        }
    
        function callDep(name) {
            if (hasProp(waiting, name)) {
                var args = waiting[name];
                delete waiting[name];
                defining[name] = true;
                main.apply(undef, args);
            }
    
            if (!hasProp(defined, name) && !hasProp(defining, name)) {
                throw new Error('No ' + name);
            }
            return defined[name];
        }
    
        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }
    
        //Creates a parts array for a relName where first part is plugin ID,
        //second part is resource ID. Assumes relName has already been normalized.
        function makeRelParts(relName) {
            return relName ? splitPrefix(relName) : [];
        }
    
        /**
         * Makes a name map, normalizing the name, and using a plugin
         * for normalization if necessary. Grabs a ref to plugin
         * too, as an optimization.
         */
        makeMap = function (name, relParts) {
            var plugin,
                parts = splitPrefix(name),
                prefix = parts[0],
                relResourceName = relParts[1];
    
            name = parts[1];
    
            if (prefix) {
                prefix = normalize(prefix, relResourceName);
                plugin = callDep(prefix);
            }
    
            //Normalize according
            if (prefix) {
                if (plugin && plugin.normalize) {
                    name = plugin.normalize(name, makeNormalize(relResourceName));
                } else {
                    name = normalize(name, relResourceName);
                }
            } else {
                name = normalize(name, relResourceName);
                parts = splitPrefix(name);
                prefix = parts[0];
                name = parts[1];
                if (prefix) {
                    plugin = callDep(prefix);
                }
            }
    
            //Using ridiculous property names for space reasons
            return {
                f: prefix ? prefix + '!' + name : name, //fullName
                n: name,
                pr: prefix,
                p: plugin
            };
        };
    
        function makeConfig(name) {
            return function () {
                return (config && config.config && config.config[name]) || {};
            };
        }
    
        handlers = {
            require: function (name) {
                return makeRequire(name);
            },
            exports: function (name) {
                var e = defined[name];
                if (typeof e !== 'undefined') {
                    return e;
                } else {
                    return (defined[name] = {});
                }
            },
            module: function (name) {
                return {
                    id: name,
                    uri: '',
                    exports: defined[name],
                    config: makeConfig(name)
                };
            }
        };
    
        main = function (name, deps, callback, relName) {
            var cjsModule, depName, ret, map, i, relParts,
                args = [],
                callbackType = typeof callback,
                usingExports;
    
            //Use name if no relName
            relName = relName || name;
            relParts = makeRelParts(relName);
    
            //Call the callback to define the module, if necessary.
            if (callbackType === 'undefined' || callbackType === 'function') {
                //Pull out the defined dependencies and pass the ordered
                //values to the callback.
                //Default to [require, exports, module] if no deps
                deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
                for (i = 0; i < deps.length; i += 1) {
                    map = makeMap(deps[i], relParts);
                    depName = map.f;
    
                    //Fast path CommonJS standard dependencies.
                    if (depName === "require") {
                        args[i] = handlers.require(name);
                    } else if (depName === "exports") {
                        //CommonJS module spec 1.1
                        args[i] = handlers.exports(name);
                        usingExports = true;
                    } else if (depName === "module") {
                        //CommonJS module spec 1.1
                        cjsModule = args[i] = handlers.module(name);
                    } else if (hasProp(defined, depName) ||
                               hasProp(waiting, depName) ||
                               hasProp(defining, depName)) {
                        args[i] = callDep(depName);
                    } else if (map.p) {
                        map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                        args[i] = defined[depName];
                    } else {
                        throw new Error(name + ' missing ' + depName);
                    }
                }
    
                ret = callback ? callback.apply(defined[name], args) : undefined;
    
                if (name) {
                    //If setting exports via "module" is in play,
                    //favor that over return value and exports. After that,
                    //favor a non-undefined return value over exports use.
                    if (cjsModule && cjsModule.exports !== undef &&
                            cjsModule.exports !== defined[name]) {
                        defined[name] = cjsModule.exports;
                    } else if (ret !== undef || !usingExports) {
                        //Use the return value from the function.
                        defined[name] = ret;
                    }
                }
            } else if (name) {
                //May just be an object definition for the module. Only
                //worry about defining if have a module name.
                defined[name] = callback;
            }
        };
    
        requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
            if (typeof deps === "string") {
                if (handlers[deps]) {
                    //callback in this case is really relName
                    return handlers[deps](callback);
                }
                //Just return the module wanted. In this scenario, the
                //deps arg is the module name, and second arg (if passed)
                //is just the relName.
                //Normalize module name, if it contains . or ..
                return callDep(makeMap(deps, makeRelParts(callback)).f);
            } else if (!deps.splice) {
                //deps is a config object, not an array.
                config = deps;
                if (config.deps) {
                    req(config.deps, config.callback);
                }
                if (!callback) {
                    return;
                }
    
                if (callback.splice) {
                    //callback is an array, which means it is a dependency list.
                    //Adjust args if there are dependencies
                    deps = callback;
                    callback = relName;
                    relName = null;
                } else {
                    deps = undef;
                }
            }
    
            //Support require(['a'])
            callback = callback || function () {};
    
            //If relName is a function, it is an errback handler,
            //so remove it.
            if (typeof relName === 'function') {
                relName = forceSync;
                forceSync = alt;
            }
    
            //Simulate async callback;
            if (forceSync) {
                main(undef, deps, callback, relName);
            } else {
                //Using a non-zero value because of concern for what old browsers
                //do, and latest browsers "upgrade" to 4 if lower value is used:
                //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
                //If want a value immediately, use require('id') instead -- something
                //that works in almond on the global level, but not guaranteed and
                //unlikely to work in other AMD implementations.
                setTimeout(function () {
                    main(undef, deps, callback, relName);
                }, 4);
            }
    
            return req;
        };
    
        /**
         * Just drops the config on the floor, but returns req in case
         * the config return value is used.
         */
        req.config = function (cfg) {
            return req(cfg);
        };
    
        /**
         * Expose module registry for debugging and tooling
         */
        requirejs._defined = defined;
    
        define = function (name, deps, callback) {
            if (typeof name !== 'string') {
                throw new Error('See almond README: incorrect module build, no module name');
            }
    
            //This module may not have dependencies
            if (!deps.splice) {
                //deps is not an array, so probably means
                //an object literal or factory function for
                //the value. Adjust args.
                callback = deps;
                deps = [];
            }
    
            if (!hasProp(defined, name) && !hasProp(waiting, name)) {
                waiting[name] = [name, deps, callback];
            }
        };
    
        define.amd = {
            jQuery: true
        };
    }());
    
    S2.requirejs = requirejs;S2.require = require;S2.define = define;
    }
    }());
    S2.define("almond", function(){});
    
    /* global jQuery:false, $:false */
    S2.define('jquery',[],function () {
      var _$ = jQuery || $;
    
      if (_$ == null && console && console.error) {
        console.error(
          'Select2: An instance of jQuery or a jQuery-compatible library was not ' +
          'found. Make sure that you are including jQuery before Select2 on your ' +
          'web page.'
        );
      }
    
      return _$;
    });
    
    S2.define('select2/utils',[
      'jquery'
    ], function ($) {
      var Utils = {};
    
      Utils.Extend = function (ChildClass, SuperClass) {
        var __hasProp = {}.hasOwnProperty;
    
        function BaseConstructor () {
          this.constructor = ChildClass;
        }
    
        for (var key in SuperClass) {
          if (__hasProp.call(SuperClass, key)) {
            ChildClass[key] = SuperClass[key];
          }
        }
    
        BaseConstructor.prototype = SuperClass.prototype;
        ChildClass.prototype = new BaseConstructor();
        ChildClass.__super__ = SuperClass.prototype;
    
        return ChildClass;
      };
    
      function getMethods (theClass) {
        var proto = theClass.prototype;
    
        var methods = [];
    
        for (var methodName in proto) {
          var m = proto[methodName];
    
          if (typeof m !== 'function') {
            continue;
          }
    
          if (methodName === 'constructor') {
            continue;
          }
    
          methods.push(methodName);
        }
    
        return methods;
      }
    
      Utils.Decorate = function (SuperClass, DecoratorClass) {
        var decoratedMethods = getMethods(DecoratorClass);
        var superMethods = getMethods(SuperClass);
    
        function DecoratedClass () {
          var unshift = Array.prototype.unshift;
    
          var argCount = DecoratorClass.prototype.constructor.length;
    
          var calledConstructor = SuperClass.prototype.constructor;
    
          if (argCount > 0) {
            unshift.call(arguments, SuperClass.prototype.constructor);
    
            calledConstructor = DecoratorClass.prototype.constructor;
          }
    
          calledConstructor.apply(this, arguments);
        }
    
        DecoratorClass.displayName = SuperClass.displayName;
    
        function ctr () {
          this.constructor = DecoratedClass;
        }
    
        DecoratedClass.prototype = new ctr();
    
        for (var m = 0; m < superMethods.length; m++) {
            var superMethod = superMethods[m];
    
            DecoratedClass.prototype[superMethod] =
              SuperClass.prototype[superMethod];
        }
    
        var calledMethod = function (methodName) {
          // Stub out the original method if it's not decorating an actual method
          var originalMethod = function () {};
    
          if (methodName in DecoratedClass.prototype) {
            originalMethod = DecoratedClass.prototype[methodName];
          }
    
          var decoratedMethod = DecoratorClass.prototype[methodName];
    
          return function () {
            var unshift = Array.prototype.unshift;
    
            unshift.call(arguments, originalMethod);
    
            return decoratedMethod.apply(this, arguments);
          };
        };
    
        for (var d = 0; d < decoratedMethods.length; d++) {
          var decoratedMethod = decoratedMethods[d];
    
          DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);
        }
    
        return DecoratedClass;
      };
    
      var Observable = function () {
        this.listeners = {};
      };
    
      Observable.prototype.on = function (event, callback) {
        this.listeners = this.listeners || {};
    
        if (event in this.listeners) {
          this.listeners[event].push(callback);
        } else {
          this.listeners[event] = [callback];
        }
      };
    
      Observable.prototype.trigger = function (event) {
        var slice = Array.prototype.slice;
        var params = slice.call(arguments, 1);
    
        this.listeners = this.listeners || {};
    
        // Params should always come in as an array
        if (params == null) {
          params = [];
        }
    
        // If there are no arguments to the event, use a temporary object
        if (params.length === 0) {
          params.push({});
        }
    
        // Set the `_type` of the first object to the event
        params[0]._type = event;
    
        if (event in this.listeners) {
          this.invoke(this.listeners[event], slice.call(arguments, 1));
        }
    
        if ('*' in this.listeners) {
          this.invoke(this.listeners['*'], arguments);
        }
      };
    
      Observable.prototype.invoke = function (listeners, params) {
        for (var i = 0, len = listeners.length; i < len; i++) {
          listeners[i].apply(this, params);
        }
      };
    
      Utils.Observable = Observable;
    
      Utils.generateChars = function (length) {
        var chars = '';
    
        for (var i = 0; i < length; i++) {
          var randomChar = Math.floor(Math.random() * 36);
          chars += randomChar.toString(36);
        }
    
        return chars;
      };
    
      Utils.bind = function (func, context) {
        return function () {
          func.apply(context, arguments);
        };
      };
    
      Utils._convertData = function (data) {
        for (var originalKey in data) {
          var keys = originalKey.split('-');
    
          var dataLevel = data;
    
          if (keys.length === 1) {
            continue;
          }
    
          for (var k = 0; k < keys.length; k++) {
            var key = keys[k];
    
            // Lowercase the first letter
            // By default, dash-separated becomes camelCase
            key = key.substring(0, 1).toLowerCase() + key.substring(1);
    
            if (!(key in dataLevel)) {
              dataLevel[key] = {};
            }
    
            if (k == keys.length - 1) {
              dataLevel[key] = data[originalKey];
            }
    
            dataLevel = dataLevel[key];
          }
    
          delete data[originalKey];
        }
    
        return data;
      };
    
      Utils.hasScroll = function (index, el) {
        // Adapted from the function created by @ShadowScripter
        // and adapted by @BillBarry on the Stack Exchange Code Review website.
        // The original code can be found at
        // http://codereview.stackexchange.com/q/13338
        // and was designed to be used with the Sizzle selector engine.
    
        var $el = $(el);
        var overflowX = el.style.overflowX;
        var overflowY = el.style.overflowY;
    
        //Check both x and y declarations
        if (overflowX === overflowY &&
            (overflowY === 'hidden' || overflowY === 'visible')) {
          return false;
        }
    
        if (overflowX === 'scroll' || overflowY === 'scroll') {
          return true;
        }
    
        return ($el.innerHeight() < el.scrollHeight ||
          $el.innerWidth() < el.scrollWidth);
      };
    
      Utils.escapeMarkup = function (markup) {
        var replaceMap = {
          '\\': '&#92;',
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          '\'': '&#39;',
          '/': '&#47;'
        };
    
        // Do not try to escape the markup if it's not a string
        if (typeof markup !== 'string') {
          return markup;
        }
    
        return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
          return replaceMap[match];
        });
      };
    
      // Append an array of jQuery nodes to a given element.
      Utils.appendMany = function ($element, $nodes) {
        // jQuery 1.7.x does not support $.fn.append() with an array
        // Fall back to a jQuery object collection using $.fn.add()
        if ($.fn.jquery.substr(0, 3) === '1.7') {
          var $jqNodes = $();
    
          $.map($nodes, function (node) {
            $jqNodes = $jqNodes.add(node);
          });
    
          $nodes = $jqNodes;
        }
    
        $element.append($nodes);
      };
    
      return Utils;
    });
    
    S2.define('select2/results',[
      'jquery',
      './utils'
    ], function ($, Utils) {
      function Results ($element, options, dataAdapter) {
        this.$element = $element;
        this.data = dataAdapter;
        this.options = options;
    
        Results.__super__.constructor.call(this);
      }
    
      Utils.Extend(Results, Utils.Observable);
    
      Results.prototype.render = function () {
        var $results = $(
          '<ul class="select2-results__options" role="tree"></ul>'
        );
    
        if (this.options.get('multiple')) {
          $results.attr('aria-multiselectable', 'true');
        }
    
        this.$results = $results;
    
        return $results;
      };
    
      Results.prototype.clear = function () {
        this.$results.empty();
      };
    
      Results.prototype.displayMessage = function (params) {
        var escapeMarkup = this.options.get('escapeMarkup');
    
        this.clear();
        this.hideLoading();
    
        var $message = $(
          '<li role="treeitem" aria-live="assertive"' +
          ' class="select2-results__option"></li>'
        );
    
        var message = this.options.get('translations').get(params.message);
    
        $message.append(
          escapeMarkup(
            message(params.args)
          )
        );
    
        $message[0].className += ' select2-results__message';
    
        this.$results.append($message);
      };
    
      Results.prototype.hideMessages = function () {
        this.$results.find('.select2-results__message').remove();
      };
    
      Results.prototype.append = function (data) {
        this.hideLoading();
    
        var $options = [];
    
        if (data.results == null || data.results.length === 0) {
          if (this.$results.children().length === 0) {
            this.trigger('results:message', {
              message: 'noResults'
            });
          }
    
          return;
        }
    
        data.results = this.sort(data.results);
    
        for (var d = 0; d < data.results.length; d++) {
          var item = data.results[d];
    
          var $option = this.option(item);
    
          $options.push($option);
        }
    
        this.$results.append($options);
      };
    
      Results.prototype.position = function ($results, $dropdown) {
        var $resultsContainer = $dropdown.find('.select2-results');
        $resultsContainer.append($results);
      };
    
      Results.prototype.sort = function (data) {
        var sorter = this.options.get('sorter');
    
        return sorter(data);
      };
    
      Results.prototype.highlightFirstItem = function () {
        var $options = this.$results
          .find('.select2-results__option[aria-selected]');
    
        var $selected = $options.filter('[aria-selected=true]');
    
        // Check if there are any selected options
        if ($selected.length > 0) {
          // If there are selected options, highlight the first
          $selected.first().trigger('mouseenter');
        } else {
          // If there are no selected options, highlight the first option
          // in the dropdown
          $options.first().trigger('mouseenter');
        }
    
        this.ensureHighlightVisible();
      };
    
      Results.prototype.setClasses = function () {
        var self = this;
    
        this.data.current(function (selected) {
          var selectedIds = $.map(selected, function (s) {
            return s.id.toString();
          });
    
          var $options = self.$results
            .find('.select2-results__option[aria-selected]');
    
          $options.each(function () {
            var $option = $(this);
    
            var item = $.data(this, 'data');
    
            // id needs to be converted to a string when comparing
            var id = '' + item.id;
    
            if ((item.element != null && item.element.selected) ||
                (item.element == null && $.inArray(id, selectedIds) > -1)) {
              $option.attr('aria-selected', 'true');
            } else {
              $option.attr('aria-selected', 'false');
            }
          });
    
        });
      };
    
      Results.prototype.showLoading = function (params) {
        this.hideLoading();
    
        var loadingMore = this.options.get('translations').get('searching');
    
        var loading = {
          disabled: true,
          loading: true,
          text: loadingMore(params)
        };
        var $loading = this.option(loading);
        $loading.className += ' loading-results';
    
        this.$results.prepend($loading);
      };
    
      Results.prototype.hideLoading = function () {
        this.$results.find('.loading-results').remove();
      };
    
      Results.prototype.option = function (data) {
        var option = document.createElement('li');
        option.className = 'select2-results__option';
    
        var attrs = {
          'role': 'treeitem',
          'aria-selected': 'false'
        };
    
        if (data.disabled) {
          delete attrs['aria-selected'];
          attrs['aria-disabled'] = 'true';
        }
    
        if (data.id == null) {
          delete attrs['aria-selected'];
        }
    
        if (data._resultId != null) {
          option.id = data._resultId;
        }
    
        if (data.title) {
          option.title = data.title;
        }
    
        if (data.children) {
          attrs.role = 'group';
          attrs['aria-label'] = data.text;
          delete attrs['aria-selected'];
        }
    
        for (var attr in attrs) {
          var val = attrs[attr];
    
          option.setAttribute(attr, val);
        }
    
        if (data.children) {
          var $option = $(option);
    
          var label = document.createElement('strong');
          label.className = 'select2-results__group';
    
          var $label = $(label);
          this.template(data, label);
    
          var $children = [];
    
          for (var c = 0; c < data.children.length; c++) {
            var child = data.children[c];
    
            var $child = this.option(child);
    
            $children.push($child);
          }
    
          var $childrenContainer = $('<ul></ul>', {
            'class': 'select2-results__options select2-results__options--nested'
          });
    
          $childrenContainer.append($children);
    
          $option.append(label);
          $option.append($childrenContainer);
        } else {
          this.template(data, option);
        }
    
        $.data(option, 'data', data);
    
        return option;
      };
    
      Results.prototype.bind = function (container, $container) {
        var self = this;
    
        var id = container.id + '-results';
    
        this.$results.attr('id', id);
    
        container.on('results:all', function (params) {
          self.clear();
          self.append(params.data);
    
          if (container.isOpen()) {
            self.setClasses();
            self.highlightFirstItem();
          }
        });
    
        container.on('results:append', function (params) {
          self.append(params.data);
    
          if (container.isOpen()) {
            self.setClasses();
          }
        });
    
        container.on('query', function (params) {
          self.hideMessages();
          self.showLoading(params);
        });
    
        container.on('select', function () {
          if (!container.isOpen()) {
            return;
          }
    
          self.setClasses();
          self.highlightFirstItem();
        });
    
        container.on('unselect', function () {
          if (!container.isOpen()) {
            return;
          }
    
          self.setClasses();
          self.highlightFirstItem();
        });
    
        container.on('open', function () {
          // When the dropdown is open, aria-expended="true"
          self.$results.attr('aria-expanded', 'true');
          self.$results.attr('aria-hidden', 'false');
    
          self.setClasses();
          self.ensureHighlightVisible();
        });
    
        container.on('close', function () {
          // When the dropdown is closed, aria-expended="false"
          self.$results.attr('aria-expanded', 'false');
          self.$results.attr('aria-hidden', 'true');
          self.$results.removeAttr('aria-activedescendant');
        });
    
        container.on('results:toggle', function () {
          var $highlighted = self.getHighlightedResults();
    
          if ($highlighted.length === 0) {
            return;
          }
    
          $highlighted.trigger('mouseup');
        });
    
        container.on('results:select', function () {
          var $highlighted = self.getHighlightedResults();
    
          if ($highlighted.length === 0) {
            return;
          }
    
          var data = $highlighted.data('data');
    
          if ($highlighted.attr('aria-selected') == 'true') {
            self.trigger('close', {});
          } else {
            self.trigger('select', {
              data: data
            });
          }
        });
    
        container.on('results:previous', function () {
          var $highlighted = self.getHighlightedResults();
    
          var $options = self.$results.find('[aria-selected]');
    
          var currentIndex = $options.index($highlighted);
    
          // If we are already at te top, don't move further
          if (currentIndex === 0) {
            return;
          }
    
          var nextIndex = currentIndex - 1;
    
          // If none are highlighted, highlight the first
          if ($highlighted.length === 0) {
            nextIndex = 0;
          }
    
          var $next = $options.eq(nextIndex);
    
          $next.trigger('mouseenter');
    
          var currentOffset = self.$results.offset().top;
          var nextTop = $next.offset().top;
          var nextOffset = self.$results.scrollTop() + (nextTop - currentOffset);
    
          if (nextIndex === 0) {
            self.$results.scrollTop(0);
          } else if (nextTop - currentOffset < 0) {
            self.$results.scrollTop(nextOffset);
          }
        });
    
        container.on('results:next', function () {
          var $highlighted = self.getHighlightedResults();
    
          var $options = self.$results.find('[aria-selected]');
    
          var currentIndex = $options.index($highlighted);
    
          var nextIndex = currentIndex + 1;
    
          // If we are at the last option, stay there
          if (nextIndex >= $options.length) {
            return;
          }
    
          var $next = $options.eq(nextIndex);
    
          $next.trigger('mouseenter');
    
          var currentOffset = self.$results.offset().top +
            self.$results.outerHeight(false);
          var nextBottom = $next.offset().top + $next.outerHeight(false);
          var nextOffset = self.$results.scrollTop() + nextBottom - currentOffset;
    
          if (nextIndex === 0) {
            self.$results.scrollTop(0);
          } else if (nextBottom > currentOffset) {
            self.$results.scrollTop(nextOffset);
          }
        });
    
        container.on('results:focus', function (params) {
          params.element.addClass('select2-results__option--highlighted');
        });
    
        container.on('results:message', function (params) {
          self.displayMessage(params);
        });
    
        if ($.fn.mousewheel) {
          this.$results.on('mousewheel', function (e) {
            var top = self.$results.scrollTop();
    
            var bottom = self.$results.get(0).scrollHeight - top + e.deltaY;
    
            var isAtTop = e.deltaY > 0 && top - e.deltaY <= 0;
            var isAtBottom = e.deltaY < 0 && bottom <= self.$results.height();
    
            if (isAtTop) {
              self.$results.scrollTop(0);
    
              e.preventDefault();
              e.stopPropagation();
            } else if (isAtBottom) {
              self.$results.scrollTop(
                self.$results.get(0).scrollHeight - self.$results.height()
              );
    
              e.preventDefault();
              e.stopPropagation();
            }
          });
        }
    
        this.$results.on('mouseup', '.select2-results__option[aria-selected]',
          function (evt) {
          var $this = $(this);
    
          var data = $this.data('data');
    
          if ($this.attr('aria-selected') === 'true') {
            if (self.options.get('multiple')) {
              self.trigger('unselect', {
                originalEvent: evt,
                data: data
              });
            } else {
              self.trigger('close', {});
            }
    
            return;
          }
    
          self.trigger('select', {
            originalEvent: evt,
            data: data
          });
        });
    
        this.$results.on('mouseenter', '.select2-results__option[aria-selected]',
          function (evt) {
          var data = $(this).data('data');
    
          self.getHighlightedResults()
              .removeClass('select2-results__option--highlighted');
    
          self.trigger('results:focus', {
            data: data,
            element: $(this)
          });
        });
      };
    
      Results.prototype.getHighlightedResults = function () {
        var $highlighted = this.$results
        .find('.select2-results__option--highlighted');
    
        return $highlighted;
      };
    
      Results.prototype.destroy = function () {
        this.$results.remove();
      };
    
      Results.prototype.ensureHighlightVisible = function () {
        var $highlighted = this.getHighlightedResults();
    
        if ($highlighted.length === 0) {
          return;
        }
    
        var $options = this.$results.find('[aria-selected]');
    
        var currentIndex = $options.index($highlighted);
    
        var currentOffset = this.$results.offset().top;
        var nextTop = $highlighted.offset().top;
        var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);
    
        var offsetDelta = nextTop - currentOffset;
        nextOffset -= $highlighted.outerHeight(false) * 2;
    
        if (currentIndex <= 2) {
          this.$results.scrollTop(0);
        } else if (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) {
          this.$results.scrollTop(nextOffset);
        }
      };
    
      Results.prototype.template = function (result, container) {
        var template = this.options.get('templateResult');
        var escapeMarkup = this.options.get('escapeMarkup');
    
        var content = template(result, container);
    
        if (content == null) {
          container.style.display = 'none';
        } else if (typeof content === 'string') {
          container.innerHTML = escapeMarkup(content);
        } else {
          $(container).append(content);
        }
      };
    
      return Results;
    });
    
    S2.define('select2/keys',[
    
    ], function () {
      var KEYS = {
        BACKSPACE: 8,
        TAB: 9,
        ENTER: 13,
        SHIFT: 16,
        CTRL: 17,
        ALT: 18,
        ESC: 27,
        SPACE: 32,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        END: 35,
        HOME: 36,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        DELETE: 46
      };
    
      return KEYS;
    });
    
    S2.define('select2/selection/base',[
      'jquery',
      '../utils',
      '../keys'
    ], function ($, Utils, KEYS) {
      function BaseSelection ($element, options) {
        this.$element = $element;
        this.options = options;
    
        BaseSelection.__super__.constructor.call(this);
      }
    
      Utils.Extend(BaseSelection, Utils.Observable);
    
      BaseSelection.prototype.render = function () {
        var $selection = $(
          '<span class="select2-selection" role="combobox" ' +
          ' aria-haspopup="true" aria-expanded="false">' +
          '</span>'
        );
    
        this._tabindex = 0;
    
        if (this.$element.data('old-tabindex') != null) {
          this._tabindex = this.$element.data('old-tabindex');
        } else if (this.$element.attr('tabindex') != null) {
          this._tabindex = this.$element.attr('tabindex');
        }
    
        $selection.attr('title', this.$element.attr('title'));
        $selection.attr('tabindex', this._tabindex);
    
        this.$selection = $selection;
    
        return $selection;
      };
    
      BaseSelection.prototype.bind = function (container, $container) {
        var self = this;
    
        var id = container.id + '-container';
        var resultsId = container.id + '-results';
    
        this.container = container;
    
        this.$selection.on('focus', function (evt) {
          self.trigger('focus', evt);
        });
    
        this.$selection.on('blur', function (evt) {
          self._handleBlur(evt);
        });
    
        this.$selection.on('keydown', function (evt) {
          self.trigger('keypress', evt);
    
          if (evt.which === KEYS.SPACE) {
            evt.preventDefault();
          }
        });
    
        container.on('results:focus', function (params) {
          self.$selection.attr('aria-activedescendant', params.data._resultId);
        });
    
        container.on('selection:update', function (params) {
          self.update(params.data);
        });
    
        container.on('open', function () {
          // When the dropdown is open, aria-expanded="true"
          self.$selection.attr('aria-expanded', 'true');
          self.$selection.attr('aria-owns', resultsId);
    
          self._attachCloseHandler(container);
        });
    
        container.on('close', function () {
          // When the dropdown is closed, aria-expanded="false"
          self.$selection.attr('aria-expanded', 'false');
          self.$selection.removeAttr('aria-activedescendant');
          self.$selection.removeAttr('aria-owns');
    
          self.$selection.focus();
    
          self._detachCloseHandler(container);
        });
    
        container.on('enable', function () {
          self.$selection.attr('tabindex', self._tabindex);
        });
    
        container.on('disable', function () {
          self.$selection.attr('tabindex', '-1');
        });
      };
    
      BaseSelection.prototype._handleBlur = function (evt) {
        var self = this;
    
        // This needs to be delayed as the active element is the body when the tab
        // key is pressed, possibly along with others.
        window.setTimeout(function () {
          // Don't trigger `blur` if the focus is still in the selection
          if (
            (document.activeElement == self.$selection[0]) ||
            ($.contains(self.$selection[0], document.activeElement))
          ) {
            return;
          }
    
          self.trigger('blur', evt);
        }, 1);
      };
    
      BaseSelection.prototype._attachCloseHandler = function (container) {
        var self = this;
    
        $(document.body).on('mousedown.select2.' + container.id, function (e) {
          var $target = $(e.target);
    
          var $select = $target.closest('.select2');
    
          var $all = $('.select2.select2-container--open');
    
          $all.each(function () {
            var $this = $(this);
    
            if (this == $select[0]) {
              return;
            }
    
            var $element = $this.data('element');
    
            $element.select2('close');
          });
        });
      };
    
      BaseSelection.prototype._detachCloseHandler = function (container) {
        $(document.body).off('mousedown.select2.' + container.id);
      };
    
      BaseSelection.prototype.position = function ($selection, $container) {
        var $selectionContainer = $container.find('.selection');
        $selectionContainer.append($selection);
      };
    
      BaseSelection.prototype.destroy = function () {
        this._detachCloseHandler(this.container);
      };
    
      BaseSelection.prototype.update = function (data) {
        throw new Error('The `update` method must be defined in child classes.');
      };
    
      return BaseSelection;
    });
    
    S2.define('select2/selection/single',[
      'jquery',
      './base',
      '../utils',
      '../keys'
    ], function ($, BaseSelection, Utils, KEYS) {
      function SingleSelection () {
        SingleSelection.__super__.constructor.apply(this, arguments);
      }
    
      Utils.Extend(SingleSelection, BaseSelection);
    
      SingleSelection.prototype.render = function () {
        var $selection = SingleSelection.__super__.render.call(this);
    
        $selection.addClass('select2-selection--single');
    
        $selection.html(
          '<span class="select2-selection__rendered"></span>' +
          '<span class="select2-selection__arrow" role="presentation">' +
            '<b role="presentation"></b>' +
          '</span>'
        );
    
        return $selection;
      };
    
      SingleSelection.prototype.bind = function (container, $container) {
        var self = this;
    
        SingleSelection.__super__.bind.apply(this, arguments);
    
        var id = container.id + '-container';
    
        this.$selection.find('.select2-selection__rendered').attr('id', id);
        this.$selection.attr('aria-labelledby', id);
    
        this.$selection.on('mousedown', function (evt) {
          // Only respond to left clicks
          if (evt.which !== 1) {
            return;
          }
    
          self.trigger('toggle', {
            originalEvent: evt
          });
        });
    
        this.$selection.on('focus', function (evt) {
          // User focuses on the container
        });
    
        this.$selection.on('blur', function (evt) {
          // User exits the container
        });
    
        container.on('focus', function (evt) {
          if (!container.isOpen()) {
            self.$selection.focus();
          }
        });
    
        container.on('selection:update', function (params) {
          self.update(params.data);
        });
      };
    
      SingleSelection.prototype.clear = function () {
        this.$selection.find('.select2-selection__rendered').empty();
      };
    
      SingleSelection.prototype.display = function (data, container) {
        var template = this.options.get('templateSelection');
        var escapeMarkup = this.options.get('escapeMarkup');
    
        return escapeMarkup(template(data, container));
      };
    
      SingleSelection.prototype.selectionContainer = function () {
        return $('<span></span>');
      };
    
      SingleSelection.prototype.update = function (data) {
        if (data.length === 0) {
          this.clear();
          return;
        }
    
        var selection = data[0];
    
        var $rendered = this.$selection.find('.select2-selection__rendered');
        var formatted = this.display(selection, $rendered);
    
        $rendered.empty().append(formatted);
        $rendered.prop('title', selection.title || selection.text);
      };
    
      return SingleSelection;
    });
    
    S2.define('select2/selection/multiple',[
      'jquery',
      './base',
      '../utils'
    ], function ($, BaseSelection, Utils) {
      function MultipleSelection ($element, options) {
        MultipleSelection.__super__.constructor.apply(this, arguments);
      }
    
      Utils.Extend(MultipleSelection, BaseSelection);
    
      MultipleSelection.prototype.render = function () {
        var $selection = MultipleSelection.__super__.render.call(this);
    
        $selection.addClass('select2-selection--multiple');
    
        $selection.html(
          '<ul class="select2-selection__rendered"></ul>'
        );
    
        return $selection;
      };
    
      MultipleSelection.prototype.bind = function (container, $container) {
        var self = this;
    
        MultipleSelection.__super__.bind.apply(this, arguments);
    
        this.$selection.on('click', function (evt) {
          self.trigger('toggle', {
            originalEvent: evt
          });
        });
    
        this.$selection.on(
          'click',
          '.select2-selection__choice__remove',
          function (evt) {
            // Ignore the event if it is disabled
            if (self.options.get('disabled')) {
              return;
            }
    
            var $remove = $(this);
            var $selection = $remove.parent();
    
            var data = $selection.data('data');
    
            self.trigger('unselect', {
              originalEvent: evt,
              data: data
            });
          }
        );
      };
    
      MultipleSelection.prototype.clear = function () {
        this.$selection.find('.select2-selection__rendered').empty();
      };
    
      MultipleSelection.prototype.display = function (data, container) {
        var template = this.options.get('templateSelection');
        var escapeMarkup = this.options.get('escapeMarkup');
    
        return escapeMarkup(template(data, container));
      };
    
      MultipleSelection.prototype.selectionContainer = function () {
        var $container = $(
          '<li class="select2-selection__choice">' +
            '<span class="select2-selection__choice__remove" role="presentation">' +
              '&times;' +
            '</span>' +
          '</li>'
        );
    
        return $container;
      };
    
      MultipleSelection.prototype.update = function (data) {
        this.clear();
    
        if (data.length === 0) {
          return;
        }
    
        var $selections = [];
    
        for (var d = 0; d < data.length; d++) {
          var selection = data[d];
    
          var $selection = this.selectionContainer();
          var formatted = this.display(selection, $selection);
    
          $selection.append(formatted);
          $selection.prop('title', selection.title || selection.text);
    
          $selection.data('data', selection);
    
          $selections.push($selection);
        }
    
        var $rendered = this.$selection.find('.select2-selection__rendered');
    
        Utils.appendMany($rendered, $selections);
      };
    
      return MultipleSelection;
    });
    
    S2.define('select2/selection/placeholder',[
      '../utils'
    ], function (Utils) {
      function Placeholder (decorated, $element, options) {
        this.placeholder = this.normalizePlaceholder(options.get('placeholder'));
    
        decorated.call(this, $element, options);
      }
    
      Placeholder.prototype.normalizePlaceholder = function (_, placeholder) {
        if (typeof placeholder === 'string') {
          placeholder = {
            id: '',
            text: placeholder
          };
        }
    
        return placeholder;
      };
    
      Placeholder.prototype.createPlaceholder = function (decorated, placeholder) {
        var $placeholder = this.selectionContainer();
    
        $placeholder.html(this.display(placeholder));
        $placeholder.addClass('select2-selection__placeholder')
                    .removeClass('select2-selection__choice');
    
        return $placeholder;
      };
    
      Placeholder.prototype.update = function (decorated, data) {
        var singlePlaceholder = (
          data.length == 1 && data[0].id != this.placeholder.id
        );
        var multipleSelections = data.length > 1;
    
        if (multipleSelections || singlePlaceholder) {
          return decorated.call(this, data);
        }
    
        this.clear();
    
        var $placeholder = this.createPlaceholder(this.placeholder);
    
        this.$selection.find('.select2-selection__rendered').append($placeholder);
      };
    
      return Placeholder;
    });
    
    S2.define('select2/selection/allowClear',[
      'jquery',
      '../keys'
    ], function ($, KEYS) {
      function AllowClear () { }
    
      AllowClear.prototype.bind = function (decorated, container, $container) {
        var self = this;
    
        decorated.call(this, container, $container);
    
        if (this.placeholder == null) {
          if (this.options.get('debug') && window.console && console.error) {
            console.error(
              'Select2: The `allowClear` option should be used in combination ' +
              'with the `placeholder` option.'
            );
          }
        }
    
        this.$selection.on('mousedown', '.select2-selection__clear',
          function (evt) {
            self._handleClear(evt);
        });
    
        container.on('keypress', function (evt) {
          self._handleKeyboardClear(evt, container);
        });
      };
    
      AllowClear.prototype._handleClear = function (_, evt) {
        // Ignore the event if it is disabled
        if (this.options.get('disabled')) {
          return;
        }
    
        var $clear = this.$selection.find('.select2-selection__clear');
    
        // Ignore the event if nothing has been selected
        if ($clear.length === 0) {
          return;
        }
    
        evt.stopPropagation();
    
        var data = $clear.data('data');
    
        for (var d = 0; d < data.length; d++) {
          var unselectData = {
            data: data[d]
          };
    
          // Trigger the `unselect` event, so people can prevent it from being
          // cleared.
          this.trigger('unselect', unselectData);
    
          // If the event was prevented, don't clear it out.
          if (unselectData.prevented) {
            return;
          }
        }
    
        this.$element.val(this.placeholder.id).trigger('change');
    
        this.trigger('toggle', {});
      };
    
      AllowClear.prototype._handleKeyboardClear = function (_, evt, container) {
        if (container.isOpen()) {
          return;
        }
    
        if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {
          this._handleClear(evt);
        }
      };
    
      AllowClear.prototype.update = function (decorated, data) {
        decorated.call(this, data);
    
        if (this.$selection.find('.select2-selection__placeholder').length > 0 ||
            data.length === 0) {
          return;
        }
    
        var $remove = $(
          '<span class="select2-selection__clear">' +
            '&times;' +
          '</span>'
        );
        $remove.data('data', data);
    
        this.$selection.find('.select2-selection__rendered').prepend($remove);
      };
    
      return AllowClear;
    });
    
    S2.define('select2/selection/search',[
      'jquery',
      '../utils',
      '../keys'
    ], function ($, Utils, KEYS) {
      function Search (decorated, $element, options) {
        decorated.call(this, $element, options);
      }
    
      Search.prototype.render = function (decorated) {
        var $search = $(
          '<li class="select2-search select2-search--inline">' +
            '<input class="select2-search__field" type="search" tabindex="-1"' +
            ' autocomplete="off" autocorrect="off" autocapitalize="none"' +
            ' spellcheck="false" role="textbox" aria-autocomplete="list" />' +
          '</li>'
        );
    
        this.$searchContainer = $search;
        this.$search = $search.find('input');
    
        var $rendered = decorated.call(this);
    
        this._transferTabIndex();
    
        return $rendered;
      };
    
      Search.prototype.bind = function (decorated, container, $container) {
        var self = this;
    
        decorated.call(this, container, $container);
    
        container.on('open', function () {
          self.$search.trigger('focus');
        });
    
        container.on('close', function () {
          self.$search.val('');
          self.$search.removeAttr('aria-activedescendant');
          self.$search.trigger('focus');
        });
    
        container.on('enable', function () {
          self.$search.prop('disabled', false);
    
          self._transferTabIndex();
        });
    
        container.on('disable', function () {
          self.$search.prop('disabled', true);
        });
    
        container.on('focus', function (evt) {
          self.$search.trigger('focus');
        });
    
        container.on('results:focus', function (params) {
          self.$search.attr('aria-activedescendant', params.id);
        });
    
        this.$selection.on('focusin', '.select2-search--inline', function (evt) {
          self.trigger('focus', evt);
        });
    
        this.$selection.on('focusout', '.select2-search--inline', function (evt) {
          self._handleBlur(evt);
        });
    
        this.$selection.on('keydown', '.select2-search--inline', function (evt) {
          evt.stopPropagation();
    
          self.trigger('keypress', evt);
    
          self._keyUpPrevented = evt.isDefaultPrevented();
    
          var key = evt.which;
    
          if (key === KEYS.BACKSPACE && self.$search.val() === '') {
            var $previousChoice = self.$searchContainer
              .prev('.select2-selection__choice');
    
            if ($previousChoice.length > 0) {
              var item = $previousChoice.data('data');
    
              self.searchRemoveChoice(item);
    
              evt.preventDefault();
            }
          }
        });
    
        // Try to detect the IE version should the `documentMode` property that
        // is stored on the document. This is only implemented in IE and is
        // slightly cleaner than doing a user agent check.
        // This property is not available in Edge, but Edge also doesn't have
        // this bug.
        var msie = document.documentMode;
        var disableInputEvents = msie && msie <= 11;
    
        // Workaround for browsers which do not support the `input` event
        // This will prevent double-triggering of events for browsers which support
        // both the `keyup` and `input` events.
        this.$selection.on(
          'input.searchcheck',
          '.select2-search--inline',
          function (evt) {
            // IE will trigger the `input` event when a placeholder is used on a
            // search box. To get around this issue, we are forced to ignore all
            // `input` events in IE and keep using `keyup`.
            if (disableInputEvents) {
              self.$selection.off('input.search input.searchcheck');
              return;
            }
    
            // Unbind the duplicated `keyup` event
            self.$selection.off('keyup.search');
          }
        );
    
        this.$selection.on(
          'keyup.search input.search',
          '.select2-search--inline',
          function (evt) {
            // IE will trigger the `input` event when a placeholder is used on a
            // search box. To get around this issue, we are forced to ignore all
            // `input` events in IE and keep using `keyup`.
            if (disableInputEvents && evt.type === 'input') {
              self.$selection.off('input.search input.searchcheck');
              return;
            }
    
            var key = evt.which;
    
            // We can freely ignore events from modifier keys
            if (key == KEYS.SHIFT || key == KEYS.CTRL || key == KEYS.ALT) {
              return;
            }
    
            // Tabbing will be handled during the `keydown` phase
            if (key == KEYS.TAB) {
              return;
            }
    
            self.handleSearch(evt);
          }
        );
      };
    
      /**
       * This method will transfer the tabindex attribute from the rendered
       * selection to the search box. This allows for the search box to be used as
       * the primary focus instead of the selection container.
       *
       * @private
       */
      Search.prototype._transferTabIndex = function (decorated) {
        this.$search.attr('tabindex', this.$selection.attr('tabindex'));
        this.$selection.attr('tabindex', '-1');
      };
    
      Search.prototype.createPlaceholder = function (decorated, placeholder) {
        this.$search.attr('placeholder', placeholder.text);
      };
    
      Search.prototype.update = function (decorated, data) {
        var searchHadFocus = this.$search[0] == document.activeElement;
    
        this.$search.attr('placeholder', '');
    
        decorated.call(this, data);
    
        this.$selection.find('.select2-selection__rendered')
                       .append(this.$searchContainer);
    
        this.resizeSearch();
        if (searchHadFocus) {
          this.$search.focus();
        }
      };
    
      Search.prototype.handleSearch = function () {
        this.resizeSearch();
    
        if (!this._keyUpPrevented) {
          var input = this.$search.val();
    
          this.trigger('query', {
            term: input
          });
        }
    
        this._keyUpPrevented = false;
      };
    
      Search.prototype.searchRemoveChoice = function (decorated, item) {
        this.trigger('unselect', {
          data: item
        });
    
        this.$search.val(item.text);
        this.handleSearch();
      };
    
      Search.prototype.resizeSearch = function () {
        this.$search.css('width', '25px');
    
        var width = '';
    
        if (this.$search.attr('placeholder') !== '') {
          width = this.$selection.find('.select2-selection__rendered').innerWidth();
        } else {
          var minimumWidth = this.$search.val().length + 1;
    
          width = (minimumWidth * 0.75) + 'em';
        }
    
        this.$search.css('width', width);
      };
    
      return Search;
    });
    
    S2.define('select2/selection/eventRelay',[
      'jquery'
    ], function ($) {
      function EventRelay () { }
    
      EventRelay.prototype.bind = function (decorated, container, $container) {
        var self = this;
        var relayEvents = [
          'open', 'opening',
          'close', 'closing',
          'select', 'selecting',
          'unselect', 'unselecting'
        ];
    
        var preventableEvents = ['opening', 'closing', 'selecting', 'unselecting'];
    
        decorated.call(this, container, $container);
    
        container.on('*', function (name, params) {
          // Ignore events that should not be relayed
          if ($.inArray(name, relayEvents) === -1) {
            return;
          }
    
          // The parameters should always be an object
          params = params || {};
    
          // Generate the jQuery event for the Select2 event
          var evt = $.Event('select2:' + name, {
            params: params
          });
    
          self.$element.trigger(evt);
    
          // Only handle preventable events if it was one
          if ($.inArray(name, preventableEvents) === -1) {
            return;
          }
    
          params.prevented = evt.isDefaultPrevented();
        });
      };
    
      return EventRelay;
    });
    
    S2.define('select2/translation',[
      'jquery',
      'require'
    ], function ($, require) {
      function Translation (dict) {
        this.dict = dict || {};
      }
    
      Translation.prototype.all = function () {
        return this.dict;
      };
    
      Translation.prototype.get = function (key) {
        return this.dict[key];
      };
    
      Translation.prototype.extend = function (translation) {
        this.dict = $.extend({}, translation.all(), this.dict);
      };
    
      // Static functions
    
      Translation._cache = {};
    
      Translation.loadPath = function (path) {
        if (!(path in Translation._cache)) {
          var translations = require(path);
    
          Translation._cache[path] = translations;
        }
    
        return new Translation(Translation._cache[path]);
      };
    
      return Translation;
    });
    
    S2.define('select2/diacritics',[
    
    ], function () {
      var diacritics = {
        '\u24B6': 'A',
        '\uFF21': 'A',
        '\u00C0': 'A',
        '\u00C1': 'A',
        '\u00C2': 'A',
        '\u1EA6': 'A',
        '\u1EA4': 'A',
        '\u1EAA': 'A',
        '\u1EA8': 'A',
        '\u00C3': 'A',
        '\u0100': 'A',
        '\u0102': 'A',
        '\u1EB0': 'A',
        '\u1EAE': 'A',
        '\u1EB4': 'A',
        '\u1EB2': 'A',
        '\u0226': 'A',
        '\u01E0': 'A',
        '\u00C4': 'A',
        '\u01DE': 'A',
        '\u1EA2': 'A',
        '\u00C5': 'A',
        '\u01FA': 'A',
        '\u01CD': 'A',
        '\u0200': 'A',
        '\u0202': 'A',
        '\u1EA0': 'A',
        '\u1EAC': 'A',
        '\u1EB6': 'A',
        '\u1E00': 'A',
        '\u0104': 'A',
        '\u023A': 'A',
        '\u2C6F': 'A',
        '\uA732': 'AA',
        '\u00C6': 'AE',
        '\u01FC': 'AE',
        '\u01E2': 'AE',
        '\uA734': 'AO',
        '\uA736': 'AU',
        '\uA738': 'AV',
        '\uA73A': 'AV',
        '\uA73C': 'AY',
        '\u24B7': 'B',
        '\uFF22': 'B',
        '\u1E02': 'B',
        '\u1E04': 'B',
        '\u1E06': 'B',
        '\u0243': 'B',
        '\u0182': 'B',
        '\u0181': 'B',
        '\u24B8': 'C',
        '\uFF23': 'C',
        '\u0106': 'C',
        '\u0108': 'C',
        '\u010A': 'C',
        '\u010C': 'C',
        '\u00C7': 'C',
        '\u1E08': 'C',
        '\u0187': 'C',
        '\u023B': 'C',
        '\uA73E': 'C',
        '\u24B9': 'D',
        '\uFF24': 'D',
        '\u1E0A': 'D',
        '\u010E': 'D',
        '\u1E0C': 'D',
        '\u1E10': 'D',
        '\u1E12': 'D',
        '\u1E0E': 'D',
        '\u0110': 'D',
        '\u018B': 'D',
        '\u018A': 'D',
        '\u0189': 'D',
        '\uA779': 'D',
        '\u01F1': 'DZ',
        '\u01C4': 'DZ',
        '\u01F2': 'Dz',
        '\u01C5': 'Dz',
        '\u24BA': 'E',
        '\uFF25': 'E',
        '\u00C8': 'E',
        '\u00C9': 'E',
        '\u00CA': 'E',
        '\u1EC0': 'E',
        '\u1EBE': 'E',
        '\u1EC4': 'E',
        '\u1EC2': 'E',
        '\u1EBC': 'E',
        '\u0112': 'E',
        '\u1E14': 'E',
        '\u1E16': 'E',
        '\u0114': 'E',
        '\u0116': 'E',
        '\u00CB': 'E',
        '\u1EBA': 'E',
        '\u011A': 'E',
        '\u0204': 'E',
        '\u0206': 'E',
        '\u1EB8': 'E',
        '\u1EC6': 'E',
        '\u0228': 'E',
        '\u1E1C': 'E',
        '\u0118': 'E',
        '\u1E18': 'E',
        '\u1E1A': 'E',
        '\u0190': 'E',
        '\u018E': 'E',
        '\u24BB': 'F',
        '\uFF26': 'F',
        '\u1E1E': 'F',
        '\u0191': 'F',
        '\uA77B': 'F',
        '\u24BC': 'G',
        '\uFF27': 'G',
        '\u01F4': 'G',
        '\u011C': 'G',
        '\u1E20': 'G',
        '\u011E': 'G',
        '\u0120': 'G',
        '\u01E6': 'G',
        '\u0122': 'G',
        '\u01E4': 'G',
        '\u0193': 'G',
        '\uA7A0': 'G',
        '\uA77D': 'G',
        '\uA77E': 'G',
        '\u24BD': 'H',
        '\uFF28': 'H',
        '\u0124': 'H',
        '\u1E22': 'H',
        '\u1E26': 'H',
        '\u021E': 'H',
        '\u1E24': 'H',
        '\u1E28': 'H',
        '\u1E2A': 'H',
        '\u0126': 'H',
        '\u2C67': 'H',
        '\u2C75': 'H',
        '\uA78D': 'H',
        '\u24BE': 'I',
        '\uFF29': 'I',
        '\u00CC': 'I',
        '\u00CD': 'I',
        '\u00CE': 'I',
        '\u0128': 'I',
        '\u012A': 'I',
        '\u012C': 'I',
        '\u0130': 'I',
        '\u00CF': 'I',
        '\u1E2E': 'I',
        '\u1EC8': 'I',
        '\u01CF': 'I',
        '\u0208': 'I',
        '\u020A': 'I',
        '\u1ECA': 'I',
        '\u012E': 'I',
        '\u1E2C': 'I',
        '\u0197': 'I',
        '\u24BF': 'J',
        '\uFF2A': 'J',
        '\u0134': 'J',
        '\u0248': 'J',
        '\u24C0': 'K',
        '\uFF2B': 'K',
        '\u1E30': 'K',
        '\u01E8': 'K',
        '\u1E32': 'K',
        '\u0136': 'K',
        '\u1E34': 'K',
        '\u0198': 'K',
        '\u2C69': 'K',
        '\uA740': 'K',
        '\uA742': 'K',
        '\uA744': 'K',
        '\uA7A2': 'K',
        '\u24C1': 'L',
        '\uFF2C': 'L',
        '\u013F': 'L',
        '\u0139': 'L',
        '\u013D': 'L',
        '\u1E36': 'L',
        '\u1E38': 'L',
        '\u013B': 'L',
        '\u1E3C': 'L',
        '\u1E3A': 'L',
        '\u0141': 'L',
        '\u023D': 'L',
        '\u2C62': 'L',
        '\u2C60': 'L',
        '\uA748': 'L',
        '\uA746': 'L',
        '\uA780': 'L',
        '\u01C7': 'LJ',
        '\u01C8': 'Lj',
        '\u24C2': 'M',
        '\uFF2D': 'M',
        '\u1E3E': 'M',
        '\u1E40': 'M',
        '\u1E42': 'M',
        '\u2C6E': 'M',
        '\u019C': 'M',
        '\u24C3': 'N',
        '\uFF2E': 'N',
        '\u01F8': 'N',
        '\u0143': 'N',
        '\u00D1': 'N',
        '\u1E44': 'N',
        '\u0147': 'N',
        '\u1E46': 'N',
        '\u0145': 'N',
        '\u1E4A': 'N',
        '\u1E48': 'N',
        '\u0220': 'N',
        '\u019D': 'N',
        '\uA790': 'N',
        '\uA7A4': 'N',
        '\u01CA': 'NJ',
        '\u01CB': 'Nj',
        '\u24C4': 'O',
        '\uFF2F': 'O',
        '\u00D2': 'O',
        '\u00D3': 'O',
        '\u00D4': 'O',
        '\u1ED2': 'O',
        '\u1ED0': 'O',
        '\u1ED6': 'O',
        '\u1ED4': 'O',
        '\u00D5': 'O',
        '\u1E4C': 'O',
        '\u022C': 'O',
        '\u1E4E': 'O',
        '\u014C': 'O',
        '\u1E50': 'O',
        '\u1E52': 'O',
        '\u014E': 'O',
        '\u022E': 'O',
        '\u0230': 'O',
        '\u00D6': 'O',
        '\u022A': 'O',
        '\u1ECE': 'O',
        '\u0150': 'O',
        '\u01D1': 'O',
        '\u020C': 'O',
        '\u020E': 'O',
        '\u01A0': 'O',
        '\u1EDC': 'O',
        '\u1EDA': 'O',
        '\u1EE0': 'O',
        '\u1EDE': 'O',
        '\u1EE2': 'O',
        '\u1ECC': 'O',
        '\u1ED8': 'O',
        '\u01EA': 'O',
        '\u01EC': 'O',
        '\u00D8': 'O',
        '\u01FE': 'O',
        '\u0186': 'O',
        '\u019F': 'O',
        '\uA74A': 'O',
        '\uA74C': 'O',
        '\u01A2': 'OI',
        '\uA74E': 'OO',
        '\u0222': 'OU',
        '\u24C5': 'P',
        '\uFF30': 'P',
        '\u1E54': 'P',
        '\u1E56': 'P',
        '\u01A4': 'P',
        '\u2C63': 'P',
        '\uA750': 'P',
        '\uA752': 'P',
        '\uA754': 'P',
        '\u24C6': 'Q',
        '\uFF31': 'Q',
        '\uA756': 'Q',
        '\uA758': 'Q',
        '\u024A': 'Q',
        '\u24C7': 'R',
        '\uFF32': 'R',
        '\u0154': 'R',
        '\u1E58': 'R',
        '\u0158': 'R',
        '\u0210': 'R',
        '\u0212': 'R',
        '\u1E5A': 'R',
        '\u1E5C': 'R',
        '\u0156': 'R',
        '\u1E5E': 'R',
        '\u024C': 'R',
        '\u2C64': 'R',
        '\uA75A': 'R',
        '\uA7A6': 'R',
        '\uA782': 'R',
        '\u24C8': 'S',
        '\uFF33': 'S',
        '\u1E9E': 'S',
        '\u015A': 'S',
        '\u1E64': 'S',
        '\u015C': 'S',
        '\u1E60': 'S',
        '\u0160': 'S',
        '\u1E66': 'S',
        '\u1E62': 'S',
        '\u1E68': 'S',
        '\u0218': 'S',
        '\u015E': 'S',
        '\u2C7E': 'S',
        '\uA7A8': 'S',
        '\uA784': 'S',
        '\u24C9': 'T',
        '\uFF34': 'T',
        '\u1E6A': 'T',
        '\u0164': 'T',
        '\u1E6C': 'T',
        '\u021A': 'T',
        '\u0162': 'T',
        '\u1E70': 'T',
        '\u1E6E': 'T',
        '\u0166': 'T',
        '\u01AC': 'T',
        '\u01AE': 'T',
        '\u023E': 'T',
        '\uA786': 'T',
        '\uA728': 'TZ',
        '\u24CA': 'U',
        '\uFF35': 'U',
        '\u00D9': 'U',
        '\u00DA': 'U',
        '\u00DB': 'U',
        '\u0168': 'U',
        '\u1E78': 'U',
        '\u016A': 'U',
        '\u1E7A': 'U',
        '\u016C': 'U',
        '\u00DC': 'U',
        '\u01DB': 'U',
        '\u01D7': 'U',
        '\u01D5': 'U',
        '\u01D9': 'U',
        '\u1EE6': 'U',
        '\u016E': 'U',
        '\u0170': 'U',
        '\u01D3': 'U',
        '\u0214': 'U',
        '\u0216': 'U',
        '\u01AF': 'U',
        '\u1EEA': 'U',
        '\u1EE8': 'U',
        '\u1EEE': 'U',
        '\u1EEC': 'U',
        '\u1EF0': 'U',
        '\u1EE4': 'U',
        '\u1E72': 'U',
        '\u0172': 'U',
        '\u1E76': 'U',
        '\u1E74': 'U',
        '\u0244': 'U',
        '\u24CB': 'V',
        '\uFF36': 'V',
        '\u1E7C': 'V',
        '\u1E7E': 'V',
        '\u01B2': 'V',
        '\uA75E': 'V',
        '\u0245': 'V',
        '\uA760': 'VY',
        '\u24CC': 'W',
        '\uFF37': 'W',
        '\u1E80': 'W',
        '\u1E82': 'W',
        '\u0174': 'W',
        '\u1E86': 'W',
        '\u1E84': 'W',
        '\u1E88': 'W',
        '\u2C72': 'W',
        '\u24CD': 'X',
        '\uFF38': 'X',
        '\u1E8A': 'X',
        '\u1E8C': 'X',
        '\u24CE': 'Y',
        '\uFF39': 'Y',
        '\u1EF2': 'Y',
        '\u00DD': 'Y',
        '\u0176': 'Y',
        '\u1EF8': 'Y',
        '\u0232': 'Y',
        '\u1E8E': 'Y',
        '\u0178': 'Y',
        '\u1EF6': 'Y',
        '\u1EF4': 'Y',
        '\u01B3': 'Y',
        '\u024E': 'Y',
        '\u1EFE': 'Y',
        '\u24CF': 'Z',
        '\uFF3A': 'Z',
        '\u0179': 'Z',
        '\u1E90': 'Z',
        '\u017B': 'Z',
        '\u017D': 'Z',
        '\u1E92': 'Z',
        '\u1E94': 'Z',
        '\u01B5': 'Z',
        '\u0224': 'Z',
        '\u2C7F': 'Z',
        '\u2C6B': 'Z',
        '\uA762': 'Z',
        '\u24D0': 'a',
        '\uFF41': 'a',
        '\u1E9A': 'a',
        '\u00E0': 'a',
        '\u00E1': 'a',
        '\u00E2': 'a',
        '\u1EA7': 'a',
        '\u1EA5': 'a',
        '\u1EAB': 'a',
        '\u1EA9': 'a',
        '\u00E3': 'a',
        '\u0101': 'a',
        '\u0103': 'a',
        '\u1EB1': 'a',
        '\u1EAF': 'a',
        '\u1EB5': 'a',
        '\u1EB3': 'a',
        '\u0227': 'a',
        '\u01E1': 'a',
        '\u00E4': 'a',
        '\u01DF': 'a',
        '\u1EA3': 'a',
        '\u00E5': 'a',
        '\u01FB': 'a',
        '\u01CE': 'a',
        '\u0201': 'a',
        '\u0203': 'a',
        '\u1EA1': 'a',
        '\u1EAD': 'a',
        '\u1EB7': 'a',
        '\u1E01': 'a',
        '\u0105': 'a',
        '\u2C65': 'a',
        '\u0250': 'a',
        '\uA733': 'aa',
        '\u00E6': 'ae',
        '\u01FD': 'ae',
        '\u01E3': 'ae',
        '\uA735': 'ao',
        '\uA737': 'au',
        '\uA739': 'av',
        '\uA73B': 'av',
        '\uA73D': 'ay',
        '\u24D1': 'b',
        '\uFF42': 'b',
        '\u1E03': 'b',
        '\u1E05': 'b',
        '\u1E07': 'b',
        '\u0180': 'b',
        '\u0183': 'b',
        '\u0253': 'b',
        '\u24D2': 'c',
        '\uFF43': 'c',
        '\u0107': 'c',
        '\u0109': 'c',
        '\u010B': 'c',
        '\u010D': 'c',
        '\u00E7': 'c',
        '\u1E09': 'c',
        '\u0188': 'c',
        '\u023C': 'c',
        '\uA73F': 'c',
        '\u2184': 'c',
        '\u24D3': 'd',
        '\uFF44': 'd',
        '\u1E0B': 'd',
        '\u010F': 'd',
        '\u1E0D': 'd',
        '\u1E11': 'd',
        '\u1E13': 'd',
        '\u1E0F': 'd',
        '\u0111': 'd',
        '\u018C': 'd',
        '\u0256': 'd',
        '\u0257': 'd',
        '\uA77A': 'd',
        '\u01F3': 'dz',
        '\u01C6': 'dz',
        '\u24D4': 'e',
        '\uFF45': 'e',
        '\u00E8': 'e',
        '\u00E9': 'e',
        '\u00EA': 'e',
        '\u1EC1': 'e',
        '\u1EBF': 'e',
        '\u1EC5': 'e',
        '\u1EC3': 'e',
        '\u1EBD': 'e',
        '\u0113': 'e',
        '\u1E15': 'e',
        '\u1E17': 'e',
        '\u0115': 'e',
        '\u0117': 'e',
        '\u00EB': 'e',
        '\u1EBB': 'e',
        '\u011B': 'e',
        '\u0205': 'e',
        '\u0207': 'e',
        '\u1EB9': 'e',
        '\u1EC7': 'e',
        '\u0229': 'e',
        '\u1E1D': 'e',
        '\u0119': 'e',
        '\u1E19': 'e',
        '\u1E1B': 'e',
        '\u0247': 'e',
        '\u025B': 'e',
        '\u01DD': 'e',
        '\u24D5': 'f',
        '\uFF46': 'f',
        '\u1E1F': 'f',
        '\u0192': 'f',
        '\uA77C': 'f',
        '\u24D6': 'g',
        '\uFF47': 'g',
        '\u01F5': 'g',
        '\u011D': 'g',
        '\u1E21': 'g',
        '\u011F': 'g',
        '\u0121': 'g',
        '\u01E7': 'g',
        '\u0123': 'g',
        '\u01E5': 'g',
        '\u0260': 'g',
        '\uA7A1': 'g',
        '\u1D79': 'g',
        '\uA77F': 'g',
        '\u24D7': 'h',
        '\uFF48': 'h',
        '\u0125': 'h',
        '\u1E23': 'h',
        '\u1E27': 'h',
        '\u021F': 'h',
        '\u1E25': 'h',
        '\u1E29': 'h',
        '\u1E2B': 'h',
        '\u1E96': 'h',
        '\u0127': 'h',
        '\u2C68': 'h',
        '\u2C76': 'h',
        '\u0265': 'h',
        '\u0195': 'hv',
        '\u24D8': 'i',
        '\uFF49': 'i',
        '\u00EC': 'i',
        '\u00ED': 'i',
        '\u00EE': 'i',
        '\u0129': 'i',
        '\u012B': 'i',
        '\u012D': 'i',
        '\u00EF': 'i',
        '\u1E2F': 'i',
        '\u1EC9': 'i',
        '\u01D0': 'i',
        '\u0209': 'i',
        '\u020B': 'i',
        '\u1ECB': 'i',
        '\u012F': 'i',
        '\u1E2D': 'i',
        '\u0268': 'i',
        '\u0131': 'i',
        '\u24D9': 'j',
        '\uFF4A': 'j',
        '\u0135': 'j',
        '\u01F0': 'j',
        '\u0249': 'j',
        '\u24DA': 'k',
        '\uFF4B': 'k',
        '\u1E31': 'k',
        '\u01E9': 'k',
        '\u1E33': 'k',
        '\u0137': 'k',
        '\u1E35': 'k',
        '\u0199': 'k',
        '\u2C6A': 'k',
        '\uA741': 'k',
        '\uA743': 'k',
        '\uA745': 'k',
        '\uA7A3': 'k',
        '\u24DB': 'l',
        '\uFF4C': 'l',
        '\u0140': 'l',
        '\u013A': 'l',
        '\u013E': 'l',
        '\u1E37': 'l',
        '\u1E39': 'l',
        '\u013C': 'l',
        '\u1E3D': 'l',
        '\u1E3B': 'l',
        '\u017F': 'l',
        '\u0142': 'l',
        '\u019A': 'l',
        '\u026B': 'l',
        '\u2C61': 'l',
        '\uA749': 'l',
        '\uA781': 'l',
        '\uA747': 'l',
        '\u01C9': 'lj',
        '\u24DC': 'm',
        '\uFF4D': 'm',
        '\u1E3F': 'm',
        '\u1E41': 'm',
        '\u1E43': 'm',
        '\u0271': 'm',
        '\u026F': 'm',
        '\u24DD': 'n',
        '\uFF4E': 'n',
        '\u01F9': 'n',
        '\u0144': 'n',
        '\u00F1': 'n',
        '\u1E45': 'n',
        '\u0148': 'n',
        '\u1E47': 'n',
        '\u0146': 'n',
        '\u1E4B': 'n',
        '\u1E49': 'n',
        '\u019E': 'n',
        '\u0272': 'n',
        '\u0149': 'n',
        '\uA791': 'n',
        '\uA7A5': 'n',
        '\u01CC': 'nj',
        '\u24DE': 'o',
        '\uFF4F': 'o',
        '\u00F2': 'o',
        '\u00F3': 'o',
        '\u00F4': 'o',
        '\u1ED3': 'o',
        '\u1ED1': 'o',
        '\u1ED7': 'o',
        '\u1ED5': 'o',
        '\u00F5': 'o',
        '\u1E4D': 'o',
        '\u022D': 'o',
        '\u1E4F': 'o',
        '\u014D': 'o',
        '\u1E51': 'o',
        '\u1E53': 'o',
        '\u014F': 'o',
        '\u022F': 'o',
        '\u0231': 'o',
        '\u00F6': 'o',
        '\u022B': 'o',
        '\u1ECF': 'o',
        '\u0151': 'o',
        '\u01D2': 'o',
        '\u020D': 'o',
        '\u020F': 'o',
        '\u01A1': 'o',
        '\u1EDD': 'o',
        '\u1EDB': 'o',
        '\u1EE1': 'o',
        '\u1EDF': 'o',
        '\u1EE3': 'o',
        '\u1ECD': 'o',
        '\u1ED9': 'o',
        '\u01EB': 'o',
        '\u01ED': 'o',
        '\u00F8': 'o',
        '\u01FF': 'o',
        '\u0254': 'o',
        '\uA74B': 'o',
        '\uA74D': 'o',
        '\u0275': 'o',
        '\u01A3': 'oi',
        '\u0223': 'ou',
        '\uA74F': 'oo',
        '\u24DF': 'p',
        '\uFF50': 'p',
        '\u1E55': 'p',
        '\u1E57': 'p',
        '\u01A5': 'p',
        '\u1D7D': 'p',
        '\uA751': 'p',
        '\uA753': 'p',
        '\uA755': 'p',
        '\u24E0': 'q',
        '\uFF51': 'q',
        '\u024B': 'q',
        '\uA757': 'q',
        '\uA759': 'q',
        '\u24E1': 'r',
        '\uFF52': 'r',
        '\u0155': 'r',
        '\u1E59': 'r',
        '\u0159': 'r',
        '\u0211': 'r',
        '\u0213': 'r',
        '\u1E5B': 'r',
        '\u1E5D': 'r',
        '\u0157': 'r',
        '\u1E5F': 'r',
        '\u024D': 'r',
        '\u027D': 'r',
        '\uA75B': 'r',
        '\uA7A7': 'r',
        '\uA783': 'r',
        '\u24E2': 's',
        '\uFF53': 's',
        '\u00DF': 's',
        '\u015B': 's',
        '\u1E65': 's',
        '\u015D': 's',
        '\u1E61': 's',
        '\u0161': 's',
        '\u1E67': 's',
        '\u1E63': 's',
        '\u1E69': 's',
        '\u0219': 's',
        '\u015F': 's',
        '\u023F': 's',
        '\uA7A9': 's',
        '\uA785': 's',
        '\u1E9B': 's',
        '\u24E3': 't',
        '\uFF54': 't',
        '\u1E6B': 't',
        '\u1E97': 't',
        '\u0165': 't',
        '\u1E6D': 't',
        '\u021B': 't',
        '\u0163': 't',
        '\u1E71': 't',
        '\u1E6F': 't',
        '\u0167': 't',
        '\u01AD': 't',
        '\u0288': 't',
        '\u2C66': 't',
        '\uA787': 't',
        '\uA729': 'tz',
        '\u24E4': 'u',
        '\uFF55': 'u',
        '\u00F9': 'u',
        '\u00FA': 'u',
        '\u00FB': 'u',
        '\u0169': 'u',
        '\u1E79': 'u',
        '\u016B': 'u',
        '\u1E7B': 'u',
        '\u016D': 'u',
        '\u00FC': 'u',
        '\u01DC': 'u',
        '\u01D8': 'u',
        '\u01D6': 'u',
        '\u01DA': 'u',
        '\u1EE7': 'u',
        '\u016F': 'u',
        '\u0171': 'u',
        '\u01D4': 'u',
        '\u0215': 'u',
        '\u0217': 'u',
        '\u01B0': 'u',
        '\u1EEB': 'u',
        '\u1EE9': 'u',
        '\u1EEF': 'u',
        '\u1EED': 'u',
        '\u1EF1': 'u',
        '\u1EE5': 'u',
        '\u1E73': 'u',
        '\u0173': 'u',
        '\u1E77': 'u',
        '\u1E75': 'u',
        '\u0289': 'u',
        '\u24E5': 'v',
        '\uFF56': 'v',
        '\u1E7D': 'v',
        '\u1E7F': 'v',
        '\u028B': 'v',
        '\uA75F': 'v',
        '\u028C': 'v',
        '\uA761': 'vy',
        '\u24E6': 'w',
        '\uFF57': 'w',
        '\u1E81': 'w',
        '\u1E83': 'w',
        '\u0175': 'w',
        '\u1E87': 'w',
        '\u1E85': 'w',
        '\u1E98': 'w',
        '\u1E89': 'w',
        '\u2C73': 'w',
        '\u24E7': 'x',
        '\uFF58': 'x',
        '\u1E8B': 'x',
        '\u1E8D': 'x',
        '\u24E8': 'y',
        '\uFF59': 'y',
        '\u1EF3': 'y',
        '\u00FD': 'y',
        '\u0177': 'y',
        '\u1EF9': 'y',
        '\u0233': 'y',
        '\u1E8F': 'y',
        '\u00FF': 'y',
        '\u1EF7': 'y',
        '\u1E99': 'y',
        '\u1EF5': 'y',
        '\u01B4': 'y',
        '\u024F': 'y',
        '\u1EFF': 'y',
        '\u24E9': 'z',
        '\uFF5A': 'z',
        '\u017A': 'z',
        '\u1E91': 'z',
        '\u017C': 'z',
        '\u017E': 'z',
        '\u1E93': 'z',
        '\u1E95': 'z',
        '\u01B6': 'z',
        '\u0225': 'z',
        '\u0240': 'z',
        '\u2C6C': 'z',
        '\uA763': 'z',
        '\u0386': '\u0391',
        '\u0388': '\u0395',
        '\u0389': '\u0397',
        '\u038A': '\u0399',
        '\u03AA': '\u0399',
        '\u038C': '\u039F',
        '\u038E': '\u03A5',
        '\u03AB': '\u03A5',
        '\u038F': '\u03A9',
        '\u03AC': '\u03B1',
        '\u03AD': '\u03B5',
        '\u03AE': '\u03B7',
        '\u03AF': '\u03B9',
        '\u03CA': '\u03B9',
        '\u0390': '\u03B9',
        '\u03CC': '\u03BF',
        '\u03CD': '\u03C5',
        '\u03CB': '\u03C5',
        '\u03B0': '\u03C5',
        '\u03C9': '\u03C9',
        '\u03C2': '\u03C3'
      };
    
      return diacritics;
    });
    
    S2.define('select2/data/base',[
      '../utils'
    ], function (Utils) {
      function BaseAdapter ($element, options) {
        BaseAdapter.__super__.constructor.call(this);
      }
    
      Utils.Extend(BaseAdapter, Utils.Observable);
    
      BaseAdapter.prototype.current = function (callback) {
        throw new Error('The `current` method must be defined in child classes.');
      };
    
      BaseAdapter.prototype.query = function (params, callback) {
        throw new Error('The `query` method must be defined in child classes.');
      };
    
      BaseAdapter.prototype.bind = function (container, $container) {
        // Can be implemented in subclasses
      };
    
      BaseAdapter.prototype.destroy = function () {
        // Can be implemented in subclasses
      };
    
      BaseAdapter.prototype.generateResultId = function (container, data) {
        var id = container.id + '-result-';
    
        id += Utils.generateChars(4);
    
        if (data.id != null) {
          id += '-' + data.id.toString();
        } else {
          id += '-' + Utils.generateChars(4);
        }
        return id;
      };
    
      return BaseAdapter;
    });
    
    S2.define('select2/data/select',[
      './base',
      '../utils',
      'jquery'
    ], function (BaseAdapter, Utils, $) {
      function SelectAdapter ($element, options) {
        this.$element = $element;
        this.options = options;
    
        SelectAdapter.__super__.constructor.call(this);
      }
    
      Utils.Extend(SelectAdapter, BaseAdapter);
    
      SelectAdapter.prototype.current = function (callback) {
        var data = [];
        var self = this;
    
        this.$element.find(':selected').each(function () {
          var $option = $(this);
    
          var option = self.item($option);
    
          data.push(option);
        });
    
        callback(data);
      };
    
      SelectAdapter.prototype.select = function (data) {
        var self = this;
    
        data.selected = true;
    
        // If data.element is a DOM node, use it instead
        if ($(data.element).is('option')) {
          data.element.selected = true;
    
          this.$element.trigger('change');
    
          return;
        }
    
        if (this.$element.prop('multiple')) {
          this.current(function (currentData) {
            var val = [];
    
            data = [data];
            data.push.apply(data, currentData);
    
            for (var d = 0; d < data.length; d++) {
              var id = data[d].id;
    
              if ($.inArray(id, val) === -1) {
                val.push(id);
              }
            }
    
            self.$element.val(val);
            self.$element.trigger('change');
          });
        } else {
          var val = data.id;
    
          this.$element.val(val);
          this.$element.trigger('change');
        }
      };
    
      SelectAdapter.prototype.unselect = function (data) {
        var self = this;
    
        if (!this.$element.prop('multiple')) {
          return;
        }
    
        data.selected = false;
    
        if ($(data.element).is('option')) {
          data.element.selected = false;
    
          this.$element.trigger('change');
    
          return;
        }
    
        this.current(function (currentData) {
          var val = [];
    
          for (var d = 0; d < currentData.length; d++) {
            var id = currentData[d].id;
    
            if (id !== data.id && $.inArray(id, val) === -1) {
              val.push(id);
            }
          }
    
          self.$element.val(val);
    
          self.$element.trigger('change');
        });
      };
    
      SelectAdapter.prototype.bind = function (container, $container) {
        var self = this;
    
        this.container = container;
    
        container.on('select', function (params) {
          self.select(params.data);
        });
    
        container.on('unselect', function (params) {
          self.unselect(params.data);
        });
      };
    
      SelectAdapter.prototype.destroy = function () {
        // Remove anything added to child elements
        this.$element.find('*').each(function () {
          // Remove any custom data set by Select2
          $.removeData(this, 'data');
        });
      };
    
      SelectAdapter.prototype.query = function (params, callback) {
        var data = [];
        var self = this;
    
        var $options = this.$element.children();
    
        $options.each(function () {
          var $option = $(this);
    
          if (!$option.is('option') && !$option.is('optgroup')) {
            return;
          }
    
          var option = self.item($option);
    
          var matches = self.matches(params, option);
    
          if (matches !== null) {
            data.push(matches);
          }
        });
    
        callback({
          results: data
        });
      };
    
      SelectAdapter.prototype.addOptions = function ($options) {
        Utils.appendMany(this.$element, $options);
      };
    
      SelectAdapter.prototype.option = function (data) {
        var option;
    
        if (data.children) {
          option = document.createElement('optgroup');
          option.label = data.text;
        } else {
          option = document.createElement('option');
    
          if (option.textContent !== undefined) {
            option.textContent = data.text;
          } else {
            option.innerText = data.text;
          }
        }
    
        if (data.id !== undefined) {
          option.value = data.id;
        }
    
        if (data.disabled) {
          option.disabled = true;
        }
    
        if (data.selected) {
          option.selected = true;
        }
    
        if (data.title) {
          option.title = data.title;
        }
    
        var $option = $(option);
    
        var normalizedData = this._normalizeItem(data);
        normalizedData.element = option;
    
        // Override the option's data with the combined data
        $.data(option, 'data', normalizedData);
    
        return $option;
      };
    
      SelectAdapter.prototype.item = function ($option) {
        var data = {};
    
        data = $.data($option[0], 'data');
    
        if (data != null) {
          return data;
        }
    
        if ($option.is('option')) {
          data = {
            id: $option.val(),
            text: $option.text(),
            disabled: $option.prop('disabled'),
            selected: $option.prop('selected'),
            title: $option.prop('title')
          };
        } else if ($option.is('optgroup')) {
          data = {
            text: $option.prop('label'),
            children: [],
            title: $option.prop('title')
          };
    
          var $children = $option.children('option');
          var children = [];
    
          for (var c = 0; c < $children.length; c++) {
            var $child = $($children[c]);
    
            var child = this.item($child);
    
            children.push(child);
          }
    
          data.children = children;
        }
    
        data = this._normalizeItem(data);
        data.element = $option[0];
    
        $.data($option[0], 'data', data);
    
        return data;
      };
    
      SelectAdapter.prototype._normalizeItem = function (item) {
        if (!$.isPlainObject(item)) {
          item = {
            id: item,
            text: item
          };
        }
    
        item = $.extend({}, {
          text: ''
        }, item);
    
        var defaults = {
          selected: false,
          disabled: false
        };
    
        if (item.id != null) {
          item.id = item.id.toString();
        }
    
        if (item.text != null) {
          item.text = item.text.toString();
        }
    
        if (item._resultId == null && item.id && this.container != null) {
          item._resultId = this.generateResultId(this.container, item);
        }
    
        return $.extend({}, defaults, item);
      };
    
      SelectAdapter.prototype.matches = function (params, data) {
        var matcher = this.options.get('matcher');
    
        return matcher(params, data);
      };
    
      return SelectAdapter;
    });
    
    S2.define('select2/data/array',[
      './select',
      '../utils',
      'jquery'
    ], function (SelectAdapter, Utils, $) {
      function ArrayAdapter ($element, options) {
        var data = options.get('data') || [];
    
        ArrayAdapter.__super__.constructor.call(this, $element, options);
    
        this.addOptions(this.convertToOptions(data));
      }
    
      Utils.Extend(ArrayAdapter, SelectAdapter);
    
      ArrayAdapter.prototype.select = function (data) {
        var $option = this.$element.find('option').filter(function (i, elm) {
          return elm.value == data.id.toString();
        });
    
        if ($option.length === 0) {
          $option = this.option(data);
    
          this.addOptions($option);
        }
    
        ArrayAdapter.__super__.select.call(this, data);
      };
    
      ArrayAdapter.prototype.convertToOptions = function (data) {
        var self = this;
    
        var $existing = this.$element.find('option');
        var existingIds = $existing.map(function () {
          return self.item($(this)).id;
        }).get();
    
        var $options = [];
    
        // Filter out all items except for the one passed in the argument
        function onlyItem (item) {
          return function () {
            return $(this).val() == item.id;
          };
        }
    
        for (var d = 0; d < data.length; d++) {
          var item = this._normalizeItem(data[d]);
    
          // Skip items which were pre-loaded, only merge the data
          if ($.inArray(item.id, existingIds) >= 0) {
            var $existingOption = $existing.filter(onlyItem(item));
    
            var existingData = this.item($existingOption);
            var newData = $.extend(true, {}, item, existingData);
    
            var $newOption = this.option(newData);
    
            $existingOption.replaceWith($newOption);
    
            continue;
          }
    
          var $option = this.option(item);
    
          if (item.children) {
            var $children = this.convertToOptions(item.children);
    
            Utils.appendMany($option, $children);
          }
    
          $options.push($option);
        }
    
        return $options;
      };
    
      return ArrayAdapter;
    });
    
    S2.define('select2/data/ajax',[
      './array',
      '../utils',
      'jquery'
    ], function (ArrayAdapter, Utils, $) {
      function AjaxAdapter ($element, options) {
        this.ajaxOptions = this._applyDefaults(options.get('ajax'));
    
        if (this.ajaxOptions.processResults != null) {
          this.processResults = this.ajaxOptions.processResults;
        }
    
        AjaxAdapter.__super__.constructor.call(this, $element, options);
      }
    
      Utils.Extend(AjaxAdapter, ArrayAdapter);
    
      AjaxAdapter.prototype._applyDefaults = function (options) {
        var defaults = {
          data: function (params) {
            return $.extend({}, params, {
              q: params.term
            });
          },
          transport: function (params, success, failure) {
            var $request = $.ajax(params);
    
            $request.then(success);
            $request.fail(failure);
    
            return $request;
          }
        };
    
        return $.extend({}, defaults, options, true);
      };
    
      AjaxAdapter.prototype.processResults = function (results) {
        return results;
      };
    
      AjaxAdapter.prototype.query = function (params, callback) {
        var matches = [];
        var self = this;
    
        if (this._request != null) {
          // JSONP requests cannot always be aborted
          if ($.isFunction(this._request.abort)) {
            this._request.abort();
          }
    
          this._request = null;
        }
    
        var options = $.extend({
          type: 'GET'
        }, this.ajaxOptions);
    
        if (typeof options.url === 'function') {
          options.url = options.url.call(this.$element, params);
        }
    
        if (typeof options.data === 'function') {
          options.data = options.data.call(this.$element, params);
        }
    
        function request () {
          var $request = options.transport(options, function (data) {
            var results = self.processResults(data, params);
    
            if (self.options.get('debug') && window.console && console.error) {
              // Check to make sure that the response included a `results` key.
              if (!results || !results.results || !$.isArray(results.results)) {
                console.error(
                  'Select2: The AJAX results did not return an array in the ' +
                  '`results` key of the response.'
                );
              }
            }
    
            callback(results);
          }, function () {
            // Attempt to detect if a request was aborted
            // Only works if the transport exposes a status property
            if ($request.status && $request.status === '0') {
              return;
            }
    
            self.trigger('results:message', {
              message: 'errorLoading'
            });
          });
    
          self._request = $request;
        }
    
        if (this.ajaxOptions.delay && params.term != null) {
          if (this._queryTimeout) {
            window.clearTimeout(this._queryTimeout);
          }
    
          this._queryTimeout = window.setTimeout(request, this.ajaxOptions.delay);
        } else {
          request();
        }
      };
    
      return AjaxAdapter;
    });
    
    S2.define('select2/data/tags',[
      'jquery'
    ], function ($) {
      function Tags (decorated, $element, options) {
        var tags = options.get('tags');
    
        var createTag = options.get('createTag');
    
        if (createTag !== undefined) {
          this.createTag = createTag;
        }
    
        var insertTag = options.get('insertTag');
    
        if (insertTag !== undefined) {
            this.insertTag = insertTag;
        }
    
        decorated.call(this, $element, options);
    
        if ($.isArray(tags)) {
          for (var t = 0; t < tags.length; t++) {
            var tag = tags[t];
            var item = this._normalizeItem(tag);
    
            var $option = this.option(item);
    
            this.$element.append($option);
          }
        }
      }
    
      Tags.prototype.query = function (decorated, params, callback) {
        var self = this;
    
        this._removeOldTags();
    
        if (params.term == null || params.page != null) {
          decorated.call(this, params, callback);
          return;
        }
    
        function wrapper (obj, child) {
          var data = obj.results;
    
          for (var i = 0; i < data.length; i++) {
            var option = data[i];
    
            var checkChildren = (
              option.children != null &&
              !wrapper({
                results: option.children
              }, true)
            );
    
            var optionText = (option.text || '').toUpperCase();
            var paramsTerm = (params.term || '').toUpperCase();
    
            var checkText = optionText === paramsTerm;
    
            if (checkText || checkChildren) {
              if (child) {
                return false;
              }
    
              obj.data = data;
              callback(obj);
    
              return;
            }
          }
    
          if (child) {
            return true;
          }
    
          var tag = self.createTag(params);
    
          if (tag != null) {
            var $option = self.option(tag);
            $option.attr('data-select2-tag', true);
    
            self.addOptions([$option]);
    
            self.insertTag(data, tag);
          }
    
          obj.results = data;
    
          callback(obj);
        }
    
        decorated.call(this, params, wrapper);
      };
    
      Tags.prototype.createTag = function (decorated, params) {
        var term = $.trim(params.term);
    
        if (term === '') {
          return null;
        }
    
        return {
          id: term,
          text: term
        };
      };
    
      Tags.prototype.insertTag = function (_, data, tag) {
        data.unshift(tag);
      };
    
      Tags.prototype._removeOldTags = function (_) {
        var tag = this._lastTag;
    
        var $options = this.$element.find('option[data-select2-tag]');
    
        $options.each(function () {
          if (this.selected) {
            return;
          }
    
          $(this).remove();
        });
      };
    
      return Tags;
    });
    
    S2.define('select2/data/tokenizer',[
      'jquery'
    ], function ($) {
      function Tokenizer (decorated, $element, options) {
        var tokenizer = options.get('tokenizer');
    
        if (tokenizer !== undefined) {
          this.tokenizer = tokenizer;
        }
    
        decorated.call(this, $element, options);
      }
    
      Tokenizer.prototype.bind = function (decorated, container, $container) {
        decorated.call(this, container, $container);
    
        this.$search =  container.dropdown.$search || container.selection.$search ||
          $container.find('.select2-search__field');
      };
    
      Tokenizer.prototype.query = function (decorated, params, callback) {
        var self = this;
    
        function createAndSelect (data) {
          // Normalize the data object so we can use it for checks
          var item = self._normalizeItem(data);
    
          // Check if the data object already exists as a tag
          // Select it if it doesn't
          var $existingOptions = self.$element.find('option').filter(function () {
            return $(this).val() === item.id;
          });
    
          // If an existing option wasn't found for it, create the option
          if (!$existingOptions.length) {
            var $option = self.option(item);
            $option.attr('data-select2-tag', true);
    
            self._removeOldTags();
            self.addOptions([$option]);
          }
    
          // Select the item, now that we know there is an option for it
          select(item);
        }
    
        function select (data) {
          self.trigger('select', {
            data: data
          });
        }
    
        params.term = params.term || '';
    
        var tokenData = this.tokenizer(params, this.options, createAndSelect);
    
        if (tokenData.term !== params.term) {
          // Replace the search term if we have the search box
          if (this.$search.length) {
            this.$search.val(tokenData.term);
            this.$search.focus();
          }
    
          params.term = tokenData.term;
        }
    
        decorated.call(this, params, callback);
      };
    
      Tokenizer.prototype.tokenizer = function (_, params, options, callback) {
        var separators = options.get('tokenSeparators') || [];
        var term = params.term;
        var i = 0;
    
        var createTag = this.createTag || function (params) {
          return {
            id: params.term,
            text: params.term
          };
        };
    
        while (i < term.length) {
          var termChar = term[i];
    
          if ($.inArray(termChar, separators) === -1) {
            i++;
    
            continue;
          }
    
          var part = term.substr(0, i);
          var partParams = $.extend({}, params, {
            term: part
          });
    
          var data = createTag(partParams);
    
          if (data == null) {
            i++;
            continue;
          }
    
          callback(data);
    
          // Reset the term to not include the tokenized portion
          term = term.substr(i + 1) || '';
          i = 0;
        }
    
        return {
          term: term
        };
      };
    
      return Tokenizer;
    });
    
    S2.define('select2/data/minimumInputLength',[
    
    ], function () {
      function MinimumInputLength (decorated, $e, options) {
        this.minimumInputLength = options.get('minimumInputLength');
    
        decorated.call(this, $e, options);
      }
    
      MinimumInputLength.prototype.query = function (decorated, params, callback) {
        params.term = params.term || '';
    
        if (params.term.length < this.minimumInputLength) {
          this.trigger('results:message', {
            message: 'inputTooShort',
            args: {
              minimum: this.minimumInputLength,
              input: params.term,
              params: params
            }
          });
    
          return;
        }
    
        decorated.call(this, params, callback);
      };
    
      return MinimumInputLength;
    });
    
    S2.define('select2/data/maximumInputLength',[
    
    ], function () {
      function MaximumInputLength (decorated, $e, options) {
        this.maximumInputLength = options.get('maximumInputLength');
    
        decorated.call(this, $e, options);
      }
    
      MaximumInputLength.prototype.query = function (decorated, params, callback) {
        params.term = params.term || '';
    
        if (this.maximumInputLength > 0 &&
            params.term.length > this.maximumInputLength) {
          this.trigger('results:message', {
            message: 'inputTooLong',
            args: {
              maximum: this.maximumInputLength,
              input: params.term,
              params: params
            }
          });
    
          return;
        }
    
        decorated.call(this, params, callback);
      };
    
      return MaximumInputLength;
    });
    
    S2.define('select2/data/maximumSelectionLength',[
    
    ], function (){
      function MaximumSelectionLength (decorated, $e, options) {
        this.maximumSelectionLength = options.get('maximumSelectionLength');
    
        decorated.call(this, $e, options);
      }
    
      MaximumSelectionLength.prototype.query =
        function (decorated, params, callback) {
          var self = this;
    
          this.current(function (currentData) {
            var count = currentData != null ? currentData.length : 0;
            if (self.maximumSelectionLength > 0 &&
              count >= self.maximumSelectionLength) {
              self.trigger('results:message', {
                message: 'maximumSelected',
                args: {
                  maximum: self.maximumSelectionLength
                }
              });
              return;
            }
            decorated.call(self, params, callback);
          });
      };
    
      return MaximumSelectionLength;
    });
    
    S2.define('select2/dropdown',[
      'jquery',
      './utils'
    ], function ($, Utils) {
      function Dropdown ($element, options) {
        this.$element = $element;
        this.options = options;
    
        Dropdown.__super__.constructor.call(this);
      }
    
      Utils.Extend(Dropdown, Utils.Observable);
    
      Dropdown.prototype.render = function () {
        var $dropdown = $(
          '<span class="select2-dropdown">' +
            '<span class="select2-results"></span>' +
          '</span>'
        );
    
        $dropdown.attr('dir', this.options.get('dir'));
    
        this.$dropdown = $dropdown;
    
        return $dropdown;
      };
    
      Dropdown.prototype.bind = function () {
        // Should be implemented in subclasses
      };
    
      Dropdown.prototype.position = function ($dropdown, $container) {
        // Should be implmented in subclasses
      };
    
      Dropdown.prototype.destroy = function () {
        // Remove the dropdown from the DOM
        this.$dropdown.remove();
      };
    
      return Dropdown;
    });
    
    S2.define('select2/dropdown/search',[
      'jquery',
      '../utils'
    ], function ($, Utils) {
      function Search () { }
    
      Search.prototype.render = function (decorated) {
        var $rendered = decorated.call(this);
    
        var $search = $(
          '<span class="select2-search select2-search--dropdown">' +
            '<input class="select2-search__field" type="search" tabindex="-1"' +
            ' autocomplete="off" autocorrect="off" autocapitalize="none"' +
            ' spellcheck="false" role="textbox" />' +
          '</span>'
        );
    
        this.$searchContainer = $search;
        this.$search = $search.find('input');
    
        $rendered.prepend($search);
    
        return $rendered;
      };
    
      Search.prototype.bind = function (decorated, container, $container) {
        var self = this;
    
        decorated.call(this, container, $container);
    
        this.$search.on('keydown', function (evt) {
          self.trigger('keypress', evt);
    
          self._keyUpPrevented = evt.isDefaultPrevented();
        });
    
        // Workaround for browsers which do not support the `input` event
        // This will prevent double-triggering of events for browsers which support
        // both the `keyup` and `input` events.
        this.$search.on('input', function (evt) {
          // Unbind the duplicated `keyup` event
          $(this).off('keyup');
        });
    
        this.$search.on('keyup input', function (evt) {
          self.handleSearch(evt);
        });
    
        container.on('open', function () {
          self.$search.attr('tabindex', 0);
    
          self.$search.focus();
    
          window.setTimeout(function () {
            self.$search.focus();
          }, 0);
        });
    
        container.on('close', function () {
          self.$search.attr('tabindex', -1);
    
          self.$search.val('');
        });
    
        container.on('focus', function () {
          if (!container.isOpen()) {
            self.$search.focus();
          }
        });
    
        container.on('results:all', function (params) {
          if (params.query.term == null || params.query.term === '') {
            var showSearch = self.showSearch(params);
    
            if (showSearch) {
              self.$searchContainer.removeClass('select2-search--hide');
            } else {
              self.$searchContainer.addClass('select2-search--hide');
            }
          }
        });
      };
    
      Search.prototype.handleSearch = function (evt) {
        if (!this._keyUpPrevented) {
          var input = this.$search.val();
    
          this.trigger('query', {
            term: input
          });
        }
    
        this._keyUpPrevented = false;
      };
    
      Search.prototype.showSearch = function (_, params) {
        return true;
      };
    
      return Search;
    });
    
    S2.define('select2/dropdown/hidePlaceholder',[
    
    ], function () {
      function HidePlaceholder (decorated, $element, options, dataAdapter) {
        this.placeholder = this.normalizePlaceholder(options.get('placeholder'));
    
        decorated.call(this, $element, options, dataAdapter);
      }
    
      HidePlaceholder.prototype.append = function (decorated, data) {
        data.results = this.removePlaceholder(data.results);
    
        decorated.call(this, data);
      };
    
      HidePlaceholder.prototype.normalizePlaceholder = function (_, placeholder) {
        if (typeof placeholder === 'string') {
          placeholder = {
            id: '',
            text: placeholder
          };
        }
    
        return placeholder;
      };
    
      HidePlaceholder.prototype.removePlaceholder = function (_, data) {
        var modifiedData = data.slice(0);
    
        for (var d = data.length - 1; d >= 0; d--) {
          var item = data[d];
    
          if (this.placeholder.id === item.id) {
            modifiedData.splice(d, 1);
          }
        }
    
        return modifiedData;
      };
    
      return HidePlaceholder;
    });
    
    S2.define('select2/dropdown/infiniteScroll',[
      'jquery'
    ], function ($) {
      function InfiniteScroll (decorated, $element, options, dataAdapter) {
        this.lastParams = {};
    
        decorated.call(this, $element, options, dataAdapter);
    
        this.$loadingMore = this.createLoadingMore();
        this.loading = false;
      }
    
      InfiniteScroll.prototype.append = function (decorated, data) {
        this.$loadingMore.remove();
        this.loading = false;
    
        decorated.call(this, data);
    
        if (this.showLoadingMore(data)) {
          this.$results.append(this.$loadingMore);
        }
      };
    
      InfiniteScroll.prototype.bind = function (decorated, container, $container) {
        var self = this;
    
        decorated.call(this, container, $container);
    
        container.on('query', function (params) {
          self.lastParams = params;
          self.loading = true;
        });
    
        container.on('query:append', function (params) {
          self.lastParams = params;
          self.loading = true;
        });
    
        this.$results.on('scroll', function () {
          var isLoadMoreVisible = $.contains(
            document.documentElement,
            self.$loadingMore[0]
          );
    
          if (self.loading || !isLoadMoreVisible) {
            return;
          }
    
          var currentOffset = self.$results.offset().top +
            self.$results.outerHeight(false);
          var loadingMoreOffset = self.$loadingMore.offset().top +
            self.$loadingMore.outerHeight(false);
    
          if (currentOffset + 50 >= loadingMoreOffset) {
            self.loadMore();
          }
        });
      };
    
      InfiniteScroll.prototype.loadMore = function () {
        this.loading = true;
    
        var params = $.extend({}, {page: 1}, this.lastParams);
    
        params.page++;
    
        this.trigger('query:append', params);
      };
    
      InfiniteScroll.prototype.showLoadingMore = function (_, data) {
        return data.pagination && data.pagination.more;
      };
    
      InfiniteScroll.prototype.createLoadingMore = function () {
        var $option = $(
          '<li ' +
          'class="select2-results__option select2-results__option--load-more"' +
          'role="treeitem" aria-disabled="true"></li>'
        );
    
        var message = this.options.get('translations').get('loadingMore');
    
        $option.html(message(this.lastParams));
    
        return $option;
      };
    
      return InfiniteScroll;
    });
    
    S2.define('select2/dropdown/attachBody',[
      'jquery',
      '../utils'
    ], function ($, Utils) {
      function AttachBody (decorated, $element, options) {
        this.$dropdownParent = options.get('dropdownParent') || $(document.body);
    
        decorated.call(this, $element, options);
      }
    
      AttachBody.prototype.bind = function (decorated, container, $container) {
        var self = this;
    
        var setupResultsEvents = false;
    
        decorated.call(this, container, $container);
    
        container.on('open', function () {
          self._showDropdown();
          self._attachPositioningHandler(container);
    
          if (!setupResultsEvents) {
            setupResultsEvents = true;
    
            container.on('results:all', function () {
              self._positionDropdown();
              self._resizeDropdown();
            });
    
            container.on('results:append', function () {
              self._positionDropdown();
              self._resizeDropdown();
            });
          }
        });
    
        container.on('close', function () {
          self._hideDropdown();
          self._detachPositioningHandler(container);
        });
    
        this.$dropdownContainer.on('mousedown', function (evt) {
          evt.stopPropagation();
        });
      };
    
      AttachBody.prototype.destroy = function (decorated) {
        decorated.call(this);
    
        this.$dropdownContainer.remove();
      };
    
      AttachBody.prototype.position = function (decorated, $dropdown, $container) {
        // Clone all of the container classes
        $dropdown.attr('class', $container.attr('class'));
    
        $dropdown.removeClass('select2');
        $dropdown.addClass('select2-container--open');
    
        $dropdown.css({
          position: 'absolute',
          top: -999999
        });
    
        this.$container = $container;
      };
    
      AttachBody.prototype.render = function (decorated) {
        var $container = $('<span></span>');
    
        var $dropdown = decorated.call(this);
        $container.append($dropdown);
    
        this.$dropdownContainer = $container;
    
        return $container;
      };
    
      AttachBody.prototype._hideDropdown = function (decorated) {
        this.$dropdownContainer.detach();
      };
    
      AttachBody.prototype._attachPositioningHandler =
          function (decorated, container) {
        var self = this;
    
        var scrollEvent = 'scroll.select2.' + container.id;
        var resizeEvent = 'resize.select2.' + container.id;
        var orientationEvent = 'orientationchange.select2.' + container.id;
    
        var $watchers = this.$container.parents().filter(Utils.hasScroll);
        $watchers.each(function () {
          $(this).data('select2-scroll-position', {
            x: $(this).scrollLeft(),
            y: $(this).scrollTop()
          });
        });
    
        $watchers.on(scrollEvent, function (ev) {
          var position = $(this).data('select2-scroll-position');
          $(this).scrollTop(position.y);
        });
    
        $(window).on(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent,
          function (e) {
          self._positionDropdown();
          self._resizeDropdown();
        });
      };
    
      AttachBody.prototype._detachPositioningHandler =
          function (decorated, container) {
        var scrollEvent = 'scroll.select2.' + container.id;
        var resizeEvent = 'resize.select2.' + container.id;
        var orientationEvent = 'orientationchange.select2.' + container.id;
    
        var $watchers = this.$container.parents().filter(Utils.hasScroll);
        $watchers.off(scrollEvent);
    
        $(window).off(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent);
      };
    
      AttachBody.prototype._positionDropdown = function () {
        var $window = $(window);
    
        var isCurrentlyAbove = this.$dropdown.hasClass('select2-dropdown--above');
        var isCurrentlyBelow = this.$dropdown.hasClass('select2-dropdown--below');
    
        var newDirection = null;
    
        var offset = this.$container.offset();
    
        offset.bottom = offset.top + this.$container.outerHeight(false);
    
        var container = {
          height: this.$container.outerHeight(false)
        };
    
        container.top = offset.top;
        container.bottom = offset.top + container.height;
    
        var dropdown = {
          height: this.$dropdown.outerHeight(false)
        };
    
        var viewport = {
          top: $window.scrollTop(),
          bottom: $window.scrollTop() + $window.height()
        };
    
        var enoughRoomAbove = viewport.top < (offset.top - dropdown.height);
        var enoughRoomBelow = viewport.bottom > (offset.bottom + dropdown.height);
    
        var css = {
          left: offset.left,
          top: container.bottom
        };
    
        // Determine what the parent element is to use for calciulating the offset
        var $offsetParent = this.$dropdownParent;
    
        // For statically positoned elements, we need to get the element
        // that is determining the offset
        if ($offsetParent.css('position') === 'static') {
          $offsetParent = $offsetParent.offsetParent();
        }
    
        var parentOffset = $offsetParent.offset();
    
        css.top -= parentOffset.top;
        css.left -= parentOffset.left;
    
        if (!isCurrentlyAbove && !isCurrentlyBelow) {
          newDirection = 'below';
        }
    
        if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {
          newDirection = 'above';
        } else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {
          newDirection = 'below';
        }
    
        if (newDirection == 'above' ||
          (isCurrentlyAbove && newDirection !== 'below')) {
          css.top = container.top - parentOffset.top - dropdown.height;
        }
    
        if (newDirection != null) {
          this.$dropdown
            .removeClass('select2-dropdown--below select2-dropdown--above')
            .addClass('select2-dropdown--' + newDirection);
          this.$container
            .removeClass('select2-container--below select2-container--above')
            .addClass('select2-container--' + newDirection);
        }
    
        this.$dropdownContainer.css(css);
      };
    
      AttachBody.prototype._resizeDropdown = function () {
        var css = {
          width: this.$container.outerWidth(false) + 'px'
        };
    
        if (this.options.get('dropdownAutoWidth')) {
          css.minWidth = css.width;
          css.position = 'relative';
          css.width = 'auto';
        }
    
        this.$dropdown.css(css);
      };
    
      AttachBody.prototype._showDropdown = function (decorated) {
        this.$dropdownContainer.appendTo(this.$dropdownParent);
    
        this._positionDropdown();
        this._resizeDropdown();
      };
    
      return AttachBody;
    });
    
    S2.define('select2/dropdown/minimumResultsForSearch',[
    
    ], function () {
      function countResults (data) {
        var count = 0;
    
        for (var d = 0; d < data.length; d++) {
          var item = data[d];
    
          if (item.children) {
            count += countResults(item.children);
          } else {
            count++;
          }
        }
    
        return count;
      }
    
      function MinimumResultsForSearch (decorated, $element, options, dataAdapter) {
        this.minimumResultsForSearch = options.get('minimumResultsForSearch');
    
        if (this.minimumResultsForSearch < 0) {
          this.minimumResultsForSearch = Infinity;
        }
    
        decorated.call(this, $element, options, dataAdapter);
      }
    
      MinimumResultsForSearch.prototype.showSearch = function (decorated, params) {
        if (countResults(params.data.results) < this.minimumResultsForSearch) {
          return false;
        }
    
        return decorated.call(this, params);
      };
    
      return MinimumResultsForSearch;
    });
    
    S2.define('select2/dropdown/selectOnClose',[
    
    ], function () {
      function SelectOnClose () { }
    
      SelectOnClose.prototype.bind = function (decorated, container, $container) {
        var self = this;
    
        decorated.call(this, container, $container);
    
        container.on('close', function (params) {
          self._handleSelectOnClose(params);
        });
      };
    
      SelectOnClose.prototype._handleSelectOnClose = function (_, params) {
        if (params && params.originalSelect2Event != null) {
          var event = params.originalSelect2Event;
    
          // Don't select an item if the close event was triggered from a select or
          // unselect event
          if (event._type === 'select' || event._type === 'unselect') {
            return;
          }
        }
    
        var $highlightedResults = this.getHighlightedResults();
    
        // Only select highlighted results
        if ($highlightedResults.length < 1) {
          return;
        }
    
        var data = $highlightedResults.data('data');
    
        // Don't re-select already selected resulte
        if (
          (data.element != null && data.element.selected) ||
          (data.element == null && data.selected)
        ) {
          return;
        }
    
        this.trigger('select', {
            data: data
        });
      };
    
      return SelectOnClose;
    });
    
    S2.define('select2/dropdown/closeOnSelect',[
    
    ], function () {
      function CloseOnSelect () { }
    
      CloseOnSelect.prototype.bind = function (decorated, container, $container) {
        var self = this;
    
        decorated.call(this, container, $container);
    
        container.on('select', function (evt) {
          self._selectTriggered(evt);
        });
    
        container.on('unselect', function (evt) {
          self._selectTriggered(evt);
        });
      };
    
      CloseOnSelect.prototype._selectTriggered = function (_, evt) {
        var originalEvent = evt.originalEvent;
    
        // Don't close if the control key is being held
        if (originalEvent && originalEvent.ctrlKey) {
          return;
        }
    
        this.trigger('close', {
          originalEvent: originalEvent,
          originalSelect2Event: evt
        });
      };
    
      return CloseOnSelect;
    });
    
    S2.define('select2/i18n/en',[],function () {
      // English
      return {
        errorLoading: function () {
          return 'The results could not be loaded.';
        },
        inputTooLong: function (args) {
          var overChars = args.input.length - args.maximum;
    
          var message = 'Please delete ' + overChars + ' character';
    
          if (overChars != 1) {
            message += 's';
          }
    
          return message;
        },
        inputTooShort: function (args) {
          var remainingChars = args.minimum - args.input.length;
    
          var message = 'Please enter ' + remainingChars + ' or more characters';
    
          return message;
        },
        loadingMore: function () {
          return 'Loading more results';
        },
        maximumSelected: function (args) {
          var message = 'You can only select ' + args.maximum + ' item';
    
          if (args.maximum != 1) {
            message += 's';
          }
    
          return message;
        },
        noResults: function () {
          return 'No results found';
        },
        searching: function () {
          return 'Searching';
        }
      };
    });
    
    S2.define('select2/defaults',[
      'jquery',
      'require',
    
      './results',
    
      './selection/single',
      './selection/multiple',
      './selection/placeholder',
      './selection/allowClear',
      './selection/search',
      './selection/eventRelay',
    
      './utils',
      './translation',
      './diacritics',
    
      './data/select',
      './data/array',
      './data/ajax',
      './data/tags',
      './data/tokenizer',
      './data/minimumInputLength',
      './data/maximumInputLength',
      './data/maximumSelectionLength',
    
      './dropdown',
      './dropdown/search',
      './dropdown/hidePlaceholder',
      './dropdown/infiniteScroll',
      './dropdown/attachBody',
      './dropdown/minimumResultsForSearch',
      './dropdown/selectOnClose',
      './dropdown/closeOnSelect',
    
      './i18n/en'
    ], function ($, require,
    
                 ResultsList,
    
                 SingleSelection, MultipleSelection, Placeholder, AllowClear,
                 SelectionSearch, EventRelay,
    
                 Utils, Translation, DIACRITICS,
    
                 SelectData, ArrayData, AjaxData, Tags, Tokenizer,
                 MinimumInputLength, MaximumInputLength, MaximumSelectionLength,
    
                 Dropdown, DropdownSearch, HidePlaceholder, InfiniteScroll,
                 AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect,
    
                 EnglishTranslation) {
      function Defaults () {
        this.reset();
      }
    
      Defaults.prototype.apply = function (options) {
        options = $.extend(true, {}, this.defaults, options);
    
        if (options.dataAdapter == null) {
          if (options.ajax != null) {
            options.dataAdapter = AjaxData;
          } else if (options.data != null) {
            options.dataAdapter = ArrayData;
          } else {
            options.dataAdapter = SelectData;
          }
    
          if (options.minimumInputLength > 0) {
            options.dataAdapter = Utils.Decorate(
              options.dataAdapter,
              MinimumInputLength
            );
          }
    
          if (options.maximumInputLength > 0) {
            options.dataAdapter = Utils.Decorate(
              options.dataAdapter,
              MaximumInputLength
            );
          }
    
          if (options.maximumSelectionLength > 0) {
            options.dataAdapter = Utils.Decorate(
              options.dataAdapter,
              MaximumSelectionLength
            );
          }
    
          if (options.tags) {
            options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);
          }
    
          if (options.tokenSeparators != null || options.tokenizer != null) {
            options.dataAdapter = Utils.Decorate(
              options.dataAdapter,
              Tokenizer
            );
          }
    
          if (options.query != null) {
            var Query = require(options.amdBase + 'compat/query');
    
            options.dataAdapter = Utils.Decorate(
              options.dataAdapter,
              Query
            );
          }
    
          if (options.initSelection != null) {
            var InitSelection = require(options.amdBase + 'compat/initSelection');
    
            options.dataAdapter = Utils.Decorate(
              options.dataAdapter,
              InitSelection
            );
          }
        }
    
        if (options.resultsAdapter == null) {
          options.resultsAdapter = ResultsList;
    
          if (options.ajax != null) {
            options.resultsAdapter = Utils.Decorate(
              options.resultsAdapter,
              InfiniteScroll
            );
          }
    
          if (options.placeholder != null) {
            options.resultsAdapter = Utils.Decorate(
              options.resultsAdapter,
              HidePlaceholder
            );
          }
    
          if (options.selectOnClose) {
            options.resultsAdapter = Utils.Decorate(
              options.resultsAdapter,
              SelectOnClose
            );
          }
        }
    
        if (options.dropdownAdapter == null) {
          if (options.multiple) {
            options.dropdownAdapter = Dropdown;
          } else {
            var SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);
    
            options.dropdownAdapter = SearchableDropdown;
          }
    
          if (options.minimumResultsForSearch !== 0) {
            options.dropdownAdapter = Utils.Decorate(
              options.dropdownAdapter,
              MinimumResultsForSearch
            );
          }
    
          if (options.closeOnSelect) {
            options.dropdownAdapter = Utils.Decorate(
              options.dropdownAdapter,
              CloseOnSelect
            );
          }
    
          if (
            options.dropdownCssClass != null ||
            options.dropdownCss != null ||
            options.adaptDropdownCssClass != null
          ) {
            var DropdownCSS = require(options.amdBase + 'compat/dropdownCss');
    
            options.dropdownAdapter = Utils.Decorate(
              options.dropdownAdapter,
              DropdownCSS
            );
          }
    
          options.dropdownAdapter = Utils.Decorate(
            options.dropdownAdapter,
            AttachBody
          );
        }
    
        if (options.selectionAdapter == null) {
          if (options.multiple) {
            options.selectionAdapter = MultipleSelection;
          } else {
            options.selectionAdapter = SingleSelection;
          }
    
          // Add the placeholder mixin if a placeholder was specified
          if (options.placeholder != null) {
            options.selectionAdapter = Utils.Decorate(
              options.selectionAdapter,
              Placeholder
            );
          }
    
          if (options.allowClear) {
            options.selectionAdapter = Utils.Decorate(
              options.selectionAdapter,
              AllowClear
            );
          }
    
          if (options.multiple) {
            options.selectionAdapter = Utils.Decorate(
              options.selectionAdapter,
              SelectionSearch
            );
          }
    
          if (
            options.containerCssClass != null ||
            options.containerCss != null ||
            options.adaptContainerCssClass != null
          ) {
            var ContainerCSS = require(options.amdBase + 'compat/containerCss');
    
            options.selectionAdapter = Utils.Decorate(
              options.selectionAdapter,
              ContainerCSS
            );
          }
    
          options.selectionAdapter = Utils.Decorate(
            options.selectionAdapter,
            EventRelay
          );
        }
    
        if (typeof options.language === 'string') {
          // Check if the language is specified with a region
          if (options.language.indexOf('-') > 0) {
            // Extract the region information if it is included
            var languageParts = options.language.split('-');
            var baseLanguage = languageParts[0];
    
            options.language = [options.language, baseLanguage];
          } else {
            options.language = [options.language];
          }
        }
    
        if ($.isArray(options.language)) {
          var languages = new Translation();
          options.language.push('en');
    
          var languageNames = options.language;
    
          for (var l = 0; l < languageNames.length; l++) {
            var name = languageNames[l];
            var language = {};
    
            try {
              // Try to load it with the original name
              language = Translation.loadPath(name);
            } catch (e) {
              try {
                // If we couldn't load it, check if it wasn't the full path
                name = this.defaults.amdLanguageBase + name;
                language = Translation.loadPath(name);
              } catch (ex) {
                // The translation could not be loaded at all. Sometimes this is
                // because of a configuration problem, other times this can be
                // because of how Select2 helps load all possible translation files.
                if (options.debug && window.console && console.warn) {
                  console.warn(
                    'Select2: The language file for "' + name + '" could not be ' +
                    'automatically loaded. A fallback will be used instead.'
                  );
                }
    
                continue;
              }
            }
    
            languages.extend(language);
          }
    
          options.translations = languages;
        } else {
          var baseTranslation = Translation.loadPath(
            this.defaults.amdLanguageBase + 'en'
          );
          var customTranslation = new Translation(options.language);
    
          customTranslation.extend(baseTranslation);
    
          options.translations = customTranslation;
        }
    
        return options;
      };
    
      Defaults.prototype.reset = function () {
        function stripDiacritics (text) {
          // Used 'uni range + named function' from http://jsperf.com/diacritics/18
          function match(a) {
            return DIACRITICS[a] || a;
          }
    
          return text.replace(/[^\u0000-\u007E]/g, match);
        }
    
        function matcher (params, data) {
          // Always return the object if there is nothing to compare
          if ($.trim(params.term) === '') {
            return data;
          }
    
          // Do a recursive check for options with children
          if (data.children && data.children.length > 0) {
            // Clone the data object if there are children
            // This is required as we modify the object to remove any non-matches
            var match = $.extend(true, {}, data);
    
            // Check each child of the option
            for (var c = data.children.length - 1; c >= 0; c--) {
              var child = data.children[c];
    
              var matches = matcher(params, child);
    
              // If there wasn't a match, remove the object in the array
              if (matches == null) {
                match.children.splice(c, 1);
              }
            }
    
            // If any children matched, return the new object
            if (match.children.length > 0) {
              return match;
            }
    
            // If there were no matching children, check just the plain object
            return matcher(params, match);
          }
    
          var original = stripDiacritics(data.text).toUpperCase();
          var term = stripDiacritics(params.term).toUpperCase();
    
          // Check if the text contains the term
          if (original.indexOf(term) > -1) {
            return data;
          }
    
          // If it doesn't contain the term, don't return anything
          return null;
        }
    
        this.defaults = {
          amdBase: './',
          amdLanguageBase: './i18n/',
          closeOnSelect: true,
          debug: false,
          dropdownAutoWidth: false,
          escapeMarkup: Utils.escapeMarkup,
          language: EnglishTranslation,
          matcher: matcher,
          minimumInputLength: 0,
          maximumInputLength: 0,
          maximumSelectionLength: 0,
          minimumResultsForSearch: 0,
          selectOnClose: false,
          sorter: function (data) {
            return data;
          },
          templateResult: function (result) {
            return result.text;
          },
          templateSelection: function (selection) {
            return selection.text;
          },
          theme: 'default',
          width: 'resolve'
        };
      };
    
      Defaults.prototype.set = function (key, value) {
        var camelKey = $.camelCase(key);
    
        var data = {};
        data[camelKey] = value;
    
        var convertedData = Utils._convertData(data);
    
        $.extend(this.defaults, convertedData);
      };
    
      var defaults = new Defaults();
    
      return defaults;
    });
    
    S2.define('select2/options',[
      'require',
      'jquery',
      './defaults',
      './utils'
    ], function (require, $, Defaults, Utils) {
      function Options (options, $element) {
        this.options = options;
    
        if ($element != null) {
          this.fromElement($element);
        }
    
        this.options = Defaults.apply(this.options);
    
        if ($element && $element.is('input')) {
          var InputCompat = require(this.get('amdBase') + 'compat/inputData');
    
          this.options.dataAdapter = Utils.Decorate(
            this.options.dataAdapter,
            InputCompat
          );
        }
      }
    
      Options.prototype.fromElement = function ($e) {
        var excludedData = ['select2'];
    
        if (this.options.multiple == null) {
          this.options.multiple = $e.prop('multiple');
        }
    
        if (this.options.disabled == null) {
          this.options.disabled = $e.prop('disabled');
        }
    
        if (this.options.language == null) {
          if ($e.prop('lang')) {
            this.options.language = $e.prop('lang').toLowerCase();
          } else if ($e.closest('[lang]').prop('lang')) {
            this.options.language = $e.closest('[lang]').prop('lang');
          }
        }
    
        if (this.options.dir == null) {
          if ($e.prop('dir')) {
            this.options.dir = $e.prop('dir');
          } else if ($e.closest('[dir]').prop('dir')) {
            this.options.dir = $e.closest('[dir]').prop('dir');
          } else {
            this.options.dir = 'ltr';
          }
        }
    
        $e.prop('disabled', this.options.disabled);
        $e.prop('multiple', this.options.multiple);
    
        if ($e.data('select2Tags')) {
          if (this.options.debug && window.console && console.warn) {
            console.warn(
              'Select2: The `data-select2-tags` attribute has been changed to ' +
              'use the `data-data` and `data-tags="true"` attributes and will be ' +
              'removed in future versions of Select2.'
            );
          }
    
          $e.data('data', $e.data('select2Tags'));
          $e.data('tags', true);
        }
    
        if ($e.data('ajaxUrl')) {
          if (this.options.debug && window.console && console.warn) {
            console.warn(
              'Select2: The `data-ajax-url` attribute has been changed to ' +
              '`data-ajax--url` and support for the old attribute will be removed' +
              ' in future versions of Select2.'
            );
          }
    
          $e.attr('ajax--url', $e.data('ajaxUrl'));
          $e.data('ajax--url', $e.data('ajaxUrl'));
        }
    
        var dataset = {};
    
        // Prefer the element's `dataset` attribute if it exists
        // jQuery 1.x does not correctly handle data attributes with multiple dashes
        if ($.fn.jquery && $.fn.jquery.substr(0, 2) == '1.' && $e[0].dataset) {
          dataset = $.extend(true, {}, $e[0].dataset, $e.data());
        } else {
          dataset = $e.data();
        }
    
        var data = $.extend(true, {}, dataset);
    
        data = Utils._convertData(data);
    
        for (var key in data) {
          if ($.inArray(key, excludedData) > -1) {
            continue;
          }
    
          if ($.isPlainObject(this.options[key])) {
            $.extend(this.options[key], data[key]);
          } else {
            this.options[key] = data[key];
          }
        }
    
        return this;
      };
    
      Options.prototype.get = function (key) {
        return this.options[key];
      };
    
      Options.prototype.set = function (key, val) {
        this.options[key] = val;
      };
    
      return Options;
    });
    
    S2.define('select2/core',[
      'jquery',
      './options',
      './utils',
      './keys'
    ], function ($, Options, Utils, KEYS) {
      var Select2 = function ($element, options) {
        if ($element.data('select2') != null) {
          $element.data('select2').destroy();
        }
    
        this.$element = $element;
    
        this.id = this._generateId($element);
    
        options = options || {};
    
        this.options = new Options(options, $element);
    
        Select2.__super__.constructor.call(this);
    
        // Set up the tabindex
    
        var tabindex = $element.attr('tabindex') || 0;
        $element.data('old-tabindex', tabindex);
        $element.attr('tabindex', '-1');
    
        // Set up containers and adapters
    
        var DataAdapter = this.options.get('dataAdapter');
        this.dataAdapter = new DataAdapter($element, this.options);
    
        var $container = this.render();
    
        this._placeContainer($container);
    
        var SelectionAdapter = this.options.get('selectionAdapter');
        this.selection = new SelectionAdapter($element, this.options);
        this.$selection = this.selection.render();
    
        this.selection.position(this.$selection, $container);
    
        var DropdownAdapter = this.options.get('dropdownAdapter');
        this.dropdown = new DropdownAdapter($element, this.options);
        this.$dropdown = this.dropdown.render();
    
        this.dropdown.position(this.$dropdown, $container);
    
        var ResultsAdapter = this.options.get('resultsAdapter');
        this.results = new ResultsAdapter($element, this.options, this.dataAdapter);
        this.$results = this.results.render();
    
        this.results.position(this.$results, this.$dropdown);
    
        // Bind events
    
        var self = this;
    
        // Bind the container to all of the adapters
        this._bindAdapters();
    
        // Register any DOM event handlers
        this._registerDomEvents();
    
        // Register any internal event handlers
        this._registerDataEvents();
        this._registerSelectionEvents();
        this._registerDropdownEvents();
        this._registerResultsEvents();
        this._registerEvents();
    
        // Set the initial state
        this.dataAdapter.current(function (initialData) {
          self.trigger('selection:update', {
            data: initialData
          });
        });
    
        // Hide the original select
        $element.addClass('select2-hidden-accessible');
        $element.attr('aria-hidden', 'true');
    
        // Synchronize any monitored attributes
        this._syncAttributes();
    
        $element.data('select2', this);
      };
    
      Utils.Extend(Select2, Utils.Observable);
    
      Select2.prototype._generateId = function ($element) {
        var id = '';
    
        if ($element.attr('id') != null) {
          id = $element.attr('id');
        } else if ($element.attr('name') != null) {
          id = $element.attr('name') + '-' + Utils.generateChars(2);
        } else {
          id = Utils.generateChars(4);
        }
    
        id = id.replace(/(:|\.|\[|\]|,)/g, '');
        id = 'select2-' + id;
    
        return id;
      };
    
      Select2.prototype._placeContainer = function ($container) {
        $container.insertAfter(this.$element);
    
        var width = this._resolveWidth(this.$element, this.options.get('width'));
    
        if (width != null) {
          $container.css('width', width);
        }
      };
    
      Select2.prototype._resolveWidth = function ($element, method) {
        var WIDTH = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;
    
        if (method == 'resolve') {
          var styleWidth = this._resolveWidth($element, 'style');
    
          if (styleWidth != null) {
            return styleWidth;
          }
    
          return this._resolveWidth($element, 'element');
        }
    
        if (method == 'element') {
          var elementWidth = $element.outerWidth(false);
    
          if (elementWidth <= 0) {
            return 'auto';
          }
    
          return elementWidth + 'px';
        }
    
        if (method == 'style') {
          var style = $element.attr('style');
    
          if (typeof(style) !== 'string') {
            return null;
          }
    
          var attrs = style.split(';');
    
          for (var i = 0, l = attrs.length; i < l; i = i + 1) {
            var attr = attrs[i].replace(/\s/g, '');
            var matches = attr.match(WIDTH);
    
            if (matches !== null && matches.length >= 1) {
              return matches[1];
            }
          }
    
          return null;
        }
    
        return method;
      };
    
      Select2.prototype._bindAdapters = function () {
        this.dataAdapter.bind(this, this.$container);
        this.selection.bind(this, this.$container);
    
        this.dropdown.bind(this, this.$container);
        this.results.bind(this, this.$container);
      };
    
      Select2.prototype._registerDomEvents = function () {
        var self = this;
    
        this.$element.on('change.select2', function () {
          self.dataAdapter.current(function (data) {
            self.trigger('selection:update', {
              data: data
            });
          });
        });
    
        this.$element.on('focus.select2', function (evt) {
          self.trigger('focus', evt);
        });
    
        this._syncA = Utils.bind(this._syncAttributes, this);
        this._syncS = Utils.bind(this._syncSubtree, this);
    
        if (this.$element[0].attachEvent) {
          this.$element[0].attachEvent('onpropertychange', this._syncA);
        }
    
        var observer = window.MutationObserver ||
          window.WebKitMutationObserver ||
          window.MozMutationObserver
        ;
    
        if (observer != null) {
          this._observer = new observer(function (mutations) {
            $.each(mutations, self._syncA);
            $.each(mutations, self._syncS);
          });
          this._observer.observe(this.$element[0], {
            attributes: true,
            childList: true,
            subtree: false
          });
        } else if (this.$element[0].addEventListener) {
          this.$element[0].addEventListener(
            'DOMAttrModified',
            self._syncA,
            false
          );
          this.$element[0].addEventListener(
            'DOMNodeInserted',
            self._syncS,
            false
          );
          this.$element[0].addEventListener(
            'DOMNodeRemoved',
            self._syncS,
            false
          );
        }
      };
    
      Select2.prototype._registerDataEvents = function () {
        var self = this;
    
        this.dataAdapter.on('*', function (name, params) {
          self.trigger(name, params);
        });
      };
    
      Select2.prototype._registerSelectionEvents = function () {
        var self = this;
        var nonRelayEvents = ['toggle', 'focus'];
    
        this.selection.on('toggle', function () {
          self.toggleDropdown();
        });
    
        this.selection.on('focus', function (params) {
          self.focus(params);
        });
    
        this.selection.on('*', function (name, params) {
          if ($.inArray(name, nonRelayEvents) !== -1) {
            return;
          }
    
          self.trigger(name, params);
        });
      };
    
      Select2.prototype._registerDropdownEvents = function () {
        var self = this;
    
        this.dropdown.on('*', function (name, params) {
          self.trigger(name, params);
        });
      };
    
      Select2.prototype._registerResultsEvents = function () {
        var self = this;
    
        this.results.on('*', function (name, params) {
          self.trigger(name, params);
        });
      };
    
      Select2.prototype._registerEvents = function () {
        var self = this;
    
        this.on('open', function () {
          self.$container.addClass('select2-container--open');
        });
    
        this.on('close', function () {
          self.$container.removeClass('select2-container--open');
        });
    
        this.on('enable', function () {
          self.$container.removeClass('select2-container--disabled');
        });
    
        this.on('disable', function () {
          self.$container.addClass('select2-container--disabled');
        });
    
        this.on('blur', function () {
          self.$container.removeClass('select2-container--focus');
        });
    
        this.on('query', function (params) {
          if (!self.isOpen()) {
            self.trigger('open', {});
          }
    
          this.dataAdapter.query(params, function (data) {
            self.trigger('results:all', {
              data: data,
              query: params
            });
          });
        });
    
        this.on('query:append', function (params) {
          this.dataAdapter.query(params, function (data) {
            self.trigger('results:append', {
              data: data,
              query: params
            });
          });
        });
    
        this.on('keypress', function (evt) {
          var key = evt.which;
    
          if (self.isOpen()) {
            if (key === KEYS.ESC || key === KEYS.TAB ||
                (key === KEYS.UP && evt.altKey)) {
              self.close();
    
              evt.preventDefault();
            } else if (key === KEYS.ENTER) {
              self.trigger('results:select', {});
    
              evt.preventDefault();
            } else if ((key === KEYS.SPACE && evt.ctrlKey)) {
              self.trigger('results:toggle', {});
    
              evt.preventDefault();
            } else if (key === KEYS.UP) {
              self.trigger('results:previous', {});
    
              evt.preventDefault();
            } else if (key === KEYS.DOWN) {
              self.trigger('results:next', {});
    
              evt.preventDefault();
            }
          } else {
            if (key === KEYS.ENTER || key === KEYS.SPACE ||
                (key === KEYS.DOWN && evt.altKey)) {
              self.open();
    
              evt.preventDefault();
            }
          }
        });
      };
    
      Select2.prototype._syncAttributes = function () {
        this.options.set('disabled', this.$element.prop('disabled'));
    
        if (this.options.get('disabled')) {
          if (this.isOpen()) {
            this.close();
          }
    
          this.trigger('disable', {});
        } else {
          this.trigger('enable', {});
        }
      };
    
      Select2.prototype._syncSubtree = function (evt, mutations) {
        var changed = false;
        var self = this;
    
        // Ignore any mutation events raised for elements that aren't options or
        // optgroups. This handles the case when the select element is destroyed
        if (
          evt && evt.target && (
            evt.target.nodeName !== 'OPTION' && evt.target.nodeName !== 'OPTGROUP'
          )
        ) {
          return;
        }
    
        if (!mutations) {
          // If mutation events aren't supported, then we can only assume that the
          // change affected the selections
          changed = true;
        } else if (mutations.addedNodes && mutations.addedNodes.length > 0) {
          for (var n = 0; n < mutations.addedNodes.length; n++) {
            var node = mutations.addedNodes[n];
    
            if (node.selected) {
              changed = true;
            }
          }
        } else if (mutations.removedNodes && mutations.removedNodes.length > 0) {
          changed = true;
        }
    
        // Only re-pull the data if we think there is a change
        if (changed) {
          this.dataAdapter.current(function (currentData) {
            self.trigger('selection:update', {
              data: currentData
            });
          });
        }
      };
    
      /**
       * Override the trigger method to automatically trigger pre-events when
       * there are events that can be prevented.
       */
      Select2.prototype.trigger = function (name, args) {
        var actualTrigger = Select2.__super__.trigger;
        var preTriggerMap = {
          'open': 'opening',
          'close': 'closing',
          'select': 'selecting',
          'unselect': 'unselecting'
        };
    
        if (args === undefined) {
          args = {};
        }
    
        if (name in preTriggerMap) {
          var preTriggerName = preTriggerMap[name];
          var preTriggerArgs = {
            prevented: false,
            name: name,
            args: args
          };
    
          actualTrigger.call(this, preTriggerName, preTriggerArgs);
    
          if (preTriggerArgs.prevented) {
            args.prevented = true;
    
            return;
          }
        }
    
        actualTrigger.call(this, name, args);
      };
    
      Select2.prototype.toggleDropdown = function () {
        if (this.options.get('disabled')) {
          return;
        }
    
        if (this.isOpen()) {
          this.close();
        } else {
          this.open();
        }
      };
    
      Select2.prototype.open = function () {
        if (this.isOpen()) {
          return;
        }
    
        this.trigger('query', {});
      };
    
      Select2.prototype.close = function () {
        if (!this.isOpen()) {
          return;
        }
    
        this.trigger('close', {});
      };
    
      Select2.prototype.isOpen = function () {
        return this.$container.hasClass('select2-container--open');
      };
    
      Select2.prototype.hasFocus = function () {
        return this.$container.hasClass('select2-container--focus');
      };
    
      Select2.prototype.focus = function (data) {
        // No need to re-trigger focus events if we are already focused
        if (this.hasFocus()) {
          return;
        }
    
        this.$container.addClass('select2-container--focus');
        this.trigger('focus', {});
      };
    
      Select2.prototype.enable = function (args) {
        if (this.options.get('debug') && window.console && console.warn) {
          console.warn(
            'Select2: The `select2("enable")` method has been deprecated and will' +
            ' be removed in later Select2 versions. Use $element.prop("disabled")' +
            ' instead.'
          );
        }
    
        if (args == null || args.length === 0) {
          args = [true];
        }
    
        var disabled = !args[0];
    
        this.$element.prop('disabled', disabled);
      };
    
      Select2.prototype.data = function () {
        if (this.options.get('debug') &&
            arguments.length > 0 && window.console && console.warn) {
          console.warn(
            'Select2: Data can no longer be set using `select2("data")`. You ' +
            'should consider setting the value instead using `$element.val()`.'
          );
        }
    
        var data = [];
    
        this.dataAdapter.current(function (currentData) {
          data = currentData;
        });
    
        return data;
      };
    
      Select2.prototype.val = function (args) {
        if (this.options.get('debug') && window.console && console.warn) {
          console.warn(
            'Select2: The `select2("val")` method has been deprecated and will be' +
            ' removed in later Select2 versions. Use $element.val() instead.'
          );
        }
    
        if (args == null || args.length === 0) {
          return this.$element.val();
        }
    
        var newVal = args[0];
    
        if ($.isArray(newVal)) {
          newVal = $.map(newVal, function (obj) {
            return obj.toString();
          });
        }
    
        this.$element.val(newVal).trigger('change');
      };
    
      Select2.prototype.destroy = function () {
        this.$container.remove();
    
        if (this.$element[0].detachEvent) {
          this.$element[0].detachEvent('onpropertychange', this._syncA);
        }
    
        if (this._observer != null) {
          this._observer.disconnect();
          this._observer = null;
        } else if (this.$element[0].removeEventListener) {
          this.$element[0]
            .removeEventListener('DOMAttrModified', this._syncA, false);
          this.$element[0]
            .removeEventListener('DOMNodeInserted', this._syncS, false);
          this.$element[0]
            .removeEventListener('DOMNodeRemoved', this._syncS, false);
        }
    
        this._syncA = null;
        this._syncS = null;
    
        this.$element.off('.select2');
        this.$element.attr('tabindex', this.$element.data('old-tabindex'));
    
        this.$element.removeClass('select2-hidden-accessible');
        this.$element.attr('aria-hidden', 'false');
        this.$element.removeData('select2');
    
        this.dataAdapter.destroy();
        this.selection.destroy();
        this.dropdown.destroy();
        this.results.destroy();
    
        this.dataAdapter = null;
        this.selection = null;
        this.dropdown = null;
        this.results = null;
      };
    
      Select2.prototype.render = function () {
        var $container = $(
          '<span class="select2 select2-container">' +
            '<span class="selection"></span>' +
            '<span class="dropdown-wrapper" aria-hidden="true"></span>' +
          '</span>'
        );
    
        $container.attr('dir', this.options.get('dir'));
    
        this.$container = $container;
    
        this.$container.addClass('select2-container--' + this.options.get('theme'));
    
        $container.data('element', this.$element);
    
        return $container;
      };
    
      return Select2;
    });
    
    S2.define('select2/compat/utils',[
      'jquery'
    ], function ($) {
      function syncCssClasses ($dest, $src, adapter) {
        var classes, replacements = [], adapted;
    
        classes = $.trim($dest.attr('class'));
    
        if (classes) {
          classes = '' + classes; // for IE which returns object
    
          $(classes.split(/\s+/)).each(function () {
            // Save all Select2 classes
            if (this.indexOf('select2-') === 0) {
              replacements.push(this);
            }
          });
        }
    
        classes = $.trim($src.attr('class'));
    
        if (classes) {
          classes = '' + classes; // for IE which returns object
    
          $(classes.split(/\s+/)).each(function () {
            // Only adapt non-Select2 classes
            if (this.indexOf('select2-') !== 0) {
              adapted = adapter(this);
    
              if (adapted != null) {
                replacements.push(adapted);
              }
            }
          });
        }
    
        $dest.attr('class', replacements.join(' '));
      }
    
      return {
        syncCssClasses: syncCssClasses
      };
    });
    
    S2.define('select2/compat/containerCss',[
      'jquery',
      './utils'
    ], function ($, CompatUtils) {
      // No-op CSS adapter that discards all classes by default
      function _containerAdapter (clazz) {
        return null;
      }
    
      function ContainerCSS () { }
    
      ContainerCSS.prototype.render = function (decorated) {
        var $container = decorated.call(this);
    
        var containerCssClass = this.options.get('containerCssClass') || '';
    
        if ($.isFunction(containerCssClass)) {
          containerCssClass = containerCssClass(this.$element);
        }
    
        var containerCssAdapter = this.options.get('adaptContainerCssClass');
        containerCssAdapter = containerCssAdapter || _containerAdapter;
    
        if (containerCssClass.indexOf(':all:') !== -1) {
          containerCssClass = containerCssClass.replace(':all:', '');
    
          var _cssAdapter = containerCssAdapter;
    
          containerCssAdapter = function (clazz) {
            var adapted = _cssAdapter(clazz);
    
            if (adapted != null) {
              // Append the old one along with the adapted one
              return adapted + ' ' + clazz;
            }
    
            return clazz;
          };
        }
    
        var containerCss = this.options.get('containerCss') || {};
    
        if ($.isFunction(containerCss)) {
          containerCss = containerCss(this.$element);
        }
    
        CompatUtils.syncCssClasses($container, this.$element, containerCssAdapter);
    
        $container.css(containerCss);
        $container.addClass(containerCssClass);
    
        return $container;
      };
    
      return ContainerCSS;
    });
    
    S2.define('select2/compat/dropdownCss',[
      'jquery',
      './utils'
    ], function ($, CompatUtils) {
      // No-op CSS adapter that discards all classes by default
      function _dropdownAdapter (clazz) {
        return null;
      }
    
      function DropdownCSS () { }
    
      DropdownCSS.prototype.render = function (decorated) {
        var $dropdown = decorated.call(this);
    
        var dropdownCssClass = this.options.get('dropdownCssClass') || '';
    
        if ($.isFunction(dropdownCssClass)) {
          dropdownCssClass = dropdownCssClass(this.$element);
        }
    
        var dropdownCssAdapter = this.options.get('adaptDropdownCssClass');
        dropdownCssAdapter = dropdownCssAdapter || _dropdownAdapter;
    
        if (dropdownCssClass.indexOf(':all:') !== -1) {
          dropdownCssClass = dropdownCssClass.replace(':all:', '');
    
          var _cssAdapter = dropdownCssAdapter;
    
          dropdownCssAdapter = function (clazz) {
            var adapted = _cssAdapter(clazz);
    
            if (adapted != null) {
              // Append the old one along with the adapted one
              return adapted + ' ' + clazz;
            }
    
            return clazz;
          };
        }
    
        var dropdownCss = this.options.get('dropdownCss') || {};
    
        if ($.isFunction(dropdownCss)) {
          dropdownCss = dropdownCss(this.$element);
        }
    
        CompatUtils.syncCssClasses($dropdown, this.$element, dropdownCssAdapter);
    
        $dropdown.css(dropdownCss);
        $dropdown.addClass(dropdownCssClass);
    
        return $dropdown;
      };
    
      return DropdownCSS;
    });
    
    S2.define('select2/compat/initSelection',[
      'jquery'
    ], function ($) {
      function InitSelection (decorated, $element, options) {
        if (options.get('debug') && window.console && console.warn) {
          console.warn(
            'Select2: The `initSelection` option has been deprecated in favor' +
            ' of a custom data adapter that overrides the `current` method. ' +
            'This method is now called multiple times instead of a single ' +
            'time when the instance is initialized. Support will be removed ' +
            'for the `initSelection` option in future versions of Select2'
          );
        }
    
        this.initSelection = options.get('initSelection');
        this._isInitialized = false;
    
        decorated.call(this, $element, options);
      }
    
      InitSelection.prototype.current = function (decorated, callback) {
        var self = this;
    
        if (this._isInitialized) {
          decorated.call(this, callback);
    
          return;
        }
    
        this.initSelection.call(null, this.$element, function (data) {
          self._isInitialized = true;
    
          if (!$.isArray(data)) {
            data = [data];
          }
    
          callback(data);
        });
      };
    
      return InitSelection;
    });
    
    S2.define('select2/compat/inputData',[
      'jquery'
    ], function ($) {
      function InputData (decorated, $element, options) {
        this._currentData = [];
        this._valueSeparator = options.get('valueSeparator') || ',';
    
        if ($element.prop('type') === 'hidden') {
          if (options.get('debug') && console && console.warn) {
            console.warn(
              'Select2: Using a hidden input with Select2 is no longer ' +
              'supported and may stop working in the future. It is recommended ' +
              'to use a `<select>` element instead.'
            );
          }
        }
    
        decorated.call(this, $element, options);
      }
    
      InputData.prototype.current = function (_, callback) {
        function getSelected (data, selectedIds) {
          var selected = [];
    
          if (data.selected || $.inArray(data.id, selectedIds) !== -1) {
            data.selected = true;
            selected.push(data);
          } else {
            data.selected = false;
          }
    
          if (data.children) {
            selected.push.apply(selected, getSelected(data.children, selectedIds));
          }
    
          return selected;
        }
    
        var selected = [];
    
        for (var d = 0; d < this._currentData.length; d++) {
          var data = this._currentData[d];
    
          selected.push.apply(
            selected,
            getSelected(
              data,
              this.$element.val().split(
                this._valueSeparator
              )
            )
          );
        }
    
        callback(selected);
      };
    
      InputData.prototype.select = function (_, data) {
        if (!this.options.get('multiple')) {
          this.current(function (allData) {
            $.map(allData, function (data) {
              data.selected = false;
            });
          });
    
          this.$element.val(data.id);
          this.$element.trigger('change');
        } else {
          var value = this.$element.val();
          value += this._valueSeparator + data.id;
    
          this.$element.val(value);
          this.$element.trigger('change');
        }
      };
    
      InputData.prototype.unselect = function (_, data) {
        var self = this;
    
        data.selected = false;
    
        this.current(function (allData) {
          var values = [];
    
          for (var d = 0; d < allData.length; d++) {
            var item = allData[d];
    
            if (data.id == item.id) {
              continue;
            }
    
            values.push(item.id);
          }
    
          self.$element.val(values.join(self._valueSeparator));
          self.$element.trigger('change');
        });
      };
    
      InputData.prototype.query = function (_, params, callback) {
        var results = [];
    
        for (var d = 0; d < this._currentData.length; d++) {
          var data = this._currentData[d];
    
          var matches = this.matches(params, data);
    
          if (matches !== null) {
            results.push(matches);
          }
        }
    
        callback({
          results: results
        });
      };
    
      InputData.prototype.addOptions = function (_, $options) {
        var options = $.map($options, function ($option) {
          return $.data($option[0], 'data');
        });
    
        this._currentData.push.apply(this._currentData, options);
      };
    
      return InputData;
    });
    
    S2.define('select2/compat/matcher',[
      'jquery'
    ], function ($) {
      function oldMatcher (matcher) {
        function wrappedMatcher (params, data) {
          var match = $.extend(true, {}, data);
    
          if (params.term == null || $.trim(params.term) === '') {
            return match;
          }
    
          if (data.children) {
            for (var c = data.children.length - 1; c >= 0; c--) {
              var child = data.children[c];
    
              // Check if the child object matches
              // The old matcher returned a boolean true or false
              var doesMatch = matcher(params.term, child.text, child);
    
              // If the child didn't match, pop it off
              if (!doesMatch) {
                match.children.splice(c, 1);
              }
            }
    
            if (match.children.length > 0) {
              return match;
            }
          }
    
          if (matcher(params.term, data.text, data)) {
            return match;
          }
    
          return null;
        }
    
        return wrappedMatcher;
      }
    
      return oldMatcher;
    });
    
    S2.define('select2/compat/query',[
    
    ], function () {
      function Query (decorated, $element, options) {
        if (options.get('debug') && window.console && console.warn) {
          console.warn(
            'Select2: The `query` option has been deprecated in favor of a ' +
            'custom data adapter that overrides the `query` method. Support ' +
            'will be removed for the `query` option in future versions of ' +
            'Select2.'
          );
        }
    
        decorated.call(this, $element, options);
      }
    
      Query.prototype.query = function (_, params, callback) {
        params.callback = callback;
    
        var query = this.options.get('query');
    
        query.call(null, params);
      };
    
      return Query;
    });
    
    S2.define('select2/dropdown/attachContainer',[
    
    ], function () {
      function AttachContainer (decorated, $element, options) {
        decorated.call(this, $element, options);
      }
    
      AttachContainer.prototype.position =
        function (decorated, $dropdown, $container) {
        var $dropdownContainer = $container.find('.dropdown-wrapper');
        $dropdownContainer.append($dropdown);
    
        $dropdown.addClass('select2-dropdown--below');
        $container.addClass('select2-container--below');
      };
    
      return AttachContainer;
    });
    
    S2.define('select2/dropdown/stopPropagation',[
    
    ], function () {
      function StopPropagation () { }
    
      StopPropagation.prototype.bind = function (decorated, container, $container) {
        decorated.call(this, container, $container);
    
        var stoppedEvents = [
        'blur',
        'change',
        'click',
        'dblclick',
        'focus',
        'focusin',
        'focusout',
        'input',
        'keydown',
        'keyup',
        'keypress',
        'mousedown',
        'mouseenter',
        'mouseleave',
        'mousemove',
        'mouseover',
        'mouseup',
        'search',
        'touchend',
        'touchstart'
        ];
    
        this.$dropdown.on(stoppedEvents.join(' '), function (evt) {
          evt.stopPropagation();
        });
      };
    
      return StopPropagation;
    });
    
    S2.define('select2/selection/stopPropagation',[
    
    ], function () {
      function StopPropagation () { }
    
      StopPropagation.prototype.bind = function (decorated, container, $container) {
        decorated.call(this, container, $container);
    
        var stoppedEvents = [
          'blur',
          'change',
          'click',
          'dblclick',
          'focus',
          'focusin',
          'focusout',
          'input',
          'keydown',
          'keyup',
          'keypress',
          'mousedown',
          'mouseenter',
          'mouseleave',
          'mousemove',
          'mouseover',
          'mouseup',
          'search',
          'touchend',
          'touchstart'
        ];
    
        this.$selection.on(stoppedEvents.join(' '), function (evt) {
          evt.stopPropagation();
        });
      };
    
      return StopPropagation;
    });
    
    /*!
     * jQuery Mousewheel 3.1.13
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license
     * http://jquery.org/license
     */
    
    (function (factory) {
        if ( typeof S2.define === 'function' && S2.define.amd ) {
            // AMD. Register as an anonymous module.
            S2.define('jquery-mousewheel',['jquery'], factory);
        } else if (typeof exports === 'object') {
            // Node/CommonJS style for Browserify
            module.exports = factory;
        } else {
            // Browser globals
            factory(jQuery);
        }
    }(function ($) {
    
        var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
            toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
                        ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
            slice  = Array.prototype.slice,
            nullLowestDeltaTimeout, lowestDelta;
    
        if ( $.event.fixHooks ) {
            for ( var i = toFix.length; i; ) {
                $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
            }
        }
    
        var special = $.event.special.mousewheel = {
            version: '3.1.12',
    
            setup: function() {
                if ( this.addEventListener ) {
                    for ( var i = toBind.length; i; ) {
                        this.addEventListener( toBind[--i], handler, false );
                    }
                } else {
                    this.onmousewheel = handler;
                }
                // Store the line height and page height for this particular element
                $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
                $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
            },
    
            teardown: function() {
                if ( this.removeEventListener ) {
                    for ( var i = toBind.length; i; ) {
                        this.removeEventListener( toBind[--i], handler, false );
                    }
                } else {
                    this.onmousewheel = null;
                }
                // Clean up the data we added to the element
                $.removeData(this, 'mousewheel-line-height');
                $.removeData(this, 'mousewheel-page-height');
            },
    
            getLineHeight: function(elem) {
                var $elem = $(elem),
                    $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
                if (!$parent.length) {
                    $parent = $('body');
                }
                return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
            },
    
            getPageHeight: function(elem) {
                return $(elem).height();
            },
    
            settings: {
                adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
                normalizeOffset: true  // calls getBoundingClientRect for each event
            }
        };
    
        $.fn.extend({
            mousewheel: function(fn) {
                return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
            },
    
            unmousewheel: function(fn) {
                return this.unbind('mousewheel', fn);
            }
        });
    
    
        function handler(event) {
            var orgEvent   = event || window.event,
                args       = slice.call(arguments, 1),
                delta      = 0,
                deltaX     = 0,
                deltaY     = 0,
                absDelta   = 0,
                offsetX    = 0,
                offsetY    = 0;
            event = $.event.fix(orgEvent);
            event.type = 'mousewheel';
    
            // Old school scrollwheel delta
            if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
            if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
            if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
            if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }
    
            // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
            if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
                deltaX = deltaY * -1;
                deltaY = 0;
            }
    
            // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
            delta = deltaY === 0 ? deltaX : deltaY;
    
            // New school wheel delta (wheel event)
            if ( 'deltaY' in orgEvent ) {
                deltaY = orgEvent.deltaY * -1;
                delta  = deltaY;
            }
            if ( 'deltaX' in orgEvent ) {
                deltaX = orgEvent.deltaX;
                if ( deltaY === 0 ) { delta  = deltaX * -1; }
            }
    
            // No change actually happened, no reason to go any further
            if ( deltaY === 0 && deltaX === 0 ) { return; }
    
            // Need to convert lines and pages to pixels if we aren't already in pixels
            // There are three delta modes:
            //   * deltaMode 0 is by pixels, nothing to do
            //   * deltaMode 1 is by lines
            //   * deltaMode 2 is by pages
            if ( orgEvent.deltaMode === 1 ) {
                var lineHeight = $.data(this, 'mousewheel-line-height');
                delta  *= lineHeight;
                deltaY *= lineHeight;
                deltaX *= lineHeight;
            } else if ( orgEvent.deltaMode === 2 ) {
                var pageHeight = $.data(this, 'mousewheel-page-height');
                delta  *= pageHeight;
                deltaY *= pageHeight;
                deltaX *= pageHeight;
            }
    
            // Store lowest absolute delta to normalize the delta values
            absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );
    
            if ( !lowestDelta || absDelta < lowestDelta ) {
                lowestDelta = absDelta;
    
                // Adjust older deltas if necessary
                if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
                    lowestDelta /= 40;
                }
            }
    
            // Adjust older deltas if necessary
            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
                // Divide all the things by 40!
                delta  /= 40;
                deltaX /= 40;
                deltaY /= 40;
            }
    
            // Get a whole, normalized value for the deltas
            delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
            deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
            deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);
    
            // Normalise offsetX and offsetY properties
            if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {
                var boundingRect = this.getBoundingClientRect();
                offsetX = event.clientX - boundingRect.left;
                offsetY = event.clientY - boundingRect.top;
            }
    
            // Add information to the event object
            event.deltaX = deltaX;
            event.deltaY = deltaY;
            event.deltaFactor = lowestDelta;
            event.offsetX = offsetX;
            event.offsetY = offsetY;
            // Go ahead and set deltaMode to 0 since we converted to pixels
            // Although this is a little odd since we overwrite the deltaX/Y
            // properties with normalized deltas.
            event.deltaMode = 0;
    
            // Add event and delta to the front of the arguments
            args.unshift(event, delta, deltaX, deltaY);
    
            // Clearout lowestDelta after sometime to better
            // handle multiple device types that give different
            // a different lowestDelta
            // Ex: trackpad = 3 and mouse wheel = 120
            if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
            nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);
    
            return ($.event.dispatch || $.event.handle).apply(this, args);
        }
    
        function nullLowestDelta() {
            lowestDelta = null;
        }
    
        function shouldAdjustOldDeltas(orgEvent, absDelta) {
            // If this is an older event and the delta is divisable by 120,
            // then we are assuming that the browser is treating this as an
            // older mouse wheel event and that we should divide the deltas
            // by 40 to try and get a more usable deltaFactor.
            // Side note, this actually impacts the reported scroll distance
            // in older browsers and can cause scrolling to be slower than native.
            // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
            return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
        }
    
    }));
    
    S2.define('jquery.select2',[
      'jquery',
      'jquery-mousewheel',
    
      './select2/core',
      './select2/defaults'
    ], function ($, _, Select2, Defaults) {
      if ($.fn.select2 == null) {
        // All methods that should return the element
        var thisMethods = ['open', 'close', 'destroy'];
    
        $.fn.select2 = function (options) {
          options = options || {};
    
          if (typeof options === 'object') {
            this.each(function () {
              var instanceOptions = $.extend(true, {}, options);
    
              var instance = new Select2($(this), instanceOptions);
            });
    
            return this;
          } else if (typeof options === 'string') {
            var ret;
            var args = Array.prototype.slice.call(arguments, 1);
    
            this.each(function () {
              var instance = $(this).data('select2');
    
              if (instance == null && window.console && console.error) {
                console.error(
                  'The select2(\'' + options + '\') method was called on an ' +
                  'element that is not using Select2.'
                );
              }
    
              ret = instance[options].apply(instance, args);
            });
    
            // Check if we should be returning `this`
            if ($.inArray(options, thisMethods) > -1) {
              return this;
            }
    
            return ret;
          } else {
            throw new Error('Invalid arguments for Select2: ' + options);
          }
        };
      }
    
      if ($.fn.select2.defaults == null) {
        $.fn.select2.defaults = Defaults;
      }
    
      return Select2;
    });
    
      // Return the AMD loader configuration so it can be used outside of this file
      return {
        define: S2.define,
        require: S2.require
      };
    }());
    
      // Autoload the jQuery bindings
      // We know that all of the modules exist above this, so we're safe
      var select2 = S2.require('jquery.select2');
    
      // Hold the AMD module references on the jQuery function that was just loaded
      // This allows Select2 to use the internal loader outside of this file, such
      // as in the language files.
      jQuery.fn.select2.amd = S2;
    
      // Return the Select2 instance for anyone who is importing it.
      return select2;
    }));
    
    (function () {
        var $;
        $ = this.jQuery || window.jQuery;
        win = $(window), body = $('body'), doc = $(document);
    
        $.fn.hc_accordion = function () {
            var acd = $(this);
            acd.find('ul>li').each(function (index, el) {
                if ($(el).find('ul li').length > 0) $(el).prepend('<button type="button" class="acd-drop"></button>');
            });
            acd.on('click', '.acd-drop', function (e) {
                e.preventDefault();
                var ul = $(this).nextAll("ul");
                if (ul.is(":hidden") === true) {
                    ul.parent('li').parent('ul').children('li').children('ul').slideUp(180);
                    ul.parent('li').parent('ul').children('li').children('.acd-drop').removeClass("active");
                    $(this).addClass("active");
                    ul.slideDown(180);
                } else {
                    $(this).removeClass("active");
                    ul.slideUp(180);
                }
            });
        }
    
        $.fn.hc_menu = function (options) {
            var settings = $.extend({
                open: '.open-mnav',
            }, options),
                this_ = $(this);
            var m_nav = $('<div class="m-nav"><button class="m-nav-close"><i class="icon_close"></i></button><div class="nav-ct"></div></div>');
            body.append(m_nav);
    
            m_nav.find('.m-nav-close').click(function (e) {
                e.preventDefault();
                mnav_close();
            });
            m_nav.find('.nav-ct').append($('.logo').clone());
            m_nav.find('.nav-ct').append(this_.children().clone());
    
            var mnav_open = function () {
                m_nav.addClass('active');
                body.append('<div class="m-nav-over"></div>').css('overflow', 'hidden');
            }
            var mnav_close = function () {
                m_nav.removeClass('active');
                body.children('.m-nav-over').remove();
                body.css('overflow', '');
            }
    
            //click menu
            $('#main-menu li a').click(function (e) {
                e.preventDefault();
                let id = $(this).attr('data-id');
                $('html, body').animate({
                    scrollTop: $(id).position().top - 60
                }, 800);
                mnav_close();
                return false;
            });

            // $('#main-menu-mb_h2 li a').click(function (e) {
            //     e.preventDefault();
            //     let id = $(this).attr('data-id');
            //     $('html, body').animate({
            //         scrollTop: $(id).position().top - 60
            //     }, 800);
            //     mnav_close();
            //     return false;
            // });

            $('#main-menu-mb li a').click(function (e) {
                e.preventDefault();
                let id = $(this).attr('data-id');
                $('html, body').animate({
                    scrollTop: $(id).position().top - 60
                }, 800);
                mnav_close();
                return false;
            });
    
            //back to top
            // $('.logo').click(function () {
            //     $('html, body').animate({
            //         scrollTop: 0
            //     }, 800);
            //     mnav_close();
            //     return false;
            // });
    
            //price-list
            $('.item-price .ct .btn-pri').click(function (e) {
                e.preventDefault();
                $('html, body').animate({
                    scrollTop: $('#suport').position().top - 60
                }, 800);
                return false;
            });
    
            doc.on('click', settings.open, function (e) {
                e.preventDefault();
                if (win.width() <= 1199) mnav_open();
            }).on('click', '.m-nav-over', function (e) {
                e.preventDefault();
                mnav_close();
            });
    
            m_nav.hc_accordion();
    
        }
    
    
        $.fn.hc_countdown = function (options) {
            var settings = $.extend({
                date: new Date().getTime() + 1000 * 60 * 60 * 24,
            }, options),
                this_ = $(this);
    
            var countDownDate = new Date(settings.date).getTime();
    
            var count = setInterval(function () {
                var now = new Date().getTime();
                var distance = countDownDate - now;
                var days = Math.floor(distance / (1000 * 60 * 60 * 24));
                var hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                var minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                var seconds = Math.floor((distance % (1000 * 60)) / 1000);
                this_.html('<div class="item"><span>' + days + '</span> ng y</div>' +
                    '<div class="item"><span>' + hours + '</span> gi</div>' +
                    '<div class="item"><span>' + minutes + '</span> pht </div>' +
                    '<div class="item"><span>' + seconds + '</span> giy </div>'
                );
                if (distance < 0) {
                    clearInterval(count);
                }
            }, 1000);
        }
    
        $.fn.hc_upload = function (options) {
            var settings = $.extend({
                multiple: false,
                result: '.hc-upload-pane',
            }, options),
                this_ = $(this);
    
            var input_name = this_.attr('name');
            this_.removeAttr('name');
    
            this_.change(function (e) {
                if ($(settings.result).length > 0) {
                    var files = event.target.files;
                    if (settings.multiple) {
                        for (var i = 0, files_len = files.length; i < files_len; i++) {
                            var path = URL.createObjectURL(files[i]);
                            var name = files[i].name;
                            var size = Math.round(files[i].size / 1024 / 1024 * 100) / 100;
                            var type = files[i].type.slice(files[i].type.indexOf('/') + 1);
    
                            var img = $('<img src="' + path + '">');
                            var input = $('<input type="hidden" name="' + input_name + '[]"' +
                                '" value="' + path +
                                '" data-name="' + name +
                                '" data-size="' + size +
                                '" data-type="' + type +
                                '" data-path="' + path +
                                '">');
                            var elm = $('<div class="hc-upload"><button type="button" class="hc-del smooth">&times;</button></div>').append(img).append(input);
                            $(settings.result).append(elm);
                        }
                    } else {
                        var path = URL.createObjectURL(files[0]);
                        var img = $('<img src="' + path + '">');
                        var elm = $('<div class="hc-upload"><button type="button" class="hc-del smooth">&times;</button></div>').append(img);
                        $(settings.result).html(elm);
                    }
                }
            });
    
    
            body.on('click', '.hc-upload .hc-del', function (e) {
                e.preventDefault();
                this_.val('');
                $(this).closest('.hc-upload').remove();
            });
    
        }
    
    }).call(this);
    
    
    jQuery(function ($) {
        var win = $(window),
            body = $('body'),
            doc = $(document);
    
        var FU = {
            get_Ytid: function (url) {
                var rx = /^.*(?:(?:youtu\.be\/|v\/|vi\/|u\/\w\/|embed\/)|(?:(?:watch)?\?v(?:i)?=|\&v(?:i)?=))([^#\&\?]*).*/;
                if (url) var arr = url.match(rx);
                if (arr) return arr[1];
            },
            get_currency: function (str) {
                if (str) return str.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ".");
            },
            animate: function (elems) {
                var animEndEv = 'webkitAnimationEnd animationend';
                elems.each(function () {
                    var $this = $(this),
                        $animationType = $this.data('animation');
                    $this.addClass($animationType).one(animEndEv, function () {
                        $this.removeClass($animationType);
                    });
                });
            },
        };
    
        var UI = {
            mMenu: function () {
    
            },
            header: function () {
                var elm = $('header'),
                    h = elm.innerHeight(),
                    offset = 200,
                    mOffset = 0;
                var fixed = function () {
                    elm.addClass('fixed');
                    body.css('margin-top', h);
                }
                var unfixed = function () {
                    elm.removeClass('fixed');
                    body.css('margin-top', '');
                }
                var Mfixed = function () {
                    elm.addClass('m-fixed');
                    body.css('margin-top', h);
                }
                var unMfixed = function () {
                    elm.removeClass('m-fixed');
                    body.css('margin-top', '');
                }
                if (win.width() > 991) {
                    win.scrollTop() > offset ? fixed() : unfixed();
                } else {
                    win.scrollTop() > mOffset ? Mfixed() : unMfixed();
                }
                win.scroll(function (e) {
                    if (win.width() > 991) {
                        win.scrollTop() > offset ? fixed() : unfixed();
                    } else {
                        win.scrollTop() > mOffset ? Mfixed() : unMfixed();
                    }
                });
            },
            backTop: function () {
                var back_top = $('.back-to-top'),
                    offset = 800;
    
                back_top.click(function () {
                    $("html, body").animate({ scrollTop: 0 }, 800);
                    return false;
                });
    
                if (win.scrollTop() > offset) {
                    back_top.fadeIn(200);
                }
    
                win.scroll(function () {
                    if (win.scrollTop() > offset) back_top.fadeIn(200);
                    else back_top.fadeOut(200);
                });
            },
            slider: function () {
                $('.cas-banner-home').owlCarousel({
                    items: 1,
                    loop: true,
                    animateOut: 'fadeOut',
                    animateIn: 'fadeIn',
                    responsiveClass: true,
                    nav: false,
                    dots: true,
                    autoplay: true,
                    autoPlaySpeed: 5000,
                    autoplayTimeout: 5000,
                    smartSpeed: 1000,
                    navClass: ["sl-arrow prev", "sl-arrow next"],
                    onChanged: slider_change,
                })
                function slider_change(e) {
                    var aniElm = $('.cas-banner-home .owl-item').eq(e.item['index']).find("[data-animation ^= 'animated']");
                    FU.animate(aniElm);
                }
                $('.slide-news').owlCarousel({
                    items: 3,
                    loop: true,
                    animateOut: 'fadeOut',
                    animateIn: 'fadeIn',
                    responsiveClass: true,
                    nav: true,
                    dots: false,
                    autoplay: true,
                    autoPlaySpeed: 5000,
                    autoplayTimeout: 5000,
                    smartSpeed: 1000,
                    margin: 30,
                    slideBy: 1,
                    navClass: ["sl-arrow prev", "sl-arrow next"],
                    navText: ["<i class='fal fa-arrow-left'></i></i></i>", "<i class='fal fa-arrow-right'></i>"],
                    responsive: {
                        991: {
                            items: 3,
                        },
                        479: {
                            items: 2,
                            autoHeight: true,
                        },
                        0: {
                            items: 1,
                            autoHeight: true,
                        }
                    }
                })
            },
            input_number: function () {
                doc.on('keydown', '.numberic', function (event) {
                    if (!(!event.shiftKey &&
                        !(event.keyCode < 48 || event.keyCode > 57) ||
                        !(event.keyCode < 96 || event.keyCode > 105) ||
                        event.keyCode == 46 ||
                        event.keyCode == 8 ||
                        event.keyCode == 190 ||
                        event.keyCode == 9 ||
                        event.keyCode == 116 ||
                        (event.keyCode >= 35 && event.keyCode <= 39)
                    )) {
                        event.preventDefault();
                    }
                });
                doc.on('click', '.i-number .up', function (e) {
                    e.preventDefault();
                    var input = $(this).parents('.i-number').children('input');
                    var max = Number(input.attr('max')),
                        val = Number(input.val());
                    if (!isNaN(val)) {
                        if (!isNaN(max) && input.attr('max').trim() != '') {
                            if (val >= max) {
                                return false;
                            }
                        }
                        input.val(val + 1);
                        input.trigger('number.up');
                    }
                });
                doc.on('click', '.i-number .down', function (e) {
                    e.preventDefault();
                    var input = $(this).parents('.i-number').children('input');
                    var min = Number(input.attr('min')),
                        val = Number(input.val());
                    if (!isNaN(val)) {
                        if (!isNaN(min) && input.attr('max').trim() != '') {
                            if (val <= min) {
                                return false;
                            }
                        }
                        input.val(val - 1);
                        input.trigger('number.down');
                    }
                });
            },
            yt_play: function () {
                doc.on('click', '.yt-box .play', function (e) {
                    var id = FU.get_Ytid($(this).closest('.yt-box').attr('data-url'));
                    $(this).closest('.yt-box iframe').remove();
                    $(this).closest('.yt-box').append('<iframe src="https://www.youtube.com/embed/' + id + '?rel=0&amp;autoplay=1&amp;showinfo=0" frameborder="0" allowfullscreen></iframe>');
                });
            },
            psy: function () {
                var btn = '.psy-btn',
                    sec = $('.psy-section'),
                    pane = '.psy-pane';
                doc.on('click', btn, function (e) {
                    e.preventDefault();
                    $(this).closest(pane).find(btn).removeClass('active');
                    $(this).addClass('active');
                    $("html, body").animate({ scrollTop: $($(this).attr('href')).offset().top - 40 }, 600);
                });
    
                var section_act = function () {
                    sec.each(function (index, el) {
                        if (win.scrollTop() + (win.height() / 2) >= $(el).offset().top) {
                            var id = $(el).attr('id');
                            $(pane).find(btn).removeClass('active');
                            $(pane).find(btn + '[href="#' + id + '"]').addClass('active');
                        }
                    });
                }
                section_act();
                win.scroll(function () {
                    section_act();
                });
            },
            toggle: function () {
                var ani = 100;
                $('[data-show]').each(function (index, el) {
                    var ct = $($(el).attr('data-show'));
                    $(el).click(function (e) {
                        e.preventDefault();
                        ct.fadeToggle(ani);
                    });
                });
                win.click(function (e) {
                    $('[data-show]').each(function (index, el) {
                        var ct = $($(el).attr('data-show'));
                        if (ct.has(e.target).length == 0 && !ct.is(e.target) && $(el).has(e.target).length == 0 && !$(el).is(e.target)) {
                            ct.fadeOut(ani);
                        }
                    });
                });
            },
            uiCounterup: function () {
                var item = $('.hc-couter'),
                    flag = true;
                if (item.length > 0) {
                    run(item);
                    win.scroll(function () {
                        if (flag == true) {
                            run(item);
                        }
                    });
    
                    function run(item) {
                        if (win.scrollTop() + 70 < item.offset().top && item.offset().top + item.innerHeight() < win.scrollTop() + win.height()) {
                            count(item);
                            flag = false;
                        }
                    }
    
                    function count(item) {
                        item.each(function () {
                            var this_ = $(this);
                            var num = Number(this_.text().replace(".", ""));
                            var incre = num / 80;
    
                            function start(counter) {
                                if (counter <= num) {
                                    setTimeout(function () {
                                        this_.text(FU.get_currency(Math.ceil(counter)));
                                        counter = counter + incre;
                                        start(counter);
                                    }, 20);
                                } else {
                                    this_.text(FU.get_currency(num));
                                }
                            }
                            start(0);
                        });
                    }
                }
            },
            drop: function () {
                $('.language').each(function () {
                    var this_ = $(this);
                    var label = this_.children('.label');
                    var ct = this_.children('ul');
                    var item = ct.children('li').children('a');
    
                    this_.click(function () {
                        ct.slideToggle(150);
                    });
    
                    item.click(function (e) {
                        e.preventDefault();
                        label.html($(this).html());
                    });
    
                    win.click(function (e) {
                        if (this_.has(e.target).length == 0 && !this_.is(e.target)) {
                            this_.children('ul').slideUp(150);
                        }
                    })
                });
            },
            ready: function () {
                UI.drop();
                UI.slider();
                UI.backTop();
                UI.psy();
            },
        }
    
    
        UI.ready();
    
    
        // /*custom here*/
        $('.d-nav').hc_menu({
            open: '.open-mnav',
        })
        WOW.prototype.addBox = function (element) {
            this.boxes.push(element);
        };
    
        var wow = new WOW({
            mobile: false
        });
        wow.init();
        /*if ($(window).width() > 1199) {
            $('.wow').on('scrollSpy:exit', function() {
                $(this).css({
                    'visibility': 'hidden',
                    'animation-name': 'none'
                }).removeClass('animated');
                wow.addBox(this);
            }).scrollSpy();
        }*/
    
        //chuyen dong background
        if ($(window).width() > 1199) {
            function translateBackground(parent, el) {
                var lFollowX = 0,
                    lFollowY = 0,
                    x = 0,
                    y = 0,
                    friction = 1 / 20;
    
                function moveBackground() {
                    x += (lFollowX - x) * friction;
                    y += (lFollowY - y) * friction;
    
                    translate = 'translate(' + x + 'px, ' + y + 'px) scale(1)';
                    $(el).css({
                        '-webit-transform': translate,
                        '-moz-transform': translate,
                        'transform': translate
                    });
    
                    window.requestAnimationFrame(moveBackground);
                }
    
                $(parent).on('mousemove click', function (e) {
    
                    var lMouseX = Math.max(-100, Math.min(100, $(window).width() / 2 - e.clientX));
                    var lMouseY = Math.max(-100, Math.min(100, $(window).height() / 2 - e.clientY));
                    lFollowX = (20 * lMouseX) / 100; // 100 : 12 = lMouxeX : lFollow
                    lFollowY = (10 * lMouseY) / 100;
    
                });
    
                moveBackground();
            }
            translateBackground('.content-banner', '.ct-img-banner');
            // translateBackground('.content-banner', '.text-banner');
        }
    
        $('.ic-search').click(function (event) {
            $(this).children('i').toggleClass('fa-search fa-times');
            $(this).next('.form-search-hd').toggleClass('show');
        });
    
        $(window).scroll(function () {
            // var hbn_top= $('.banner-top').height();
            if ($(window).scrollTop() > 100) $('header').addClass('scroll');
            else $('header').removeClass('scroll');
        });
        $('#map').hover(function () {
            $('.wrap-map .dc').fadeOut(100);
        }, function () {
            $('.wrap-map .dc').fadeIn(100);
        });
        if ($(window).width() > 991) {
            if ($('.sb-news').length > 0) {
                $('.sb-news').stick_in_parent({
                    offset_top: 90,
                });
            }
        }
        $('.expand').click(function (event) {
            var moretext = "Xem thm";
            var lesstext = "Rut gon";
            $('.wrap-intro.home .ct').toggleClass('show');
            $(this).children('i').toggleClass('arrow_carrot-2down arrow_carrot-2up');
            $(this).toggleClass('more');
    
            if ($(this).hasClass('more')) {
                $(this).children('span').html(moretext);
            } else {
                $(this).children('span').html(lesstext);
            }
        });
    
    
        // footer toggle
        if (win.width() < 575) {
            $('.item-ft .title').click(function (event) {
                $(this).children('i').stop().toggleClass('fa-chevron-down fa-chevron-up');
                $(this).next('.link').stop().slideToggle();
            });
        }
        // js for form lien he
        $(".career-form__form-control").blur(function () {
            if (!$(this).val()) {
                $(this).removeClass("valid");
            } else {
                $(this).addClass("valid");
            };
        });
    
        //sticky
        if ($(win).width() > 991) {
            if ($('.sticky').length > 0) {
                $('.sticky').stick_in_parent({
                    offset_top: 90,
                });
            }
        }
    
        //swiper
        var swiper = new Swiper('.swiper-container', {
            autoplay: {
                delay: 5000,
            },
            effect: 'coverflow',
            loop: true,
            slideToClickedSlide: true,
            speed: 400,
            spaceBetween: -50,
            centeredSlides: true,
            slidesPerView: 5,
            initialSlide: 3,
            keyboardControl: true,
            mousewheelControl: true,
            lazyLoading: true,
            preventClicks: false,
            preventClicksPropagation: false,
            lazyLoadingInPrevNext: true,
            coverflowEffect: {
                rotate: 0,
                depth: 250,
            },
            pagination: {
                el: '.swiper-pagination',
            },
            breakpoints: {
                1366: {
                    slidesPerView: 5,
                },
                1024: {
                    slidesPerView: 4,
                },
                320: {
                    slidesPerView: 3,
                }
            }
    
        });
    
    })